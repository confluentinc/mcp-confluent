/**
 * This file was auto-generated by openapi-typescript.
 * Do not make direct changes to the file.
 */

export interface paths {
  "/v1/metrics/{dataset}/descriptors": {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /**
     * List all metric descriptors
     * @deprecated
     * @description Lists all the metric descriptors for a dataset.
     *
     *     A metric descriptor represents metadata for a metric, including its data type and labels.
     *     This metadata is provided programmatically to enable clients to dynamically adjust as new
     *     metrics are added to the dataset, rather than hardcoding metric names in client code.
     *
     */
    get: {
      parameters: {
        query?: {
          /** @description The maximum number of results to return. The page size is an integer in the range from 1 through 1000. */
          page_size?: number;
          /** @description The next page token. The token is returned by the previous request as part of `meta.pagination`. */
          page_token?: components["schemas"]["PageToken"];
        };
        header?: never;
        path: {
          /** @description The dataset to list metric descriptors for. Currently the only supported dataset name is `cloud`. See [here](#section/Object-Model/Datasets). */
          dataset: components["schemas"]["Dataset"];
        };
        cookie?: never;
      };
      requestBody?: never;
      responses: {
        /** @description Successful response */
        200: {
          headers: {
            [name: string]: unknown;
          };
          content: {
            "application/json": components["schemas"]["ListMetricDescriptorsResponse"];
          };
        };
        429: components["responses"]["RateLimitError"];
        /** @description Error */
        default: {
          headers: {
            [name: string]: unknown;
          };
          content: {
            "application/json": components["schemas"]["ErrorResponse"];
          };
        };
      };
    };
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  "/v1/metrics/{dataset}/query": {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Query metric values
     * @deprecated
     * @description Queries metrics in a dataset.
     */
    post: {
      parameters: {
        query?: never;
        header?: never;
        path: {
          /** @description The dataset to query. Currently the only supported dataset name is `cloud`. See [here](#section/Object-Model/Datasets). */
          dataset: components["schemas"]["Dataset"];
        };
        cookie?: never;
      };
      requestBody?: {
        content: {
          "application/json": components["schemas"]["QueryRequest"];
        };
      };
      responses: {
        /** @description Successful response */
        200: {
          headers: {
            [name: string]: unknown;
          };
          content: {
            "application/json": components["schemas"]["QueryResponse"];
          };
        };
        429: components["responses"]["RateLimitError"];
        /** @description Error */
        default: {
          headers: {
            [name: string]: unknown;
          };
          content: {
            "application/json": components["schemas"]["ErrorResponse"];
          };
        };
      };
    };
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  "/v1/metrics/{dataset}/attributes": {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Query label values
     * @deprecated
     * @description Enumerates label values for a single metric.
     *
     */
    post: {
      parameters: {
        query?: {
          /** @description The next page token. The token is returned by the previous request as part of `meta.pagination`. */
          page_token?: string;
        };
        header?: never;
        path: {
          /** @description The dataset to query. */
          dataset: components["schemas"]["Dataset"];
        };
        cookie?: never;
      };
      requestBody?: {
        content: {
          "application/json": {
            /** @description The metric that the label values are enumerated for. */
            metric: string;
            /** @description The label(s) that the values are enumerated for. */
            group_by: string[];
            filter?: components["schemas"]["Filter"];
            /** @description Defines the time range(s) for which available metrics will be listed. A time range is an ISO-8601 interval. When unspecified, the value defaults to the last hour before the request was made */
            intervals?: components["schemas"]["Interval"][];
            /** @default 100 */
            limit?: number;
          };
        };
      };
      responses: {
        /** @description Successful response */
        200: {
          headers: {
            [name: string]: unknown;
          };
          content: {
            "application/json": components["schemas"]["AttributesResponse"];
          };
        };
        429: components["responses"]["RateLimitError"];
        /** @description Error */
        default: {
          headers: {
            [name: string]: unknown;
          };
          content: {
            "application/json": components["schemas"]["ErrorResponse"];
          };
        };
      };
    };
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  "/v2/metrics/{dataset}/descriptors/metrics": {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /**
     * List metric descriptors
     * @description Lists all the metric descriptors for a dataset.
     *
     *     A metric descriptor represents metadata for a metric, including its data type and labels.
     *     This metadata is provided programmatically to enable clients to dynamically adjust as new
     *     metrics are added to the dataset, rather than hardcoding metric names in client code.
     *
     */
    get: {
      parameters: {
        query?: {
          /** @description The maximum number of results to return. The page size is an integer in the range from 1 through 1000. */
          page_size?: number;
          /** @description The next page token. The token is returned by the previous request as part of `meta.pagination`. */
          page_token?: components["schemas"]["PageToken"];
          /** @description The type of the resource to list metric descriptors for. */
          resource_type?: components["schemas"]["ResourceType"];
        };
        header?: never;
        path: {
          /** @description The dataset to list metric descriptors for. Currently the only supported dataset name is `cloud`. See [here](#section/Object-Model/Datasets). */
          dataset: components["schemas"]["Dataset"];
        };
        cookie?: never;
      };
      requestBody?: never;
      responses: {
        /** @description Successful response */
        200: {
          headers: {
            [name: string]: unknown;
          };
          content: {
            "application/json": components["schemas"]["ListMetricDescriptorsResponse"];
          };
        };
        429: components["responses"]["RateLimitError"];
        /** @description Error */
        default: {
          headers: {
            [name: string]: unknown;
          };
          content: {
            "application/json": components["schemas"]["ErrorResponse"];
          };
        };
      };
    };
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  "/v2/metrics/{dataset}/descriptors/resources": {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /**
     * List resource descriptors
     * @description Lists all the resource descriptors for a dataset.
     *
     */
    get: {
      parameters: {
        query?: {
          /** @description The maximum number of results to return. The page size is an integer in the range from 1 through 1000. */
          page_size?: number;
          /** @description The next page token. The token is returned by the previous request as part of `meta.pagination`. */
          page_token?: components["schemas"]["PageToken"];
        };
        header?: never;
        path: {
          /** @description The dataset to list resource descriptors for. Currently the only supported dataset name is `cloud`. See [here](#section/Object-Model/Datasets). */
          dataset: components["schemas"]["Dataset"];
        };
        cookie?: never;
      };
      requestBody?: never;
      responses: {
        /** @description Successful response */
        200: {
          headers: {
            [name: string]: unknown;
          };
          content: {
            "application/json": components["schemas"]["ListResourceDescriptorsResponse"];
          };
        };
        429: components["responses"]["RateLimitError"];
        /** @description Error */
        default: {
          headers: {
            [name: string]: unknown;
          };
          content: {
            "application/json": components["schemas"]["ErrorResponse"];
          };
        };
      };
    };
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  "/v2/metrics/{dataset}/query": {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Query metric values
     * @description Query for metric values in a dataset.
     *
     */
    post: {
      parameters: {
        query?: {
          /** @description The next page token. The token is returned by the previous request as part of `meta.pagination`. Pagination is only supported for requests containing a `group_by` element. */
          page_token?: components["schemas"]["PageToken"];
        };
        header?: never;
        path: {
          /** @description The dataset to query. Currently the only supported dataset name is `cloud`. See [here](#section/Object-Model/Datasets). */
          dataset: components["schemas"]["Dataset"];
        };
        cookie?: never;
      };
      requestBody?: {
        content: {
          "application/json": components["schemas"]["QueryRequest"];
        };
      };
      responses: {
        /** @description Successful response */
        200: {
          headers: {
            [name: string]: unknown;
          };
          content: {
            "application/json": components["schemas"]["QueryResponse"];
          };
        };
        429: components["responses"]["RateLimitError"];
        /** @description Error */
        default: {
          headers: {
            [name: string]: unknown;
          };
          content: {
            "application/json": components["schemas"]["ErrorResponse"];
          };
        };
      };
    };
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  "/v2/metrics/{dataset}/export": {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /**
     * Export metric values
     * @description Export current metric values in [OpenMetrics format](https://github.com/OpenObservability/OpenMetrics/blob/main/specification/OpenMetrics.md)
     *     or [Prometheus format](https://prometheus.io/docs/instrumenting/exposition_formats/#text-based-format),
     *     suitable for import into an external monitoring system. Returns the single most recent
     *     data point for each metric, for each distinct combination of labels.
     *
     *     #### Supported datasets and metrics
     *     Only the `cloud` dataset is supported for this endpoint.
     *
     *     Only a subset of metrics and labels from the dataset are included in the export response. To request
     *     a particular metric or label be added, please contact [Confluent Support](https://support.confluent.io).
     *
     *     #### Metric translation
     *     Metric and label names are translated to adhere to [Prometheus restrictions](https://prometheus.io/docs/concepts/data_model/#metric-names-and-labels).
     *     The `resource.` and `metric.` prefixes from label names are also dropped to simplify consumption in downstream systems.
     *
     *     Counter metrics are classified as the Prometheus `gauge` type to conform to required semantics.
     *     > The `counter` type in Prometheus must be monotonically increasing, whereas Confluent
     *     Metrics API counters are represented as deltas.
     *
     *     #### Timestamp offset
     *     To account for [metric data latency](#section/Client-Considerations-and-Best-Practices/Metric-Data-Latency),
     *     this endpoint returns metrics from the current timestamp minus a fixed offset. The current
     *     offset is 5 minutes rounded down to the start of the minute. For example, if a request is
     *     received at `12:06:41`, the returned metrics will have the timestamp `12:01:00` and represent the
     *     data for the interval `12:01:00` through `12:02:00` (exclusive).
     *
     *     > **NOTE:** Confluent may choose to lengthen or shorten this offset based on operational
     *     considerations. _Doing so is considered a backwards-compatible change_.
     *
     *     To accommodate this offset, the timestamps in the response should be honored when importing
     *     the metrics. For example, in prometheus this can be controlled using the `honor_timestamps`
     *     flag.
     *
     *     #### Rate limits
     *     Since metrics are available at minute granularity, it is expected that clients scrape this
     *     endpoint at most once per minute. To allow for ad-hoc testing, the rate limit is enforced
     *     at hourly granularity. To accommodate retries, the rate limit is 80 requests per hour
     *     rather than 60 per hour.
     *
     *     The rate limit is evaluated on a per-resource basis. For example, the following requests would
     *     each be allowed an 80-requests-per-hour rate:
     *     * `GET /v2/metrics/cloud/export?resource.kafka.id=lkc-1&resource.kafka.id=lkc-2`
     *     * `GET /v2/metrics/cloud/export?resource.kafka.id=lkc-3`
     *
     *     Rate limits for this endpoint are also scoped to the authentication principal. This allows multiple systems
     *     to export metrics for the same resources by configuring each with a separate service account.
     *
     *     If the rate limit is exceeded, the response body will include a message indicating which
     *     resource exceeded the limit.
     *     ```json
     *     {
     *       "errors": [
     *         {
     *           "status": "429",
     *           "detail": "Too many requests have been made for the following resources: kafka.id:lkc-12345. Please see the documentation for current rate limits."
     *         }
     *       ]
     *     }
     *     ```
     *
     *     #### Example Prometheus scrape configuration
     *     Here is an example [prometheus configuration](https://prometheus.io/docs/prometheus/latest/configuration/configuration/)
     *     for scraping this endpoint:
     *
     *     ```yaml
     *     scrape_configs:
     *       - job_name: Confluent Cloud
     *         scrape_interval: 1m
     *         scrape_timeout: 1m
     *         honor_timestamps: true
     *         static_configs:
     *           - targets:
     *             - api.telemetry.confluent.cloud
     *         scheme: https
     *         basic_auth:
     *           username: <Cloud API Key>
     *           password: <Cloud API Secret>
     *         metrics_path: /v2/metrics/cloud/export
     *         params:
     *           "resource.kafka.id":
     *             - lkc-1
     *             - lkc-2
     *     ```
     *
     */
    get: {
      parameters: {
        query?: {
          /** @description The ID of the Kafka cluster to export metrics for. This parameter can be specified multiple times (e.g. `?resource.kafka.id=lkc-1&resource.kafka.id=lkc-2`). */
          "resource.kafka.id"?: string[];
          /** @description The ID of the Connector to export metrics for. This parameter can be specified multiple times. */
          "resource.connector.id"?: string[];
          /** @description The ID of the ksqlDB application to export metrics for. This parameter can be specified multiple times. */
          "resource.ksql.id"?: string[];
          /** @description The ID of the Schema Registry to export metrics for. This parameter can be specified multiple times. */
          "resource.schema_registry.id"?: string[];
          /** @description The metric to export. If this parameter is not specified, all metrics for the resource will be exported. This parameter can be specified multiple times. */
          metric?: string[];
        };
        header?: never;
        path: {
          /** @description The dataset to export metrics for. Currently the only supported dataset name is `cloud`. See [here](#section/Object-Model/Datasets). */
          dataset: components["schemas"]["Dataset"];
        };
        cookie?: never;
      };
      requestBody?: never;
      responses: {
        /** @description Successful response */
        200: {
          headers: {
            [name: string]: unknown;
          };
          content: {
            /** @example # HELP confluent_kafka_server_received_bytes The delta count of bytes of the customer's data received from the network. Each sample is the number of bytes received since the previous data sample. The count is sampled every 60 seconds.
             *     # TYPE confluent_kafka_server_received_bytes gauge
             *     confluent_kafka_server_received_bytes{kafka_id="lkc-1",topic="topicA"} 10.0 1609459200
             *     confluent_kafka_server_received_bytes{kafka_id="lkc-1",topic="topicB"} 20.0 1609459200
             *     confluent_kafka_server_received_bytes{kafka_id="lkc-2",topic="topicA"} 30.0 1609459200
             *
             *     # HELP confluent_kafka_server_sent_bytes The delta count of bytes of the customer's data sent to the network. Each sample is the number of bytes sent since the previous data sample. The count is sampled every 60 seconds.
             *     # TYPE confluent_kafka_server_sent_bytes gauge
             *     confluent_kafka_server_sent_bytes{kafka_id="lkc-1",topic="topicA"} 90.0 1609459200
             *     confluent_kafka_server_sent_bytes{kafka_id="lkc-1",topic="topicB"} 80.0 1609459200
             *     confluent_kafka_server_sent_bytes{kafka_id="lkc-2",topic="topicA"} 70.0 1609459200
             *      */
            "text/plain;version=0.0.4": string;
            /** @example # TYPE confluent_kafka_server_received_bytes gauge
             *     # UNIT confluent_kafka_server_received_bytes bytes
             *     # HELP confluent_kafka_server_received_bytes The delta count of bytes of the customer's data received from the network. Each sample is the number of bytes received since the previous data sample. The count is sampled every 60 seconds.
             *     confluent_kafka_server_received_bytes{kafka_id="lkc-1",topic="topicA"} 30.0 1609459200.000
             *     confluent_kafka_server_received_bytes{kafka_id="lkc-1",topic="topicB"} 70.0 1609459200.000
             *     confluent_kafka_server_received_bytes{kafka_id="lkc-2",topic="topicA"} 230.0 1609459200.000
             *     confluent_kafka_server_received_bytes{kafka_id="lkc-2",topic="topicB"} 270.0 1609459200.000
             *     # TYPE confluent_kafka_server_sent_bytes gauge
             *     # UNIT confluent_kafka_server_received_bytes bytes
             *     # HELP confluent_kafka_server_sent_bytes The delta count of bytes of the customer's data sent over the network. Each sample is the number of bytes sent since the previous data point. The count is sampled every 60 seconds.
             *     confluent_kafka_server_sent_bytes{kafka_id="lkc-1",topic="topicA"} 34.0 1609459200.000
             *     confluent_kafka_server_sent_bytes{kafka_id="lkc-1",topic="topicB"} 74.0 1609459200.000
             *     #EOF
             *      */
            "application/openmetrics-text;version=1.0.0;charset=utf-8": string;
          };
        };
        429: components["responses"]["RateLimitError"];
        /** @description Error */
        default: {
          headers: {
            [name: string]: unknown;
          };
          content: {
            "application/json": components["schemas"]["ErrorResponse"];
          };
        };
      };
    };
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  "/v2/metrics/{dataset}/attributes": {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Query label values
     * @description Enumerates label values for a single metric.
     *
     */
    post: {
      parameters: {
        query?: {
          /** @description The next page token. The token is returned by the previous request as part of `meta.pagination`. */
          page_token?: string;
        };
        header?: never;
        path: {
          /** @description The dataset to query. */
          dataset: components["schemas"]["Dataset"];
        };
        cookie?: never;
      };
      requestBody?: {
        content: {
          "application/json": components["schemas"]["AttributesRequest"];
        };
      };
      responses: {
        /** @description Successful response */
        200: {
          headers: {
            [name: string]: unknown;
          };
          content: {
            "application/json": components["schemas"]["AttributesResponse"];
          };
        };
        429: components["responses"]["RateLimitError"];
        /** @description Error */
        default: {
          headers: {
            [name: string]: unknown;
          };
          content: {
            "application/json": components["schemas"]["ErrorResponse"];
          };
        };
      };
    };
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
}
export type webhooks = Record<string, never>;
export interface components {
  schemas: {
    /** @description A logical collection of metrics that can be described and queried. Currently the only supported dataset name is `cloud`. See [here](#section/Object-Model/Datasets). */
    Dataset: string;
    /** @description An opaque token that you use to get the next page of results. */
    PageToken: string;
    /**
     * @description The pagination information.
     * @example {
     *       "page_size": 10,
     *       "total_size": 25
     *     }
     */
    Pagination: {
      /**
       * Format: int32
       * @description The page size requested by the user.
       */
      page_size: number;
      /**
       * Format: int32
       * @description The total number of items, if the total size can be determined in advance; otherwise, `total_size` is not included.
       */
      total_size?: number;
      next_page_token?: components["schemas"]["PageToken"];
    };
    /** @description Meta object */
    Meta: {
      pagination: components["schemas"]["Pagination"];
    };
    /** @description link information */
    Links: {
      /** @description The next page of resources in a collection. The link is present only if the current document is part of a collection. */
      next?: string;
    };
    /** @example {
     *       "errors": [
     *         {
     *           "detail": "fieldA must not be null"
     *         },
     *         {
     *           "detail": "fieldB must not be null"
     *         }
     *       ]
     *     } */
    ErrorResponse: {
      errors: {
        /** @description A unique identifier for this particular occurrence of the problem. */
        id?: string;
        /** @description The HTTP status code applicable to this problem, expressed as a string value. */
        status?: string;
        /** @description An application-specific error code, expressed as a string value. */
        code?: string;
        /** @description A human-readable explanation specific to this occurrence of the problem. */
        detail?: string;
        meta?: components["schemas"]["Meta"];
        links?: components["schemas"]["Links"];
      }[];
    };
    /**
     * @description The description of a label.
     * @example {
     *       "key": "topic",
     *       "description": "The name of the Kafka topic.",
     *       "exportable": true
     *     }
     */
    LabelDescriptor: {
      /** @description The description of the metric. */
      description: string;
      /** @description The key of the label. */
      key: string;
      /** @description Is this label included in the `/export` endpoint response? */
      exportable?: boolean;
    };
    /**
     * @description Defines a metric type and its schema.
     * @example {
     *       "description": "The delta count of bytes received from the network. The count is sampled every 60 seconds.",
     *       "name": "io.confluent.kafka.server/received_bytes",
     *       "unit": "By",
     *       "type": "GAUGE_INT64",
     *       "exportable": true,
     *       "lifecycle_stage": "GENERAL_AVAILABILITY",
     *       "resources": [
     *         "kafka"
     *       ],
     *       "labels": [
     *         {
     *           "key": "topic",
     *           "description": "The name of the Kafka topic.",
     *           "exportable": true
     *         }
     *       ]
     *     }
     */
    MetricDescriptor: {
      /** @description The description of the metric. */
      description: string;
      /** @description Labels for filtering and aggregating this metric. For example, you can
       *     filter the `io.confluent.kafka.server/received_bytes` metric by the
       *     `topic` label.
       *      */
      labels: components["schemas"]["LabelDescriptor"][];
      /** @description The unique name of the metric, for example,
       *     `io.confluent.kafka.server/received_bytes`.
       *      */
      name: string;
      /** @description The unit that the metric value is reported in. Units follow the format described in
       *     [the Unified Code for Units of Measure](http://unitsofmeasure.org/ucum.html).
       *     For example, `By` for bytes and `By/s` for bytes per second.
       *      */
      unit: string;
      /** @description The type of the measurement. The metric type follows the
       *     [OpenTelemetry](https://opentelemetry.io/) exposition format.
       *     * `GAUGE_(INT64|DOUBLE)`: An instantaneous measurement of a value.
       *       Gauge metrics are implicitly averaged when aggregating over time.
       *     * `COUNTER_(INT64|DOUBLE)`: The count of occurrences in a _single (one minute) sampling
       *       interval_ (unless otherwise stated in the metric description).
       *       Counter metrics are implicitly summed when aggregating over time.
       *      */
      type: string;
      /** @description The support lifecycle stage for this metric:
       *     * `PREVIEW`: May change at any time
       *     * `GENERAL_AVAILABILITY`: Fully released and stable. Will not change without notice.
       *     * `DEPRECATED`: No longer supported. Will be removed in the future at the annouced date.
       *      */
      lifecycle_stage: string;
      /** @description Is this metric included in the `/export` endpoint response? */
      exportable: boolean;
      /** @description The resource types to which this metric pertains. */
      resources: string[];
    };
    /** @description The ListMetricDescriptors response. */
    ListMetricDescriptorsResponse: {
      /** @description The metric descriptors for the specified dataset. */
      data: components["schemas"]["MetricDescriptor"][];
      meta: components["schemas"]["Meta"];
      links?: components["schemas"]["Links"];
    };
    /** @enum {string} */
    AggregationFunction: "SUM";
    /** @example {
     *       "metric": "io.confluent.kafka.server/bytes_in",
     *       "agg": "SUM"
     *     } */
    Aggregation: {
      /** @description The metric to aggregate. */
      metric: string;
      /** @description The aggregation function for the label buckets defined in `group_by`. */
      agg?: components["schemas"]["AggregationFunction"];
    };
    /**
     * Format: ISO-8601 duration (PnDTnHnMn.nS) or ALL
     * @description Defines the time buckets that the aggregation is performed for.
     *     Buckets are specified in
     *     [ISO-8601 duration syntax](https://en.wikipedia.org/wiki/ISO_8601#Durations), but
     *     only the enumerated values are supported. Buckets are aligned to UTC boundaries.
     *     The special `ALL` value defines a single bucket for all intervals.
     *
     *     The allowed granularity for a query is restricted by the length of that query's `interval`.
     *     Do not confuse intervals with retention time. Confluent uses granularity and intervals to validate requests. Retention time is  the length of time Confluent stores data. For example, requests with a granularity of `PT1M` can have a maximum interval of six hours. A  request with a granularity of `PT1M` and an interval of 12 hours  would fail validation. For more information about retention time,  see the  [FAQ](https://docs.confluent.io/cloud/current/monitoring/metrics-api.html#what-is-the-retention-time-of-metrics-in-the-metrics-api).
     *     Granularity equal to or greater than `PT1H` can use any interval.
     *
     *     | Granularity          | Maximum Interval Length  |
     *     |----------------------|--------------------------|
     *     | `PT1M` (1 minute)    | 6 hours                  |
     *     | `PT5M` (5 minutes)   | 1 day                    |
     *     | `PT15M` (15 minutes) | 4 days                   |
     *     | `PT30M` (30 minutes) | 7 days                   |
     *     | `PT1H` (1 hour)      | Any                      |
     *     | `PT4H` (4 hours)     | Any                      |
     *     | `PT6H` (6 hours)     | Any                      |
     *     | `PT12H` (12 hours)   | Any                      |
     *     | `P1D` (1 day)        | Any                      |
     *     | `ALL`                | Any                      |
     *
     * @example PT1H
     * @enum {string}
     */
    Granularity:
      | "PT1M"
      | "PT5M"
      | "PT15M"
      | "PT30M"
      | "PT1H"
      | "PT4H"
      | "PT6H"
      | "PT12H"
      | "P1D"
      | "ALL";
    /**
     * Field Filter
     * @example {
     *       "op": "EQ",
     *       "field": "resource.kafka.id",
     *       "value": "lkc-1234"
     *     }
     */
    FieldFilter: {
      /**
       * @description The comparison operator for the filter.
       *     Note that labels are compared _lexicographically_.
       *
       *     The `GT` or `GTE` operators can be used to page through grouped result sets that exceed
       *     the query limit.
       *
       * @enum {string}
       */
      op: "EQ" | "GT" | "GTE";
      /**
       * @description The field to filter on; see [here](#section/Object-Model/Labels) on using labels as
       *     filter fields.
       *
       * @example metric.topic
       */
      field?: string;
      value: string | number;
    };
    /** @description Metric filter. */
    Filter:
      | components["schemas"]["FieldFilter"]
      | components["schemas"]["CompoundFilter"]
      | components["schemas"]["UnaryFilter"];
    /**
     * Compound Filter
     * @example {
     *       "op": "OR",
     *       "filters": [
     *         {
     *           "field": "resource.kafka.id",
     *           "op": "EQ",
     *           "value": "lkc-1234"
     *         },
     *         {
     *           "field": "resource.kafka.id",
     *           "op": "EQ",
     *           "value": "lkc-5678"
     *         }
     *       ]
     *     }
     */
    CompoundFilter: {
      /** @enum {string} */
      op: "AND" | "OR";
      filters: components["schemas"]["Filter"][];
    };
    /**
     * Unary Filter
     * @example {
     *       "op": "NOT",
     *       "filter": {
     *         "field": "metric.topic",
     *         "op": "EQ",
     *         "value": "topicA"
     *       }
     *     }
     */
    UnaryFilter: {
      /** @enum {string} */
      op: "NOT";
      filter: components["schemas"]["Filter"];
    };
    /** @example {
     *       "metric": "io.confluent.kafka.server/bytes_in",
     *       "agg": "SUM",
     *       "order": "DESCENDING"
     *     } */
    OrderBy: {
      metric: string;
      agg?: components["schemas"]["AggregationFunction"];
      /**
       * @default DESCENDING
       * @enum {string}
       */
      order: "ASCENDING" | "DESCENDING";
    };
    /** Format: ISO-8601 interval (<start>/<end> | <start>/<duration> | <duration>/<end>) */
    Interval: string;
    /**
     * @description Desired response format for query results.
     *     * `FLAT` (default): Each item in the response `data` array represents a data point in the
     *       timeseries. Each data point contains the `timestamp`, metric aggregation `value` and
     *       attributes for the `group_by` labels.
     *     * `GROUPED`: Each item in the response `data` array represents a group. Each group contains
     *       attributes for the `group_by` labels and an array of `points` for the metric aggregation
     *       timeseries. **Only allowed when `group_by` is non-empty.**
     *
     *     Please see the response schema and accompanying examples for more details.
     *
     * @default FLAT
     * @enum {string}
     */
    ResponseFormat: "FLAT" | "GROUPED";
    QueryRequest: {
      /** @description Specifies which metrics to query and the aggregation operator to apply across the `group_by` labels. **Currently, only one aggregation per request is supported.** */
      aggregations: components["schemas"]["Aggregation"][];
      /** @description Specifies how data gets bucketed by label(s); see [here](#section/Object-Model/Labels)
       *     on using labels for grouping query results.
       *      */
      group_by?: string[];
      granularity: components["schemas"]["Granularity"];
      filter?: components["schemas"]["Filter"];
      /** @description Sort ordering for result groups. **Only valid for `granularity: "ALL"`.**
       *     If not specified, defaults to the first `aggregation` in descending order.
       *
       *     Note that this ordering applies to the groups.
       *     Within a group (or for ungrouped results), data points are always ordered by `timestamp`
       *     in descending order.
       *      */
      order_by?: components["schemas"]["OrderBy"][];
      /** @description Defines the time range(s) that the query runs over.
       *     A time range is an ISO-8601 interval.
       *
       *     The keyword `now` can be used in place of a timestamp to refer to the current time.
       *     Offset and truncation modifiers can be also be applied to the `now` expression:
       *
       *     | Modifier | Syntax | Examples |
       *     | --- | --- | --- |
       *     | Offset | `(+\|-)<amount>(m\|h\|d)` | `-2m` (minus 2 minutes)<br/>`-1h` (minus 1 hour) |
       *     | Truncation | `\|(m\|h\|d)` | `\|m` (round down to start of minute)<br/>`\|h` (round down to start of hour) |
       *
       *     All hour/day truncation is performed against the UTC timezone.
       *
       *     If `now` is `2020-01-01T02:13:27Z`, some examples are:
       *     * `now-2m|m`: `now` minus 2 minutes, truncated to start of minute.
       *     <br/>Resolves to `2020-01-01T02:11:00Z`
       *     * `now|h`: `now` truncated to start of hour.
       *     <br/>Resolves to `2020-01-01T02:00:00Z`
       *     * `now-1d|d`: `now` minus 1 day, truncated to start of day.
       *     <br/>Resolves to `2019-12-31T00:00:00Z`
       *
       *     When using `now`, it is recommended to apply a negative offset to avoid incomplete data
       *     (see [metric availability delays](#section/Client-Considerations-and-Best-Practices/Metric-Data-Latency))
       *     and align to minute boundaries (e.g. `now-2m|m`).
       *      */
      intervals: components["schemas"]["Interval"][];
      /**
       * @description The maximum number of _groups_ to return. The maximum number of data points in the response is equal to `limit * (interval / granularity)`. For example, with an interval of 1 day, granularity of `PT1H`, and limit of `2` there will be a maximum of 48 data points in the response (24 for each group).
       * @default 100
       */
      limit: number;
      format?: components["schemas"]["ResponseFormat"];
    };
    /** @example {
     *       "timestamp": "2019-10-17T20:17:00.000Z",
     *       "resource.kafka.id": "lkc-12345entry",
     *       "metric.topic": "foo",
     *       "value": 9741
     *     } */
    Point: {
      /**
       * Format: date-time
       * @description The timestamp for this time bucket, aligned to UTC boundaries.
       */
      timestamp: string;
      /** @description The value for the requested aggregation for this time bucket. */
      value: number;
    } & {
      [key: string]: unknown;
    };
    /**
     * Flat Response
     * @example {
     *       "data": [
     *         {
     *           "timestamp": "2019-10-17T20:17:00.000Z",
     *           "metric.topic": "foo",
     *           "value": 9741
     *         },
     *         {
     *           "timestamp": "2019-10-17T20:18:00.000Z",
     *           "metric.topic": "foo",
     *           "value": 9246
     *         },
     *         {
     *           "timestamp": "2019-10-17T20:17:00.000Z",
     *           "metric.topic": "bar",
     *           "value": 844.1
     *         },
     *         {
     *           "timestamp": "2019-10-17T20:18:00.000Z",
     *           "metric.topic": "bar",
     *           "value": 821.1
     *         }
     *       ]
     *     }
     */
    FlatQueryResponse: {
      /** @description An array of results for this query. Each item includes `timestamp`, `value`, and an attribute for each label specified in the request's `group_by`. */
      data: components["schemas"]["Point"][];
    };
    /**
     * Grouped Response
     * @example {
     *       "data": [
     *         {
     *           "metric.topic": "foo",
     *           "points": [
     *             {
     *               "timestamp": "2019-10-17T20:17:00.000Z",
     *               "value": 9741
     *             },
     *             {
     *               "timestamp": "2019-10-17T20:18:00.000Z",
     *               "value": 9246
     *             }
     *           ]
     *         },
     *         {
     *           "metric.topic": "bar",
     *           "points": [
     *             {
     *               "timestamp": "2019-10-17T20:17:00.000Z",
     *               "value": 844.1
     *             },
     *             {
     *               "timestamp": "2019-10-17T20:18:00.000Z",
     *               "value": 821.1
     *             }
     *           ]
     *         }
     *       ]
     *     }
     */
    GroupedQueryResponse: {
      /** @description An array of results for this query. Each item represents a group bucket having a distinct set of label values for the request's `group_by`.  The groups are ordered lexicographically by the label values for that group. */
      data: ({
        points: components["schemas"]["Point"][];
      } & {
        [key: string]: unknown;
      })[];
    };
    QueryResponse:
      | components["schemas"]["FlatQueryResponse"]
      | components["schemas"]["GroupedQueryResponse"];
    /** @example {
     *       "data": [
     *         {
     *           "metric.label.topic": "foo"
     *         },
     *         {
     *           "metric.label.topic": "bar"
     *         },
     *         {
     *           "metric.label.topic": "baz"
     *         }
     *       ],
     *       "meta": {
     *         "pagination": {
     *           "page_size": 3,
     *           "total_size": 3
     *         }
     *       }
     *     } */
    AttributesResponse: {
      /** @description The enumerated labels, as an array of key/value pairs. */
      data: {
        [key: string]: string;
      }[];
      meta: components["schemas"]["Meta"];
      links?: components["schemas"]["Links"];
    };
    /** @description A named type for a resource (e.g. `kafka`, `connector`). */
    ResourceType: string;
    /**
     * @description A Resource represents the entity producing metrics.
     *     For example: a Kafka cluster a Kafka Connector, etc.
     *
     * @example {
     *       "type": "kafka",
     *       "description": "A Kafka cluster.",
     *       "labels": [
     *         {
     *           "key": "kafka.id",
     *           "description": "ID of the kafka cluster",
     *           "exportable": true
     *         }
     *       ]
     *     }
     */
    ResourceDescriptor: {
      type: components["schemas"]["ResourceType"];
      /** @description The description of the resource. */
      description: string;
      /** @description Labels for the resource.
       *     Resource labels can be used for filtering and aggregating metrics
       *     associated with a resource.
       *      */
      labels: components["schemas"]["LabelDescriptor"][];
    };
    /** @description The list of resource descriptors for a dataset */
    ListResourceDescriptorsResponse: {
      /** @description The resource descriptors for the specified dataset. */
      data: components["schemas"]["ResourceDescriptor"][];
      meta: components["schemas"]["Meta"];
      links?: components["schemas"]["Links"];
    };
    AttributesRequest: {
      /** @description The metric that the label values are enumerated for. */
      metric?: string;
      /** @description The label(s) that the values are enumerated for. */
      group_by: string[];
      filter?: components["schemas"]["Filter"];
      /** @description Defines the time range(s) for which available metrics will be listed. A time range is an ISO-8601 interval. When unspecified, the value defaults to the last hour before the request was made */
      intervals?: components["schemas"]["Interval"][];
      /** @default 100 */
      limit: number;
    };
  };
  responses: {
    /** @description Rate Limit Exceeded */
    RateLimitError: {
      headers: {
        [name: string]: unknown;
      };
      content?: never;
    };
  };
  parameters: never;
  requestBodies: never;
  headers: never;
  pathItems: never;
}
export type $defs = Record<string, never>;
export type operations = Record<string, never>;
