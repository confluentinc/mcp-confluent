/**
 * This file was auto-generated by openapi-typescript.
 * Do not make direct changes to the file.
 */

export interface paths {
  "/iam/v2/api-keys": {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /**
     * List of API Keys
     * @description [![General Availability](https://img.shields.io/badge/Lifecycle%20Stage-General%20Availability-%2345c6e8)](#section/Versioning/API-Lifecycle-Policy)
     *
     *     Retrieve a sorted, filtered, paginated list of all API keys.
     *
     *     This can show all keys for a single owner (across resources - Kafka clusters), or all keys for a single
     *     resource (across owners). If no `owner` or `resource` filters are specified, returns all API Keys in the
     *     organization. You will only see the keys that are accessible to the account making the API request.
     *
     */
    get: operations["listIamV2ApiKeys"];
    put?: never;
    /**
     * Create an API Key
     * @description [![General Availability](https://img.shields.io/badge/Lifecycle%20Stage-General%20Availability-%2345c6e8)](#section/Versioning/API-Lifecycle-Policy)
     *
     *     Make a request to create an API key.
     */
    post: operations["createIamV2ApiKey"];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  "/iam/v2/api-keys/{id}": {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /**
     * Read an API Key
     * @description [![General Availability](https://img.shields.io/badge/Lifecycle%20Stage-General%20Availability-%2345c6e8)](#section/Versioning/API-Lifecycle-Policy)
     *
     *     Make a request to read an API key.
     */
    get: operations["getIamV2ApiKey"];
    put?: never;
    post?: never;
    /**
     * Delete an API Key
     * @description [![General Availability](https://img.shields.io/badge/Lifecycle%20Stage-General%20Availability-%2345c6e8)](#section/Versioning/API-Lifecycle-Policy)
     *
     *     Make a request to delete an API key.
     */
    delete: operations["deleteIamV2ApiKey"];
    options?: never;
    head?: never;
    /**
     * Update an API Key
     * @description [![General Availability](https://img.shields.io/badge/Lifecycle%20Stage-General%20Availability-%2345c6e8)](#section/Versioning/API-Lifecycle-Policy)
     *
     *     Make a request to update an API key.
     *
     *
     */
    patch: operations["updateIamV2ApiKey"];
    trace?: never;
  };
  "/org/v2/environments": {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /**
     * List of Environments
     * @description [![General Availability](https://img.shields.io/badge/Lifecycle%20Stage-General%20Availability-%2345c6e8)](#section/Versioning/API-Lifecycle-Policy)
     *
     *     Retrieve a sorted, filtered, paginated list of all environments.
     */
    get: operations["listOrgV2Environments"];
    put?: never;
    /**
     * Create an Environment
     * @description [![General Availability](https://img.shields.io/badge/Lifecycle%20Stage-General%20Availability-%2345c6e8)](#section/Versioning/API-Lifecycle-Policy)
     *
     *     Make a request to create an environment.
     */
    post: operations["createOrgV2Environment"];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  "/org/v2/environments/{id}": {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /**
     * Read an Environment
     * @description [![General Availability](https://img.shields.io/badge/Lifecycle%20Stage-General%20Availability-%2345c6e8)](#section/Versioning/API-Lifecycle-Policy)
     *
     *     Make a request to read an environment.
     */
    get: operations["getOrgV2Environment"];
    put?: never;
    post?: never;
    /**
     * Delete an Environment
     * @description [![General Availability](https://img.shields.io/badge/Lifecycle%20Stage-General%20Availability-%2345c6e8)](#section/Versioning/API-Lifecycle-Policy)
     *
     *     Make a request to delete an environment.
     *
     *     If successful, this request will also recursively delete all of the environment's associated resources,
     *     including all Kafka clusters, connectors, etc.
     *
     */
    delete: operations["deleteOrgV2Environment"];
    options?: never;
    head?: never;
    /**
     * Update an Environment
     * @description [![General Availability](https://img.shields.io/badge/Lifecycle%20Stage-General%20Availability-%2345c6e8)](#section/Versioning/API-Lifecycle-Policy)
     *
     *     Make a request to update an environment.
     *
     *
     */
    patch: operations["updateOrgV2Environment"];
    trace?: never;
  };
  "/org/v2/organizations": {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /**
     * List of Organizations
     * @description [![General Availability](https://img.shields.io/badge/Lifecycle%20Stage-General%20Availability-%2345c6e8)](#section/Versioning/API-Lifecycle-Policy)
     *
     *     Retrieve a sorted, filtered, paginated list of all organizations.
     */
    get: operations["listOrgV2Organizations"];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  "/org/v2/organizations/{id}": {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /**
     * Read an Organization
     * @description [![General Availability](https://img.shields.io/badge/Lifecycle%20Stage-General%20Availability-%2345c6e8)](#section/Versioning/API-Lifecycle-Policy)
     *
     *     Make a request to read an organization.
     */
    get: operations["getOrgV2Organization"];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    /**
     * Update an Organization
     * @description [![General Availability](https://img.shields.io/badge/Lifecycle%20Stage-General%20Availability-%2345c6e8)](#section/Versioning/API-Lifecycle-Policy)
     *
     *     Make a request to update an organization.
     *
     *
     */
    patch: operations["updateOrgV2Organization"];
    trace?: never;
  };
  "/iam/v2/users": {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /**
     * List of Users
     * @description [![General Availability](https://img.shields.io/badge/Lifecycle%20Stage-General%20Availability-%2345c6e8)](#section/Versioning/API-Lifecycle-Policy)
     *
     *     Retrieve a sorted, filtered, paginated list of all users.
     */
    get: operations["listIamV2Users"];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  "/iam/v2/users/{id}": {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /**
     * Read a User
     * @description [![General Availability](https://img.shields.io/badge/Lifecycle%20Stage-General%20Availability-%2345c6e8)](#section/Versioning/API-Lifecycle-Policy)
     *
     *     Make a request to read a user.
     */
    get: operations["getIamV2User"];
    put?: never;
    post?: never;
    /**
     * Delete a User
     * @description [![General Availability](https://img.shields.io/badge/Lifecycle%20Stage-General%20Availability-%2345c6e8)](#section/Versioning/API-Lifecycle-Policy)
     *
     *     Make a request to delete a user.
     *
     *     If successful, this request will also recursively delete all of the user's associated resources,
     *     including its cloud and cluster API keys.
     *
     */
    delete: operations["deleteIamV2User"];
    options?: never;
    head?: never;
    /**
     * Update a User
     * @description [![General Availability](https://img.shields.io/badge/Lifecycle%20Stage-General%20Availability-%2345c6e8)](#section/Versioning/API-Lifecycle-Policy)
     *
     *     Make a request to update a user.
     *
     *
     */
    patch: operations["updateIamV2User"];
    trace?: never;
  };
  "/iam/v2/users/{id}/auth": {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    /**
     * Update Auth Type of a User
     * @description [![General Availability](https://img.shields.io/badge/Lifecycle%20Stage-General%20Availability-%2345c6e8)](#section/Versioning/API-Lifecycle-Policy)
     *
     *     Update the auth type of a user
     */
    patch: operations["update_auth_typeIamV2User"];
    trace?: never;
  };
  "/iam/v2/service-accounts": {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /**
     * List of Service Accounts
     * @description [![General Availability](https://img.shields.io/badge/Lifecycle%20Stage-General%20Availability-%2345c6e8)](#section/Versioning/API-Lifecycle-Policy)
     *
     *     Retrieve a sorted, filtered, paginated list of all service accounts.
     */
    get: operations["listIamV2ServiceAccounts"];
    put?: never;
    /**
     * Create a Service Account
     * @description [![General Availability](https://img.shields.io/badge/Lifecycle%20Stage-General%20Availability-%2345c6e8)](#section/Versioning/API-Lifecycle-Policy)
     *
     *     Make a request to create a service account.
     */
    post: operations["createIamV2ServiceAccount"];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  "/iam/v2/service-accounts/{id}": {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /**
     * Read a Service Account
     * @description [![General Availability](https://img.shields.io/badge/Lifecycle%20Stage-General%20Availability-%2345c6e8)](#section/Versioning/API-Lifecycle-Policy)
     *
     *     Make a request to read a service account.
     */
    get: operations["getIamV2ServiceAccount"];
    put?: never;
    post?: never;
    /**
     * Delete a Service Account
     * @description [![General Availability](https://img.shields.io/badge/Lifecycle%20Stage-General%20Availability-%2345c6e8)](#section/Versioning/API-Lifecycle-Policy)
     *
     *     Make a request to delete a service account.
     *
     *     If successful, this request will also recursively delete all of the service account's associated resources,
     *     including its cloud and cluster API keys.
     *
     */
    delete: operations["deleteIamV2ServiceAccount"];
    options?: never;
    head?: never;
    /**
     * Update a Service Account
     * @description [![General Availability](https://img.shields.io/badge/Lifecycle%20Stage-General%20Availability-%2345c6e8)](#section/Versioning/API-Lifecycle-Policy)
     *
     *     Make a request to update a service account.
     *
     *
     */
    patch: operations["updateIamV2ServiceAccount"];
    trace?: never;
  };
  "/iam/v2/invitations": {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /**
     * List of Invitations
     * @description [![General Availability](https://img.shields.io/badge/Lifecycle%20Stage-General%20Availability-%2345c6e8)](#section/Versioning/API-Lifecycle-Policy)
     *
     *     Retrieve a sorted, filtered, paginated list of all invitations.
     */
    get: operations["listIamV2Invitations"];
    put?: never;
    /**
     * Create an Invitation
     * @description [![General Availability](https://img.shields.io/badge/Lifecycle%20Stage-General%20Availability-%2345c6e8)](#section/Versioning/API-Lifecycle-Policy)
     *
     *     Make a request to create an invitation.
     *
     *     The newly invited user will not have any permissions. Give the user permission by assigning them to one or
     *     more roles by creating
     *     [role bindings](https://docs.confluent.io/cloud/current/api.html#tag/Role-Bindings-(iamv2))
     *     for the created `user`.
     *
     */
    post: operations["createIamV2Invitation"];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  "/iam/v2/invitations/{id}": {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /**
     * Read an Invitation
     * @description [![General Availability](https://img.shields.io/badge/Lifecycle%20Stage-General%20Availability-%2345c6e8)](#section/Versioning/API-Lifecycle-Policy)
     *
     *     Make a request to read an invitation.
     */
    get: operations["getIamV2Invitation"];
    put?: never;
    post?: never;
    /**
     * Delete an Invitation
     * @description [![General Availability](https://img.shields.io/badge/Lifecycle%20Stage-General%20Availability-%2345c6e8)](#section/Versioning/API-Lifecycle-Policy)
     *
     *     Make a request to delete an invitation.
     *
     *     Delete will deactivate the user if the user didn't accept the invitation yet.
     *
     */
    delete: operations["deleteIamV2Invitation"];
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  "/iam/v2/ip-groups": {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /**
     * List of IP Groups
     * @description [![General Availability](https://img.shields.io/badge/Lifecycle%20Stage-General%20Availability-%2345c6e8)](#section/Versioning/API-Lifecycle-Policy)
     *
     *     Retrieve a sorted, filtered, paginated list of all IP groups.
     */
    get: operations["listIamV2IpGroups"];
    put?: never;
    /**
     * Create an IP Group
     * @description [![General Availability](https://img.shields.io/badge/Lifecycle%20Stage-General%20Availability-%2345c6e8)](#section/Versioning/API-Lifecycle-Policy)
     *
     *     Make a request to create an IP group.
     */
    post: operations["createIamV2IpGroup"];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  "/iam/v2/ip-groups/{id}": {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /**
     * Read an IP Group
     * @description [![General Availability](https://img.shields.io/badge/Lifecycle%20Stage-General%20Availability-%2345c6e8)](#section/Versioning/API-Lifecycle-Policy)
     *
     *     Make a request to read an IP group.
     */
    get: operations["getIamV2IpGroup"];
    put?: never;
    post?: never;
    /**
     * Delete an IP Group
     * @description [![General Availability](https://img.shields.io/badge/Lifecycle%20Stage-General%20Availability-%2345c6e8)](#section/Versioning/API-Lifecycle-Policy)
     *
     *     Make a request to delete an IP group.
     */
    delete: operations["deleteIamV2IpGroup"];
    options?: never;
    head?: never;
    /**
     * Update an IP Group
     * @description [![General Availability](https://img.shields.io/badge/Lifecycle%20Stage-General%20Availability-%2345c6e8)](#section/Versioning/API-Lifecycle-Policy)
     *
     *     Make a request to update an IP group.
     *
     *
     */
    patch: operations["updateIamV2IpGroup"];
    trace?: never;
  };
  "/iam/v2/ip-filters": {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /**
     * List of IP Filters
     * @description [![General Availability](https://img.shields.io/badge/Lifecycle%20Stage-General%20Availability-%2345c6e8)](#section/Versioning/API-Lifecycle-Policy)
     *
     *     Retrieve a sorted, filtered, paginated list of all IP filters.
     */
    get: operations["listIamV2IpFilters"];
    put?: never;
    /**
     * Create an IP Filter
     * @description [![General Availability](https://img.shields.io/badge/Lifecycle%20Stage-General%20Availability-%2345c6e8)](#section/Versioning/API-Lifecycle-Policy)
     *
     *     Make a request to create an IP filter.
     */
    post: operations["createIamV2IpFilter"];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  "/iam/v2/ip-filters/{id}": {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /**
     * Read an IP Filter
     * @description [![General Availability](https://img.shields.io/badge/Lifecycle%20Stage-General%20Availability-%2345c6e8)](#section/Versioning/API-Lifecycle-Policy)
     *
     *     Make a request to read an IP filter.
     */
    get: operations["getIamV2IpFilter"];
    put?: never;
    post?: never;
    /**
     * Delete an IP Filter
     * @description [![General Availability](https://img.shields.io/badge/Lifecycle%20Stage-General%20Availability-%2345c6e8)](#section/Versioning/API-Lifecycle-Policy)
     *
     *     Make a request to delete an IP filter.
     */
    delete: operations["deleteIamV2IpFilter"];
    options?: never;
    head?: never;
    /**
     * Update an IP Filter
     * @description [![General Availability](https://img.shields.io/badge/Lifecycle%20Stage-General%20Availability-%2345c6e8)](#section/Versioning/API-Lifecycle-Policy)
     *
     *     Make a request to update an IP filter.
     *
     *
     */
    patch: operations["updateIamV2IpFilter"];
    trace?: never;
  };
  "/iam/v2/ip-filter-summary": {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /**
     * Read an IP Filter Summary
     * @description [![General Availability](https://img.shields.io/badge/Lifecycle%20Stage-General%20Availability-%2345c6e8)](#section/Versioning/API-Lifecycle-Policy)
     *
     *     Make a request to read an IP filter summary.
     */
    get: operations["getIamV2IpFilterSummary"];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  "/iam/v2/role-bindings": {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /**
     * List of Role Bindings
     * @description [![General Availability](https://img.shields.io/badge/Lifecycle%20Stage-General%20Availability-%2345c6e8)](#section/Versioning/API-Lifecycle-Policy)
     *
     *     Retrieve a sorted, filtered, paginated list of all role bindings.
     */
    get: operations["listIamV2RoleBindings"];
    put?: never;
    /**
     * Create a Role Binding
     * @description [![General Availability](https://img.shields.io/badge/Lifecycle%20Stage-General%20Availability-%2345c6e8)](#section/Versioning/API-Lifecycle-Policy)
     *
     *     Make a request to create a role binding.
     */
    post: operations["createIamV2RoleBinding"];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  "/iam/v2/role-bindings/{id}": {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /**
     * Read a Role Binding
     * @description [![General Availability](https://img.shields.io/badge/Lifecycle%20Stage-General%20Availability-%2345c6e8)](#section/Versioning/API-Lifecycle-Policy)
     *
     *     Make a request to read a role binding.
     */
    get: operations["getIamV2RoleBinding"];
    put?: never;
    post?: never;
    /**
     * Delete a Role Binding
     * @description [![General Availability](https://img.shields.io/badge/Lifecycle%20Stage-General%20Availability-%2345c6e8)](#section/Versioning/API-Lifecycle-Policy)
     *
     *     Make a request to delete a role binding.
     */
    delete: operations["deleteIamV2RoleBinding"];
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  "/notifications/v1/subscriptions": {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /**
     * List of Subscriptions
     * @description [![General Availability](https://img.shields.io/badge/Lifecycle%20Stage-General%20Availability-%2345c6e8)](#section/Versioning/API-Lifecycle-Policy)
     *
     *     Retrieve a sorted, filtered, paginated list of all subscriptions.
     */
    get: operations["listNotificationsV1Subscriptions"];
    put?: never;
    /**
     * Create a Subscription
     * @description [![General Availability](https://img.shields.io/badge/Lifecycle%20Stage-General%20Availability-%2345c6e8)](#section/Versioning/API-Lifecycle-Policy)
     *
     *     Make a request to create a subscription.
     */
    post: operations["createNotificationsV1Subscription"];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  "/notifications/v1/subscriptions/{id}": {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /**
     * Read a Subscription
     * @description [![General Availability](https://img.shields.io/badge/Lifecycle%20Stage-General%20Availability-%2345c6e8)](#section/Versioning/API-Lifecycle-Policy)
     *
     *     Make a request to read a subscription.
     */
    get: operations["getNotificationsV1Subscription"];
    put?: never;
    post?: never;
    /**
     * Delete a Subscription
     * @description [![General Availability](https://img.shields.io/badge/Lifecycle%20Stage-General%20Availability-%2345c6e8)](#section/Versioning/API-Lifecycle-Policy)
     *
     *     Make a request to delete a subscription.
     */
    delete: operations["deleteNotificationsV1Subscription"];
    options?: never;
    head?: never;
    /**
     * Update a Subscription
     * @description [![General Availability](https://img.shields.io/badge/Lifecycle%20Stage-General%20Availability-%2345c6e8)](#section/Versioning/API-Lifecycle-Policy)
     *
     *     Make a request to update a subscription.
     *
     *
     */
    patch: operations["updateNotificationsV1Subscription"];
    trace?: never;
  };
  "/notifications/v1/integrations": {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /**
     * List of Integrations
     * @description [![General Availability](https://img.shields.io/badge/Lifecycle%20Stage-General%20Availability-%2345c6e8)](#section/Versioning/API-Lifecycle-Policy)
     *
     *     Retrieve a sorted, filtered, paginated list of all integrations.
     */
    get: operations["listNotificationsV1Integrations"];
    put?: never;
    /**
     * Create an Integration
     * @description [![General Availability](https://img.shields.io/badge/Lifecycle%20Stage-General%20Availability-%2345c6e8)](#section/Versioning/API-Lifecycle-Policy)
     *
     *     Make a request to create an integration.
     */
    post: operations["createNotificationsV1Integration"];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  "/notifications/v1/integrations/{id}": {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /**
     * Read an Integration
     * @description [![General Availability](https://img.shields.io/badge/Lifecycle%20Stage-General%20Availability-%2345c6e8)](#section/Versioning/API-Lifecycle-Policy)
     *
     *     Make a request to read an integration.
     */
    get: operations["getNotificationsV1Integration"];
    put?: never;
    post?: never;
    /**
     * Delete an Integration
     * @description [![General Availability](https://img.shields.io/badge/Lifecycle%20Stage-General%20Availability-%2345c6e8)](#section/Versioning/API-Lifecycle-Policy)
     *
     *     Make a request to delete an integration.
     */
    delete: operations["deleteNotificationsV1Integration"];
    options?: never;
    head?: never;
    /**
     * Update an Integration
     * @description [![General Availability](https://img.shields.io/badge/Lifecycle%20Stage-General%20Availability-%2345c6e8)](#section/Versioning/API-Lifecycle-Policy)
     *
     *     Make a request to update an integration.
     *
     *
     */
    patch: operations["updateNotificationsV1Integration"];
    trace?: never;
  };
  "/notifications/v1/integrations:test": {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Test a Webhook, Slack or Microsoft Teams integration
     * @description [![General Availability](https://img.shields.io/badge/Lifecycle%20Stage-General%20Availability-%2345c6e8)](#section/Versioning/API-Lifecycle-Policy)
     *
     *     Sends a test notification to validate the integration. This is supported only for Webhook, Slack
     *     and MsTeams targets
     *
     */
    post: operations["testNotificationsV1Integration"];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  "/notifications/v1/notification-types": {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /**
     * List of Notification Types
     * @description [![General Availability](https://img.shields.io/badge/Lifecycle%20Stage-General%20Availability-%2345c6e8)](#section/Versioning/API-Lifecycle-Policy)
     *
     *     Retrieve a sorted, filtered, paginated list of all notification types.
     */
    get: operations["listNotificationsV1NotificationTypes"];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  "/notifications/v1/notification-types/{id}": {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /**
     * Read a Notification Type
     * @description [![General Availability](https://img.shields.io/badge/Lifecycle%20Stage-General%20Availability-%2345c6e8)](#section/Versioning/API-Lifecycle-Policy)
     *
     *     Make a request to read a notification type.
     */
    get: operations["getNotificationsV1NotificationType"];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  "/cmk/v2/clusters": {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /**
     * List of Clusters
     * @description [![General Availability](https://img.shields.io/badge/Lifecycle%20Stage-General%20Availability-%2345c6e8)](#section/Versioning/API-Lifecycle-Policy)
     *
     *     Retrieve a sorted, filtered, paginated list of all clusters.
     */
    get: operations["listCmkV2Clusters"];
    put?: never;
    /**
     * Create a Cluster
     * @description [![General Availability](https://img.shields.io/badge/Lifecycle%20Stage-General%20Availability-%2345c6e8)](#section/Versioning/API-Lifecycle-Policy)
     *
     *     Make a request to create a cluster.
     */
    post: operations["createCmkV2Cluster"];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  "/cmk/v2/clusters/{id}": {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /**
     * Read a Cluster
     * @description [![General Availability](https://img.shields.io/badge/Lifecycle%20Stage-General%20Availability-%2345c6e8)](#section/Versioning/API-Lifecycle-Policy)
     *
     *     Make a request to read a cluster.
     */
    get: operations["getCmkV2Cluster"];
    put?: never;
    post?: never;
    /**
     * Delete a Cluster
     * @description [![General Availability](https://img.shields.io/badge/Lifecycle%20Stage-General%20Availability-%2345c6e8)](#section/Versioning/API-Lifecycle-Policy)
     *
     *     Make a request to delete a cluster.
     */
    delete: operations["deleteCmkV2Cluster"];
    options?: never;
    head?: never;
    /**
     * Update a Cluster
     * @description [![General Availability](https://img.shields.io/badge/Lifecycle%20Stage-General%20Availability-%2345c6e8)](#section/Versioning/API-Lifecycle-Policy)
     *
     *     Make a request to update a cluster.
     *
     *
     */
    patch: operations["updateCmkV2Cluster"];
    trace?: never;
  };
  "/ksqldbcm/v2/clusters": {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /**
     * List of Clusters
     * @description [![General Availability](https://img.shields.io/badge/Lifecycle%20Stage-General%20Availability-%2345c6e8)](#section/Versioning/API-Lifecycle-Policy)
     *
     *     Retrieve a sorted, filtered, paginated list of all clusters.
     */
    get: operations["listKsqldbcmV2Clusters"];
    put?: never;
    /**
     * Create a Cluster
     * @description [![General Availability](https://img.shields.io/badge/Lifecycle%20Stage-General%20Availability-%2345c6e8)](#section/Versioning/API-Lifecycle-Policy)
     *
     *     Make a request to create a cluster.
     */
    post: operations["createKsqldbcmV2Cluster"];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  "/ksqldbcm/v2/clusters/{id}": {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /**
     * Read a Cluster
     * @description [![General Availability](https://img.shields.io/badge/Lifecycle%20Stage-General%20Availability-%2345c6e8)](#section/Versioning/API-Lifecycle-Policy)
     *
     *     Make a request to read a cluster.
     */
    get: operations["getKsqldbcmV2Cluster"];
    put?: never;
    post?: never;
    /**
     * Delete a Cluster
     * @description [![General Availability](https://img.shields.io/badge/Lifecycle%20Stage-General%20Availability-%2345c6e8)](#section/Versioning/API-Lifecycle-Policy)
     *
     *     Make a request to delete a cluster.
     */
    delete: operations["deleteKsqldbcmV2Cluster"];
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  "/connect/v1/environments/{environment_id}/clusters/{kafka_cluster_id}/connectors": {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description The unique identifier of the environment this resource belongs to. */
        environment_id: string;
        /** @description The unique identifier for the Kafka cluster. */
        kafka_cluster_id: string;
      };
      cookie?: never;
    };
    /**
     * List of Connectors
     * @description [![General Availability](https://img.shields.io/badge/Lifecycle%20Stage-General%20Availability-%2345c6e8)](#section/Versioning/API-Lifecycle-Policy)
     *
     *     Retrieve a list of "names" of the active connectors. You can then make a [read request](#operation/readConnectv1Connector) for a specific connector by name.
     */
    get: operations["listConnectv1Connectors"];
    put?: never;
    /**
     * Create a Connector
     * @description [![General Availability](https://img.shields.io/badge/Lifecycle%20Stage-General%20Availability-%2345c6e8)](#section/Versioning/API-Lifecycle-Policy)
     *
     *     Create a new connector. Returns the new connector information if successful.
     */
    post: operations["createConnectv1Connector"];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  "/connect/v1/environments/{environment_id}/clusters/{kafka_cluster_id}/connectors?expand=info,status,id": {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /**
     * List of Connectors with Expansions
     * @description [![General Availability](https://img.shields.io/badge/Lifecycle%20Stage-General%20Availability-%2345c6e8)](#section/Versioning/API-Lifecycle-Policy)
     *
     *     Retrieve an object with the queried expansions of all connectors. Without `expand` query parameter, this list connector’s endpoint will return a [list of only the connector names](#operation/listConnectv1Connectors).
     */
    get: operations["listConnectv1ConnectorsWithExpansions"];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  "/connect/v1/environments/{environment_id}/clusters/{kafka_cluster_id}/connectors/{connector_name}/config": {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description The unique name of the connector. */
        connector_name: string;
        /** @description The unique identifier of the environment this resource belongs to. */
        environment_id: string;
        /** @description The unique identifier for the Kafka cluster. */
        kafka_cluster_id: string;
      };
      cookie?: never;
    };
    /**
     * Read a Connector Configuration
     * @description [![General Availability](https://img.shields.io/badge/Lifecycle%20Stage-General%20Availability-%2345c6e8)](#section/Versioning/API-Lifecycle-Policy)
     *
     *     Get the configuration for the connector.
     */
    get: operations["getConnectv1ConnectorConfig"];
    /**
     * Create or Update a Connector Configuration
     * @description Create a new connector using the given configuration, or update the configuration for an existing connector. Returns information about the connector after the change has been made.
     */
    put: operations["createOrUpdateConnectv1ConnectorConfig"];
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  "/connect/v1/environments/{environment_id}/clusters/{kafka_cluster_id}/connectors/{connector_name}": {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description The unique name of the connector. */
        connector_name: string;
        /** @description The unique identifier of the environment this resource belongs to. */
        environment_id: string;
        /** @description The unique identifier for the Kafka cluster. */
        kafka_cluster_id: string;
      };
      cookie?: never;
    };
    /**
     * Read a Connector
     * @description [![General Availability](https://img.shields.io/badge/Lifecycle%20Stage-General%20Availability-%2345c6e8)](#section/Versioning/API-Lifecycle-Policy)
     *
     *     Get information about the connector.
     */
    get: operations["readConnectv1Connector"];
    put?: never;
    post?: never;
    /**
     * Delete a Connector
     * @description [![General Availability](https://img.shields.io/badge/Lifecycle%20Stage-General%20Availability-%2345c6e8)](#section/Versioning/API-Lifecycle-Policy)
     *
     *     Delete a connector. Halts all tasks and deletes the connector configuration.
     */
    delete: operations["deleteConnectv1Connector"];
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  "/connect/v1/environments/{environment_id}/clusters/{kafka_cluster_id}/connectors/{connector_name}/pause": {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description The unique name of the connector. */
        connector_name: string;
        /** @description The unique identifier of the environment this resource belongs to. */
        environment_id: string;
        /** @description The unique identifier for the Kafka cluster. */
        kafka_cluster_id: string;
      };
      cookie?: never;
    };
    get?: never;
    /**
     * Pause a Connector
     * @description [![General Availability](https://img.shields.io/badge/Lifecycle%20Stage-General%20Availability-%2345c6e8)](#section/Versioning/API-Lifecycle-Policy)
     *
     *     Pause the connector and its tasks. Stops message processing until the connector is resumed. This call is asynchronous and the tasks will not transition to PAUSED state at the same time.
     */
    put: operations["pauseConnectv1Connector"];
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  "/connect/v1/environments/{environment_id}/clusters/{kafka_cluster_id}/connectors/{connector_name}/resume": {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description The unique name of the connector. */
        connector_name: string;
        /** @description The unique identifier of the environment this resource belongs to. */
        environment_id: string;
        /** @description The unique identifier for the Kafka cluster. */
        kafka_cluster_id: string;
      };
      cookie?: never;
    };
    get?: never;
    /**
     * Resume a Connector
     * @description [![General Availability](https://img.shields.io/badge/Lifecycle%20Stage-General%20Availability-%2345c6e8)](#section/Versioning/API-Lifecycle-Policy)
     *
     *     Resume a paused connector or do nothing if the connector is not paused. This call is asynchronous and the tasks will not transition to RUNNING state at the same time.
     */
    put: operations["resumeConnectv1Connector"];
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  "/connect/v1/environments/{environment_id}/clusters/{kafka_cluster_id}/connectors/{connector_name}/restart": {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description The unique name of the connector. */
        connector_name: string;
        /** @description The unique identifier of the environment this resource belongs to. */
        environment_id: string;
        /** @description The unique identifier for the Kafka cluster. */
        kafka_cluster_id: string;
      };
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Restart a Connector
     * @description [![Preview](https://img.shields.io/badge/Lifecycle%20Stage-Preview-%2300afba)](#section/Versioning/API-Lifecycle-Policy)
     *     Restart the connector and its tasks. Stops message processing until the connector and tasks are restart. This call is asynchronous and the connector will not transition to another state at the same time.
     */
    post: operations["restartConnectv1Connector"];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  "/connect/v1/environments/{environment_id}/clusters/{kafka_cluster_id}/connectors/{connector_name}/status": {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description The unique name of the connector. */
        connector_name: string;
        /** @description The unique identifier of the environment this resource belongs to. */
        environment_id: string;
        /** @description The unique identifier for the Kafka cluster. */
        kafka_cluster_id: string;
      };
      cookie?: never;
    };
    /**
     * Read a Connector Status
     * @description Get current status of the connector. This includes whether it is running, failed, or paused. Also includes which worker it is assigned to, error information if it has failed, and the state of all its tasks.
     */
    get: operations["readConnectv1ConnectorStatus"];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  "/connect/v1/environments/{environment_id}/clusters/{kafka_cluster_id}/connectors/{connector_name}/tasks": {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description The unique name of the connector. */
        connector_name: string;
        /** @description The unique identifier of the environment this resource belongs to. */
        environment_id: string;
        /** @description The unique identifier for the Kafka cluster. */
        kafka_cluster_id: string;
      };
      cookie?: never;
    };
    /**
     * List of Connector Tasks
     * @description [![General Availability](https://img.shields.io/badge/Lifecycle%20Stage-General%20Availability-%2345c6e8)](#section/Versioning/API-Lifecycle-Policy)
     *
     *     Get a list of tasks currently running for the connector.
     */
    get: operations["listConnectv1ConnectorTasks"];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  "/connect/v1/environments/{environment_id}/clusters/{kafka_cluster_id}/connector-plugins": {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description The unique identifier of the environment this resource belongs to. */
        environment_id: string;
        /** @description The unique identifier for the Kafka cluster. */
        kafka_cluster_id: string;
      };
      cookie?: never;
    };
    /**
     * List of Managed Connector plugins
     * @description [![General Availability](https://img.shields.io/badge/Lifecycle%20Stage-General%20Availability-%2345c6e8)](#section/Versioning/API-Lifecycle-Policy)
     *
     *     Return a list of Managed Connector plugins installed in the Kafka Connect cluster.
     */
    get: operations["listConnectv1ConnectorPlugins"];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  "/connect/v1/environments/{environment_id}/clusters/{kafka_cluster_id}/connector-plugins/{plugin_name}/config/validate": {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description The unique name of the connector plugin. */
        plugin_name: string;
        /** @description The unique identifier of the environment this resource belongs to. */
        environment_id: string;
        /** @description The unique identifier for the Kafka cluster. */
        kafka_cluster_id: string;
      };
      cookie?: never;
    };
    get?: never;
    /**
     * Validate a Managed Connector Plugin
     * @description [![General Availability](https://img.shields.io/badge/Lifecycle%20Stage-General%20Availability-%2345c6e8)](#section/Versioning/API-Lifecycle-Policy)
     *
     *     Validate the provided configuration values against the configuration definition. This API performs per config validation and returns suggested values and validation error messages.
     */
    put: operations["validateConnectv1ConnectorPlugin"];
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  "/connect/v1/environments/{environment_id}/clusters/{kafka_cluster_id}/connectors/{connector_name}/offsets": {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description The unique name of the connector. */
        connector_name: string;
        /** @description The unique identifier of the environment this resource belongs to. */
        environment_id: string;
        /** @description The unique identifier for the Kafka cluster. */
        kafka_cluster_id: string;
      };
      cookie?: never;
    };
    /**
     * Get a Connector Offsets
     * @description [![General Availability](https://img.shields.io/badge/Lifecycle%20Stage-General%20Availability-%2345c6e8)](#section/Versioning/API-Lifecycle-Policy)
     *
     *     Get the current offsets for the connector. The offsets provide information on the point in the source system,
     *     from which the connector is pulling in data. The offsets of a connector are continuously observed periodically and are queryable via this API.
     */
    get: operations["getConnectv1ConnectorOffsets"];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  "/connect/v1/environments/{environment_id}/clusters/{kafka_cluster_id}/connectors/{connector_name}/offsets/request": {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description The unique name of the connector. */
        connector_name: string;
        /** @description The unique identifier of the environment this resource belongs to. */
        environment_id: string;
        /** @description The unique identifier for the Kafka cluster. */
        kafka_cluster_id: string;
      };
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Request to Alter the Connector Offsets
     * @description [![General Availability](https://img.shields.io/badge/Lifecycle%20Stage-General%20Availability-%2345c6e8)](#section/Versioning/API-Lifecycle-Policy)
     *
     *     Request to alter the offsets of a connector. This supports the ability to PATCH/DELETE the offsets of a connector.
     *     Note, you will see momentary downtime as this will internally stop the connector, while the offsets are being altered.
     *     You can only make one alter offsets request at a time for a connector.
     */
    post: operations["alterConnectv1ConnectorOffsetsRequest"];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  "/connect/v1/environments/{environment_id}/clusters/{kafka_cluster_id}/connectors/{connector_name}/offsets/request/status": {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description The unique name of the connector. */
        connector_name: string;
        /** @description The unique identifier of the environment this resource belongs to. */
        environment_id: string;
        /** @description The unique identifier for the Kafka cluster. */
        kafka_cluster_id: string;
      };
      cookie?: never;
    };
    /**
     * Get the Status of Alter Offset Request
     * @description [![General Availability](https://img.shields.io/badge/Lifecycle%20Stage-General%20Availability-%2345c6e8)](#section/Versioning/API-Lifecycle-Policy)
     *
     *     Get the status of the previous alter offset request.
     */
    get: operations["getConnectv1ConnectorOffsetsRequestStatus"];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  "/connect/v1/custom-connector-plugins": {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /**
     * List of Custom Connector Plugins
     * @description [![General Availability](https://img.shields.io/badge/Lifecycle%20Stage-General%20Availability-%2345c6e8)](#section/Versioning/API-Lifecycle-Policy)
     *
     *     Retrieve a sorted, filtered, paginated list of all custom connector plugins.
     *
     *     If no `cloud` filter is specified, returns custom connector plugins from all clouds.
     *
     */
    get: operations["listConnectV1CustomConnectorPlugins"];
    put?: never;
    /**
     * Create a Custom Connector Plugin
     * @description [![General Availability](https://img.shields.io/badge/Lifecycle%20Stage-General%20Availability-%2345c6e8)](#section/Versioning/API-Lifecycle-Policy)
     *
     *     Make a request to create a custom connector plugin.
     */
    post: operations["createConnectV1CustomConnectorPlugin"];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  "/connect/v1/custom-connector-plugins/{id}": {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /**
     * Read a Custom Connector Plugin
     * @description [![General Availability](https://img.shields.io/badge/Lifecycle%20Stage-General%20Availability-%2345c6e8)](#section/Versioning/API-Lifecycle-Policy)
     *
     *     Make a request to read a custom connector plugin.
     */
    get: operations["getConnectV1CustomConnectorPlugin"];
    put?: never;
    post?: never;
    /**
     * Delete a Custom Connector Plugin
     * @description [![General Availability](https://img.shields.io/badge/Lifecycle%20Stage-General%20Availability-%2345c6e8)](#section/Versioning/API-Lifecycle-Policy)
     *
     *     Make a request to delete a custom connector plugin.
     */
    delete: operations["deleteConnectV1CustomConnectorPlugin"];
    options?: never;
    head?: never;
    /**
     * Update a Custom Connector Plugin
     * @description [![General Availability](https://img.shields.io/badge/Lifecycle%20Stage-General%20Availability-%2345c6e8)](#section/Versioning/API-Lifecycle-Policy)
     *
     *     Make a request to update a custom connector plugin.
     *
     *
     */
    patch: operations["updateConnectV1CustomConnectorPlugin"];
    trace?: never;
  };
  "/connect/v1/presigned-upload-url": {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Request a presigned upload URL for a new Custom Connector Plugin.
     * @description [![General Availability](https://img.shields.io/badge/Lifecycle%20Stage-General%20Availability-%2345c6e8)](#section/Versioning/API-Lifecycle-Policy)
     *
     *     Request a presigned upload URL to upload a Custom Connector Plugin archive.
     */
    post: operations["presigned-upload-urlConnectV1PresignedUrl"];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  "/kafka/v3/clusters/{cluster_id}": {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /**
         * @description The Kafka cluster ID.
         * @example cluster-1
         */
        cluster_id: components["parameters"]["ClusterId"];
      };
      cookie?: never;
    };
    /**
     * Get Cluster
     * @description [![Generally Available](https://img.shields.io/badge/Lifecycle%20Stage-Generally%20Available-%2345c6e8)](#section/Versioning/API-Lifecycle-Policy)
     *
     *     Return the Kafka cluster with the specified ``cluster_id``.
     */
    get: operations["getKafkaCluster"];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  "/kafka/v3/clusters/{cluster_id}/acls:batch": {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /**
         * @description The Kafka cluster ID.
         * @example cluster-1
         */
        cluster_id: components["parameters"]["ClusterId"];
      };
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Batch Create ACLs
     * @description [![Generally Available](https://img.shields.io/badge/Lifecycle%20Stage-Generally%20Available-%2345c6e8)](#section/Versioning/API-Lifecycle-Policy)
     *
     *     Create ACLs.
     */
    post: operations["batchCreateKafkaAcls"];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  "/kafka/v3/clusters/{cluster_id}/acls": {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /**
         * @description The Kafka cluster ID.
         * @example cluster-1
         */
        cluster_id: components["parameters"]["ClusterId"];
      };
      cookie?: never;
    };
    /**
     * List ACLs
     * @description [![Generally Available](https://img.shields.io/badge/Lifecycle%20Stage-Generally%20Available-%2345c6e8)](#section/Versioning/API-Lifecycle-Policy)
     *
     *     Return a list of ACLs that match the search criteria.
     */
    get: operations["getKafkaAcls"];
    put?: never;
    /**
     * Create an ACL
     * @description [![Generally Available](https://img.shields.io/badge/Lifecycle%20Stage-Generally%20Available-%2345c6e8)](#section/Versioning/API-Lifecycle-Policy)
     *
     *     Create an ACL.
     */
    post: operations["createKafkaAcls"];
    /**
     * Delete ACLs
     * @description [![Generally Available](https://img.shields.io/badge/Lifecycle%20Stage-Generally%20Available-%2345c6e8)](#section/Versioning/API-Lifecycle-Policy)
     *
     *     Delete the ACLs that match the search criteria.
     */
    delete: operations["deleteKafkaAcls"];
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  "/kafka/v3/clusters/{cluster_id}/broker-configs": {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /**
         * @description The Kafka cluster ID.
         * @example cluster-1
         */
        cluster_id: components["parameters"]["ClusterId"];
      };
      cookie?: never;
    };
    /**
     * List Dynamic Broker Configs
     * @description [![Generally Available](https://img.shields.io/badge/Lifecycle%20Stage-Generally%20Available-%2345c6e8)](#section/Versioning/API-Lifecycle-Policy)
     *
     *     Return a list of dynamic cluster-wide broker configuration parameters for the specified Kafka
     *     cluster. Returns an empty list if there are no dynamic cluster-wide broker configuration parameters.
     */
    get: operations["listKafkaClusterConfigs"];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  "/kafka/v3/clusters/{cluster_id}/broker-configs:alter": {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /**
         * @description The Kafka cluster ID.
         * @example cluster-1
         */
        cluster_id: components["parameters"]["ClusterId"];
      };
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Batch Alter Dynamic Broker Configs
     * @description [![Generally Available](https://img.shields.io/badge/Lifecycle%20Stage-Generally%20Available-%2345c6e8)](#section/Versioning/API-Lifecycle-Policy)
     *
     *     Update or delete a set of dynamic cluster-wide broker configuration parameters.
     */
    post: operations["updateKafkaClusterConfigs"];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  "/kafka/v3/clusters/{cluster_id}/broker-configs/{name}": {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /**
         * @description The Kafka cluster ID.
         * @example cluster-1
         */
        cluster_id: components["parameters"]["ClusterId"];
        /**
         * @description The configuration parameter name.
         * @example compression.type
         */
        name: components["parameters"]["ConfigName"];
      };
      cookie?: never;
    };
    /**
     * Get Dynamic Broker Config
     * @description [![Generally Available](https://img.shields.io/badge/Lifecycle%20Stage-Generally%20Available-%2345c6e8)](#section/Versioning/API-Lifecycle-Policy)
     *
     *     Return the dynamic cluster-wide broker configuration parameter specified by ``name``.
     */
    get: operations["getKafkaClusterConfig"];
    /**
     * Update Dynamic Broker Config
     * @description [![Generally Available](https://img.shields.io/badge/Lifecycle%20Stage-Generally%20Available-%2345c6e8)](#section/Versioning/API-Lifecycle-Policy)
     *
     *     Update the dynamic cluster-wide broker configuration parameter specified by ``name``.
     */
    put: operations["updateKafkaClusterConfig"];
    post?: never;
    /**
     * Reset Dynamic Broker Config
     * @description [![Generally Available](https://img.shields.io/badge/Lifecycle%20Stage-Generally%20Available-%2345c6e8)](#section/Versioning/API-Lifecycle-Policy)
     *
     *     Reset the configuration parameter specified by ``name`` to its
     *     default value by deleting a dynamic cluster-wide configuration.
     */
    delete: operations["deleteKafkaClusterConfig"];
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  "/kafka/v3/clusters/{cluster_id}/consumer-groups": {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /**
         * @description The Kafka cluster ID.
         * @example cluster-1
         */
        cluster_id: components["parameters"]["ClusterId"];
      };
      cookie?: never;
    };
    /**
     * List Consumer Groups
     * @description [![Generally Available](https://img.shields.io/badge/Lifecycle%20Stage-Generally%20Available-%2345c6e8)](#section/Versioning/API-Lifecycle-Policy)
     *
     *     Return the list of consumer groups that belong to the specified
     *     Kafka cluster.
     */
    get: operations["listKafkaConsumerGroups"];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  "/kafka/v3/clusters/{cluster_id}/consumer-groups/{consumer_group_id}": {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /**
         * @description The Kafka cluster ID.
         * @example cluster-1
         */
        cluster_id: components["parameters"]["ClusterId"];
        /**
         * @description The consumer group ID.
         * @example consumer-group-1
         */
        consumer_group_id: components["parameters"]["ConsumerGroupId"];
      };
      cookie?: never;
    };
    /**
     * Get Consumer Group
     * @description [![Generally Available](https://img.shields.io/badge/Lifecycle%20Stage-Generally%20Available-%2345c6e8)](#section/Versioning/API-Lifecycle-Policy)
     *
     *     Return the consumer group specified by the ``consumer_group_id``.
     */
    get: operations["getKafkaConsumerGroup"];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  "/kafka/v3/clusters/{cluster_id}/consumer-groups/{consumer_group_id}/consumers": {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /**
         * @description The Kafka cluster ID.
         * @example cluster-1
         */
        cluster_id: components["parameters"]["ClusterId"];
        /**
         * @description The consumer group ID.
         * @example consumer-group-1
         */
        consumer_group_id: components["parameters"]["ConsumerGroupId"];
      };
      cookie?: never;
    };
    /**
     * List Consumers
     * @description [![Generally Available](https://img.shields.io/badge/Lifecycle%20Stage-Generally%20Available-%2345c6e8)](#section/Versioning/API-Lifecycle-Policy)
     *
     *     Return a list of consumers that belong to the specified consumer
     *     group.
     */
    get: operations["listKafkaConsumers"];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  "/kafka/v3/clusters/{cluster_id}/consumer-groups/{consumer_group_id}/lag-summary": {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /**
         * @description The Kafka cluster ID.
         * @example cluster-1
         */
        cluster_id: components["parameters"]["ClusterId"];
        /**
         * @description The consumer group ID.
         * @example consumer-group-1
         */
        consumer_group_id: components["parameters"]["ConsumerGroupId"];
      };
      cookie?: never;
    };
    /**
     * Get Consumer Group Lag Summary
     * @description [![Generally Available](https://img.shields.io/badge/Lifecycle%20Stage-Generally%20Available-%2345c6e8)](#section/Versioning/API-Lifecycle-Policy) [![Available in dedicated clusters only](https://img.shields.io/badge/-Available%20in%20dedicated%20clusters%20only-%23bc8540)](https://docs.confluent.io/cloud/current/clusters/cluster-types.html#dedicated-cluster)
     *
     *     Return the maximum and total lag of the consumers belonging to the
     *     specified consumer group.
     */
    get: operations["getKafkaConsumerGroupLagSummary"];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  "/kafka/v3/clusters/{cluster_id}/consumer-groups/{consumer_group_id}/lags": {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /**
         * @description The Kafka cluster ID.
         * @example cluster-1
         */
        cluster_id: components["parameters"]["ClusterId"];
        /**
         * @description The consumer group ID.
         * @example consumer-group-1
         */
        consumer_group_id: components["parameters"]["ConsumerGroupId"];
      };
      cookie?: never;
    };
    /**
     * List Consumer Lags
     * @description [![Generally Available](https://img.shields.io/badge/Lifecycle%20Stage-Generally%20Available-%2345c6e8)](#section/Versioning/API-Lifecycle-Policy) [![Available in dedicated clusters only](https://img.shields.io/badge/-Available%20in%20dedicated%20clusters%20only-%23bc8540)](https://docs.confluent.io/cloud/current/clusters/cluster-types.html#dedicated-cluster)
     *
     *     Return a list of consumer lags of the consumers belonging to the
     *     specified consumer group.
     */
    get: operations["listKafkaConsumerLags"];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  "/kafka/v3/clusters/{cluster_id}/consumer-groups/{consumer_group_id}/lags/{topic_name}/partitions/{partition_id}": {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /**
         * @description The Kafka cluster ID.
         * @example cluster-1
         */
        cluster_id: components["parameters"]["ClusterId"];
        /**
         * @description The consumer group ID.
         * @example consumer-group-1
         */
        consumer_group_id: components["parameters"]["ConsumerGroupId"];
        /**
         * @description The topic name.
         * @example topic-1
         */
        topic_name: components["parameters"]["TopicName"];
        /**
         * @description The partition ID.
         * @example 0
         */
        partition_id: components["parameters"]["PartitionId"];
      };
      cookie?: never;
    };
    /**
     * Get Consumer Lag
     * @description [![Generally Available](https://img.shields.io/badge/Lifecycle%20Stage-Generally%20Available-%2345c6e8)](#section/Versioning/API-Lifecycle-Policy) [![Available in dedicated clusters only](https://img.shields.io/badge/-Available%20in%20dedicated%20clusters%20only-%23bc8540)](https://docs.confluent.io/cloud/current/clusters/cluster-types.html#dedicated-cluster)
     *
     *     Return the consumer lag on a partition with the given `partition_id`.
     */
    get: operations["getKafkaConsumerLag"];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  "/kafka/v3/clusters/{cluster_id}/consumer-groups/{consumer_group_id}/consumers/{consumer_id}": {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /**
         * @description The Kafka cluster ID.
         * @example cluster-1
         */
        cluster_id: components["parameters"]["ClusterId"];
        /**
         * @description The consumer group ID.
         * @example consumer-group-1
         */
        consumer_group_id: components["parameters"]["ConsumerGroupId"];
        /**
         * @description The consumer ID.
         * @example consumer-1
         */
        consumer_id: components["parameters"]["ConsumerId"];
      };
      cookie?: never;
    };
    /**
     * Get Consumer
     * @description [![Generally Available](https://img.shields.io/badge/Lifecycle%20Stage-Generally%20Available-%2345c6e8)](#section/Versioning/API-Lifecycle-Policy)
     *
     *     Return the consumer specified by the ``consumer_id``.
     */
    get: operations["getKafkaConsumer"];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  "/kafka/v3/clusters/{cluster_id}/topics": {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /**
         * @description The Kafka cluster ID.
         * @example cluster-1
         */
        cluster_id: components["parameters"]["ClusterId"];
      };
      cookie?: never;
    };
    /**
     * List Topics
     * @description [![Generally Available](https://img.shields.io/badge/Lifecycle%20Stage-Generally%20Available-%2345c6e8)](#section/Versioning/API-Lifecycle-Policy)
     *
     *     Return the list of topics that belong to the specified Kafka cluster.
     */
    get: operations["listKafkaTopics"];
    put?: never;
    /**
     * Create Topic
     * @description [![Generally Available](https://img.shields.io/badge/Lifecycle%20Stage-Generally%20Available-%2345c6e8)](#section/Versioning/API-Lifecycle-Policy)
     *
     *     Create a topic.
     *     Also supports a dry-run mode that only validates whether the topic creation would succeed
     *     if the ``validate_only`` request property is explicitly specified and set to true. Note that
     *     when dry-run mode is being used the response status would be 200 OK instead of 201 Created.
     */
    post: operations["createKafkaTopic"];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  "/kafka/v3/clusters/{cluster_id}/topics/{topic_name}": {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /**
         * @description The Kafka cluster ID.
         * @example cluster-1
         */
        cluster_id: components["parameters"]["ClusterId"];
        /**
         * @description The topic name.
         * @example topic-1
         */
        topic_name: components["parameters"]["TopicName"];
      };
      cookie?: never;
    };
    /**
     * Get Topic
     * @description [![Generally Available](https://img.shields.io/badge/Lifecycle%20Stage-Generally%20Available-%2345c6e8)](#section/Versioning/API-Lifecycle-Policy)
     *
     *     Return the topic with the given `topic_name`.
     */
    get: operations["getKafkaTopic"];
    put?: never;
    post?: never;
    /**
     * Delete Topic
     * @description [![Generally Available](https://img.shields.io/badge/Lifecycle%20Stage-Generally%20Available-%2345c6e8)](#section/Versioning/API-Lifecycle-Policy)
     *
     *     Delete the topic with the given `topic_name`.
     */
    delete: operations["deleteKafkaTopic"];
    options?: never;
    head?: never;
    /**
     * Update Partition Count
     * @description [![Generally Available](https://img.shields.io/badge/Lifecycle%20Stage-Generally%20Available-%2345c6e8)](#section/Versioning/API-Lifecycle-Policy)
     *
     *     Increase the number of partitions for a topic. To update other topic
     *     configurations, see https://docs.confluent.io/cloud/current/api.html#tag/Configs-(v3)/operation/updateKafkaTopicConfig.
     */
    patch: operations["updatePartitionCountKafkaTopic"];
    trace?: never;
  };
  "/kafka/v3/clusters/{cluster_id}/topics/{topic_name}/configs": {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /**
         * @description The Kafka cluster ID.
         * @example cluster-1
         */
        cluster_id: components["parameters"]["ClusterId"];
        /**
         * @description The topic name.
         * @example topic-1
         */
        topic_name: components["parameters"]["TopicName"];
      };
      cookie?: never;
    };
    /**
     * List Topic Configs
     * @description [![Generally Available](https://img.shields.io/badge/Lifecycle%20Stage-Generally%20Available-%2345c6e8)](#section/Versioning/API-Lifecycle-Policy)
     *
     *     Return the list of configuration parameters that belong to the specified topic.
     */
    get: operations["listKafkaTopicConfigs"];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  "/kafka/v3/clusters/{cluster_id}/topics/{topic_name}/configs:alter": {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /**
         * @description The Kafka cluster ID.
         * @example cluster-1
         */
        cluster_id: components["parameters"]["ClusterId"];
        /**
         * @description The topic name.
         * @example topic-1
         */
        topic_name: components["parameters"]["TopicName"];
      };
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Batch Alter Topic Configs
     * @description [![Generally Available](https://img.shields.io/badge/Lifecycle%20Stage-Generally%20Available-%2345c6e8)](#section/Versioning/API-Lifecycle-Policy)
     *
     *     Update or delete a set of topic configuration parameters.
     *     Also supports a dry-run mode that only validates whether the operation would succeed if the
     *     ``validate_only`` request property is explicitly specified and set to true.
     */
    post: operations["updateKafkaTopicConfigBatch"];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  "/kafka/v3/clusters/{cluster_id}/topics/{topic_name}/configs/{name}": {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /**
         * @description The Kafka cluster ID.
         * @example cluster-1
         */
        cluster_id: components["parameters"]["ClusterId"];
        /**
         * @description The topic name.
         * @example topic-1
         */
        topic_name: components["parameters"]["TopicName"];
        /**
         * @description The configuration parameter name.
         * @example compression.type
         */
        name: components["parameters"]["ConfigName"];
      };
      cookie?: never;
    };
    /**
     * Get Topic Config
     * @description [![Generally Available](https://img.shields.io/badge/Lifecycle%20Stage-Generally%20Available-%2345c6e8)](#section/Versioning/API-Lifecycle-Policy)
     *
     *     Return the configuration parameter with the given `name`.
     */
    get: operations["getKafkaTopicConfig"];
    /**
     * Update Topic Config
     * @description [![Generally Available](https://img.shields.io/badge/Lifecycle%20Stage-Generally%20Available-%2345c6e8)](#section/Versioning/API-Lifecycle-Policy)
     *
     *     Update the configuration parameter with given `name`. To update the
     *     number of partitions, see
     *     https://docs.confluent.io/cloud/current/api.html#tag/Topic-(v3)/operation/updatePartitionCountKafkaTopic.
     */
    put: operations["updateKafkaTopicConfig"];
    post?: never;
    /**
     * Reset Topic Config
     * @description [![Generally Available](https://img.shields.io/badge/Lifecycle%20Stage-Generally%20Available-%2345c6e8)](#section/Versioning/API-Lifecycle-Policy)
     *
     *     Reset the configuration parameter with given `name` to its default value.
     */
    delete: operations["deleteKafkaTopicConfig"];
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  "/kafka/v3/clusters/{cluster_id}/topics/{topic_name}/partitions": {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /**
         * @description The Kafka cluster ID.
         * @example cluster-1
         */
        cluster_id: components["parameters"]["ClusterId"];
        /**
         * @description The topic name.
         * @example topic-1
         */
        topic_name: components["parameters"]["TopicName"];
      };
      cookie?: never;
    };
    /**
     * List Partitions
     * @description [![Generally Available](https://img.shields.io/badge/Lifecycle%20Stage-Generally%20Available-%2345c6e8)](#section/Versioning/API-Lifecycle-Policy)
     *
     *     Return the list of partitions that belong to the specified topic.
     */
    get: operations["listKafkaPartitions"];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  "/kafka/v3/clusters/{cluster_id}/topics/{topic_name}/partitions/{partition_id}": {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /**
         * @description The Kafka cluster ID.
         * @example cluster-1
         */
        cluster_id: components["parameters"]["ClusterId"];
        /**
         * @description The topic name.
         * @example topic-1
         */
        topic_name: components["parameters"]["TopicName"];
        /**
         * @description The partition ID.
         * @example 0
         */
        partition_id: components["parameters"]["PartitionId"];
      };
      cookie?: never;
    };
    /**
     * Get Partition
     * @description [![Generally Available](https://img.shields.io/badge/Lifecycle%20Stage-Generally%20Available-%2345c6e8)](#section/Versioning/API-Lifecycle-Policy)
     *
     *     Return the partition with the given `partition_id`.
     */
    get: operations["getKafkaPartition"];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  "/kafka/v3/clusters/{cluster_id}/topics/-/configs": {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /**
         * @description The Kafka cluster ID.
         * @example cluster-1
         */
        cluster_id: components["parameters"]["ClusterId"];
      };
      cookie?: never;
    };
    /**
     * List All Topic Configs
     * @description [![Generally Available](https://img.shields.io/badge/Lifecycle%20Stage-Generally%20Available-%2345c6e8)](#section/Versioning/API-Lifecycle-Policy)
     *
     *     Return the list of configuration parameters for all topics hosted by the specified
     *     cluster.
     */
    get: operations["listKafkaAllTopicConfigs"];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  "/kafka/v3/clusters/{cluster_id}/topics/{topic_name}/records": {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /**
         * @description The Kafka cluster ID.
         * @example cluster-1
         */
        cluster_id: components["parameters"]["ClusterId"];
        /**
         * @description The topic name.
         * @example topic-1
         */
        topic_name: components["parameters"]["TopicName"];
      };
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Produce Records
     * @description [![Generally Available](https://img.shields.io/badge/Lifecycle%20Stage-Generally%20Available-%2345c6e8)](#section/Versioning/API-Lifecycle-Policy)
     *
     *     Produce records to the given topic, returning delivery reports for each
     *     record produced. This API can be used in streaming mode by setting
     *     "Transfer-Encoding: chunked" header. For as long as the connection is
     *     kept open, the server will keep accepting records. Records are streamed
     *     to and from the server as Concatenated JSON. For each record sent to the
     *     server, the server will asynchronously send back a delivery report, in
     *     the same order, each with its own error_code. An error_code of 200
     *     indicates success. The HTTP status code will be HTTP 200 OK as long as
     *     the connection is successfully established. To identify records that
     *     have encountered an error, check the error_code of each delivery report.
     *
     *     Note that the cluster_id is validated only when running in Confluent Cloud.
     *
     *     This API currently does not support Schema Registry integration. Sending
     *     schemas is not supported. Only BINARY, JSON, and STRING formats are
     *     supported.
     */
    post: operations["produceRecord"];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  "/kafka/v3/clusters/{cluster_id}/links": {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /**
         * @description The Kafka cluster ID.
         * @example cluster-1
         */
        cluster_id: components["parameters"]["ClusterId"];
      };
      cookie?: never;
    };
    /**
     * List all cluster links in the dest cluster
     * @description [![Generally Available](https://img.shields.io/badge/Lifecycle%20Stage-Generally%20Available-%2345c6e8)](#section/Versioning/API-Lifecycle-Policy)
     *
     *     ``link_id`` in ``ListLinksResponseData`` is deprecated and may be removed in a future release. Use the new ``cluster_link_id`` instead.
     */
    get: operations["listKafkaLinks"];
    put?: never;
    /**
     * Create a cluster link
     * @description [![Generally Available](https://img.shields.io/badge/Lifecycle%20Stage-Generally%20Available-%2345c6e8)](#section/Versioning/API-Lifecycle-Policy)
     *
     *     Cluster link creation requires source cluster security configurations in
     *     the configs JSON section of the data request payload.
     */
    post: operations["createKafkaLink"];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  "/kafka/v3/clusters/{cluster_id}/links/{link_name}": {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /**
         * @description The Kafka cluster ID.
         * @example cluster-1
         */
        cluster_id: components["parameters"]["ClusterId"];
        /**
         * @description The link name
         * @example link-sb1
         */
        link_name: components["parameters"]["LinkName"];
      };
      cookie?: never;
    };
    /**
     * Describe the cluster link
     * @description [![Generally Available](https://img.shields.io/badge/Lifecycle%20Stage-Generally%20Available-%2345c6e8)](#section/Versioning/API-Lifecycle-Policy)
     *
     *     ``link_id`` in ``ListLinksResponseData`` is deprecated and may be removed in a future release. Use the new ``cluster_link_id`` instead.
     */
    get: operations["getKafkaLink"];
    put?: never;
    post?: never;
    /**
     * Delete the cluster link
     * @description [![Generally Available](https://img.shields.io/badge/Lifecycle%20Stage-Generally%20Available-%2345c6e8)](#section/Versioning/API-Lifecycle-Policy)
     */
    delete: operations["deleteKafkaLink"];
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  "/kafka/v3/clusters/{cluster_id}/topics/{topic_name}/default-configs": {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /**
         * @description The Kafka cluster ID.
         * @example cluster-1
         */
        cluster_id: components["parameters"]["ClusterId"];
        /**
         * @description The topic name.
         * @example topic-1
         */
        topic_name: components["parameters"]["TopicName"];
      };
      cookie?: never;
    };
    /**
     * List New Topic Default Configs
     * @description [![Generally Available](https://img.shields.io/badge/Lifecycle%20Stage-Generally%20Available-%2345c6e8)](#section/Versioning/API-Lifecycle-Policy)
     *
     *     List the default configuration parameters used if the topic were to be newly created.
     */
    get: operations["listKafkaDefaultTopicConfigs"];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  "/kafka/v3/clusters/{cluster_id}/links/{link_name}/configs": {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /**
         * @description The Kafka cluster ID.
         * @example cluster-1
         */
        cluster_id: components["parameters"]["ClusterId"];
        /**
         * @description The link name
         * @example link-sb1
         */
        link_name: components["parameters"]["LinkName"];
      };
      cookie?: never;
    };
    /**
     * List all configs of the cluster link
     * @description [![Generally Available](https://img.shields.io/badge/Lifecycle%20Stage-Generally%20Available-%2345c6e8)](#section/Versioning/API-Lifecycle-Policy)
     */
    get: operations["listKafkaLinkConfigs"];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  "/kafka/v3/clusters/{cluster_id}/links/{link_name}/configs/{config_name}": {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /**
         * @description The Kafka cluster ID.
         * @example cluster-1
         */
        cluster_id: components["parameters"]["ClusterId"];
        /**
         * @description The link name
         * @example link-sb1
         */
        link_name: components["parameters"]["LinkName"];
        /**
         * @description The link config name
         * @example consumer.offset.sync.enable
         */
        config_name: components["parameters"]["LinkConfigName"];
      };
      cookie?: never;
    };
    /**
     * Describe the config under the cluster link
     * @description [![Generally Available](https://img.shields.io/badge/Lifecycle%20Stage-Generally%20Available-%2345c6e8)](#section/Versioning/API-Lifecycle-Policy)
     */
    get: operations["getKafkaLinkConfigs"];
    /**
     * Alter the config under the cluster link
     * @description [![Generally Available](https://img.shields.io/badge/Lifecycle%20Stage-Generally%20Available-%2345c6e8)](#section/Versioning/API-Lifecycle-Policy)
     */
    put: operations["updateKafkaLinkConfig"];
    post?: never;
    /**
     * Reset the given config to default value
     * @description [![Generally Available](https://img.shields.io/badge/Lifecycle%20Stage-Generally%20Available-%2345c6e8)](#section/Versioning/API-Lifecycle-Policy)
     */
    delete: operations["deleteKafkaLinkConfig"];
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  "/kafka/v3/clusters/{cluster_id}/links/{link_name}/configs:alter": {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /**
         * @description The Kafka cluster ID.
         * @example cluster-1
         */
        cluster_id: components["parameters"]["ClusterId"];
        /**
         * @description The link name
         * @example link-sb1
         */
        link_name: components["parameters"]["LinkName"];
      };
      cookie?: never;
    };
    get?: never;
    /**
     * Batch Alter Cluster Link Configs
     * @description [![Generally Available](https://img.shields.io/badge/Lifecycle%20Stage-Generally%20Available-%2345c6e8)](#section/Versioning/API-Lifecycle-Policy)
     *
     *     Batch Alter Cluster Link Configs
     */
    put: operations["updateKafkaLinkConfigBatch"];
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  "/kafka/v3/clusters/{cluster_id}/links/{link_name}/mirrors": {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /**
         * @description The Kafka cluster ID.
         * @example cluster-1
         */
        cluster_id: components["parameters"]["ClusterId"];
        /**
         * @description The link name
         * @example link-sb1
         */
        link_name: components["parameters"]["LinkName"];
      };
      cookie?: never;
    };
    /**
     * List mirror topics
     * @description [![Generally Available](https://img.shields.io/badge/Lifecycle%20Stage-Generally%20Available-%2345c6e8)](#section/Versioning/API-Lifecycle-Policy)
     *
     *     List all mirror topics under the link
     */
    get: operations["listKafkaMirrorTopicsUnderLink"];
    put?: never;
    /**
     * Create a mirror topic
     * @description [![Generally Available](https://img.shields.io/badge/Lifecycle%20Stage-Generally%20Available-%2345c6e8)](#section/Versioning/API-Lifecycle-Policy)
     *
     *     Create a topic in the destination cluster mirroring a topic in
     *     the source cluster
     */
    post: operations["createKafkaMirrorTopic"];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  "/kafka/v3/clusters/{cluster_id}/links/-/mirrors": {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /**
         * @description The Kafka cluster ID.
         * @example cluster-1
         */
        cluster_id: components["parameters"]["ClusterId"];
      };
      cookie?: never;
    };
    /**
     * List mirror topics
     * @description [![Generally Available](https://img.shields.io/badge/Lifecycle%20Stage-Generally%20Available-%2345c6e8)](#section/Versioning/API-Lifecycle-Policy)
     *
     *     List all mirror topics in the cluster
     */
    get: operations["listKafkaMirrorTopics"];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  "/kafka/v3/clusters/{cluster_id}/links/{link_name}/mirrors/{mirror_topic_name}": {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /**
         * @description The Kafka cluster ID.
         * @example cluster-1
         */
        cluster_id: components["parameters"]["ClusterId"];
        /**
         * @description The link name
         * @example link-sb1
         */
        link_name: components["parameters"]["LinkName"];
        /**
         * @description Cluster Linking mirror topic name
         * @example topic-1
         */
        mirror_topic_name: components["parameters"]["MirrorTopicName"];
      };
      cookie?: never;
    };
    /**
     * Describe the mirror topic
     * @description [![Generally Available](https://img.shields.io/badge/Lifecycle%20Stage-Generally%20Available-%2345c6e8)](#section/Versioning/API-Lifecycle-Policy)
     */
    get: operations["readKafkaMirrorTopic"];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  "/kafka/v3/clusters/{cluster_id}/links/{link_name}/mirrors:promote": {
    parameters: {
      query?: {
        /**
         * @description To validate the action can be performed successfully or not. Default: false
         * @example false
         */
        validate_only?: components["parameters"]["ValidateOnly"];
      };
      header?: never;
      path: {
        /**
         * @description The Kafka cluster ID.
         * @example cluster-1
         */
        cluster_id: components["parameters"]["ClusterId"];
        /**
         * @description The link name
         * @example link-sb1
         */
        link_name: components["parameters"]["LinkName"];
      };
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Promote the mirror topics
     * @description [![Generally Available](https://img.shields.io/badge/Lifecycle%20Stage-Generally%20Available-%2345c6e8)](#section/Versioning/API-Lifecycle-Policy)
     */
    post: operations["updateKafkaMirrorTopicsPromote"];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  "/kafka/v3/clusters/{cluster_id}/links/{link_name}/mirrors:failover": {
    parameters: {
      query?: {
        /**
         * @description To validate the action can be performed successfully or not. Default: false
         * @example false
         */
        validate_only?: components["parameters"]["ValidateOnly"];
      };
      header?: never;
      path: {
        /**
         * @description The Kafka cluster ID.
         * @example cluster-1
         */
        cluster_id: components["parameters"]["ClusterId"];
        /**
         * @description The link name
         * @example link-sb1
         */
        link_name: components["parameters"]["LinkName"];
      };
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Failover the mirror topics
     * @description [![Generally Available](https://img.shields.io/badge/Lifecycle%20Stage-Generally%20Available-%2345c6e8)](#section/Versioning/API-Lifecycle-Policy)
     */
    post: operations["updateKafkaMirrorTopicsFailover"];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  "/kafka/v3/clusters/{cluster_id}/links/{link_name}/mirrors:pause": {
    parameters: {
      query?: {
        /**
         * @description To validate the action can be performed successfully or not. Default: false
         * @example false
         */
        validate_only?: components["parameters"]["ValidateOnly"];
      };
      header?: never;
      path: {
        /**
         * @description The Kafka cluster ID.
         * @example cluster-1
         */
        cluster_id: components["parameters"]["ClusterId"];
        /**
         * @description The link name
         * @example link-sb1
         */
        link_name: components["parameters"]["LinkName"];
      };
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Pause the mirror topics
     * @description [![Generally Available](https://img.shields.io/badge/Lifecycle%20Stage-Generally%20Available-%2345c6e8)](#section/Versioning/API-Lifecycle-Policy)
     */
    post: operations["updateKafkaMirrorTopicsPause"];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  "/kafka/v3/clusters/{cluster_id}/links/{link_name}/mirrors:resume": {
    parameters: {
      query?: {
        /**
         * @description To validate the action can be performed successfully or not. Default: false
         * @example false
         */
        validate_only?: components["parameters"]["ValidateOnly"];
      };
      header?: never;
      path: {
        /**
         * @description The Kafka cluster ID.
         * @example cluster-1
         */
        cluster_id: components["parameters"]["ClusterId"];
        /**
         * @description The link name
         * @example link-sb1
         */
        link_name: components["parameters"]["LinkName"];
      };
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Resume the mirror topics
     * @description [![Generally Available](https://img.shields.io/badge/Lifecycle%20Stage-Generally%20Available-%2345c6e8)](#section/Versioning/API-Lifecycle-Policy)
     */
    post: operations["updateKafkaMirrorTopicsResume"];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  "/kafka/v3/clusters/{cluster_id}/links/{link_name}/mirrors:reverse-and-start-mirror": {
    parameters: {
      query?: {
        /**
         * @description To validate the action can be performed successfully or not. Default: false
         * @example false
         */
        validate_only?: components["parameters"]["ValidateOnly"];
      };
      header?: never;
      path: {
        /**
         * @description The Kafka cluster ID.
         * @example cluster-1
         */
        cluster_id: components["parameters"]["ClusterId"];
        /**
         * @description The link name
         * @example link-sb1
         */
        link_name: components["parameters"]["LinkName"];
      };
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Reverse the local mirror topic and start the remote mirror topic
     * @description [![Generally Available](https://img.shields.io/badge/Lifecycle%20Stage-Generally%20Available-%2345c6e8)](#section/Versioning/API-Lifecycle-Policy)
     */
    post: operations["updateKafkaMirrorTopicsReverseAndStartMirror"];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  "/kafka/v3/clusters/{cluster_id}/links/{link_name}/mirrors:reverse-and-pause-mirror": {
    parameters: {
      query?: {
        /**
         * @description To validate the action can be performed successfully or not. Default: false
         * @example false
         */
        validate_only?: components["parameters"]["ValidateOnly"];
      };
      header?: never;
      path: {
        /**
         * @description The Kafka cluster ID.
         * @example cluster-1
         */
        cluster_id: components["parameters"]["ClusterId"];
        /**
         * @description The link name
         * @example link-sb1
         */
        link_name: components["parameters"]["LinkName"];
      };
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Reverse the local mirror topic and Pause the remote mirror topic
     * @description [![Generally Available](https://img.shields.io/badge/Lifecycle%20Stage-Generally%20Available-%2345c6e8)](#section/Versioning/API-Lifecycle-Policy)
     */
    post: operations["updateKafkaMirrorTopicsReverseAndPauseMirror"];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  "/kafka/v3/clusters/{cluster_id}/links/{link_name}/mirrors:truncate-and-restore": {
    parameters: {
      query?: {
        /**
         * @description Whether to include partition level truncation information when truncating and restoring a topic in the response. Default: false
         * @example false
         */
        include_partition_level_truncation_data?: components["parameters"]["IncludePartitionLevelTruncationData"];
        /**
         * @description To validate the action can be performed successfully or not. Default: false
         * @example false
         */
        validate_only?: components["parameters"]["ValidateOnly"];
      };
      header?: never;
      path: {
        /**
         * @description The Kafka cluster ID.
         * @example cluster-1
         */
        cluster_id: components["parameters"]["ClusterId"];
        /**
         * @description The link name
         * @example link-sb1
         */
        link_name: components["parameters"]["LinkName"];
      };
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Truncates the local topic to the remote stopped mirror log end offsets and restores mirroring to the local topic to mirror from the remote topic
     * @description [![Generally Available](https://img.shields.io/badge/Lifecycle%20Stage-Generally%20Available-%2345c6e8)](#section/Versioning/API-Lifecycle-Policy)
     */
    post: operations["updateKafkaMirrorTopicsTruncateAndRestoreMirror"];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  "/service-quota/v1/applied-quotas": {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /**
     * List of Applied Quotas
     * @description [![General Availability](https://img.shields.io/badge/Lifecycle%20Stage-General%20Availability-%2345c6e8)](#section/Versioning/API-Lifecycle-Policy)
     *
     *     Retrieve a sorted, filtered, paginated list of all applied quotas.
     *
     *     Shows all quotas for a given scope.
     *
     */
    get: operations["listServiceQuotaV1AppliedQuotas"];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  "/service-quota/v1/applied-quotas/{id}": {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /**
     * Read an Applied Quota
     * @description [![General Availability](https://img.shields.io/badge/Lifecycle%20Stage-General%20Availability-%2345c6e8)](#section/Versioning/API-Lifecycle-Policy)
     *
     *     Make a request to read an applied quota.
     */
    get: operations["getServiceQuotaV1AppliedQuota"];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  "/service-quota/v1/scopes": {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /**
     * List of Scopes
     * @description [![General Availability](https://img.shields.io/badge/Lifecycle%20Stage-General%20Availability-%2345c6e8)](#section/Versioning/API-Lifecycle-Policy)
     *
     *     Retrieve a sorted, filtered, paginated list of all scopes.
     */
    get: operations["listServiceQuotaV1Scopes"];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  "/service-quota/v1/scopes/{id}": {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /**
     * Read a Scope
     * @description [![General Availability](https://img.shields.io/badge/Lifecycle%20Stage-General%20Availability-%2345c6e8)](#section/Versioning/API-Lifecycle-Policy)
     *
     *     Make a request to read a scope.
     */
    get: operations["getServiceQuotaV1Scope"];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  "/partner/v2/entitlements": {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /**
     * List of Entitlements
     * @description [![Early Access](https://img.shields.io/badge/Lifecycle%20Stage-Early%20Access-%2345c6e8)](#section/Versioning/API-Lifecycle-Policy) [![Request Access To Partner v2](https://img.shields.io/badge/-Request%20Access%20To%20Partner%20v2-%23bc8540)](mailto:ccloud-api-access+partner-v2-early-access@confluent.io?subject=Request%20to%20join%20partner/v2%20API%20Early%20Access&body=I%E2%80%99d%20like%20to%20join%20the%20Confluent%20Cloud%20API%20Early%20Access%20for%20partner/v2%20to%20provide%20early%20feedback%21%20My%20Cloud%20Organization%20ID%20is%20%3Cretrieve%20from%20https%3A//confluent.cloud/settings/billing/payment%3E.)
     *
     *     Retrieve a sorted, filtered, paginated list of all entitlements.
     */
    get: operations["listPartnerV2Entitlements"];
    put?: never;
    /**
     * Create an Entitlement
     * @description [![Early Access](https://img.shields.io/badge/Lifecycle%20Stage-Early%20Access-%2345c6e8)](#section/Versioning/API-Lifecycle-Policy) [![Request Access To Partner v2](https://img.shields.io/badge/-Request%20Access%20To%20Partner%20v2-%23bc8540)](mailto:ccloud-api-access+partner-v2-early-access@confluent.io?subject=Request%20to%20join%20partner/v2%20API%20Early%20Access&body=I%E2%80%99d%20like%20to%20join%20the%20Confluent%20Cloud%20API%20Early%20Access%20for%20partner/v2%20to%20provide%20early%20feedback%21%20My%20Cloud%20Organization%20ID%20is%20%3Cretrieve%20from%20https%3A//confluent.cloud/settings/billing/payment%3E.)
     *
     *     Make a request to create an entitlement.
     */
    post: operations["createPartnerV2Entitlement"];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  "/partner/v2/entitlements/{id}": {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /**
     * Read an Entitlement
     * @description [![Early Access](https://img.shields.io/badge/Lifecycle%20Stage-Early%20Access-%2345c6e8)](#section/Versioning/API-Lifecycle-Policy) [![Request Access To Partner v2](https://img.shields.io/badge/-Request%20Access%20To%20Partner%20v2-%23bc8540)](mailto:ccloud-api-access+partner-v2-early-access@confluent.io?subject=Request%20to%20join%20partner/v2%20API%20Early%20Access&body=I%E2%80%99d%20like%20to%20join%20the%20Confluent%20Cloud%20API%20Early%20Access%20for%20partner/v2%20to%20provide%20early%20feedback%21%20My%20Cloud%20Organization%20ID%20is%20%3Cretrieve%20from%20https%3A//confluent.cloud/settings/billing/payment%3E.)
     *
     *     Make a request to read an entitlement.
     */
    get: operations["getPartnerV2Entitlement"];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  "/srcm/v2/regions": {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /**
     * List of Regions
     * @deprecated
     * @description [![Deprecated](https://img.shields.io/badge/Lifecycle%20Stage-Deprecated-%23ff005c)](#section/Versioning/API-Lifecycle-Policy)
     *
     *     Retrieve a sorted, filtered, paginated list of all regions.
     */
    get: operations["listSrcmV2Regions"];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  "/srcm/v2/regions/{id}": {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /**
     * Read a Region
     * @deprecated
     * @description [![Deprecated](https://img.shields.io/badge/Lifecycle%20Stage-Deprecated-%23ff005c)](#section/Versioning/API-Lifecycle-Policy)
     *
     *     Make a request to read a region.
     */
    get: operations["getSrcmV2Region"];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  "/srcm/v2/clusters": {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /**
     * List of Clusters
     * @deprecated
     * @description [![Deprecated](https://img.shields.io/badge/Lifecycle%20Stage-Deprecated-%23ff005c)](#section/Versioning/API-Lifecycle-Policy)
     *
     *     Retrieve a sorted, filtered, paginated list of all clusters.
     */
    get: operations["listSrcmV2Clusters"];
    put?: never;
    /**
     * Create a Cluster
     * @deprecated
     * @description [![Deprecated](https://img.shields.io/badge/Lifecycle%20Stage-Deprecated-%23ff005c)](#section/Versioning/API-Lifecycle-Policy)
     *
     *     Make a request to create a cluster.
     */
    post: operations["createSrcmV2Cluster"];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  "/srcm/v2/clusters/{id}": {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /**
     * Read a Cluster
     * @deprecated
     * @description [![Deprecated](https://img.shields.io/badge/Lifecycle%20Stage-Deprecated-%23ff005c)](#section/Versioning/API-Lifecycle-Policy)
     *
     *     Make a request to read a cluster.
     */
    get: operations["getSrcmV2Cluster"];
    put?: never;
    post?: never;
    /**
     * Delete a Cluster
     * @deprecated
     * @description [![Deprecated](https://img.shields.io/badge/Lifecycle%20Stage-Deprecated-%23ff005c)](#section/Versioning/API-Lifecycle-Policy)
     *
     *     Make a request to delete a cluster.
     */
    delete: operations["deleteSrcmV2Cluster"];
    options?: never;
    head?: never;
    /**
     * Update a Cluster
     * @deprecated
     * @description [![Deprecated](https://img.shields.io/badge/Lifecycle%20Stage-Deprecated-%23ff005c)](#section/Versioning/API-Lifecycle-Policy)
     *
     *     Make a request to update a cluster.
     *
     *
     */
    patch: operations["updateSrcmV2Cluster"];
    trace?: never;
  };
  "/srcm/v3/clusters": {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /**
     * List of Clusters
     * @description [![General Availability](https://img.shields.io/badge/Lifecycle%20Stage-General%20Availability-%2345c6e8)](#section/Versioning/API-Lifecycle-Policy)
     *
     *     Retrieve a sorted, filtered, paginated list of all clusters.
     */
    get: operations["listSrcmV3Clusters"];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  "/srcm/v3/clusters/{id}": {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /**
     * Read a Cluster
     * @description [![General Availability](https://img.shields.io/badge/Lifecycle%20Stage-General%20Availability-%2345c6e8)](#section/Versioning/API-Lifecycle-Policy)
     *
     *     Make a request to read a cluster.
     */
    get: operations["getSrcmV3Cluster"];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  "/clusterconfig": {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /**
     * Get cluster config
     * @description Retrieves cluster config information.
     */
    get: operations["getClusterConfig"];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  "/compatibility/subjects/{subject}/versions/{version}": {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Test schema compatibility against a particular schema subject-version
     * @description Test input schema against a particular version of a subject's schema for compatibility. The compatibility level applied for the check is the configured compatibility level for the subject (http:get:: /config/(string: subject)). If this subject's compatibility level was never changed, then the global compatibility level applies (http:get:: /config).
     */
    post: operations["testCompatibilityBySubjectName"];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  "/compatibility/subjects/{subject}/versions": {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Test schema compatibility against all schemas under a subject
     * @description Test input schema against a subject's schemas for compatibility, based on the configured compatibility level of the subject. In other words, it will perform the same compatibility check as register for that subject. The compatibility level applied for the check is the configured compatibility level for the subject (http:get:: /config/(string: subject)). If this subject's compatibility level was never changed, then the global compatibility level applies (http:get:: /config).
     */
    post: operations["testCompatibilityForSubject"];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  "/config/{subject}": {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /**
     * Get subject compatibility level
     * @description Retrieves compatibility level, compatibility group, normalization,
     *     default metadata, and rule set for a subject.
     */
    get: operations["getSubjectLevelConfig"];
    /**
     * Update subject compatibility level
     * @description Update compatibility level, compatibility group, normalization,
     *     default metadata, and rule set for the specified subject. On success,
     *     echoes the original request back to the client.
     */
    put: operations["updateSubjectLevelConfig"];
    post?: never;
    /**
     * Delete subject compatibility level
     * @description Deletes the specified subject-level compatibility level config and reverts to the global default.
     */
    delete: operations["deleteSubjectConfig"];
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  "/config": {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /**
     * Get global compatibility level
     * @description Retrieves the global compatibility level, compatibility group,
     *     normalization, default metadata, and rule set.
     */
    get: operations["getTopLevelConfig"];
    /**
     * Update global compatibility level
     * @description Updates the global compatibility level, compatibility group,
     *     schema normalization, default metadata, and rule set. On success, echoes the
     *     original request back to the client.
     */
    put: operations["updateTopLevelConfig"];
    post?: never;
    /**
     * Delete global compatibility level
     * @description Deletes the global compatibility level config and reverts to the default.
     */
    delete: operations["deleteTopLevelConfig"];
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  "/exporters": {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /**
     * Gets all schema exporters
     * @description Retrieves a list of schema exporters that have been created.
     */
    get: operations["listExporters"];
    put?: never;
    /**
     * Creates a new schema exporter
     * @description Creates a new schema exporter. All attributes in request body are optional except config.
     */
    post: operations["registerExporter"];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  "/exporters/{name}": {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /**
     * Gets schema exporter by name
     * @description Retrieves the information of the schema exporter.
     */
    get: operations["getExporterInfoByName"];
    /**
     * Update schema exporter by name
     * @description Updates the information or configurations of the schema exporter. All attributes in request body are optional.
     */
    put: operations["updateExporterInfo"];
    post?: never;
    /**
     * Delete schema exporter by name
     * @description Deletes the schema exporter.
     */
    delete: operations["deleteExporter"];
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  "/exporters/{name}/status": {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /**
     * Gets schema exporter status by name
     * @description Retrieves the status of the schema exporter.
     */
    get: operations["getExporterStatusByName"];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  "/exporters/{name}/config": {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /**
     * Gets schema exporter config by name
     * @description Retrieves the config of the schema exporter.
     */
    get: operations["getExporterConfigByName"];
    /**
     * Update schema exporter config by name
     * @description Retrieves the config of the schema exporter.
     */
    put: operations["updateExporterConfigByName"];
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  "/exporters/{name}/pause": {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    /**
     * Pause schema exporter by name
     * @description Pauses the state of the schema exporter.
     */
    put: operations["pauseExporterByName"];
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  "/exporters/{name}/reset": {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    /**
     * Reset schema exporter by name
     * @description Reset the state of the schema exporter.
     */
    put: operations["resetExporterByName"];
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  "/exporters/{name}/resume": {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    /**
     * Resume schema exporter by name
     * @description Resume running of the schema exporter.
     */
    put: operations["resumeExporterByName"];
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  "/contexts": {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /**
     * List contexts
     * @description Retrieves a list of contexts.
     */
    get: operations["listContexts"];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  "/mode/{subject}": {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /**
     * Get subject mode
     * @description Retrieves the subject mode.
     */
    get: operations["getMode"];
    /**
     * Update subject mode
     * @description Update mode for the specified subject. On success, echoes the original request back to the client.
     */
    put: operations["updateMode"];
    post?: never;
    /**
     * Delete subject mode
     * @description Deletes the specified subject-level mode and reverts to the global default.
     */
    delete: operations["deleteSubjectMode"];
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  "/mode": {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /**
     * Get global mode
     * @description Retrieves global mode.
     */
    get: operations["getTopLevelMode"];
    /**
     * Update global mode
     * @description Update global mode. On success, echoes the original request back to the client.
     */
    put: operations["updateTopLevelMode"];
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  "/schemas/ids/{id}": {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /**
     * Get schema string by ID
     * @description Retrieves the schema string identified by the input ID.
     */
    get: operations["getSchema"];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  "/schemas/ids/{id}/schema": {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /**
     * Get schema by ID
     * @description Retrieves the schema identified by the input ID.
     */
    get: operations["getSchemaOnly"];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  "/schemas/types": {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /**
     * List supported schema types
     * @description Retrieve the schema types supported by this registry.
     */
    get: operations["getSchemaTypes"];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  "/schemas": {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /**
     * List schemas
     * @description Get the schemas matching the specified parameters.
     */
    get: operations["getSchemas"];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  "/schemas/ids/{id}/subjects": {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /**
     * List subjects associated to schema ID
     * @description Retrieves all the subjects associated with a particular schema ID.
     */
    get: operations["getSubjects"];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  "/schemas/ids/{id}/versions": {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /**
     * List subject-versions associated to schema ID
     * @description Get all the subject-version pairs associated with the input ID.
     */
    get: operations["getVersions"];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  "/subjects/{subject}/versions/{version}": {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /**
     * Get schema by version
     * @description Retrieves a specific version of the schema registered under this subject.
     */
    get: operations["getSchemaByVersion"];
    put?: never;
    post?: never;
    /**
     * Delete schema version
     * @description Deletes a specific version of the schema registered under this subject. This only deletes the version and the schema ID remains intact making it still possible to decode data using the schema ID. This API is recommended to be used only in development environments or under extreme circumstances where-in, its required to delete a previously registered schema for compatibility purposes or re-register previously registered schema.
     */
    delete: operations["deleteSchemaVersion"];
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  "/subjects/{subject}/versions/{version}/referencedby": {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /**
     * List schemas referencing a schema
     * @description Retrieves the IDs of schemas that reference the specified schema.
     */
    get: operations["getReferencedBy"];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  "/subjects/{subject}/versions/{version}/schema": {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /**
     * Get schema string by version
     * @description Retrieves the schema for the specified version of this subject. Only the unescaped schema string is returned.
     */
    get: operations["getSchemaOnly_1"];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  "/subjects/{subject}/versions": {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /**
     * List versions under subject
     * @description Retrieves a list of versions registered under the specified subject.
     */
    get: operations["listVersions"];
    put?: never;
    /**
     * Register schema under a subject
     * @description Register a new schema under the specified subject. If successfully registered, this returns the unique identifier of this schema in the registry. The returned identifier should be used to retrieve this schema from the schemas resource and is different from the schema's version which is associated with the subject. If the same schema is registered under a different subject, the same identifier will be returned. However, the version of the schema may be different under different subjects.
     *     A schema should be compatible with the previously registered schema or schemas (if there are any) as per the configured compatibility level. The configured compatibility level can be obtained by issuing a GET http:get:: /config/(string: subject). If that returns null, then GET http:get:: /config
     *     When there are multiple instances of Schema Registry running in the same cluster, the schema registration request will be forwarded to one of the instances designated as the primary. If the primary is not available, the client will get an error code indicating that the forwarding has failed.
     */
    post: operations["register"];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  "/subjects/{subject}": {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Lookup schema under subject
     * @description Check if a schema has already been registered under the specified subject. If so, this returns the schema string along with its globally unique identifier, its version under this subject and the subject name.
     */
    post: operations["lookUpSchemaUnderSubject"];
    /**
     * Delete subject
     * @description Deletes the specified subject and its associated compatibility level if registered. It is recommended to use this API only when a topic needs to be recycled or in development environment.
     */
    delete: operations["deleteSubject"];
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  "/subjects": {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /**
     * List subjects
     * @description Retrieves a list of registered subjects matching specified parameters.
     */
    get: operations["list"];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  "/dek-registry/v1/keks": {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /** Get a list of kek names */
    get: operations["getKekNames"];
    put?: never;
    /** Create a kek */
    post: operations["createKek"];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  "/dek-registry/v1/keks/{name}": {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /** Get a kek by name */
    get: operations["getKek"];
    /** Alters a kek */
    put: operations["putKek"];
    post?: never;
    /** Delete a kek */
    delete: operations["deleteKek"];
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  "/dek-registry/v1/keks/{name}/undelete": {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /** Undelete a kek */
    post: operations["undeleteKek"];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  "/dek-registry/v1/keks/{name}/deks": {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /** Get a list of dek subjects */
    get: operations["getDekSubjects"];
    put?: never;
    /** Create a dek */
    post: operations["createDek"];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  "/dek-registry/v1/keks/{name}/deks/{subject}": {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /** Get a dek by subject */
    get: operations["getDek"];
    put?: never;
    post?: never;
    /** Delete all versions of a dek */
    delete: operations["deleteDekVersions"];
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  "/dek-registry/v1/keks/{name}/deks/{subject}/versions/{version}": {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /** Get a dek by subject and version */
    get: operations["getDekByVersion"];
    put?: never;
    post?: never;
    /** Delete a dek version */
    delete: operations["deleteDekVersion"];
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  "/dek-registry/v1/keks/{name}/deks/{subject}/versions": {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /** List versions of dek */
    get: operations["getDekVersions"];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  "/dek-registry/v1/keks/{name}/deks/{subject}/versions/{version}/undelete": {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /** Undelete a dek version */
    post: operations["undeleteDekVersion"];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  "/dek-registry/v1/keks/{name}/deks/{subject}/undelete": {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /** Undelete all versions of a dek */
    post: operations["undeleteDekVersions"];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  "/catalog/v1/types/businessmetadatadefs": {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /**
     * Bulk Read Business Metadata Definitions
     * @description [![Generally Available](https://img.shields.io/badge/Lifecycle%20Stage-Generally%20Available-%2345c6e8)](#section/Versioning/API-Lifecycle-Policy)
     *
     *     Bulk retrieval API for retrieving business metadata definitions.
     */
    get: operations["getAllBusinessMetadataDefs"];
    /**
     * Bulk Update Business Metadata Definitions
     * @description [![Generally Available](https://img.shields.io/badge/Lifecycle%20Stage-Generally%20Available-%2345c6e8)](#section/Versioning/API-Lifecycle-Policy)
     *
     *     Bulk update API for business metadata definitions.
     */
    put: operations["updateBusinessMetadataDefs"];
    /**
     * Bulk Create Business Metadata Definitions
     * @description [![Generally Available](https://img.shields.io/badge/Lifecycle%20Stage-Generally%20Available-%2345c6e8)](#section/Versioning/API-Lifecycle-Policy)
     *
     *     Bulk create API for business metadata definitions.
     */
    post: operations["createBusinessMetadataDefs"];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  "/catalog/v1/types/businessmetadatadefs/{bmName}": {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /**
     * Read Business Metadata Definition
     * @description [![Generally Available](https://img.shields.io/badge/Lifecycle%20Stage-Generally%20Available-%2345c6e8)](#section/Versioning/API-Lifecycle-Policy)
     *
     *     Get the business metadata definition with the given name.
     */
    get: operations["getBusinessMetadataDefByName"];
    put?: never;
    post?: never;
    /**
     * Delete Business Metadata Definition
     * @description [![Generally Available](https://img.shields.io/badge/Lifecycle%20Stage-Generally%20Available-%2345c6e8)](#section/Versioning/API-Lifecycle-Policy)
     *
     *     Delete API for business metadata definition identified by its name.
     */
    delete: operations["deleteBusinessMetadataDef"];
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  "/catalog/v1/entity/businessmetadata": {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    /**
     * Bulk Update Business Metadata
     * @description [![Generally Available](https://img.shields.io/badge/Lifecycle%20Stage-Generally%20Available-%2345c6e8)](#section/Versioning/API-Lifecycle-Policy)
     *
     *     Bulk API to update multiple business metadata.
     */
    put: operations["updateBusinessMetadata"];
    /**
     * Bulk Create Business Metadata
     * @description [![Generally Available](https://img.shields.io/badge/Lifecycle%20Stage-Generally%20Available-%2345c6e8)](#section/Versioning/API-Lifecycle-Policy)
     *
     *     Bulk API to create multiple business metadata.
     */
    post: operations["createBusinessMetadata"];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  "/catalog/v1/entity/type/{typeName}/name/{qualifiedName}/businessmetadata": {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /**
     * Read Business Metadata for an Entity
     * @description [![Generally Available](https://img.shields.io/badge/Lifecycle%20Stage-Generally%20Available-%2345c6e8)](#section/Versioning/API-Lifecycle-Policy)
     *
     *     Gets the list of business metadata for a given entity represented
     *     by a qualified name.
     */
    get: operations["getBusinessMetadata"];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  "/catalog/v1/entity/type/{typeName}/name/{qualifiedName}/businessmetadata/{bmName}": {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    post?: never;
    /**
     * Delete a Business Metadata for an Entity
     * @description [![Generally Available](https://img.shields.io/badge/Lifecycle%20Stage-Generally%20Available-%2345c6e8)](#section/Versioning/API-Lifecycle-Policy)
     *
     *     Delete a business metadata on an entity.
     */
    delete: operations["deleteBusinessMetadata"];
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  "/catalog/v1/entity/tags": {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    /**
     * Bulk Update Tags
     * @description [![Generally Available](https://img.shields.io/badge/Lifecycle%20Stage-Generally%20Available-%2345c6e8)](#section/Versioning/API-Lifecycle-Policy)
     *
     *     Bulk API to update multiple tags.
     */
    put: operations["updateTags"];
    /**
     * Bulk Create Tags
     * @description [![Generally Available](https://img.shields.io/badge/Lifecycle%20Stage-Generally%20Available-%2345c6e8)](#section/Versioning/API-Lifecycle-Policy)
     *
     *     Bulk API to create multiple tags.
     */
    post: operations["createTags"];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  "/catalog/v1/entity/type/{typeName}/name/{qualifiedName}": {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /**
     * Read an Entity
     * @description [![Generally Available](https://img.shields.io/badge/Lifecycle%20Stage-Generally%20Available-%2345c6e8)](#section/Versioning/API-Lifecycle-Policy)
     *
     *     Fetch complete definition of an entity given its type and unique attribute.
     */
    get: operations["getByUniqueAttributes"];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  "/catalog/v1/entity/type/{typeName}/name/{qualifiedName}/tags": {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /**
     * Read Tags for an Entity
     * @description [![Generally Available](https://img.shields.io/badge/Lifecycle%20Stage-Generally%20Available-%2345c6e8)](#section/Versioning/API-Lifecycle-Policy)
     *
     *     Gets the list of tags for a given entity represented by a qualified name.
     */
    get: operations["getTags"];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  "/catalog/v1/entity": {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    /**
     * Update an Entity Attribute
     * @description [![Generally Available](https://img.shields.io/badge/Lifecycle%20Stage-Generally%20Available-%2345c6e8)](#section/Versioning/API-Lifecycle-Policy)
     *
     *     Partially update an entity attribute.
     */
    put: operations["partialEntityUpdate"];
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  "/catalog/v1/entity/type/{typeName}/name/{qualifiedName}/tags/{tagName}": {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    post?: never;
    /**
     * Delete a Tag for an Entity
     * @description [![Generally Available](https://img.shields.io/badge/Lifecycle%20Stage-Generally%20Available-%2345c6e8)](#section/Versioning/API-Lifecycle-Policy)
     *
     *     Delete a tag for an entity.
     */
    delete: operations["deleteTag"];
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  "/catalog/v1/search/attribute": {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /**
     * Search by Attribute
     * @description [![Generally Available](https://img.shields.io/badge/Lifecycle%20Stage-Generally%20Available-%2345c6e8)](#section/Versioning/API-Lifecycle-Policy)
     *
     *     Retrieve data for the specified attribute search query.
     */
    get: operations["searchUsingAttribute"];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  "/catalog/v1/search/basic": {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /**
     * Search by Fulltext Query
     * @description [![Generally Available](https://img.shields.io/badge/Lifecycle%20Stage-Generally%20Available-%2345c6e8)](#section/Versioning/API-Lifecycle-Policy)
     *
     *     Retrieve data for the specified fulltext query.
     */
    get: operations["searchUsingBasic"];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  "/catalog/v1/types/tagdefs": {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /**
     * Bulk Read Tag Definitions
     * @description [![Generally Available](https://img.shields.io/badge/Lifecycle%20Stage-Generally%20Available-%2345c6e8)](#section/Versioning/API-Lifecycle-Policy)
     *
     *     Bulk retrieval API for retrieving tag definitions.
     */
    get: operations["getAllTagDefs"];
    /**
     * Bulk Update Tag Definitions
     * @description [![Generally Available](https://img.shields.io/badge/Lifecycle%20Stage-Generally%20Available-%2345c6e8)](#section/Versioning/API-Lifecycle-Policy)
     *
     *     Bulk update API for tag definitions.
     */
    put: operations["updateTagDefs"];
    /**
     * Bulk Create Tag Definitions
     * @description [![Generally Available](https://img.shields.io/badge/Lifecycle%20Stage-Generally%20Available-%2345c6e8)](#section/Versioning/API-Lifecycle-Policy)
     *
     *     Bulk create API for tag definitions.
     */
    post: operations["createTagDefs"];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  "/catalog/v1/types/tagdefs/{tagName}": {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /**
     * Read Tag Definition
     * @description [![Generally Available](https://img.shields.io/badge/Lifecycle%20Stage-Generally%20Available-%2345c6e8)](#section/Versioning/API-Lifecycle-Policy)
     *
     *     Get the tag definition with the given name.
     */
    get: operations["getTagDefByName"];
    put?: never;
    post?: never;
    /**
     * Delete Tag Definition
     * @description [![Generally Available](https://img.shields.io/badge/Lifecycle%20Stage-Generally%20Available-%2345c6e8)](#section/Versioning/API-Lifecycle-Policy)
     *
     *     Delete API for tag definition identified by its name.
     */
    delete: operations["deleteTagDef"];
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  "/cdx/v1/provider-shared-resources": {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /**
     * List of Provider Shared Resources
     * @description [![General Availability](https://img.shields.io/badge/Lifecycle%20Stage-General%20Availability-%2345c6e8)](#section/Versioning/API-Lifecycle-Policy)
     *
     *     Retrieve a sorted, filtered, paginated list of all provider shared resources.
     */
    get: operations["listCdxV1ProviderSharedResources"];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  "/cdx/v1/provider-shared-resources/{id}": {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /**
     * Read a Provider Shared Resource
     * @description [![General Availability](https://img.shields.io/badge/Lifecycle%20Stage-General%20Availability-%2345c6e8)](#section/Versioning/API-Lifecycle-Policy)
     *
     *     Make a request to read a provider shared resource.
     */
    get: operations["getCdxV1ProviderSharedResource"];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    /**
     * Update a Provider Shared Resource
     * @description [![General Availability](https://img.shields.io/badge/Lifecycle%20Stage-General%20Availability-%2345c6e8)](#section/Versioning/API-Lifecycle-Policy)
     *
     *     Make a request to update a provider shared resource.
     *
     *
     */
    patch: operations["updateCdxV1ProviderSharedResource"];
    trace?: never;
  };
  "/cdx/v1/provider-shared-resources/{id}/images/{file_name}": {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /**
     * Get image for shared resource
     * @description [![General Availability](https://img.shields.io/badge/Lifecycle%20Stage-General%20Availability-%2345c6e8)](#section/Versioning/API-Lifecycle-Policy)
     *
     *     Returns the image file for the shared resource
     */
    get: operations["view_imageCdxV1ProviderSharedResource"];
    put?: never;
    /**
     * Upload image for shared resource
     * @description [![General Availability](https://img.shields.io/badge/Lifecycle%20Stage-General%20Availability-%2345c6e8)](#section/Versioning/API-Lifecycle-Policy)
     *
     *     Upload the image file for the shared resource
     */
    post: operations["upload_imageCdxV1ProviderSharedResource"];
    /**
     * Delete the shared resource's image
     * @description [![General Availability](https://img.shields.io/badge/Lifecycle%20Stage-General%20Availability-%2345c6e8)](#section/Versioning/API-Lifecycle-Policy)
     *
     *     Deletes the image file for the shared resource
     */
    delete: operations["delete_imageCdxV1ProviderSharedResource"];
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  "/cdx/v1/provider-shares": {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /**
     * List of Provider Shares
     * @description [![General Availability](https://img.shields.io/badge/Lifecycle%20Stage-General%20Availability-%2345c6e8)](#section/Versioning/API-Lifecycle-Policy)
     *
     *     Retrieve a sorted, filtered, paginated list of all provider shares.
     */
    get: operations["listCdxV1ProviderShares"];
    put?: never;
    /**
     * Create a provider share
     * @description [![General Availability](https://img.shields.io/badge/Lifecycle%20Stage-General%20Availability-%2345c6e8)](#section/Versioning/API-Lifecycle-Policy)
     *
     *     Creates a share based on delivery method.
     */
    post: operations["createCdxV1ProviderShare"];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  "/cdx/v1/provider-shares/{id}": {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /**
     * Read a Provider Share
     * @description [![General Availability](https://img.shields.io/badge/Lifecycle%20Stage-General%20Availability-%2345c6e8)](#section/Versioning/API-Lifecycle-Policy)
     *
     *     Make a request to read a provider share.
     */
    get: operations["getCdxV1ProviderShare"];
    put?: never;
    post?: never;
    /**
     * Delete a Provider Share
     * @description [![General Availability](https://img.shields.io/badge/Lifecycle%20Stage-General%20Availability-%2345c6e8)](#section/Versioning/API-Lifecycle-Policy)
     *
     *     Make a request to delete a provider share.
     */
    delete: operations["deleteCdxV1ProviderShare"];
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  "/cdx/v1/provider-shares/{id}:resend": {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Resend
     * @description [![General Availability](https://img.shields.io/badge/Lifecycle%20Stage-General%20Availability-%2345c6e8)](#section/Versioning/API-Lifecycle-Policy)
     *
     *     Resend provider share
     */
    post: operations["resendCdxV1ProviderShare"];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  "/cdx/v1/consumer-shared-resources": {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /**
     * List of Consumer Shared Resources
     * @description [![General Availability](https://img.shields.io/badge/Lifecycle%20Stage-General%20Availability-%2345c6e8)](#section/Versioning/API-Lifecycle-Policy)
     *
     *     Retrieve a sorted, filtered, paginated list of all consumer shared resources.
     */
    get: operations["listCdxV1ConsumerSharedResources"];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  "/cdx/v1/consumer-shared-resources/{id}": {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /**
     * Read a Consumer Shared Resource
     * @description [![General Availability](https://img.shields.io/badge/Lifecycle%20Stage-General%20Availability-%2345c6e8)](#section/Versioning/API-Lifecycle-Policy)
     *
     *     Make a request to read a consumer shared resource.
     */
    get: operations["getCdxV1ConsumerSharedResource"];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  "/cdx/v1/consumer-shared-resources/{id}/images/{file_name}": {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /**
     * Get image for shared resource
     * @description [![General Availability](https://img.shields.io/badge/Lifecycle%20Stage-General%20Availability-%2345c6e8)](#section/Versioning/API-Lifecycle-Policy)
     *
     *     Returns the image file for the shared resource
     */
    get: operations["imageCdxV1ConsumerSharedResource"];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  "/cdx/v1/consumer-shared-resources/{id}:network": {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /**
     * Get shared resource's network configuration
     * @description [![General Availability](https://img.shields.io/badge/Lifecycle%20Stage-General%20Availability-%2345c6e8)](#section/Versioning/API-Lifecycle-Policy)
     *
     *     Returns network information of the shared resource
     */
    get: operations["networkCdxV1ConsumerSharedResource"];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  "/cdx/v1/consumer-shares": {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /**
     * List of Consumer Shares
     * @description [![General Availability](https://img.shields.io/badge/Lifecycle%20Stage-General%20Availability-%2345c6e8)](#section/Versioning/API-Lifecycle-Policy)
     *
     *     Retrieve a sorted, filtered, paginated list of all consumer shares.
     */
    get: operations["listCdxV1ConsumerShares"];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  "/cdx/v1/consumer-shares/{id}": {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /**
     * Read a Consumer Share
     * @description [![General Availability](https://img.shields.io/badge/Lifecycle%20Stage-General%20Availability-%2345c6e8)](#section/Versioning/API-Lifecycle-Policy)
     *
     *     Make a request to read a consumer share.
     */
    get: operations["getCdxV1ConsumerShare"];
    put?: never;
    post?: never;
    /**
     * Delete a Consumer Share
     * @description [![General Availability](https://img.shields.io/badge/Lifecycle%20Stage-General%20Availability-%2345c6e8)](#section/Versioning/API-Lifecycle-Policy)
     *
     *     Make a request to delete a consumer share.
     */
    delete: operations["deleteCdxV1ConsumerShare"];
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  "/cdx/v1/shared-tokens:resources": {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Validate token to view shared resources
     * @description [![General Availability](https://img.shields.io/badge/Lifecycle%20Stage-General%20Availability-%2345c6e8)](#section/Versioning/API-Lifecycle-Policy)
     *
     *     Validate and decrypt the shared token and view token's shared resources
     */
    post: operations["resourcesCdxV1SharedToken"];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  "/cdx/v1/shared-tokens:redeem": {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Redeem token
     * @description [![General Availability](https://img.shields.io/badge/Lifecycle%20Stage-General%20Availability-%2345c6e8)](#section/Versioning/API-Lifecycle-Policy)
     *
     *     Redeem the shared token for shared topic and cluster access information
     */
    post: operations["redeemCdxV1SharedToken"];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  "/cdx/v1/opt-in": {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /**
     * Read the organization's stream sharing opt-in settings
     * @description [![General Availability](https://img.shields.io/badge/Lifecycle%20Stage-General%20Availability-%2345c6e8)](#section/Versioning/API-Lifecycle-Policy)
     *
     *     Returns the organization's stream sharing opt-in settings.
     *
     */
    get: operations["getCdxV1OptIn"];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    /**
     * Set the organization's stream sharing opt-in settings
     * @description [![General Availability](https://img.shields.io/badge/Lifecycle%20Stage-General%20Availability-%2345c6e8)](#section/Versioning/API-Lifecycle-Policy)
     *
     *     Updates the organization's stream sharing opt-in settings.
     *
     *
     *
     */
    patch: operations["updateCdxV1OptIn"];
    trace?: never;
  };
  "/partner/v2/organizations/{id}": {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /**
     * Read an Organization
     * @description [![Early Access](https://img.shields.io/badge/Lifecycle%20Stage-Early%20Access-%2345c6e8)](#section/Versioning/API-Lifecycle-Policy) [![Request Access To Partner v2](https://img.shields.io/badge/-Request%20Access%20To%20Partner%20v2-%23bc8540)](mailto:ccloud-api-access+partner-v2-early-access@confluent.io?subject=Request%20to%20join%20partner/v2%20API%20Early%20Access&body=I%E2%80%99d%20like%20to%20join%20the%20Confluent%20Cloud%20API%20Early%20Access%20for%20partner/v2%20to%20provide%20early%20feedback%21%20My%20Cloud%20Organization%20ID%20is%20%3Cretrieve%20from%20https%3A//confluent.cloud/settings/billing/payment%3E.)
     *
     *     Make a request to read an organization.
     */
    get: operations["getPartnerV2Organization"];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  "/partner/v2/organizations": {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /**
     * List of Organizations
     * @description [![Early Access](https://img.shields.io/badge/Lifecycle%20Stage-Early%20Access-%2345c6e8)](#section/Versioning/API-Lifecycle-Policy) [![Request Access To Partner v2](https://img.shields.io/badge/-Request%20Access%20To%20Partner%20v2-%23bc8540)](mailto:ccloud-api-access+partner-v2-early-access@confluent.io?subject=Request%20to%20join%20partner/v2%20API%20Early%20Access&body=I%E2%80%99d%20like%20to%20join%20the%20Confluent%20Cloud%20API%20Early%20Access%20for%20partner/v2%20to%20provide%20early%20feedback%21%20My%20Cloud%20Organization%20ID%20is%20%3Cretrieve%20from%20https%3A//confluent.cloud/settings/billing/payment%3E.)
     *
     *     Retrieve a sorted, filtered, paginated list of all organizations.
     */
    get: operations["listPartnerV2Organizations"];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  "/partner/v2/signup": {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Signup an Organization on behalf of a Customer
     * @description [![Early Access](https://img.shields.io/badge/Lifecycle%20Stage-Early%20Access-%2345c6e8)](#section/Versioning/API-Lifecycle-Policy) [![Request Access To Partner v2](https://img.shields.io/badge/-Request%20Access%20To%20Partner%20v2-%23bc8540)](mailto:ccloud-api-access+partner-v2-early-access@confluent.io?subject=Request%20to%20join%20partner/v2%20API%20Early%20Access&body=I%E2%80%99d%20like%20to%20join%20the%20Confluent%20Cloud%20API%20Early%20Access%20for%20partner/v2%20to%20provide%20early%20feedback%21%20My%20Cloud%20Organization%20ID%20is%20%3Cretrieve%20from%20https%3A//confluent.cloud/settings/billing/payment%3E.)
     *
     *     Create an organization for a customer. You must pass in either an entitlement object reference (a url to
     *     a previously created entitlement) or entitlement details. If you pass in an entitlement object reference, we will link with the
     *     created entitlement. If you pass in the entitlement details, we will create the entitlement with the organization
     *     in a single transaction. If you pass in user details (email, given name, and family name), we will
     *     create a user as well. If you do not pass in user details, you MUST call `/partner/v2/signup/activate`
     *     with user details to complete signup.
     */
    post: operations["signup"];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  "/partner/v2/signup/activate": {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Activate an Incomplete Signup
     * @description [![Early Access](https://img.shields.io/badge/Lifecycle%20Stage-Early%20Access-%2345c6e8)](#section/Versioning/API-Lifecycle-Policy) [![Request Access To Partner v2](https://img.shields.io/badge/-Request%20Access%20To%20Partner%20v2-%23bc8540)](mailto:ccloud-api-access+partner-v2-early-access@confluent.io?subject=Request%20to%20join%20partner/v2%20API%20Early%20Access&body=I%E2%80%99d%20like%20to%20join%20the%20Confluent%20Cloud%20API%20Early%20Access%20for%20partner/v2%20to%20provide%20early%20feedback%21%20My%20Cloud%20Organization%20ID%20is%20%3Cretrieve%20from%20https%3A//confluent.cloud/settings/billing/payment%3E.)
     *
     *     Creates a user in the organization previously created in `/partner/v2/signup`. This completes the signup
     *     process if you did not pass in user details to `/partner/v2/signup`. Calling this endpoint if the signup
     *     process has been completed will result in a `409 Conflict` error.
     */
    post: operations["activateSignup"];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  "/partner/v2/signup/link": {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Signup a Customer by Linking to an Existing Organization
     * @description [![Early Access](https://img.shields.io/badge/Lifecycle%20Stage-Early%20Access-%2345c6e8)](#section/Versioning/API-Lifecycle-Policy) [![Request Access To Partner v2](https://img.shields.io/badge/-Request%20Access%20To%20Partner%20v2-%23bc8540)](mailto:ccloud-api-access+partner-v2-early-access@confluent.io?subject=Request%20to%20join%20partner/v2%20API%20Early%20Access&body=I%E2%80%99d%20like%20to%20join%20the%20Confluent%20Cloud%20API%20Early%20Access%20for%20partner/v2%20to%20provide%20early%20feedback%21%20My%20Cloud%20Organization%20ID%20is%20%3Cretrieve%20from%20https%3A//confluent.cloud/settings/billing/payment%3E.)
     *
     *     Signup a customer by linking a new entitlement to an existing Confluent Cloud organization.
     */
    post: operations["signupPartnerV2Link"];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  "/networking/v1/networks": {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /**
     * List of Networks
     * @description [![General Availability](https://img.shields.io/badge/Lifecycle%20Stage-General%20Availability-%2345c6e8)](#section/Versioning/API-Lifecycle-Policy)
     *
     *     Retrieve a sorted, filtered, paginated list of all networks.
     */
    get: operations["listNetworkingV1Networks"];
    put?: never;
    /**
     * Create a Network
     * @description [![General Availability](https://img.shields.io/badge/Lifecycle%20Stage-General%20Availability-%2345c6e8)](#section/Versioning/API-Lifecycle-Policy)
     *
     *     Make a request to create a network.
     */
    post: operations["createNetworkingV1Network"];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  "/networking/v1/networks/{id}": {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /**
     * Read a Network
     * @description [![General Availability](https://img.shields.io/badge/Lifecycle%20Stage-General%20Availability-%2345c6e8)](#section/Versioning/API-Lifecycle-Policy)
     *
     *     Make a request to read a network.
     */
    get: operations["getNetworkingV1Network"];
    put?: never;
    post?: never;
    /**
     * Delete a Network
     * @description [![General Availability](https://img.shields.io/badge/Lifecycle%20Stage-General%20Availability-%2345c6e8)](#section/Versioning/API-Lifecycle-Policy)
     *
     *     Make a request to delete a network.
     */
    delete: operations["deleteNetworkingV1Network"];
    options?: never;
    head?: never;
    /**
     * Update a Network
     * @description [![General Availability](https://img.shields.io/badge/Lifecycle%20Stage-General%20Availability-%2345c6e8)](#section/Versioning/API-Lifecycle-Policy)
     *
     *     Make a request to update a network.
     *
     *
     */
    patch: operations["updateNetworkingV1Network"];
    trace?: never;
  };
  "/networking/v1/peerings": {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /**
     * List of Peerings
     * @description [![General Availability](https://img.shields.io/badge/Lifecycle%20Stage-General%20Availability-%2345c6e8)](#section/Versioning/API-Lifecycle-Policy)
     *
     *     Retrieve a sorted, filtered, paginated list of all peerings.
     */
    get: operations["listNetworkingV1Peerings"];
    put?: never;
    /**
     * Create a Peering
     * @description [![General Availability](https://img.shields.io/badge/Lifecycle%20Stage-General%20Availability-%2345c6e8)](#section/Versioning/API-Lifecycle-Policy)
     *
     *     Make a request to create a peering.
     */
    post: operations["createNetworkingV1Peering"];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  "/networking/v1/peerings/{id}": {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /**
     * Read a Peering
     * @description [![General Availability](https://img.shields.io/badge/Lifecycle%20Stage-General%20Availability-%2345c6e8)](#section/Versioning/API-Lifecycle-Policy)
     *
     *     Make a request to read a peering.
     */
    get: operations["getNetworkingV1Peering"];
    put?: never;
    post?: never;
    /**
     * Delete a Peering
     * @description [![General Availability](https://img.shields.io/badge/Lifecycle%20Stage-General%20Availability-%2345c6e8)](#section/Versioning/API-Lifecycle-Policy)
     *
     *     Make a request to delete a peering.
     */
    delete: operations["deleteNetworkingV1Peering"];
    options?: never;
    head?: never;
    /**
     * Update a Peering
     * @description [![General Availability](https://img.shields.io/badge/Lifecycle%20Stage-General%20Availability-%2345c6e8)](#section/Versioning/API-Lifecycle-Policy)
     *
     *     Make a request to update a peering.
     *
     *
     */
    patch: operations["updateNetworkingV1Peering"];
    trace?: never;
  };
  "/networking/v1/transit-gateway-attachments": {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /**
     * List of Transit Gateway Attachments
     * @description [![General Availability](https://img.shields.io/badge/Lifecycle%20Stage-General%20Availability-%2345c6e8)](#section/Versioning/API-Lifecycle-Policy)
     *
     *     Retrieve a sorted, filtered, paginated list of all transit gateway attachments.
     */
    get: operations["listNetworkingV1TransitGatewayAttachments"];
    put?: never;
    /**
     * Create a Transit Gateway Attachment
     * @description [![General Availability](https://img.shields.io/badge/Lifecycle%20Stage-General%20Availability-%2345c6e8)](#section/Versioning/API-Lifecycle-Policy)
     *
     *     Make a request to create a transit gateway attachment.
     */
    post: operations["createNetworkingV1TransitGatewayAttachment"];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  "/networking/v1/transit-gateway-attachments/{id}": {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /**
     * Read a Transit Gateway Attachment
     * @description [![General Availability](https://img.shields.io/badge/Lifecycle%20Stage-General%20Availability-%2345c6e8)](#section/Versioning/API-Lifecycle-Policy)
     *
     *     Make a request to read a transit gateway attachment.
     */
    get: operations["getNetworkingV1TransitGatewayAttachment"];
    put?: never;
    post?: never;
    /**
     * Delete a Transit Gateway Attachment
     * @description [![General Availability](https://img.shields.io/badge/Lifecycle%20Stage-General%20Availability-%2345c6e8)](#section/Versioning/API-Lifecycle-Policy)
     *
     *     Make a request to delete a transit gateway attachment.
     */
    delete: operations["deleteNetworkingV1TransitGatewayAttachment"];
    options?: never;
    head?: never;
    /**
     * Update a Transit Gateway Attachment
     * @description [![General Availability](https://img.shields.io/badge/Lifecycle%20Stage-General%20Availability-%2345c6e8)](#section/Versioning/API-Lifecycle-Policy)
     *
     *     Make a request to update a transit gateway attachment.
     *
     *
     */
    patch: operations["updateNetworkingV1TransitGatewayAttachment"];
    trace?: never;
  };
  "/networking/v1/private-link-accesses": {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /**
     * List of Private Link Accesses
     * @description [![General Availability](https://img.shields.io/badge/Lifecycle%20Stage-General%20Availability-%2345c6e8)](#section/Versioning/API-Lifecycle-Policy)
     *
     *     Retrieve a sorted, filtered, paginated list of all private link accesses.
     */
    get: operations["listNetworkingV1PrivateLinkAccesses"];
    put?: never;
    /**
     * Create a Private Link Access
     * @description [![General Availability](https://img.shields.io/badge/Lifecycle%20Stage-General%20Availability-%2345c6e8)](#section/Versioning/API-Lifecycle-Policy)
     *
     *     Make a request to create a private link access.
     */
    post: operations["createNetworkingV1PrivateLinkAccess"];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  "/networking/v1/private-link-accesses/{id}": {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /**
     * Read a Private Link Access
     * @description [![General Availability](https://img.shields.io/badge/Lifecycle%20Stage-General%20Availability-%2345c6e8)](#section/Versioning/API-Lifecycle-Policy)
     *
     *     Make a request to read a private link access.
     */
    get: operations["getNetworkingV1PrivateLinkAccess"];
    put?: never;
    post?: never;
    /**
     * Delete a Private Link Access
     * @description [![General Availability](https://img.shields.io/badge/Lifecycle%20Stage-General%20Availability-%2345c6e8)](#section/Versioning/API-Lifecycle-Policy)
     *
     *     Make a request to delete a private link access.
     */
    delete: operations["deleteNetworkingV1PrivateLinkAccess"];
    options?: never;
    head?: never;
    /**
     * Update a Private Link Access
     * @description [![General Availability](https://img.shields.io/badge/Lifecycle%20Stage-General%20Availability-%2345c6e8)](#section/Versioning/API-Lifecycle-Policy)
     *
     *     Make a request to update a private link access.
     *
     *
     */
    patch: operations["updateNetworkingV1PrivateLinkAccess"];
    trace?: never;
  };
  "/networking/v1/network-link-services": {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /**
     * List of Network Link Services
     * @description [![General Availability](https://img.shields.io/badge/Lifecycle%20Stage-General%20Availability-%2345c6e8)](#section/Versioning/API-Lifecycle-Policy)
     *
     *     Retrieve a sorted, filtered, paginated list of all network link services.
     */
    get: operations["listNetworkingV1NetworkLinkServices"];
    put?: never;
    /**
     * Create a Network Link Service
     * @description [![General Availability](https://img.shields.io/badge/Lifecycle%20Stage-General%20Availability-%2345c6e8)](#section/Versioning/API-Lifecycle-Policy)
     *
     *     Make a request to create a network link service.
     */
    post: operations["createNetworkingV1NetworkLinkService"];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  "/networking/v1/network-link-services/{id}": {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /**
     * Read a Network Link Service
     * @description [![General Availability](https://img.shields.io/badge/Lifecycle%20Stage-General%20Availability-%2345c6e8)](#section/Versioning/API-Lifecycle-Policy)
     *
     *     Make a request to read a network link service.
     */
    get: operations["getNetworkingV1NetworkLinkService"];
    put?: never;
    post?: never;
    /**
     * Delete a Network Link Service
     * @description [![General Availability](https://img.shields.io/badge/Lifecycle%20Stage-General%20Availability-%2345c6e8)](#section/Versioning/API-Lifecycle-Policy)
     *
     *     Make a request to delete a network link service.
     */
    delete: operations["deleteNetworkingV1NetworkLinkService"];
    options?: never;
    head?: never;
    /**
     * Update a Network Link Service
     * @description [![General Availability](https://img.shields.io/badge/Lifecycle%20Stage-General%20Availability-%2345c6e8)](#section/Versioning/API-Lifecycle-Policy)
     *
     *     Make a request to update a network link service.
     *
     *
     */
    patch: operations["updateNetworkingV1NetworkLinkService"];
    trace?: never;
  };
  "/networking/v1/network-link-endpoints": {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /**
     * List of Network Link Endpoints
     * @description [![General Availability](https://img.shields.io/badge/Lifecycle%20Stage-General%20Availability-%2345c6e8)](#section/Versioning/API-Lifecycle-Policy)
     *
     *     Retrieve a sorted, filtered, paginated list of all network link endpoints.
     */
    get: operations["listNetworkingV1NetworkLinkEndpoints"];
    put?: never;
    /**
     * Create a Network Link Endpoint
     * @description [![General Availability](https://img.shields.io/badge/Lifecycle%20Stage-General%20Availability-%2345c6e8)](#section/Versioning/API-Lifecycle-Policy)
     *
     *     Make a request to create a network link endpoint.
     */
    post: operations["createNetworkingV1NetworkLinkEndpoint"];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  "/networking/v1/network-link-endpoints/{id}": {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /**
     * Read a Network Link Endpoint
     * @description [![General Availability](https://img.shields.io/badge/Lifecycle%20Stage-General%20Availability-%2345c6e8)](#section/Versioning/API-Lifecycle-Policy)
     *
     *     Make a request to read a network link endpoint.
     */
    get: operations["getNetworkingV1NetworkLinkEndpoint"];
    put?: never;
    post?: never;
    /**
     * Delete a Network Link Endpoint
     * @description [![General Availability](https://img.shields.io/badge/Lifecycle%20Stage-General%20Availability-%2345c6e8)](#section/Versioning/API-Lifecycle-Policy)
     *
     *     Make a request to delete a network link endpoint.
     */
    delete: operations["deleteNetworkingV1NetworkLinkEndpoint"];
    options?: never;
    head?: never;
    /**
     * Update a Network Link Endpoint
     * @description [![General Availability](https://img.shields.io/badge/Lifecycle%20Stage-General%20Availability-%2345c6e8)](#section/Versioning/API-Lifecycle-Policy)
     *
     *     Make a request to update a network link endpoint.
     *
     *
     */
    patch: operations["updateNetworkingV1NetworkLinkEndpoint"];
    trace?: never;
  };
  "/networking/v1/network-link-service-associations": {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /**
     * List of Network Link Service Associations
     * @description [![General Availability](https://img.shields.io/badge/Lifecycle%20Stage-General%20Availability-%2345c6e8)](#section/Versioning/API-Lifecycle-Policy)
     *
     *     Retrieve a sorted, filtered, paginated list of all network link service associations.
     */
    get: operations["listNetworkingV1NetworkLinkServiceAssociations"];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  "/networking/v1/network-link-service-associations/{id}": {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /**
     * Read a Network Link Service Association
     * @description [![General Availability](https://img.shields.io/badge/Lifecycle%20Stage-General%20Availability-%2345c6e8)](#section/Versioning/API-Lifecycle-Policy)
     *
     *     Make a request to read a network link service association.
     */
    get: operations["getNetworkingV1NetworkLinkServiceAssociation"];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  "/networking/v1/ip-addresses": {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /**
     * List of IP Addresses
     * @description [![General Availability](https://img.shields.io/badge/Lifecycle%20Stage-General%20Availability-%2345c6e8)](#section/Versioning/API-Lifecycle-Policy)
     *
     *     Related guide: [Use Public Egress IP addresses on Confluent Cloud](https://docs.confluent.io/cloud/current/networking/static-egress-ip-addresses.html)
     *
     *     Retrieve a sorted, filtered, paginated list of all IP Addresses.
     */
    get: operations["listNetworkingV1IpAddresses"];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  "/networking/v1/private-link-attachments": {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /**
     * List of Private Link Attachments
     * @description [![General Availability](https://img.shields.io/badge/Lifecycle%20Stage-General%20Availability-%2345c6e8)](#section/Versioning/API-Lifecycle-Policy)
     *
     *     Retrieve a sorted, filtered, paginated list of all private link attachments.
     */
    get: operations["listNetworkingV1PrivateLinkAttachments"];
    put?: never;
    /**
     * Create a Private Link Attachment
     * @description [![General Availability](https://img.shields.io/badge/Lifecycle%20Stage-General%20Availability-%2345c6e8)](#section/Versioning/API-Lifecycle-Policy)
     *
     *     Make a request to create a private link attachment.
     */
    post: operations["createNetworkingV1PrivateLinkAttachment"];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  "/networking/v1/private-link-attachments/{id}": {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /**
     * Read a Private Link Attachment
     * @description [![General Availability](https://img.shields.io/badge/Lifecycle%20Stage-General%20Availability-%2345c6e8)](#section/Versioning/API-Lifecycle-Policy)
     *
     *     Make a request to read a private link attachment.
     */
    get: operations["getNetworkingV1PrivateLinkAttachment"];
    put?: never;
    post?: never;
    /**
     * Delete a Private Link Attachment
     * @description [![General Availability](https://img.shields.io/badge/Lifecycle%20Stage-General%20Availability-%2345c6e8)](#section/Versioning/API-Lifecycle-Policy)
     *
     *     Make a request to delete a private link attachment.
     */
    delete: operations["deleteNetworkingV1PrivateLinkAttachment"];
    options?: never;
    head?: never;
    /**
     * Update a Private Link Attachment
     * @description [![General Availability](https://img.shields.io/badge/Lifecycle%20Stage-General%20Availability-%2345c6e8)](#section/Versioning/API-Lifecycle-Policy)
     *
     *     Make a request to update a private link attachment.
     *
     *
     */
    patch: operations["updateNetworkingV1PrivateLinkAttachment"];
    trace?: never;
  };
  "/networking/v1/private-link-attachment-connections": {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /**
     * List of Private Link Attachment Connections
     * @description [![General Availability](https://img.shields.io/badge/Lifecycle%20Stage-General%20Availability-%2345c6e8)](#section/Versioning/API-Lifecycle-Policy)
     *
     *     Retrieve a sorted, filtered, paginated list of all private link attachment connections.
     */
    get: operations["listNetworkingV1PrivateLinkAttachmentConnections"];
    put?: never;
    /**
     * Create a Private Link Attachment Connection
     * @description [![General Availability](https://img.shields.io/badge/Lifecycle%20Stage-General%20Availability-%2345c6e8)](#section/Versioning/API-Lifecycle-Policy)
     *
     *     Make a request to create a private link attachment connection.
     */
    post: operations["createNetworkingV1PrivateLinkAttachmentConnection"];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  "/networking/v1/private-link-attachment-connections/{id}": {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /**
     * Read a Private Link Attachment Connection
     * @description [![General Availability](https://img.shields.io/badge/Lifecycle%20Stage-General%20Availability-%2345c6e8)](#section/Versioning/API-Lifecycle-Policy)
     *
     *     Make a request to read a private link attachment connection.
     */
    get: operations["getNetworkingV1PrivateLinkAttachmentConnection"];
    put?: never;
    post?: never;
    /**
     * Delete a Private Link Attachment Connection
     * @description [![General Availability](https://img.shields.io/badge/Lifecycle%20Stage-General%20Availability-%2345c6e8)](#section/Versioning/API-Lifecycle-Policy)
     *
     *     Make a request to delete a private link attachment connection.
     */
    delete: operations["deleteNetworkingV1PrivateLinkAttachmentConnection"];
    options?: never;
    head?: never;
    /**
     * Update a Private Link Attachment Connection
     * @description [![General Availability](https://img.shields.io/badge/Lifecycle%20Stage-General%20Availability-%2345c6e8)](#section/Versioning/API-Lifecycle-Policy)
     *
     *     Make a request to update a private link attachment connection.
     *
     *
     */
    patch: operations["updateNetworkingV1PrivateLinkAttachmentConnection"];
    trace?: never;
  };
  "/iam/v2/identity-providers": {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /**
     * List of Identity Providers
     * @description [![General Availability](https://img.shields.io/badge/Lifecycle%20Stage-General%20Availability-%2345c6e8)](#section/Versioning/API-Lifecycle-Policy)
     *
     *     Retrieve a sorted, filtered, paginated list of all identity providers.
     */
    get: operations["listIamV2IdentityProviders"];
    put?: never;
    /**
     * Create an Identity Provider
     * @description [![General Availability](https://img.shields.io/badge/Lifecycle%20Stage-General%20Availability-%2345c6e8)](#section/Versioning/API-Lifecycle-Policy)
     *
     *     Make a request to create an identity provider.
     */
    post: operations["createIamV2IdentityProvider"];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  "/iam/v2/identity-providers/{id}": {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /**
     * Read an Identity Provider
     * @description [![General Availability](https://img.shields.io/badge/Lifecycle%20Stage-General%20Availability-%2345c6e8)](#section/Versioning/API-Lifecycle-Policy)
     *
     *     Make a request to read an identity provider.
     */
    get: operations["getIamV2IdentityProvider"];
    put?: never;
    post?: never;
    /**
     * Delete an Identity Provider
     * @description [![General Availability](https://img.shields.io/badge/Lifecycle%20Stage-General%20Availability-%2345c6e8)](#section/Versioning/API-Lifecycle-Policy)
     *
     *     Make a request to delete an identity provider.
     */
    delete: operations["deleteIamV2IdentityProvider"];
    options?: never;
    head?: never;
    /**
     * Update an Identity Provider
     * @description [![General Availability](https://img.shields.io/badge/Lifecycle%20Stage-General%20Availability-%2345c6e8)](#section/Versioning/API-Lifecycle-Policy)
     *
     *     Make a request to update an identity provider.
     *
     *
     */
    patch: operations["updateIamV2IdentityProvider"];
    trace?: never;
  };
  "/iam/v2/identity-providers/{provider_id}/jwks": {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    /**
     * Refresh a provider's JWKS
     * @description [![General Availability](https://img.shields.io/badge/Lifecycle%20Stage-General%20Availability-%2345c6e8)](#section/Versioning/API-Lifecycle-Policy)
     *
     *     Make a request to refresh the provider's JWKS
     *
     *
     */
    patch: operations["refreshIamV2JsonWebKeySet"];
    trace?: never;
  };
  "/iam/v2/identity-providers/{provider_id}/identity-pools": {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /**
     * List of Identity Pools
     * @description [![General Availability](https://img.shields.io/badge/Lifecycle%20Stage-General%20Availability-%2345c6e8)](#section/Versioning/API-Lifecycle-Policy)
     *
     *     Retrieve a sorted, filtered, paginated list of all identity pools.
     */
    get: operations["listIamV2IdentityPools"];
    put?: never;
    /**
     * Create an Identity Pool
     * @description [![General Availability](https://img.shields.io/badge/Lifecycle%20Stage-General%20Availability-%2345c6e8)](#section/Versioning/API-Lifecycle-Policy)
     *
     *     Make a request to create an identity pool.
     */
    post: operations["createIamV2IdentityPool"];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  "/iam/v2/identity-providers/{provider_id}/identity-pools/{id}": {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /**
     * Read an Identity Pool
     * @description [![General Availability](https://img.shields.io/badge/Lifecycle%20Stage-General%20Availability-%2345c6e8)](#section/Versioning/API-Lifecycle-Policy)
     *
     *     Make a request to read an identity pool.
     */
    get: operations["getIamV2IdentityPool"];
    put?: never;
    post?: never;
    /**
     * Delete an Identity Pool
     * @description [![General Availability](https://img.shields.io/badge/Lifecycle%20Stage-General%20Availability-%2345c6e8)](#section/Versioning/API-Lifecycle-Policy)
     *
     *     Make a request to delete an identity pool.
     */
    delete: operations["deleteIamV2IdentityPool"];
    options?: never;
    head?: never;
    /**
     * Update an Identity Pool
     * @description [![General Availability](https://img.shields.io/badge/Lifecycle%20Stage-General%20Availability-%2345c6e8)](#section/Versioning/API-Lifecycle-Policy)
     *
     *     Make a request to update an identity pool.
     *
     *
     */
    patch: operations["updateIamV2IdentityPool"];
    trace?: never;
  };
  "/sts/v1/oauth2/token": {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Exchange an OAuth Token
     * @description [![General Availability](https://img.shields.io/badge/Lifecycle%20Stage-General%20Availability-%2345c6e8)](#section/Versioning/API-Lifecycle-Policy)
     *
     *     Use this operation to exchange an access token (JWT) issued by an external identity provider for
     *     an access token (JWT) issued by Confluent.This enables the use of external identities
     *     to access Confluent Cloud APIs.
     *
     */
    post: operations["exchangeStsV1OauthToken"];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  "/kafka-quotas/v1/client-quotas": {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /**
     * List of Client Quotas
     * @description [![General Availability](https://img.shields.io/badge/Lifecycle%20Stage-General%20Availability-%2345c6e8)](#section/Versioning/API-Lifecycle-Policy)
     *
     *     Retrieve a sorted, filtered, paginated list of all client quotas.
     */
    get: operations["listKafkaQuotasV1ClientQuotas"];
    put?: never;
    /**
     * Create a Client Quota
     * @description [![General Availability](https://img.shields.io/badge/Lifecycle%20Stage-General%20Availability-%2345c6e8)](#section/Versioning/API-Lifecycle-Policy)
     *
     *     Make a request to create a client quota.
     */
    post: operations["createKafkaQuotasV1ClientQuota"];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  "/kafka-quotas/v1/client-quotas/{id}": {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /**
     * Read a Client Quota
     * @description [![General Availability](https://img.shields.io/badge/Lifecycle%20Stage-General%20Availability-%2345c6e8)](#section/Versioning/API-Lifecycle-Policy)
     *
     *     Make a request to read a client quota.
     */
    get: operations["getKafkaQuotasV1ClientQuota"];
    put?: never;
    post?: never;
    /**
     * Delete a Client Quota
     * @description [![General Availability](https://img.shields.io/badge/Lifecycle%20Stage-General%20Availability-%2345c6e8)](#section/Versioning/API-Lifecycle-Policy)
     *
     *     Make a request to delete a client quota.
     */
    delete: operations["deleteKafkaQuotasV1ClientQuota"];
    options?: never;
    head?: never;
    /**
     * Update a Client Quota
     * @description [![General Availability](https://img.shields.io/badge/Lifecycle%20Stage-General%20Availability-%2345c6e8)](#section/Versioning/API-Lifecycle-Policy)
     *
     *     Make a request to update a client quota.
     *
     *
     */
    patch: operations["updateKafkaQuotasV1ClientQuota"];
    trace?: never;
  };
  "/byok/v1/keys": {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /**
     * List of Keys
     * @description [![General Availability](https://img.shields.io/badge/Lifecycle%20Stage-General%20Availability-%2345c6e8)](#section/Versioning/API-Lifecycle-Policy)
     *
     *     Retrieve a sorted, filtered, paginated list of all keys.
     */
    get: operations["listByokV1Keys"];
    put?: never;
    /**
     * Create a Key
     * @description [![General Availability](https://img.shields.io/badge/Lifecycle%20Stage-General%20Availability-%2345c6e8)](#section/Versioning/API-Lifecycle-Policy)
     *
     *     Make a request to create a key.
     */
    post: operations["createByokV1Key"];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  "/byok/v1/keys/{id}": {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /**
     * Read a Key
     * @description [![General Availability](https://img.shields.io/badge/Lifecycle%20Stage-General%20Availability-%2345c6e8)](#section/Versioning/API-Lifecycle-Policy)
     *
     *     Make a request to read a key.
     */
    get: operations["getByokV1Key"];
    put?: never;
    post?: never;
    /**
     * Delete a Key
     * @description [![General Availability](https://img.shields.io/badge/Lifecycle%20Stage-General%20Availability-%2345c6e8)](#section/Versioning/API-Lifecycle-Policy)
     *
     *     Make a request to delete a key.
     */
    delete: operations["deleteByokV1Key"];
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  "/billing/v1/costs": {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /**
     * List of Costs
     * @description [![General Availability](https://img.shields.io/badge/Lifecycle%20Stage-General%20Availability-%2345c6e8)](#section/Versioning/API-Lifecycle-Policy)
     *
     *     Retrieve a sorted, filtered, paginated list of all costs.
     */
    get: operations["listBillingV1Costs"];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  "/iam/v2/sso/group-mappings": {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /**
     * List of Group Mappings
     * @description [![General Availability](https://img.shields.io/badge/Lifecycle%20Stage-General%20Availability-%2345c6e8)](#section/Versioning/API-Lifecycle-Policy)
     *
     *     Retrieve a sorted, filtered, paginated list of all group mappings.
     */
    get: operations["listIamV2SsoGroupMappings"];
    put?: never;
    /**
     * Create a Group Mapping
     * @description [![General Availability](https://img.shields.io/badge/Lifecycle%20Stage-General%20Availability-%2345c6e8)](#section/Versioning/API-Lifecycle-Policy)
     *
     *     Make a request to create a group mapping.
     */
    post: operations["createIamV2SsoGroupMapping"];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  "/iam/v2/sso/group-mappings/{id}": {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /**
     * Read a Group Mapping
     * @description [![General Availability](https://img.shields.io/badge/Lifecycle%20Stage-General%20Availability-%2345c6e8)](#section/Versioning/API-Lifecycle-Policy)
     *
     *     Make a request to read a group mapping.
     */
    get: operations["getIamV2SsoGroupMapping"];
    put?: never;
    post?: never;
    /**
     * Delete a Group Mapping
     * @description [![General Availability](https://img.shields.io/badge/Lifecycle%20Stage-General%20Availability-%2345c6e8)](#section/Versioning/API-Lifecycle-Policy)
     *
     *     Make a request to delete a group mapping.
     */
    delete: operations["deleteIamV2SsoGroupMapping"];
    options?: never;
    head?: never;
    /**
     * Update a Group Mapping
     * @description [![General Availability](https://img.shields.io/badge/Lifecycle%20Stage-General%20Availability-%2345c6e8)](#section/Versioning/API-Lifecycle-Policy)
     *
     *     Make a request to update a group mapping.
     *
     *
     */
    patch: operations["updateIamV2SsoGroupMapping"];
    trace?: never;
  };
  "/fcpm/v2/compute-pools": {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /**
     * List of Compute Pools
     * @description [![General Availability](https://img.shields.io/badge/Lifecycle%20Stage-General%20Availability-%2345c6e8)](#section/Versioning/API-Lifecycle-Policy)
     *
     *     Retrieve a sorted, filtered, paginated list of all compute pools.
     */
    get: operations["listFcpmV2ComputePools"];
    put?: never;
    /**
     * Create a Compute Pool
     * @description [![General Availability](https://img.shields.io/badge/Lifecycle%20Stage-General%20Availability-%2345c6e8)](#section/Versioning/API-Lifecycle-Policy)
     *
     *     Make a request to create a compute pool.
     */
    post: operations["createFcpmV2ComputePool"];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  "/fcpm/v2/compute-pools/{id}": {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /**
     * Read a Compute Pool
     * @description [![General Availability](https://img.shields.io/badge/Lifecycle%20Stage-General%20Availability-%2345c6e8)](#section/Versioning/API-Lifecycle-Policy)
     *
     *     Make a request to read a compute pool.
     */
    get: operations["getFcpmV2ComputePool"];
    put?: never;
    post?: never;
    /**
     * Delete a Compute Pool
     * @description [![General Availability](https://img.shields.io/badge/Lifecycle%20Stage-General%20Availability-%2345c6e8)](#section/Versioning/API-Lifecycle-Policy)
     *
     *     Make a request to delete a compute pool.
     */
    delete: operations["deleteFcpmV2ComputePool"];
    options?: never;
    head?: never;
    /**
     * Update a Compute Pool
     * @description [![General Availability](https://img.shields.io/badge/Lifecycle%20Stage-General%20Availability-%2345c6e8)](#section/Versioning/API-Lifecycle-Policy)
     *
     *     Make a request to update a compute pool.
     */
    patch: operations["updateFcpmV2ComputePool"];
    trace?: never;
  };
  "/fcpm/v2/regions": {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /**
     * List of Regions
     * @description [![General Availability](https://img.shields.io/badge/Lifecycle%20Stage-General%20Availability-%2345c6e8)](#section/Versioning/API-Lifecycle-Policy)
     *
     *     Retrieve a sorted, filtered, paginated list of all regions.
     */
    get: operations["listFcpmV2Regions"];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  "/sql/v1/organizations/{organization_id}/environments/{environment_id}/connections": {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /**
     * List of Connections
     * @description [![Preview](https://img.shields.io/badge/Lifecycle%20Stage-Preview-%2300afba)](#section/Versioning/API-Lifecycle-Policy)
     *
     *     Retrieve a sorted, filtered and paginated list of all Connections.
     */
    get: operations["listSqlv1Connections"];
    put?: never;
    /**
     * Create a Connection
     * @description [![Preview](https://img.shields.io/badge/Lifecycle%20Stage-Preview-%2300afba)](#section/Versioning/API-Lifecycle-Policy)
     *
     *     Make a request to create a Connection.
     */
    post: operations["createSqlv1Connection"];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  "/sql/v1/organizations/{organization_id}/environments/{environment_id}/connections/{connection_name}": {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /**
     * Read a Connection
     * @description [![Preview](https://img.shields.io/badge/Lifecycle%20Stage-Preview-%2300afba)](#section/Versioning/API-Lifecycle-Policy)
     *
     *     Make a request to read a Connection.
     */
    get: operations["getSqlv1Connection"];
    /**
     * Update a Connection
     * @description [![Preview](https://img.shields.io/badge/Lifecycle%20Stage-Preview-%2300afba)](#section/Versioning/API-Lifecycle-Policy)
     *
     *     Make a request to update a connection.
     */
    put: operations["updateSqlv1Connection"];
    post?: never;
    /**
     * Delete a Connection
     * @description [![Preview](https://img.shields.io/badge/Lifecycle%20Stage-Preview-%2300afba)](#section/Versioning/API-Lifecycle-Policy)
     *
     *     Make a request to delete a statement.
     */
    delete: operations["deleteSqlv1Connection"];
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  "/sql/v1/organizations/{organization_id}/environments/{environment_id}/statements/{name}/results": {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /**
     * Read Statement Result
     * @description [![General Availability](https://img.shields.io/badge/Lifecycle%20Stage-General%20Availability-%2345c6e8)](#section/Versioning/API-Lifecycle-Policy)
     *
     *     Read Statement Result.
     */
    get: operations["getSqlv1StatementResult"];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  "/sql/v1/organizations/{organization_id}/environments/{environment_id}/statements": {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /**
     * List of Statements
     * @description [![General Availability](https://img.shields.io/badge/Lifecycle%20Stage-General%20Availability-%2345c6e8)](#section/Versioning/API-Lifecycle-Policy)
     *
     *     Retrieve a sorted, filtered, paginated list of all statements.
     */
    get: operations["listSqlv1Statements"];
    put?: never;
    /**
     * Create a Statement
     * @description [![General Availability](https://img.shields.io/badge/Lifecycle%20Stage-General%20Availability-%2345c6e8)](#section/Versioning/API-Lifecycle-Policy)
     *
     *     Make a request to create a statement.
     */
    post: operations["createSqlv1Statement"];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  "/sql/v1/organizations/{organization_id}/environments/{environment_id}/statements/{statement_name}": {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /**
     * Read a Statement
     * @description [![General Availability](https://img.shields.io/badge/Lifecycle%20Stage-General%20Availability-%2345c6e8)](#section/Versioning/API-Lifecycle-Policy)
     *
     *     Make a request to read a statement.
     */
    get: operations["getSqlv1Statement"];
    /**
     * Update a Statement
     * @description [![General Availability](https://img.shields.io/badge/Lifecycle%20Stage-General%20Availability-%2345c6e8)](#section/Versioning/API-Lifecycle-Policy)
     *
     *     Make a request to update a statement.
     *     The request will fail with a 409 Conflict error if the Statement has changed since it was fetched.
     *     In this case, do a GET, reapply the modifications, and try the update again.
     */
    put: operations["updateSqlv1Statement"];
    post?: never;
    /**
     * Delete a Statement
     * @description [![General Availability](https://img.shields.io/badge/Lifecycle%20Stage-General%20Availability-%2345c6e8)](#section/Versioning/API-Lifecycle-Policy)
     *
     *     Make a request to delete a statement.
     */
    delete: operations["deleteSqlv1Statement"];
    options?: never;
    head?: never;
    /**
     * Patch a Statement
     * @description [![Early Access](https://img.shields.io/badge/Lifecycle%20Stage-Early%20Access-%2345c6e8)](#section/Versioning/API-Lifecycle-Policy)
     *
     *     Make a request to patch a statement.
     */
    patch: operations["patchSqlv1Statement"];
    trace?: never;
  };
  "/sql/v1/organizations/{organization_id}/environments/{environment_id}/statements/{statement_name}/exceptions": {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /**
     * List of Statement Exceptions
     * @description [![General Availability](https://img.shields.io/badge/Lifecycle%20Stage-General%20Availability-%2345c6e8)](#section/Versioning/API-Lifecycle-Policy)
     *
     *     Retrieve a list of the 10 most recent statement exceptions.
     */
    get: operations["getSqlv1StatementExceptions"];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  "/networking/v1/dns-forwarders": {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /**
     * List of DNS Forwarders
     * @description [![General Availability](https://img.shields.io/badge/Lifecycle%20Stage-General%20Availability-%2345c6e8)](#section/Versioning/API-Lifecycle-Policy)
     *
     *     Retrieve a sorted, filtered, paginated list of all DNS forwarders.
     */
    get: operations["listNetworkingV1DnsForwarders"];
    put?: never;
    /**
     * Create a DNS Forwarder
     * @description [![General Availability](https://img.shields.io/badge/Lifecycle%20Stage-General%20Availability-%2345c6e8)](#section/Versioning/API-Lifecycle-Policy)
     *
     *     Make a request to create a DNS forwarder.
     */
    post: operations["createNetworkingV1DnsForwarder"];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  "/networking/v1/dns-forwarders/{id}": {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /**
     * Read a DNS Forwarder
     * @description [![General Availability](https://img.shields.io/badge/Lifecycle%20Stage-General%20Availability-%2345c6e8)](#section/Versioning/API-Lifecycle-Policy)
     *
     *     Make a request to read a DNS forwarder.
     */
    get: operations["getNetworkingV1DnsForwarder"];
    put?: never;
    post?: never;
    /**
     * Delete a DNS Forwarder
     * @description [![General Availability](https://img.shields.io/badge/Lifecycle%20Stage-General%20Availability-%2345c6e8)](#section/Versioning/API-Lifecycle-Policy)
     *
     *     Make a request to delete a DNS forwarder.
     */
    delete: operations["deleteNetworkingV1DnsForwarder"];
    options?: never;
    head?: never;
    /**
     * Update a DNS Forwarder
     * @description [![General Availability](https://img.shields.io/badge/Lifecycle%20Stage-General%20Availability-%2345c6e8)](#section/Versioning/API-Lifecycle-Policy)
     *
     *     Make a request to update a DNS forwarder.
     *
     *
     */
    patch: operations["updateNetworkingV1DnsForwarder"];
    trace?: never;
  };
  "/networking/v1/access-points": {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /**
     * List of Access Points
     * @description [![General Availability](https://img.shields.io/badge/Lifecycle%20Stage-General%20Availability-%2345c6e8)](#section/Versioning/API-Lifecycle-Policy)
     *
     *     Retrieve a sorted, filtered, paginated list of all access points.
     */
    get: operations["listNetworkingV1AccessPoints"];
    put?: never;
    /**
     * Create an Access Point
     * @description [![General Availability](https://img.shields.io/badge/Lifecycle%20Stage-General%20Availability-%2345c6e8)](#section/Versioning/API-Lifecycle-Policy)
     *
     *     Make a request to create an access point.
     */
    post: operations["createNetworkingV1AccessPoint"];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  "/networking/v1/access-points/{id}": {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /**
     * Read an Access Point
     * @description [![General Availability](https://img.shields.io/badge/Lifecycle%20Stage-General%20Availability-%2345c6e8)](#section/Versioning/API-Lifecycle-Policy)
     *
     *     Make a request to read an access point.
     */
    get: operations["getNetworkingV1AccessPoint"];
    put?: never;
    post?: never;
    /**
     * Delete an Access Point
     * @description [![General Availability](https://img.shields.io/badge/Lifecycle%20Stage-General%20Availability-%2345c6e8)](#section/Versioning/API-Lifecycle-Policy)
     *
     *     Make a request to delete an access point.
     */
    delete: operations["deleteNetworkingV1AccessPoint"];
    options?: never;
    head?: never;
    /**
     * Update an Access Point
     * @description [![General Availability](https://img.shields.io/badge/Lifecycle%20Stage-General%20Availability-%2345c6e8)](#section/Versioning/API-Lifecycle-Policy)
     *
     *     Make a request to update an access point.
     *
     *
     */
    patch: operations["updateNetworkingV1AccessPoint"];
    trace?: never;
  };
  "/networking/v1/dns-records": {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /**
     * List of DNS Records
     * @description [![General Availability](https://img.shields.io/badge/Lifecycle%20Stage-General%20Availability-%2345c6e8)](#section/Versioning/API-Lifecycle-Policy)
     *
     *     Retrieve a sorted, filtered, paginated list of all DNS records.
     */
    get: operations["listNetworkingV1DnsRecords"];
    put?: never;
    /**
     * Create a DNS Record
     * @description [![General Availability](https://img.shields.io/badge/Lifecycle%20Stage-General%20Availability-%2345c6e8)](#section/Versioning/API-Lifecycle-Policy)
     *
     *     Make a request to create a DNS record.
     */
    post: operations["createNetworkingV1DnsRecord"];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  "/networking/v1/dns-records/{id}": {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /**
     * Read a DNS Record
     * @description [![General Availability](https://img.shields.io/badge/Lifecycle%20Stage-General%20Availability-%2345c6e8)](#section/Versioning/API-Lifecycle-Policy)
     *
     *     Make a request to read a DNS record.
     */
    get: operations["getNetworkingV1DnsRecord"];
    put?: never;
    post?: never;
    /**
     * Delete a DNS Record
     * @description [![General Availability](https://img.shields.io/badge/Lifecycle%20Stage-General%20Availability-%2345c6e8)](#section/Versioning/API-Lifecycle-Policy)
     *
     *     Make a request to delete a DNS record.
     */
    delete: operations["deleteNetworkingV1DnsRecord"];
    options?: never;
    head?: never;
    /**
     * Update a DNS Record
     * @description [![General Availability](https://img.shields.io/badge/Lifecycle%20Stage-General%20Availability-%2345c6e8)](#section/Versioning/API-Lifecycle-Policy)
     *
     *     Make a request to update a DNS record.
     *
     *
     */
    patch: operations["updateNetworkingV1DnsRecord"];
    trace?: never;
  };
  "/iam/v2/certificate-authorities": {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /**
     * List of Certificate Authorities
     * @description [![General Availability](https://img.shields.io/badge/Lifecycle%20Stage-General%20Availability-%2345c6e8)](#section/Versioning/API-Lifecycle-Policy)
     *
     *     Retrieve a sorted, filtered, paginated list of all certificate authorities.
     */
    get: operations["listIamV2CertificateAuthorities"];
    put?: never;
    /**
     * Create a Certificate Authority
     * @description [![General Availability](https://img.shields.io/badge/Lifecycle%20Stage-General%20Availability-%2345c6e8)](#section/Versioning/API-Lifecycle-Policy)
     *
     *     Make a request to create a certificate authority.
     */
    post: operations["createIamV2CertificateAuthority"];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  "/iam/v2/certificate-authorities/{id}": {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /**
     * Read a Certificate Authority
     * @description [![General Availability](https://img.shields.io/badge/Lifecycle%20Stage-General%20Availability-%2345c6e8)](#section/Versioning/API-Lifecycle-Policy)
     *
     *     Make a request to read a certificate authority.
     */
    get: operations["getIamV2CertificateAuthority"];
    /**
     * Update a Certificate Authority
     * @description [![General Availability](https://img.shields.io/badge/Lifecycle%20Stage-General%20Availability-%2345c6e8)](#section/Versioning/API-Lifecycle-Policy)
     *
     *     Make a request to update a certificate authority.
     *
     *
     */
    put: operations["updateIamV2CertificateAuthority"];
    post?: never;
    /**
     * Delete a Certificate Authority
     * @description [![General Availability](https://img.shields.io/badge/Lifecycle%20Stage-General%20Availability-%2345c6e8)](#section/Versioning/API-Lifecycle-Policy)
     *
     *     Make a request to delete a certificate authority.
     */
    delete: operations["deleteIamV2CertificateAuthority"];
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  "/iam/v2/certificate-authorities/{certificate_authority_id}/identity-pools": {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /**
     * List of Certificate Identity Pools
     * @description [![General Availability](https://img.shields.io/badge/Lifecycle%20Stage-General%20Availability-%2345c6e8)](#section/Versioning/API-Lifecycle-Policy)
     *
     *     Retrieve a sorted, filtered, paginated list of all certificate identity pools.
     */
    get: operations["listIamV2CertificateIdentityPools"];
    put?: never;
    /**
     * Create a Certificate Identity Pool
     * @description [![General Availability](https://img.shields.io/badge/Lifecycle%20Stage-General%20Availability-%2345c6e8)](#section/Versioning/API-Lifecycle-Policy)
     *
     *     Make a request to create a certificate identity pool.
     */
    post: operations["createIamV2CertificateIdentityPool"];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  "/iam/v2/certificate-authorities/{certificate_authority_id}/identity-pools/{id}": {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /**
     * Read a Certificate Identity Pool
     * @description [![General Availability](https://img.shields.io/badge/Lifecycle%20Stage-General%20Availability-%2345c6e8)](#section/Versioning/API-Lifecycle-Policy)
     *
     *     Make a request to read a certificate identity pool.
     */
    get: operations["getIamV2CertificateIdentityPool"];
    /**
     * Update a Certificate Identity Pool
     * @description [![General Availability](https://img.shields.io/badge/Lifecycle%20Stage-General%20Availability-%2345c6e8)](#section/Versioning/API-Lifecycle-Policy)
     *
     *     Make a request to update a certificate identity pool.
     *
     *
     */
    put: operations["updateIamV2CertificateIdentityPool"];
    post?: never;
    /**
     * Delete a Certificate Identity Pool
     * @description [![General Availability](https://img.shields.io/badge/Lifecycle%20Stage-General%20Availability-%2345c6e8)](#section/Versioning/API-Lifecycle-Policy)
     *
     *     Make a request to delete a certificate identity pool.
     */
    delete: operations["deleteIamV2CertificateIdentityPool"];
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  "/pim/v1/integrations": {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /**
     * List of Integrations
     * @description [![General Availability](https://img.shields.io/badge/Lifecycle%20Stage-General%20Availability-%2345c6e8)](#section/Versioning/API-Lifecycle-Policy)
     *
     *     Retrieve a sorted, filtered, paginated list of all integrations.
     *
     *     If no `provider` filter is specified, returns provider integrations from all clouds.
     *
     */
    get: operations["listPimV1Integrations"];
    put?: never;
    /**
     * Create an Integration
     * @description [![General Availability](https://img.shields.io/badge/Lifecycle%20Stage-General%20Availability-%2345c6e8)](#section/Versioning/API-Lifecycle-Policy)
     *
     *     Make a request to create an integration.
     */
    post: operations["createPimV1Integration"];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  "/pim/v1/integrations/{id}": {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /**
     * Read an Integration
     * @description [![General Availability](https://img.shields.io/badge/Lifecycle%20Stage-General%20Availability-%2345c6e8)](#section/Versioning/API-Lifecycle-Policy)
     *
     *     Make a request to read an integration.
     */
    get: operations["getPimV1Integration"];
    put?: never;
    post?: never;
    /**
     * Delete an Integration
     * @description [![General Availability](https://img.shields.io/badge/Lifecycle%20Stage-General%20Availability-%2345c6e8)](#section/Versioning/API-Lifecycle-Policy)
     *
     *     Make a request to delete an integration.
     *
     *     This request fails if existing workloads are using this CSP integration.
     *
     */
    delete: operations["deletePimV1Integration"];
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  "/artifact/v1/flink-artifacts": {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /**
     * List of Flink Artifacts
     * @description [![General Availability](https://img.shields.io/badge/Lifecycle%20Stage-General%20Availability-%2345c6e8)](#section/Versioning/API-Lifecycle-Policy)
     *
     *     Retrieve a sorted, filtered, paginated list of all flink artifacts.
     */
    get: operations["listArtifactV1FlinkArtifacts"];
    put?: never;
    /**
     * Create a new Flink Artifact.
     * @description [![General Availability](https://img.shields.io/badge/Lifecycle%20Stage-General%20Availability-%2345c6e8)](#section/Versioning/API-Lifecycle-Policy)
     *
     *     Make a request to create a flink artifact.
     */
    post: operations["createArtifactV1FlinkArtifact"];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  "/artifact/v1/flink-artifacts/{id}": {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /**
     * Read a Flink Artifact
     * @description [![General Availability](https://img.shields.io/badge/Lifecycle%20Stage-General%20Availability-%2345c6e8)](#section/Versioning/API-Lifecycle-Policy)
     *
     *     Make a request to read a flink artifact.
     */
    get: operations["getArtifactV1FlinkArtifact"];
    put?: never;
    post?: never;
    /**
     * Delete a Flink Artifact
     * @description [![General Availability](https://img.shields.io/badge/Lifecycle%20Stage-General%20Availability-%2345c6e8)](#section/Versioning/API-Lifecycle-Policy)
     *
     *     Make a request to delete a flink artifact.
     */
    delete: operations["deleteArtifactV1FlinkArtifact"];
    options?: never;
    head?: never;
    /**
     * Update a Flink Artifact
     * @description [![General Availability](https://img.shields.io/badge/Lifecycle%20Stage-General%20Availability-%2345c6e8)](#section/Versioning/API-Lifecycle-Policy)
     *
     *     Make a request to update a flink artifact.
     *
     *
     */
    patch: operations["updateArtifactV1FlinkArtifact"];
    trace?: never;
  };
  "/artifact/v1/presigned-upload-url": {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Request a presigned upload URL for a new Flink Artifact.
     * @description [![General Availability](https://img.shields.io/badge/Lifecycle%20Stage-General%20Availability-%2345c6e8)](#section/Versioning/API-Lifecycle-Policy)
     *
     *     Request a presigned upload URL to upload a Flink Artifact archive.
     */
    post: operations["presigned-upload-urlArtifactV1PresignedUrl"];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  "/networking/v1/gateways": {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /**
     * List of Gateways
     * @description [![General Availability](https://img.shields.io/badge/Lifecycle%20Stage-General%20Availability-%2345c6e8)](#section/Versioning/API-Lifecycle-Policy)
     *
     *     Retrieve a sorted, filtered, paginated list of all gateways.
     */
    get: operations["listNetworkingV1Gateways"];
    put?: never;
    /**
     * Create a Gateway
     * @description [![General Availability](https://img.shields.io/badge/Lifecycle%20Stage-General%20Availability-%2345c6e8)](#section/Versioning/API-Lifecycle-Policy)
     *
     *     Make a request to create a gateway.
     */
    post: operations["createNetworkingV1Gateway"];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  "/networking/v1/gateways/{id}": {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /**
     * Read a Gateway
     * @description [![General Availability](https://img.shields.io/badge/Lifecycle%20Stage-General%20Availability-%2345c6e8)](#section/Versioning/API-Lifecycle-Policy)
     *
     *     Make a request to read a gateway.
     */
    get: operations["getNetworkingV1Gateway"];
    put?: never;
    post?: never;
    /**
     * Delete a Gateway
     * @description [![General Availability](https://img.shields.io/badge/Lifecycle%20Stage-General%20Availability-%2345c6e8)](#section/Versioning/API-Lifecycle-Policy)
     *
     *     Make a request to delete a gateway.
     */
    delete: operations["deleteNetworkingV1Gateway"];
    options?: never;
    head?: never;
    /**
     * Update a Gateway
     * @description [![General Availability](https://img.shields.io/badge/Lifecycle%20Stage-General%20Availability-%2345c6e8)](#section/Versioning/API-Lifecycle-Policy)
     *
     *     Make a request to update a gateway.
     *
     *
     */
    patch: operations["updateNetworkingV1Gateway"];
    trace?: never;
  };
  "/ccl/v1/custom-code-loggings": {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /**
     * List of Custom Code Loggings
     * @description [![Early Access](https://img.shields.io/badge/Lifecycle%20Stage-Early%20Access-%2345c6e8)](#section/Versioning/API-Lifecycle-Policy) [![Request Access To Custom Code Logging API EA](https://img.shields.io/badge/-Request%20Access%20To%20Custom%20Code%20Logging%20API%20EA-%23bc8540)](mailto:ccloud-api-access+ccl-v1-early-access@confluent.io?subject=Request%20to%20join%20ccl/v1%20API%20Early%20Access&body=I%E2%80%99d%20like%20to%20join%20the%20Confluent%20Cloud%20API%20Early%20Access%20for%20ccl/v1%20to%20provide%20early%20feedback%21%20My%20Cloud%20Organization%20ID%20is%20%3Cretrieve%20from%20https%3A//confluent.cloud/settings/billing/payment%3E.)
     *
     *     Retrieve a sorted, filtered, paginated list of all custom code loggings.
     */
    get: operations["listCclV1CustomCodeLoggings"];
    put?: never;
    /**
     * Create a Custom Code Logging
     * @description [![Early Access](https://img.shields.io/badge/Lifecycle%20Stage-Early%20Access-%2345c6e8)](#section/Versioning/API-Lifecycle-Policy) [![Request Access To Custom Code Logging API EA](https://img.shields.io/badge/-Request%20Access%20To%20Custom%20Code%20Logging%20API%20EA-%23bc8540)](mailto:ccloud-api-access+ccl-v1-early-access@confluent.io?subject=Request%20to%20join%20ccl/v1%20API%20Early%20Access&body=I%E2%80%99d%20like%20to%20join%20the%20Confluent%20Cloud%20API%20Early%20Access%20for%20ccl/v1%20to%20provide%20early%20feedback%21%20My%20Cloud%20Organization%20ID%20is%20%3Cretrieve%20from%20https%3A//confluent.cloud/settings/billing/payment%3E.)
     *
     *     Make a request to create a custom code logging.
     */
    post: operations["createCclV1CustomCodeLogging"];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  "/ccl/v1/custom-code-loggings/{id}": {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /**
     * Read a Custom Code Logging
     * @description [![Early Access](https://img.shields.io/badge/Lifecycle%20Stage-Early%20Access-%2345c6e8)](#section/Versioning/API-Lifecycle-Policy) [![Request Access To Custom Code Logging API EA](https://img.shields.io/badge/-Request%20Access%20To%20Custom%20Code%20Logging%20API%20EA-%23bc8540)](mailto:ccloud-api-access+ccl-v1-early-access@confluent.io?subject=Request%20to%20join%20ccl/v1%20API%20Early%20Access&body=I%E2%80%99d%20like%20to%20join%20the%20Confluent%20Cloud%20API%20Early%20Access%20for%20ccl/v1%20to%20provide%20early%20feedback%21%20My%20Cloud%20Organization%20ID%20is%20%3Cretrieve%20from%20https%3A//confluent.cloud/settings/billing/payment%3E.)
     *
     *     Make a request to read a custom code logging.
     */
    get: operations["getCclV1CustomCodeLogging"];
    put?: never;
    post?: never;
    /**
     * Delete a Custom Code Logging
     * @description [![Early Access](https://img.shields.io/badge/Lifecycle%20Stage-Early%20Access-%2345c6e8)](#section/Versioning/API-Lifecycle-Policy) [![Request Access To Custom Code Logging API EA](https://img.shields.io/badge/-Request%20Access%20To%20Custom%20Code%20Logging%20API%20EA-%23bc8540)](mailto:ccloud-api-access+ccl-v1-early-access@confluent.io?subject=Request%20to%20join%20ccl/v1%20API%20Early%20Access&body=I%E2%80%99d%20like%20to%20join%20the%20Confluent%20Cloud%20API%20Early%20Access%20for%20ccl/v1%20to%20provide%20early%20feedback%21%20My%20Cloud%20Organization%20ID%20is%20%3Cretrieve%20from%20https%3A//confluent.cloud/settings/billing/payment%3E.)
     *
     *     Make a request to delete a custom code logging.
     */
    delete: operations["deleteCclV1CustomCodeLogging"];
    options?: never;
    head?: never;
    /**
     * Update a Custom Code Logging
     * @description [![Early Access](https://img.shields.io/badge/Lifecycle%20Stage-Early%20Access-%2345c6e8)](#section/Versioning/API-Lifecycle-Policy) [![Request Access To Custom Code Logging API EA](https://img.shields.io/badge/-Request%20Access%20To%20Custom%20Code%20Logging%20API%20EA-%23bc8540)](mailto:ccloud-api-access+ccl-v1-early-access@confluent.io?subject=Request%20to%20join%20ccl/v1%20API%20Early%20Access&body=I%E2%80%99d%20like%20to%20join%20the%20Confluent%20Cloud%20API%20Early%20Access%20for%20ccl/v1%20to%20provide%20early%20feedback%21%20My%20Cloud%20Organization%20ID%20is%20%3Cretrieve%20from%20https%3A//confluent.cloud/settings/billing/payment%3E.)
     *
     *     Make a request to update a custom code logging.
     *
     *
     */
    patch: operations["updateCclV1CustomCodeLogging"];
    trace?: never;
  };
  "/tableflow/v1/regions": {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /**
     * List of Regions
     * @description [![General Availability](https://img.shields.io/badge/Lifecycle%20Stage-General%20Availability-%2345c6e8)](#section/Versioning/API-Lifecycle-Policy)
     *
     *     Retrieve a sorted, filtered, paginated list of all regions.
     */
    get: operations["listTableflowV1Regions"];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  "/tableflow/v1/tableflow-topics": {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /**
     * List of Tableflow Topics
     * @description [![General Availability](https://img.shields.io/badge/Lifecycle%20Stage-General%20Availability-%2345c6e8)](#section/Versioning/API-Lifecycle-Policy)
     *
     *     Retrieve a sorted, filtered, paginated list of all tableflow topics.
     */
    get: operations["listTableflowV1TableflowTopics"];
    put?: never;
    /**
     * Create a Tableflow Topic
     * @description [![General Availability](https://img.shields.io/badge/Lifecycle%20Stage-General%20Availability-%2345c6e8)](#section/Versioning/API-Lifecycle-Policy)
     *
     *     Make a request to create a tableflow topic.
     */
    post: operations["createTableflowV1TableflowTopic"];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  "/tableflow/v1/tableflow-topics/{display_name}": {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /**
     * Read a Tableflow Topic
     * @description [![General Availability](https://img.shields.io/badge/Lifecycle%20Stage-General%20Availability-%2345c6e8)](#section/Versioning/API-Lifecycle-Policy)
     *
     *     Make a request to read a tableflow topic.
     */
    get: operations["getTableflowV1TableflowTopic"];
    put?: never;
    post?: never;
    /**
     * Delete a Tableflow Topic
     * @description [![General Availability](https://img.shields.io/badge/Lifecycle%20Stage-General%20Availability-%2345c6e8)](#section/Versioning/API-Lifecycle-Policy)
     *
     *     Make a request to delete a tableflow topic.
     */
    delete: operations["deleteTableflowV1TableflowTopic"];
    options?: never;
    head?: never;
    /**
     * Update a Tableflow Topic
     * @description [![General Availability](https://img.shields.io/badge/Lifecycle%20Stage-General%20Availability-%2345c6e8)](#section/Versioning/API-Lifecycle-Policy)
     *
     *     Make a request to update a tableflow topic.
     *
     *
     */
    patch: operations["updateTableflowV1TableflowTopic"];
    trace?: never;
  };
  "/tableflow/v1/catalog-integrations": {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /**
     * List of Catalog Integrations
     * @description [![General Availability](https://img.shields.io/badge/Lifecycle%20Stage-General%20Availability-%2345c6e8)](#section/Versioning/API-Lifecycle-Policy)
     *
     *     Retrieve a sorted, filtered, paginated list of all catalog integrations.
     */
    get: operations["listTableflowV1CatalogIntegrations"];
    put?: never;
    /**
     * Create a Catalog Integration
     * @description [![General Availability](https://img.shields.io/badge/Lifecycle%20Stage-General%20Availability-%2345c6e8)](#section/Versioning/API-Lifecycle-Policy)
     *
     *     Make a request to create a catalog integration.
     */
    post: operations["createTableflowV1CatalogIntegration"];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  "/tableflow/v1/catalog-integrations/{id}": {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /**
     * Read a Catalog Integration
     * @description [![General Availability](https://img.shields.io/badge/Lifecycle%20Stage-General%20Availability-%2345c6e8)](#section/Versioning/API-Lifecycle-Policy)
     *
     *     Make a request to read a catalog integration.
     */
    get: operations["getTableflowV1CatalogIntegration"];
    put?: never;
    post?: never;
    /**
     * Delete a Catalog Integration
     * @description [![General Availability](https://img.shields.io/badge/Lifecycle%20Stage-General%20Availability-%2345c6e8)](#section/Versioning/API-Lifecycle-Policy)
     *
     *     Make a request to delete a catalog integration.
     */
    delete: operations["deleteTableflowV1CatalogIntegration"];
    options?: never;
    head?: never;
    /**
     * Update a Catalog Integration
     * @description [![General Availability](https://img.shields.io/badge/Lifecycle%20Stage-General%20Availability-%2345c6e8)](#section/Versioning/API-Lifecycle-Policy)
     *
     *     Make a request to update a catalog integration.
     *
     *
     */
    patch: operations["updateTableflowV1CatalogIntegration"];
    trace?: never;
  };
}
export type webhooks = Record<string, never>;
export interface components {
  schemas: {
    /** @description `ApiKey` objects represent access to different parts of Confluent Cloud. Some types
     *     of API keys represent access to a single cluster/resource such as a Kafka cluster,
     *     Schema Registry cluster or a ksqlDB cluster. Cloud API Keys represent access to resources within an organization
     *     that are not tied to a specific cluster, such as the Org API, IAM API, Metrics API or Connect API.
     *     Tableflow API keys are not tied to a specific cluster.
     *
     *     The API allows you to list, create, update and delete your API Keys.
     *
     *
     *     Related guide: [API Keys in Confluent Cloud](https://docs.confluent.io/cloud/current/client-apps/api-keys.html).
     *
     *     ## The API Keys Model
     *     <SchemaDefinition schemaRef="#/components/schemas/iam.v2.ApiKey" />
     *
     *     ## Quotas and Limits
     *     This resource is subject to the [following quotas](https://docs.confluent.io/cloud/current/quotas/overview.html):
     *
     *     | Quota | Description |
     *     | --- | --- |
     *     | `apikeys_per_org` | API Keys in one Confluent Cloud organization | */
    "iam.v2.ApiKey": {
      /**
       * @description APIVersion defines the schema version of this representation of a resource.
       * @enum {string}
       */
      readonly api_version?: "iam/v2";
      /**
       * @description Kind defines the object this REST resource represents.
       * @enum {string}
       */
      readonly kind?: "ApiKey";
      /**
       * @description ID is the "natural identifier" for an object within its scope/namespace; it is normally unique across time but not space. That is, you can assume that the ID will not be reclaimed and reused after an object is deleted ("time"); however, it may collide with IDs for other object `kinds` or objects of the same `kind` within a different scope/namespace ("space").
       * @example dlz-f3a90de
       */
      readonly id?: string;
      metadata?: components["schemas"]["ObjectMeta"] & {
        /** @example https://api.confluent.cloud/iam/v2/api-keys/ak-12345 */
        self?: unknown;
        /** @example crn://confluent.cloud/organization=9bb441c4-edef-46ac-8a41-c49e44a3fd9a/api-key=ak-12345 */
        resource_name?: unknown;
      };
      spec?: components["schemas"]["iam.v2.ApiKeySpec"];
    };
    /** @description Filter a collection by a string search */
    SearchFilter: string;
    /** @description `ApiKey` objects represent access to different parts of Confluent Cloud. Some types
     *     of API keys represent access to a single cluster/resource such as a Kafka cluster,
     *     Schema Registry cluster or a ksqlDB cluster. Cloud API Keys represent access to resources within an organization
     *     that are not tied to a specific cluster, such as the Org API, IAM API, Metrics API or Connect API.
     *     Tableflow API keys are not tied to a specific cluster.
     *
     *     The API allows you to list, create, update and delete your API Keys.
     *
     *
     *     Related guide: [API Keys in Confluent Cloud](https://docs.confluent.io/cloud/current/client-apps/api-keys.html).
     *
     *     ## The API Keys Model
     *     <SchemaDefinition schemaRef="#/components/schemas/iam.v2.ApiKey" />
     *
     *     ## Quotas and Limits
     *     This resource is subject to the [following quotas](https://docs.confluent.io/cloud/current/quotas/overview.html):
     *
     *     | Quota | Description |
     *     | --- | --- |
     *     | `apikeys_per_org` | API Keys in one Confluent Cloud organization | */
    "iam.v2.ApiKeyList": {
      /**
       * @description APIVersion defines the schema version of this representation of a resource.
       * @enum {string}
       */
      readonly api_version: "iam/v2";
      /**
       * @description Kind defines the object this REST resource represents.
       * @enum {string}
       */
      readonly kind: "ApiKeyList";
      metadata: components["schemas"]["ListMeta"] & {
        /** @example https://api.confluent.cloud/iam/v2/api-keys */
        first?: unknown;
        /** @example https://api.confluent.cloud/iam/v2/api-keys?page_token=bcAOehAY8F16YD84Z1wT */
        last?: unknown;
        /** @example https://api.confluent.cloud/iam/v2/api-keys?page_token=YIXRY97wWYmwzrax4dld */
        prev?: unknown;
        /** @example https://api.confluent.cloud/iam/v2/api-keys?page_token=UvmDWOB1iwfAIBPj6EYb */
        next?: unknown;
      };
      /** @description A data property that contains an array of resource items. Each entry in the array is a separate resource. */
      data: (components["schemas"]["iam.v2.ApiKey"] & {
        spec: Record<string, unknown>;
      })[];
    };
    /** @description The desired state of the Api Key */
    "iam.v2.ApiKeySpec": {
      /**
       * @description The API key secret. Only provided in `create` responses, not in `get` or `list`.
       * @example R15hoiDIq8Nxu/lY4mPO3DwAVIfU5W7OI+efsB607mLgHTnVW5XJGVqX2ysDx987
       */
      readonly secret?: string;
      /**
       * @description A human readable name for the API key
       * @example CI kafka access key
       */
      display_name?: string;
      /**
       * @description A human readable description for the API key
       * @example This API key provides kafka access to cluster x
       */
      description?: string;
      /** @description The owner to which this belongs. The owner can be one of iam.v2.User, iam.v2.ServiceAccount. */
      owner?: components["schemas"]["TypedGlobalObjectReference"];
      /** @description The resource associated with this object. The resource can be one of Kafka Cluster ID (example: lkc-12345),
       *     Schema Registry Cluster ID (example: lsrc-12345), ksqlDB Cluster ID (example: lksqlc-12345), or Flink
       *     (Environment + Region pair, example: env-abc123.aws.us-east-2).
       *     May be null or omitted if not associated with a resource. For creating Cloud API key, resource should be `CLOUD`,
       *     for creating Tableflow API key, resource should be `TABLEFLOW`. The resource id is case-insensitive.
       *     [Learn more in Authentication](https://docs.confluent.io/cloud/current/api.html#section/Authentication).
       *
       *     Note - Flink is in the [Preview lifecycle stage](https://docs.confluent.io/cloud/current/api.html#section/Versioning/API-Lifecycle-Policy)
       *      */
      resource?: components["schemas"]["TypedEnvScopedObjectReference"] | null;
    };
    /** @description ObjectMeta is metadata that all persisted resources must have, which includes all objects users must create. */
    ObjectMeta: {
      /**
       * Format: uri
       * @description Self is a Uniform Resource Locator (URL) at which an object can be addressed. This URL encodes the service location, API version, and other particulars necessary to locate the resource at a point in time
       * @example https://api.confluent.cloud/v2/kafka-clusters/lkc-f3a90de
       */
      readonly self: string;
      /**
       * Format: uri
       * @description Resource Name is a Uniform Resource Identifier (URI) that is globally unique across space and time. It is represented as a Confluent Resource Name
       * @example crn://confluent.cloud/kafka=lkc-f3a90de
       */
      readonly resource_name?: string;
      /**
       * Format: date-time
       * @description The date and time at which this object was created. It is represented in RFC3339 format and is in UTC.
       * @example 2006-01-02T15:04:05-07:00
       */
      readonly created_at?: string;
      /**
       * Format: date-time
       * @description The date and time at which this object was last updated. It is represented in RFC3339 format and is in UTC.
       * @example 2006-01-02T15:04:05-07:00
       */
      readonly updated_at?: string;
      /**
       * Format: date-time
       * @description The date and time at which this object was (or will be) deleted. It is represented in RFC3339 format and is in UTC.
       * @example 2006-01-02T15:04:05-07:00
       */
      readonly deleted_at?: string;
    };
    /** @description ListMeta describes metadata that resource collections may have */
    ListMeta: {
      /**
       * Format: uri
       * @description A link to the first page of results. If a response does not contain a first link, then direct navigation to the first page is not supported.
       * @example https://api.confluent.cloud/v2/resourcekinds
       */
      first?: string | null;
      /**
       * Format: uri
       * @description A link to the last page of results. If a response does not contain a last link, then direct navigation to the last page is not supported.
       * @example https://api.confluent.cloud/v2/resourcekinds?page_token=bcAOehAY8F16YD84Z1wT
       */
      last?: string | null;
      /**
       * Format: uri
       * @description A link to the previous page of results. If a response does not contain a prev link, then either there is no previous data or backwards traversal through the result set is not supported.
       * @example https://api.confluent.cloud/v2/resourcekinds?page_token=YIXRY97wWYmwzrax4dld
       */
      prev?: string | null;
      /**
       * Format: uri
       * @description A link to the next page of results. If a response does not contain a next link, then there is no more data available.
       * @example https://api.confluent.cloud/v2/resourcekinds?page_token=UvmDWOB1iwfAIBPj6EYb
       */
      next?: string | null;
      /**
       * Format: int32
       * @description Number of records in the full result set. This response may be paginated and have a smaller number of records.
       * @example 123
       */
      total_size?: number;
    };
    /** @description ObjectReference provides information for you to locate the referred object */
    ObjectReference: {
      /** @description ID of the referred resource */
      id: string;
      /** @description Environment of the referred resource, if env-scoped */
      environment?: string;
      /**
       * Format: uri
       * @description API URL for accessing or modifying the referred object
       */
      readonly related: string;
      /**
       * Format: uri
       * @description CRN reference to the referred resource
       */
      readonly resource_name: string;
      /** @description API group and version of the referred resource */
      readonly api_version?: string;
      /** @description Kind of the referred resource */
      readonly kind?: string;
    };
    /** @description ObjectReference provides information for you to locate the referred object */
    TypedGlobalObjectReference: {
      /** @description ID of the referred resource */
      id: string;
      /**
       * Format: uri
       * @description API URL for accessing or modifying the referred object
       */
      readonly related: string;
      /**
       * Format: uri
       * @description CRN reference to the referred resource
       */
      readonly resource_name: string;
      /** @description API group and version of the referred resource */
      readonly api_version?: string;
      /** @description Kind of the referred resource */
      readonly kind?: string;
    };
    /** @description ObjectReference provides information for you to locate the referred object */
    TypedEnvScopedObjectReference: {
      /** @description ID of the referred resource */
      id: string;
      /** @description Environment of the referred resource, if env-scoped */
      environment?: string;
      /**
       * Format: uri
       * @description API URL for accessing or modifying the referred object
       */
      readonly related: string;
      /**
       * Format: uri
       * @description CRN reference to the referred resource
       */
      readonly resource_name: string;
      /** @description API group and version of the referred resource */
      readonly api_version?: string;
      /** @description Kind of the referred resource */
      readonly kind?: string;
    };
    /** @description Provides information about problems encountered while performing an operation. */
    Failure: {
      /** @description List of errors which caused this operation to fail */
      errors: components["schemas"]["Error"][];
    };
    /** @description Describes a particular error encountered while performing an operation. */
    Error: {
      /** @description A unique identifier for this particular occurrence of the problem. */
      id?: string;
      /** @description The HTTP status code applicable to this problem, expressed as a string value. */
      status?: string;
      /** @description An application-specific error code, expressed as a string value. */
      code?: string;
      /** @description A short, human-readable summary of the problem. It **SHOULD NOT** change from occurrence to occurrence of the problem, except for purposes of localization. */
      title?: string;
      /** @description A human-readable explanation specific to this occurrence of the problem. */
      detail?: string;
      /** @description If this error was caused by a particular part of the API request, the source will point to the query string parameter or request body property that caused it. */
      source?: {
        /** @description A JSON Pointer [RFC6901] to the associated entity in the request document [e.g. "/spec" for a spec object, or "/spec/title" for a specific field]. */
        pointer?: string;
        /** @description A string indicating which query parameter caused the error. */
        parameter?: string;
      };
      /** Format: int32 */
      error_code?: number;
      message?: string | null;
    };
    /** @description `Environment` objects represent an isolated namespace for your Confluent resources
     *     for organizational purposes.
     *
     *     The API allows you to create, delete, and update your environments. You can retrieve
     *     individual environments as well as a list of all your environments.
     *
     *
     *     Related guide: [Environments in Confluent Cloud](https://docs.confluent.io/cloud/current/access-management/environments.html).
     *
     *     ## The Environments Model
     *     <SchemaDefinition schemaRef="#/components/schemas/org.v2.Environment" />
     *
     *     ## Quotas and Limits
     *     This resource is subject to the [following quotas](https://docs.confluent.io/cloud/current/quotas/overview.html):
     *
     *     | Quota | Description |
     *     | --- | --- |
     *     | `environments_per_org` | Environments in one Confluent Cloud organization | */
    "org.v2.Environment": {
      /**
       * @description APIVersion defines the schema version of this representation of a resource.
       * @enum {string}
       */
      readonly api_version?: "org/v2";
      /**
       * @description Kind defines the object this REST resource represents.
       * @enum {string}
       */
      readonly kind?: "Environment";
      /**
       * @description ID is the "natural identifier" for an object within its scope/namespace; it is normally unique across time but not space. That is, you can assume that the ID will not be reclaimed and reused after an object is deleted ("time"); however, it may collide with IDs for other object `kinds` or objects of the same `kind` within a different scope/namespace ("space").
       * @example dlz-f3a90de
       */
      readonly id?: string;
      metadata?: components["schemas"]["ObjectMeta"] & {
        /** @example https://api.confluent.cloud/org/v2/environments/e-12345 */
        self?: unknown;
        /** @example crn://confluent.cloud/organization=9bb441c4-edef-46ac-8a41-c49e44a3fd9a/environment=e-12345 */
        resource_name?: unknown;
      };
      /**
       * @description A human-readable name for the Environment
       * @example prod-finance01
       */
      display_name?: string;
      /** @description Stream Governance configurations for the environment */
      stream_governance_config?: components["schemas"]["org.v2.StreamGovernanceConfig"];
    };
    /** @description `Organization` objects represent a customer organization. An organization contains all customer
     *     resources (e.g., Environments, Kafka Clusters, Service Accounts, API Keys) and is tied to a billing
     *     agreement (including any annual commitment or support plan).
     *
     *     The API allows you to list, view, and update your organizations.
     *
     *
     *     Related guide: [Organizations for Confluent Cloud](https://docs.confluent.io/cloud/current/access-management/hierarchy/organizations/cloud-organization.html).
     *
     *     ## The Organizations Model
     *     <SchemaDefinition schemaRef="#/components/schemas/org.v2.Organization" />
     *
     *     ## Quotas and Limits
     *     This resource is subject to the [following quotas](https://docs.confluent.io/cloud/current/quotas/overview.html):
     *
     *     | Quota | Description |
     *     | --- | --- |
     *     | `organizations_per_user` | Confluent Cloud organizations a user belongs to | */
    "org.v2.Organization": {
      /**
       * @description APIVersion defines the schema version of this representation of a resource.
       * @enum {string}
       */
      readonly api_version?: "org/v2";
      /**
       * @description Kind defines the object this REST resource represents.
       * @enum {string}
       */
      readonly kind?: "Organization";
      /**
       * @description ID is the "natural identifier" for an object within its scope/namespace; it is normally unique across time but not space. That is, you can assume that the ID will not be reclaimed and reused after an object is deleted ("time"); however, it may collide with IDs for other object `kinds` or objects of the same `kind` within a different scope/namespace ("space").
       * @example dlz-f3a90de
       */
      readonly id?: string;
      metadata?: components["schemas"]["ObjectMeta"] & {
        /** @example https://api.confluent.cloud/org/v2/organizations/o-12345 */
        self?: unknown;
        /** @example crn://confluent.cloud/organization=o-12345 */
        resource_name?: unknown;
      };
      /**
       * @description A human-readable name for the Organization
       * @example Finance Org
       */
      display_name?: string;
      /** @description The flag to toggle Just-In-Time user provisioning for SSO-enabled organization. Available for early access only. */
      jit_enabled?: boolean;
    };
    /** @description Configurations pertaining to Stream Governance
     *      */
    "org.v2.StreamGovernanceConfig": {
      /** @description Stream Governance Package. Supported values are ESSENTIALS and ADVANCED.
       *     Package comparison can be found
       *     [here](https://docs.confluent.io/cloud/current/stream-governance/packages.html#features-by-package-type).
       *      */
      package: string;
    };
    /** @description `Environment` objects represent an isolated namespace for your Confluent resources
     *     for organizational purposes.
     *
     *     The API allows you to create, delete, and update your environments. You can retrieve
     *     individual environments as well as a list of all your environments.
     *
     *
     *     Related guide: [Environments in Confluent Cloud](https://docs.confluent.io/cloud/current/access-management/environments.html).
     *
     *     ## The Environments Model
     *     <SchemaDefinition schemaRef="#/components/schemas/org.v2.Environment" />
     *
     *     ## Quotas and Limits
     *     This resource is subject to the [following quotas](https://docs.confluent.io/cloud/current/quotas/overview.html):
     *
     *     | Quota | Description |
     *     | --- | --- |
     *     | `environments_per_org` | Environments in one Confluent Cloud organization | */
    "org.v2.EnvironmentList": {
      /**
       * @description APIVersion defines the schema version of this representation of a resource.
       * @enum {string}
       */
      readonly api_version: "org/v2";
      /**
       * @description Kind defines the object this REST resource represents.
       * @enum {string}
       */
      readonly kind: "EnvironmentList";
      metadata: components["schemas"]["ListMeta"] & {
        /** @example https://api.confluent.cloud/org/v2/environments */
        first?: unknown;
        /** @example https://api.confluent.cloud/org/v2/environments?page_token=bcAOehAY8F16YD84Z1wT */
        last?: unknown;
        /** @example https://api.confluent.cloud/org/v2/environments?page_token=YIXRY97wWYmwzrax4dld */
        prev?: unknown;
        /** @example https://api.confluent.cloud/org/v2/environments?page_token=UvmDWOB1iwfAIBPj6EYb */
        next?: unknown;
      };
      /** @description A data property that contains an array of resource items. Each entry in the array is a separate resource. */
      data: (components["schemas"]["org.v2.Environment"] &
        Record<string, unknown>)[];
    };
    /** @description `Organization` objects represent a customer organization. An organization contains all customer
     *     resources (e.g., Environments, Kafka Clusters, Service Accounts, API Keys) and is tied to a billing
     *     agreement (including any annual commitment or support plan).
     *
     *     The API allows you to list, view, and update your organizations.
     *
     *
     *     Related guide: [Organizations for Confluent Cloud](https://docs.confluent.io/cloud/current/access-management/hierarchy/organizations/cloud-organization.html).
     *
     *     ## The Organizations Model
     *     <SchemaDefinition schemaRef="#/components/schemas/org.v2.Organization" />
     *
     *     ## Quotas and Limits
     *     This resource is subject to the [following quotas](https://docs.confluent.io/cloud/current/quotas/overview.html):
     *
     *     | Quota | Description |
     *     | --- | --- |
     *     | `organizations_per_user` | Confluent Cloud organizations a user belongs to | */
    "org.v2.OrganizationList": {
      /**
       * @description APIVersion defines the schema version of this representation of a resource.
       * @enum {string}
       */
      readonly api_version: "org/v2";
      /**
       * @description Kind defines the object this REST resource represents.
       * @enum {string}
       */
      readonly kind: "OrganizationList";
      metadata: components["schemas"]["ListMeta"] & {
        /** @example https://api.confluent.cloud/org/v2/organizations */
        first?: unknown;
        /** @example https://api.confluent.cloud/org/v2/organizations?page_token=bcAOehAY8F16YD84Z1wT */
        last?: unknown;
        /** @example https://api.confluent.cloud/org/v2/organizations?page_token=YIXRY97wWYmwzrax4dld */
        prev?: unknown;
        /** @example https://api.confluent.cloud/org/v2/organizations?page_token=UvmDWOB1iwfAIBPj6EYb */
        next?: unknown;
      };
      /** @description A data property that contains an array of resource items. Each entry in the array is a separate resource. */
      data: (components["schemas"]["org.v2.Organization"] &
        Record<string, unknown>)[];
    };
    /** @description `User` objects represent individuals who may access your Confluent resources.
     *
     *     The API allows you to retrieve, update, and delete individual users, as well as list of all your
     *     users. This API cannot be used to create new user accounts.
     *
     *
     *     Related guide: [Users in Confluent Cloud](https://docs.confluent.io/cloud/current/access-management/user-account.html).
     *
     *     ## The Users Model
     *     <SchemaDefinition schemaRef="#/components/schemas/iam.v2.User" />
     *
     *     ## Quotas and Limits
     *     This resource is subject to the [following quotas](https://docs.confluent.io/cloud/current/quotas/overview.html):
     *
     *     | Quota | Description |
     *     | --- | --- |
     *     | `users_per_org` | Users in one Confluent Cloud organization | */
    "iam.v2.User": {
      /**
       * @description APIVersion defines the schema version of this representation of a resource.
       * @enum {string}
       */
      readonly api_version?: "iam/v2";
      /**
       * @description Kind defines the object this REST resource represents.
       * @enum {string}
       */
      readonly kind?: "User";
      /**
       * @description ID is the "natural identifier" for an object within its scope/namespace; it is normally unique across time but not space. That is, you can assume that the ID will not be reclaimed and reused after an object is deleted ("time"); however, it may collide with IDs for other object `kinds` or objects of the same `kind` within a different scope/namespace ("space").
       * @example dlz-f3a90de
       */
      readonly id?: string;
      metadata?: components["schemas"]["ObjectMeta"] & {
        /** @example https://api.confluent.cloud/iam/v2/users/u-12345 */
        self?: unknown;
        /** @example crn://confluent.cloud/user=u-12345 */
        resource_name?: unknown;
      };
      /**
       * Format: email
       * @description The user's email address
       * @example marty.mcfly@example.com
       */
      email?: string;
      /**
       * @description The user's full name
       * @example Marty McFly
       */
      full_name?: string;
      /**
       * @description The user's authentication method
       * @example AUTH_TYPE_SSO
       */
      readonly auth_type?: string;
    };
    /** @description `ServiceAccount` objects are typically used to represent applications and other non-human principals
     *     that may access your Confluent resources.
     *
     *     The API allows you to create, retrieve, update, and delete individual service accounts, as well as
     *     list all your service accounts.
     *
     *
     *     Related guide: [Service Accounts in Confluent Cloud](https://docs.confluent.io/cloud/current/access-management/service-account.html).
     *
     *     ## The Service Accounts Model
     *     <SchemaDefinition schemaRef="#/components/schemas/iam.v2.ServiceAccount" />
     *
     *     ## Quotas and Limits
     *     This resource is subject to the [following quotas](https://docs.confluent.io/cloud/current/quotas/overview.html):
     *
     *     | Quota | Description |
     *     | --- | --- |
     *     | `service_accounts_per_org` | Service Accounts in one Confluent Cloud organization | */
    "iam.v2.ServiceAccount": {
      /**
       * @description APIVersion defines the schema version of this representation of a resource.
       * @enum {string}
       */
      readonly api_version?: "iam/v2";
      /**
       * @description Kind defines the object this REST resource represents.
       * @enum {string}
       */
      readonly kind?: "ServiceAccount";
      /**
       * @description ID is the "natural identifier" for an object within its scope/namespace; it is normally unique across time but not space. That is, you can assume that the ID will not be reclaimed and reused after an object is deleted ("time"); however, it may collide with IDs for other object `kinds` or objects of the same `kind` within a different scope/namespace ("space").
       * @example dlz-f3a90de
       */
      readonly id?: string;
      metadata?: components["schemas"]["ObjectMeta"] & {
        /** @example https://api.confluent.cloud/iam/v2/service-accounts/sa-12345 */
        self?: unknown;
        /** @example crn://confluent.cloud/service-account=sa-12345 */
        resource_name?: unknown;
      };
      /**
       * @description A human-readable name for the Service Account
       * @example DeLorean_auto_repair
       */
      display_name?: string;
      /**
       * @description A free-form description of the Service Account
       * @example Doc's repair bot for the DeLorean
       */
      description?: string;
    };
    /** @description `Invitation` objects represent invitations to invite users to join your organizations in Confluent Cloud.
     *
     *     The API allows you to list all your invitations, as well as create, read, and delete a specified invitation.
     *
     *
     *     Related guide: [User invitations in Confluent Cloud](https://docs.confluent.io/cloud/current/access-management/identity/user-accounts.html).
     *
     *     ## The Invitations Model
     *     <SchemaDefinition schemaRef="#/components/schemas/iam.v2.Invitation" />
     *
     *     ## Quotas and Limits
     *     This resource is subject to the [following quotas](https://docs.confluent.io/cloud/current/quotas/overview.html):
     *
     *     | Quota | Description |
     *     | --- | --- |
     *     | `invitations_per_org` | Invitations in a Confluent Cloud organization | */
    "iam.v2.Invitation": {
      /**
       * @description APIVersion defines the schema version of this representation of a resource.
       * @enum {string}
       */
      readonly api_version?: "iam/v2";
      /**
       * @description Kind defines the object this REST resource represents.
       * @enum {string}
       */
      readonly kind?: "Invitation";
      /**
       * @description ID is the "natural identifier" for an object within its scope/namespace; it is normally unique across time but not space. That is, you can assume that the ID will not be reclaimed and reused after an object is deleted ("time"); however, it may collide with IDs for other object `kinds` or objects of the same `kind` within a different scope/namespace ("space").
       * @example dlz-f3a90de
       */
      readonly id?: string;
      metadata?: components["schemas"]["ObjectMeta"] & {
        /** @example https://api.confluent.cloud/iam/v2/invitations/i-12345 */
        self?: unknown;
        /** @example crn://confluent.cloud/organization=9bb441c4-edef-46ac-8a41-c49e44a3fd9a/invitation=i-12345 */
        resource_name?: unknown;
      };
      /**
       * Format: email
       * @description The user/invitee's email address
       * @example johndoe@confluent.io
       */
      email?: string;
      /**
       * @description The user/invitee's authentication type. Note that only the [OrganizationAdmin role](https://docs.confluent.io/cloud/current/access-management/access-control/cloud-rbac.html#organizationadmin)
       *     can invite AUTH_TYPE_LOCAL users to SSO organizations.
       *     The user's auth_type is set as AUTH_TYPE_SSO by default if the organization has SSO enabled.
       *     Otherwise, the user's auth_type is AUTH_TYPE_LOCAL by default.
       *
       * @example AUTH_TYPE_SSO
       */
      auth_type?: string;
      /**
       * @description The status of invitations
       * @example INVITE_STATUS_SENT
       */
      readonly status?: string;
      /**
       * Format: date-time
       * @description The timestamp that the invitation was accepted
       * @example 2022-07-06T17:21:33Z
       */
      readonly accepted_at?: string | null;
      /**
       * Format: date-time
       * @description The timestamp that the invitation will expire
       * @example 2022-07-07T17:22:39Z
       */
      readonly expires_at?: string;
      /** @description The user/invitee */
      readonly user?: components["schemas"]["GlobalObjectReference"];
      /** @description The invitation creator */
      readonly creator?: components["schemas"]["GlobalObjectReference"];
    };
    /** @description Configure user auth type */
    "iam.v2.User.ConfigureUserAuthRequest": {
      /**
       * @description APIVersion defines the schema version of this representation of a resource.
       * @enum {string}
       */
      readonly api_version?: "iam.v2/User";
      /**
       * @description Kind defines the object this REST resource represents.
       * @enum {string}
       */
      readonly kind?: "ConfigureUserAuthRequest";
      /**
       * @description ID is the "natural identifier" for an object within its scope/namespace; it is normally unique across time but not space. That is, you can assume that the ID will not be reclaimed and reused after an object is deleted ("time"); however, it may collide with IDs for other object `kinds` or objects of the same `kind` within a different scope/namespace ("space").
       * @example dlz-f3a90de
       */
      readonly id?: string;
      metadata?: components["schemas"]["ObjectMeta"] & {
        /** @example https://api.confluent.cloud/iam.v2/User/configure-user-auth-requests/cuar-12345 */
        self?: unknown;
        /** @example crn://confluent.cloud/organization=9bb441c4-edef-46ac-8a41-c49e44a3fd9a/configure-user-auth-request=cuar-12345 */
        resource_name?: unknown;
      };
      /**
       * @description The user's authentication method.
       * @example AUTH_TYPE_SSO
       */
      auth_type?: string;
    };
    /** @description Filter a collection by a string search for one or more values */
    MultipleSearchFilter: string[];
    /** @description `User` objects represent individuals who may access your Confluent resources.
     *
     *     The API allows you to retrieve, update, and delete individual users, as well as list of all your
     *     users. This API cannot be used to create new user accounts.
     *
     *
     *     Related guide: [Users in Confluent Cloud](https://docs.confluent.io/cloud/current/access-management/user-account.html).
     *
     *     ## The Users Model
     *     <SchemaDefinition schemaRef="#/components/schemas/iam.v2.User" />
     *
     *     ## Quotas and Limits
     *     This resource is subject to the [following quotas](https://docs.confluent.io/cloud/current/quotas/overview.html):
     *
     *     | Quota | Description |
     *     | --- | --- |
     *     | `users_per_org` | Users in one Confluent Cloud organization | */
    "iam.v2.UserList": {
      /**
       * @description APIVersion defines the schema version of this representation of a resource.
       * @enum {string}
       */
      readonly api_version: "iam/v2";
      /**
       * @description Kind defines the object this REST resource represents.
       * @enum {string}
       */
      readonly kind: "UserList";
      metadata: components["schemas"]["ListMeta"] & {
        /** @example https://api.confluent.cloud/iam/v2/users */
        first?: unknown;
        /** @example https://api.confluent.cloud/iam/v2/users?page_token=bcAOehAY8F16YD84Z1wT */
        last?: unknown;
        /** @example https://api.confluent.cloud/iam/v2/users?page_token=YIXRY97wWYmwzrax4dld */
        prev?: unknown;
        /** @example https://api.confluent.cloud/iam/v2/users?page_token=UvmDWOB1iwfAIBPj6EYb */
        next?: unknown;
      };
      /** @description A data property that contains an array of resource items. Each entry in the array is a separate resource. */
      data: (components["schemas"]["iam.v2.User"] & Record<string, unknown>)[];
    };
    /** @description `ServiceAccount` objects are typically used to represent applications and other non-human principals
     *     that may access your Confluent resources.
     *
     *     The API allows you to create, retrieve, update, and delete individual service accounts, as well as
     *     list all your service accounts.
     *
     *
     *     Related guide: [Service Accounts in Confluent Cloud](https://docs.confluent.io/cloud/current/access-management/service-account.html).
     *
     *     ## The Service Accounts Model
     *     <SchemaDefinition schemaRef="#/components/schemas/iam.v2.ServiceAccount" />
     *
     *     ## Quotas and Limits
     *     This resource is subject to the [following quotas](https://docs.confluent.io/cloud/current/quotas/overview.html):
     *
     *     | Quota | Description |
     *     | --- | --- |
     *     | `service_accounts_per_org` | Service Accounts in one Confluent Cloud organization | */
    "iam.v2.ServiceAccountList": {
      /**
       * @description APIVersion defines the schema version of this representation of a resource.
       * @enum {string}
       */
      readonly api_version: "iam/v2";
      /**
       * @description Kind defines the object this REST resource represents.
       * @enum {string}
       */
      readonly kind: "ServiceAccountList";
      metadata: components["schemas"]["ListMeta"] & {
        /** @example https://api.confluent.cloud/iam/v2/service-accounts */
        first?: unknown;
        /** @example https://api.confluent.cloud/iam/v2/service-accounts?page_token=bcAOehAY8F16YD84Z1wT */
        last?: unknown;
        /** @example https://api.confluent.cloud/iam/v2/service-accounts?page_token=YIXRY97wWYmwzrax4dld */
        prev?: unknown;
        /** @example https://api.confluent.cloud/iam/v2/service-accounts?page_token=UvmDWOB1iwfAIBPj6EYb */
        next?: unknown;
      };
      /** @description A data property that contains an array of resource items. Each entry in the array is a separate resource. */
      data: (components["schemas"]["iam.v2.ServiceAccount"] &
        Record<string, unknown>)[];
    };
    /** @description `Invitation` objects represent invitations to invite users to join your organizations in Confluent Cloud.
     *
     *     The API allows you to list all your invitations, as well as create, read, and delete a specified invitation.
     *
     *
     *     Related guide: [User invitations in Confluent Cloud](https://docs.confluent.io/cloud/current/access-management/identity/user-accounts.html).
     *
     *     ## The Invitations Model
     *     <SchemaDefinition schemaRef="#/components/schemas/iam.v2.Invitation" />
     *
     *     ## Quotas and Limits
     *     This resource is subject to the [following quotas](https://docs.confluent.io/cloud/current/quotas/overview.html):
     *
     *     | Quota | Description |
     *     | --- | --- |
     *     | `invitations_per_org` | Invitations in a Confluent Cloud organization | */
    "iam.v2.InvitationList": {
      /**
       * @description APIVersion defines the schema version of this representation of a resource.
       * @enum {string}
       */
      readonly api_version: "iam/v2";
      /**
       * @description Kind defines the object this REST resource represents.
       * @enum {string}
       */
      readonly kind: "InvitationList";
      metadata: components["schemas"]["ListMeta"] & {
        /** @example https://api.confluent.cloud/iam/v2/invitations */
        first?: unknown;
        /** @example https://api.confluent.cloud/iam/v2/invitations?page_token=bcAOehAY8F16YD84Z1wT */
        last?: unknown;
        /** @example https://api.confluent.cloud/iam/v2/invitations?page_token=YIXRY97wWYmwzrax4dld */
        prev?: unknown;
        /** @example https://api.confluent.cloud/iam/v2/invitations?page_token=UvmDWOB1iwfAIBPj6EYb */
        next?: unknown;
      };
      /** @description A data property that contains an array of resource items. Each entry in the array is a separate resource. */
      data: (components["schemas"]["iam.v2.Invitation"] &
        Record<string, unknown>)[];
    };
    /** @description ObjectReference provides information for you to locate the referred object */
    GlobalObjectReference: {
      /** @description ID of the referred resource */
      id: string;
      /**
       * Format: uri
       * @description API URL for accessing or modifying the referred object
       */
      readonly related: string;
      /**
       * Format: uri
       * @description CRN reference to the referred resource
       */
      readonly resource_name: string;
    };
    /** @description Definitions of networks which can be named and referred by IP blocks, commonly used to attach to IP Filter rules.
     *
     *
     *     ## The IP Groups Model
     *     <SchemaDefinition schemaRef="#/components/schemas/iam.v2.IpGroup" /> */
    "iam.v2.IpGroup": {
      /**
       * @description APIVersion defines the schema version of this representation of a resource.
       * @enum {string}
       */
      readonly api_version?: "iam/v2";
      /**
       * @description Kind defines the object this REST resource represents.
       * @enum {string}
       */
      readonly kind?: "IpGroup";
      /**
       * @description ID is the "natural identifier" for an object within its scope/namespace; it is normally unique across time but not space. That is, you can assume that the ID will not be reclaimed and reused after an object is deleted ("time"); however, it may collide with IDs for other object `kinds` or objects of the same `kind` within a different scope/namespace ("space").
       * @example dlz-f3a90de
       */
      readonly id?: string;
      metadata?: components["schemas"]["ObjectMeta"] & {
        /** @example https://api.confluent.cloud/iam/v2/ip-groups/ipg-12345 */
        self?: unknown;
        /** @example crn://confluent.cloud/organization=9bb441c4-edef-46ac-8a41-c49e44a3fd9a/ip-group=ipg-12345 */
        resource_name?: unknown;
      };
      /**
       * @description A human readable name for an IP Group. Can contain any unicode letter or number, the ASCII space character, or
       *     any of the following special characters: `[`, `]`, `|`, `&`, `+`, `-`, `_`, `/`, `.`, `,`.
       *
       * @example CorpNet
       */
      group_name?: string;
      /**
       * @description A list of CIDRs.
       * @example [
       *       "192.168.0.0/24",
       *       "192.168.7.0/24"
       *     ]
       */
      cidr_blocks?: string[];
    };
    /** @description `IP Filter` objects are bindings between IP Groups and Confluent resource(s).
     *     For example, a binding between "CorpNet" and "Management APIs" will enforce that
     *     access must come from one of the CIDR blocks associated with CorpNet.
     *     If there are multiple IP filters bound to a resource, a request matching any of the CIDR blocks
     *     for any of the IP Group will allow the request.
     *     If there are no IP Filters for a resource, then access will be granted to requests originating
     *     from any IP Address.
     *
     *
     *     ## The IP Filters Model
     *     <SchemaDefinition schemaRef="#/components/schemas/iam.v2.IpFilter" /> */
    "iam.v2.IpFilter": {
      /**
       * @description APIVersion defines the schema version of this representation of a resource.
       * @enum {string}
       */
      readonly api_version?: "iam/v2";
      /**
       * @description Kind defines the object this REST resource represents.
       * @enum {string}
       */
      readonly kind?: "IpFilter";
      /**
       * @description ID is the "natural identifier" for an object within its scope/namespace; it is normally unique across time but not space. That is, you can assume that the ID will not be reclaimed and reused after an object is deleted ("time"); however, it may collide with IDs for other object `kinds` or objects of the same `kind` within a different scope/namespace ("space").
       * @example dlz-f3a90de
       */
      readonly id?: string;
      metadata?: components["schemas"]["ObjectMeta"] & {
        /** @example https://api.confluent.cloud/iam/v2/ip-filters/ipf-12345 */
        self?: unknown;
        /** @example crn://confluent.cloud/organization=9bb441c4-edef-46ac-8a41-c49e44a3fd9a/ip-filter=ipf-12345 */
        resource_name?: unknown;
      };
      /**
       * @description A human readable name for an IP Filter. Can contain any unicode letter or number, the ASCII space character,
       *     or any of the following special characters: `[`, `]`, `|`, `&`, `+`, `-`, `_`, `/`, `.`, `,`.
       *
       * @example Management API Rules
       */
      filter_name?: string;
      /**
       * @description Scope of resources covered by this IP filter. Available resource groups include "management" and "multiple".
       *
       * @example management
       */
      resource_group?: string;
      /**
       * Format: uri
       * @description A CRN that specifies the scope of the ip filter, specifically the organization
       *     or environment. Without specifying this property, the ip filter
       *     would apply to the whole organization.
       *
       * @example crn://confluent.cloud/organization=org-123/environment=env-abc
       */
      resource_scope?: string;
      /**
       * @description Scope of resources covered by this IP filter. Resource group must be set to 'multiple'
       *     in order to use this property.During update operations, note that the operation
       *     groups passed in will replace the list of existing operation groups
       *     (passing in an empty list will remove all operation groups) from the filter
       *     (in line with the behavior for ip_groups).
       *
       * @example [
       *       "MANAGEMENT",
       *       "SCHEMA",
       *       "FLINK"
       *     ]
       */
      operation_groups?: string[];
      /** @description A list of IP Groups. */
      ip_groups?: components["schemas"]["GlobalObjectReference"][];
    };
    /** @description The IP Filter Summary endpoint returns an aggregation of the IP Filters across the system.
     *     This API can be queried in the context of an organization or an environment. It returns a
     *     summary of every operation group in the system grouped with a higher summary by operation
     *     group category.
     *      */
    "iam.v2.IpFilterSummary": {
      /**
       * @description APIVersion defines the schema version of this representation of a resource.
       * @enum {string}
       */
      readonly api_version?: "iam/v2";
      /**
       * @description Kind defines the object this REST resource represents.
       * @enum {string}
       */
      readonly kind?: "IpFilterSummary";
      /** @description The scope associated with this object. */
      scope?: string;
      /**
       * @description Summary of the operation groups and IP filters created in those operation groups.
       *
       * @example [
       *       {
       *         "name": "management",
       *         "status": "MIXED",
       *         "operation_groups": [
       *           {
       *             "name": "MANAGEMENT",
       *             "status": "LIMITED"
       *           }
       *         ]
       *       }
       *     ]
       */
      categories?: {
        /** @description Name of the category. */
        name?: string;
        /** @description Open, limited, or mixed. */
        status?: string;
        /** @description Operation groups part of this category. */
        operation_groups?: {
          /** @description Name of the operation group. */
          name?: string;
          /** @description Open, limited, or no access. */
          status?: string;
        }[];
      }[];
    };
    /** @description Definitions of networks which can be named and referred by IP blocks, commonly used to attach to IP Filter rules.
     *
     *
     *     ## The IP Groups Model
     *     <SchemaDefinition schemaRef="#/components/schemas/iam.v2.IpGroup" /> */
    "iam.v2.IpGroupList": {
      /**
       * @description APIVersion defines the schema version of this representation of a resource.
       * @enum {string}
       */
      readonly api_version: "iam/v2";
      /**
       * @description Kind defines the object this REST resource represents.
       * @enum {string}
       */
      readonly kind: "IpGroupList";
      metadata: components["schemas"]["ListMeta"] & {
        /** @example https://api.confluent.cloud/iam/v2/ip-groups */
        first?: unknown;
        /** @example https://api.confluent.cloud/iam/v2/ip-groups?page_token=bcAOehAY8F16YD84Z1wT */
        last?: unknown;
        /** @example https://api.confluent.cloud/iam/v2/ip-groups?page_token=YIXRY97wWYmwzrax4dld */
        prev?: unknown;
        /** @example https://api.confluent.cloud/iam/v2/ip-groups?page_token=UvmDWOB1iwfAIBPj6EYb */
        next?: unknown;
      };
      /** @description A data property that contains an array of resource items. Each entry in the array is a separate resource. */
      data: (components["schemas"]["iam.v2.IpGroup"] &
        Record<string, unknown>)[];
    };
    /** @description `IP Filter` objects are bindings between IP Groups and Confluent resource(s).
     *     For example, a binding between "CorpNet" and "Management APIs" will enforce that
     *     access must come from one of the CIDR blocks associated with CorpNet.
     *     If there are multiple IP filters bound to a resource, a request matching any of the CIDR blocks
     *     for any of the IP Group will allow the request.
     *     If there are no IP Filters for a resource, then access will be granted to requests originating
     *     from any IP Address.
     *
     *
     *     ## The IP Filters Model
     *     <SchemaDefinition schemaRef="#/components/schemas/iam.v2.IpFilter" /> */
    "iam.v2.IpFilterList": {
      /**
       * @description APIVersion defines the schema version of this representation of a resource.
       * @enum {string}
       */
      readonly api_version: "iam/v2";
      /**
       * @description Kind defines the object this REST resource represents.
       * @enum {string}
       */
      readonly kind: "IpFilterList";
      metadata: components["schemas"]["ListMeta"] & {
        /** @example https://api.confluent.cloud/iam/v2/ip-filters */
        first?: unknown;
        /** @example https://api.confluent.cloud/iam/v2/ip-filters?page_token=bcAOehAY8F16YD84Z1wT */
        last?: unknown;
        /** @example https://api.confluent.cloud/iam/v2/ip-filters?page_token=YIXRY97wWYmwzrax4dld */
        prev?: unknown;
        /** @example https://api.confluent.cloud/iam/v2/ip-filters?page_token=UvmDWOB1iwfAIBPj6EYb */
        next?: unknown;
      };
      /** @description A data property that contains an array of resource items. Each entry in the array is a separate resource. */
      data: (components["schemas"]["iam.v2.IpFilter"] &
        Record<string, unknown>)[];
    };
    /** @description A role binding grants a Principal a role on resources that match a pattern.
     *
     *     The API allows you to perform create, delete, and list operations on role bindings.
     *
     *
     *     Related guide: [Role-Based Access Control (RBAC)](https://docs.confluent.io/cloud/current/access-management/access-control/cloud-rbac.html).
     *
     *     ## The Role Bindings Model
     *     <SchemaDefinition schemaRef="#/components/schemas/iam.v2.RoleBinding" /> */
    "iam.v2.RoleBinding": {
      /**
       * @description APIVersion defines the schema version of this representation of a resource.
       * @enum {string}
       */
      readonly api_version?: "iam/v2";
      /**
       * @description Kind defines the object this REST resource represents.
       * @enum {string}
       */
      readonly kind?: "RoleBinding";
      /**
       * @description ID is the "natural identifier" for an object within its scope/namespace; it is normally unique across time but not space. That is, you can assume that the ID will not be reclaimed and reused after an object is deleted ("time"); however, it may collide with IDs for other object `kinds` or objects of the same `kind` within a different scope/namespace ("space").
       * @example dlz-f3a90de
       */
      readonly id?: string;
      metadata?: components["schemas"]["ObjectMeta"] & {
        /** @example https://api.confluent.cloud/iam/v2/role-bindings/rb-12345 */
        self?: unknown;
        /** @example crn://confluent.cloud/organization=9bb441c4-edef-46ac-8a41-c49e44a3fd9a/role-binding=rb-12345 */
        resource_name?: unknown;
      };
      /**
       * @description The principal User to bind the role to
       * @example User:u-111aaa
       */
      principal?: string;
      /**
       * @description The name of the role to bind to the principal
       * @example CloudClusterAdmin
       */
      role_name?: string;
      /**
       * Format: uri
       * @description A CRN that specifies the scope and resource patterns necessary for the role to bind
       * @example crn://confluent.cloud/organization=1111aaaa-11aa-11aa-11aa-111111aaaaaa/environment=env-aaa1111/cloud-cluster=lkc-1111aaa
       */
      crn_pattern?: string;
    };
    /** @description A role binding grants a Principal a role on resources that match a pattern.
     *
     *     The API allows you to perform create, delete, and list operations on role bindings.
     *
     *
     *     Related guide: [Role-Based Access Control (RBAC)](https://docs.confluent.io/cloud/current/access-management/access-control/cloud-rbac.html).
     *
     *     ## The Role Bindings Model
     *     <SchemaDefinition schemaRef="#/components/schemas/iam.v2.RoleBinding" /> */
    "iam.v2.RoleBindingList": {
      /**
       * @description APIVersion defines the schema version of this representation of a resource.
       * @enum {string}
       */
      readonly api_version: "iam/v2";
      /**
       * @description Kind defines the object this REST resource represents.
       * @enum {string}
       */
      readonly kind: "RoleBindingList";
      metadata: components["schemas"]["ListMeta"] & {
        /** @example https://api.confluent.cloud/iam/v2/role-bindings */
        first?: unknown;
        /** @example https://api.confluent.cloud/iam/v2/role-bindings?page_token=bcAOehAY8F16YD84Z1wT */
        last?: unknown;
        /** @example https://api.confluent.cloud/iam/v2/role-bindings?page_token=YIXRY97wWYmwzrax4dld */
        prev?: unknown;
        /** @example https://api.confluent.cloud/iam/v2/role-bindings?page_token=UvmDWOB1iwfAIBPj6EYb */
        next?: unknown;
      };
      /** @description A data property that contains an array of resource items. Each entry in the array is a separate resource. */
      data: (components["schemas"]["iam.v2.RoleBinding"] &
        Record<string, unknown>)[];
    };
    /** @description `Subscription` objects represent the intent of the customers to get notifications of particular types.
     *     A subscription is created for a particular `NotificationType` and the user will get notifications on the
     *     `Integrations` that are provided while creating the subscription.
     *
     *     This API allows you to create, retrieve, and update subscriptions,
     *     as well as to view the list of all your subscriptions. You can also delete subscriptions
     *     with RECOMMENDED or OPTIONAL notification types. Subscriptions with REQUIRED notification types cannot be deleted.
     *
     *
     *     Related guide: [Cloud Notifications](https://docs.confluent.io/cloud/current/monitoring/configure-notifications.html#notifications-for-ccloud).
     *
     *     ## The Subscriptions Model
     *     <SchemaDefinition schemaRef="#/components/schemas/notifications.v1.Subscription" /> */
    "notifications.v1.Subscription": {
      /**
       * @description APIVersion defines the schema version of this representation of a resource.
       * @enum {string}
       */
      readonly api_version?: "notifications/v1";
      /**
       * @description Kind defines the object this REST resource represents.
       * @enum {string}
       */
      readonly kind?: "Subscription";
      /**
       * @description ID is the "natural identifier" for an object within its scope/namespace; it is normally unique across time but not space. That is, you can assume that the ID will not be reclaimed and reused after an object is deleted ("time"); however, it may collide with IDs for other object `kinds` or objects of the same `kind` within a different scope/namespace ("space").
       * @example dlz-f3a90de
       */
      readonly id?: string;
      metadata?: components["schemas"]["ObjectMeta"] & {
        /** @example https://api.confluent.cloud/notifications/v1/subscriptions/s-12345 */
        self?: unknown;
        /** @example crn://confluent.cloud/organization=9bb441c4-edef-46ac-8a41-c49e44a3fd9a/subscription=s-12345 */
        resource_name?: unknown;
      };
      /**
       * @description Denotes the state of the subscription. When the subscription is ENABLED, the user will receive
       *     notification on the configured Integrations. If the subscription is DISABLED, the user will not
       *     recieve any notification for the configured notification type. Note that, you cannot disable
       *     a subscription for `REQUIRED` notification type.
       *
       * @example ENABLED
       */
      current_state?: string;
      /** @description The type of notification to subscribe to. */
      notification_type?: components["schemas"]["GlobalObjectReference"];
      /** @description Integrations to which notifications are to be sent. */
      integrations?: components["schemas"]["GlobalObjectReference"][];
    };
    /** @description You can create an `Integration` to specify how we can notify you when we receive an alert/notification for
     *     a subscription. Please note that you can only perform create, update and delete operations for integrations
     *     of type `Webhook`, `Slack` and `MsTeams`. You cannot create, update or delete integrations of type `RoleEmail`
     *     and `UserEmail`.
     *
     *
     *     Related guide: [Cloud Notifications](https://docs.confluent.io/cloud/current/monitoring/configure-notifications.html#notifications-for-ccloud).
     *
     *     ## The Integrations Model
     *     <SchemaDefinition schemaRef="#/components/schemas/notifications.v1.Integration" />
     *
     *     ## Quotas and Limits
     *     This resource is subject to the [following quotas](https://docs.confluent.io/cloud/current/quotas/overview.html):
     *
     *     | Quota | Description |
     *     | --- | --- |
     *     | `integrations_per_org` | Maximum number of integrations in one Confluent Cloud organization | */
    "notifications.v1.Integration": {
      /**
       * @description APIVersion defines the schema version of this representation of a resource.
       * @enum {string}
       */
      readonly api_version?: "notifications/v1";
      /**
       * @description Kind defines the object this REST resource represents.
       * @enum {string}
       */
      readonly kind?: "Integration";
      /**
       * @description ID is the "natural identifier" for an object within its scope/namespace; it is normally unique across time but not space. That is, you can assume that the ID will not be reclaimed and reused after an object is deleted ("time"); however, it may collide with IDs for other object `kinds` or objects of the same `kind` within a different scope/namespace ("space").
       * @example dlz-f3a90de
       */
      readonly id?: string;
      metadata?: components["schemas"]["ObjectMeta"] & {
        /** @example https://api.confluent.cloud/notifications/v1/integrations/i-12345 */
        self?: unknown;
        /** @example crn://confluent.cloud/organization=9bb441c4-edef-46ac-8a41-c49e44a3fd9a/integration=i-12345 */
        resource_name?: unknown;
      };
      /**
       * @description A human readable name for the particular integration
       *
       * @example Slack integration
       */
      display_name?: string;
      /**
       * @description A human readable description for the particular integration
       *
       * @example A Slack channel integration
       */
      description?: string;
      /** @description Integration-specific details (integration targets)
       *      */
      target?: Omit<components["schemas"]["notifications.v1.Target"], "kind">;
    };
    /** @description The type of notifications (and their corresponding metadata) supported by Confluent.
     *
     *
     *     Related guide: [Cloud Notifications](https://docs.confluent.io/cloud/current/monitoring/configure-notifications.html#notifications-for-ccloud).
     *
     *     ## The Notification Types Model
     *     <SchemaDefinition schemaRef="#/components/schemas/notifications.v1.NotificationType" /> */
    "notifications.v1.NotificationType": {
      /**
       * @description APIVersion defines the schema version of this representation of a resource.
       * @enum {string}
       */
      readonly api_version?: "notifications/v1";
      /**
       * @description Kind defines the object this REST resource represents.
       * @enum {string}
       */
      readonly kind?: "NotificationType";
      /**
       * @description ID is the "natural identifier" for an object within its scope/namespace; it is normally unique across time but not space. That is, you can assume that the ID will not be reclaimed and reused after an object is deleted ("time"); however, it may collide with IDs for other object `kinds` or objects of the same `kind` within a different scope/namespace ("space").
       * @example dlz-f3a90de
       */
      readonly id?: string;
      metadata?: components["schemas"]["ObjectMeta"] & {
        /** @example https://api.confluent.cloud/notifications/v1/notification-types/nt-12345 */
        self?: unknown;
        /** @example crn://confluent.cloud/organization=9bb441c4-edef-46ac-8a41-c49e44a3fd9a/notification-type=nt-12345 */
        resource_name?: unknown;
      };
      /**
       * @description Human readable display name of the notification type
       *
       * @example Cluster Shrink
       */
      display_name?: string;
      /**
       * @description Represents the group with which the notification is associated.
       *     Notifications are grouped under certain categories for better organization.
       *     - BILLING_LICENSING: All billing, payments or licensing related notifications are grouped here.
       *     - SECURITY: All Confluent Cloud and Platform security related notifications are grouped here.
       *     - SERVICE: All Confluent services (eg. Kafka, Schema Registry, Connect etc.) related notifications are
       *       grouped here.
       *     - ACCOUNT: All Confluent account related notifications are grouped here.
       *     For example: Billing, payment or license related notifications are grouped in BILLING_LICENSING category.
       *
       * @example BILLING_LICENSING
       */
      category?: string;
      /**
       * @description Human readable description of the notification type
       *
       * @example Cluster shrink operation is completed
       */
      description?: string;
      /**
       * @description Indicates whether the notification is auto-subscribed and if the user can opt-out.
       *     - REQUIRED: the user is auto-subscribed to this notification and can't opt-out.
       *     - RECOMMENDED: the user is auto-subscribed to this notification and can opt-out.
       *     - OPTIONAL: the user is not auto-subscribed to this notification but can explicitly subscribe to it.
       *
       * @example REQUIRED
       */
      subscription_priority?: string;
      /** @description Whether this notification is available to subscribe or not
       *     as per the user's current billing plan.
       *      */
      is_included_in_plan?: boolean;
      /**
       * @description Severity indicates the impact of this notification.
       *     - CRITICAL: a high impact notification which needs immediate attention.
       *     - WARN: a warning notification which can be addressed now or later.
       *     - INFO: an informational notification.
       *
       * @example INFO
       */
      severity?: string;
    };
    /** @description Target required for Slack integration */
    "notifications.v1.SlackTarget": {
      /**
       * @description Integration Type (enum property replaced by openapi-typescript)
       * @enum {string}
       */
      kind: "Slack";
      /**
       * Format: uri
       * @description Slack Webhook URL for the particular Slack channel
       * @example https://hooks.slack.com/services/{id}/{id}/{id}
       */
      webhook_url: string;
    };
    /** @description Email integration target to send email to all user with specified role */
    "notifications.v1.RoleEmailTarget": {
      /**
       * @description Email Integration type for Role (enum property replaced by openapi-typescript)
       * @enum {string}
       */
      kind: "RoleEmail";
      /**
       * @description name of the role
       * @example OrganizationAdmin
       */
      role_name: string;
    };
    /** @description Email integration target to send email to a particular user */
    "notifications.v1.UserEmailTarget": {
      /**
       * @description Email Integration type for User (enum property replaced by openapi-typescript)
       * @enum {string}
       */
      kind: "UserEmail";
      /**
       * @description ID of the user
       * @example u-temp1
       */
      user: string;
    };
    /** @description Target required for webhook integration */
    "notifications.v1.WebhookTarget": {
      /**
       * @description Integration Type (enum property replaced by openapi-typescript)
       * @enum {string}
       */
      kind: "Webhook";
      /**
       * Format: uri
       * @description URL endpoint for the webhook
       * @example https://my.webhook.url/{id}
       */
      url: string;
    };
    /** @description Target required for MS Teams integration */
    "notifications.v1.MsTeamsTarget": {
      /**
       * @description Integration Type (enum property replaced by openapi-typescript)
       * @enum {string}
       */
      kind: "MsTeams";
      /**
       * Format: uri
       * @description MS Teams Webhook URL for the particular team channel
       * @example https://admin.webhook.office.com/webhookb2/{id}/IncomingWebhook/{id}
       */
      webhook_url: string;
    };
    /**
     * @description Target for the particular integration
     * @example {
     *       "kind": "Slack",
     *       "webhook_url": "https://hooks.slack.com/services/{id}/{id}/{id}"
     *     }
     */
    "notifications.v1.Target":
      | components["schemas"]["notifications.v1.SlackTarget"]
      | components["schemas"]["notifications.v1.RoleEmailTarget"]
      | components["schemas"]["notifications.v1.UserEmailTarget"]
      | components["schemas"]["notifications.v1.WebhookTarget"]
      | components["schemas"]["notifications.v1.MsTeamsTarget"];
    /** @description `Subscription` objects represent the intent of the customers to get notifications of particular types.
     *     A subscription is created for a particular `NotificationType` and the user will get notifications on the
     *     `Integrations` that are provided while creating the subscription.
     *
     *     This API allows you to create, retrieve, and update subscriptions,
     *     as well as to view the list of all your subscriptions. You can also delete subscriptions
     *     with RECOMMENDED or OPTIONAL notification types. Subscriptions with REQUIRED notification types cannot be deleted.
     *
     *
     *     Related guide: [Cloud Notifications](https://docs.confluent.io/cloud/current/monitoring/configure-notifications.html#notifications-for-ccloud).
     *
     *     ## The Subscriptions Model
     *     <SchemaDefinition schemaRef="#/components/schemas/notifications.v1.Subscription" /> */
    "notifications.v1.SubscriptionList": {
      /**
       * @description APIVersion defines the schema version of this representation of a resource.
       * @enum {string}
       */
      readonly api_version: "notifications/v1";
      /**
       * @description Kind defines the object this REST resource represents.
       * @enum {string}
       */
      readonly kind: "SubscriptionList";
      metadata: components["schemas"]["ListMeta"] & {
        /** @example https://api.confluent.cloud/notifications/v1/subscriptions */
        first?: unknown;
        /** @example https://api.confluent.cloud/notifications/v1/subscriptions?page_token=bcAOehAY8F16YD84Z1wT */
        last?: unknown;
        /** @example https://api.confluent.cloud/notifications/v1/subscriptions?page_token=YIXRY97wWYmwzrax4dld */
        prev?: unknown;
        /** @example https://api.confluent.cloud/notifications/v1/subscriptions?page_token=UvmDWOB1iwfAIBPj6EYb */
        next?: unknown;
      };
      /** @description A data property that contains an array of resource items. Each entry in the array is a separate resource. */
      data: (components["schemas"]["notifications.v1.Subscription"] &
        Record<string, unknown>)[];
    };
    /** @description You can create an `Integration` to specify how we can notify you when we receive an alert/notification for
     *     a subscription. Please note that you can only perform create, update and delete operations for integrations
     *     of type `Webhook`, `Slack` and `MsTeams`. You cannot create, update or delete integrations of type `RoleEmail`
     *     and `UserEmail`.
     *
     *
     *     Related guide: [Cloud Notifications](https://docs.confluent.io/cloud/current/monitoring/configure-notifications.html#notifications-for-ccloud).
     *
     *     ## The Integrations Model
     *     <SchemaDefinition schemaRef="#/components/schemas/notifications.v1.Integration" />
     *
     *     ## Quotas and Limits
     *     This resource is subject to the [following quotas](https://docs.confluent.io/cloud/current/quotas/overview.html):
     *
     *     | Quota | Description |
     *     | --- | --- |
     *     | `integrations_per_org` | Maximum number of integrations in one Confluent Cloud organization | */
    "notifications.v1.IntegrationList": {
      /**
       * @description APIVersion defines the schema version of this representation of a resource.
       * @enum {string}
       */
      readonly api_version: "notifications/v1";
      /**
       * @description Kind defines the object this REST resource represents.
       * @enum {string}
       */
      readonly kind: "IntegrationList";
      metadata: components["schemas"]["ListMeta"] & {
        /** @example https://api.confluent.cloud/notifications/v1/integrations */
        first?: unknown;
        /** @example https://api.confluent.cloud/notifications/v1/integrations?page_token=bcAOehAY8F16YD84Z1wT */
        last?: unknown;
        /** @example https://api.confluent.cloud/notifications/v1/integrations?page_token=YIXRY97wWYmwzrax4dld */
        prev?: unknown;
        /** @example https://api.confluent.cloud/notifications/v1/integrations?page_token=UvmDWOB1iwfAIBPj6EYb */
        next?: unknown;
      };
      /** @description A data property that contains an array of resource items. Each entry in the array is a separate resource. */
      data: (components["schemas"]["notifications.v1.Integration"] &
        Record<string, unknown>)[];
    };
    /** @description The type of notifications (and their corresponding metadata) supported by Confluent.
     *
     *
     *     Related guide: [Cloud Notifications](https://docs.confluent.io/cloud/current/monitoring/configure-notifications.html#notifications-for-ccloud).
     *
     *     ## The Notification Types Model
     *     <SchemaDefinition schemaRef="#/components/schemas/notifications.v1.NotificationType" /> */
    "notifications.v1.NotificationTypeList": {
      /**
       * @description APIVersion defines the schema version of this representation of a resource.
       * @enum {string}
       */
      readonly api_version: "notifications/v1";
      /**
       * @description Kind defines the object this REST resource represents.
       * @enum {string}
       */
      readonly kind: "NotificationTypeList";
      metadata: components["schemas"]["ListMeta"] & {
        /** @example https://api.confluent.cloud/notifications/v1/notification-types */
        first?: unknown;
        /** @example https://api.confluent.cloud/notifications/v1/notification-types?page_token=bcAOehAY8F16YD84Z1wT */
        last?: unknown;
        /** @example https://api.confluent.cloud/notifications/v1/notification-types?page_token=YIXRY97wWYmwzrax4dld */
        prev?: unknown;
        /** @example https://api.confluent.cloud/notifications/v1/notification-types?page_token=UvmDWOB1iwfAIBPj6EYb */
        next?: unknown;
      };
      /** @description A data property that contains an array of resource items. Each entry in the array is a separate resource. */
      data: (components["schemas"]["notifications.v1.NotificationType"] &
        Record<string, unknown>)[];
    };
    /** @description `Clusters` objects represent Apache Kafka Clusters on Confluent Cloud.
     *
     *     The API allows you to list, create, read, update, and delete your Kafka clusters.
     *
     *
     *     Related guide: [Confluent Cloud Cluster Management for Apache Kafka APIs](https://docs.confluent.io/cloud/current/clusters/cluster-api.html).
     *
     *     ## The Clusters Model
     *     <SchemaDefinition schemaRef="#/components/schemas/cmk.v2.Cluster" />
     *
     *     ## Quotas and Limits
     *     This resource is subject to the [following quotas](https://docs.confluent.io/cloud/current/quotas/overview.html):
     *
     *     | Quota | Description |
     *     | --- | --- |
     *     | `kafka_clusters_per_environment` | Number of clusters in one Confluent Cloud environment | */
    "cmk.v2.Cluster": {
      /**
       * @description APIVersion defines the schema version of this representation of a resource.
       * @enum {string}
       */
      readonly api_version?: "cmk/v2";
      /**
       * @description Kind defines the object this REST resource represents.
       * @enum {string}
       */
      readonly kind?: "Cluster";
      /**
       * @description ID is the "natural identifier" for an object within its scope/namespace; it is normally unique across time but not space. That is, you can assume that the ID will not be reclaimed and reused after an object is deleted ("time"); however, it may collide with IDs for other object `kinds` or objects of the same `kind` within a different scope/namespace ("space").
       * @example dlz-f3a90de
       */
      readonly id?: string;
      metadata?: components["schemas"]["ObjectMeta"] & {
        /** @example https://api.confluent.cloud/cmk/v2/clusters/lkc-12345 */
        self?: unknown;
        /** @example crn://confluent.cloud/organization=9bb441c4-edef-46ac-8a41-c49e44a3fd9a/environment=env-abc123/cloud-cluster=lkc-12345 */
        resource_name?: unknown;
      };
      spec?: components["schemas"]["cmk.v2.ClusterSpec"];
      status?: components["schemas"]["cmk.v2.ClusterStatus"];
    };
    /** @description The status of the Cluster */
    "cmk.v2.ClusterStatus": {
      /**
       * @description The lifecyle phase of the cluster:
       *       PROVISIONED:  cluster is provisioned;
       *       PROVISIONING:  cluster provisioning is in progress;
       *       FAILED:  provisioning failed
       *
       * @example PROVISIONED
       */
      readonly phase: string;
      /**
       * Format: int32
       * @description The number of Confluent Kafka Units (CKUs) the Dedicated cluster currently has.
       *
       * @example 2
       */
      readonly cku?: number;
    };
    /** @description The basic cluster type.
     *      */
    "cmk.v2.Basic": {
      /**
       * @description Basic cluster type.
       *      (enum property replaced by openapi-typescript)
       * @enum {string}
       */
      kind: "Basic";
    };
    /** @description The standard cluster type.
     *      */
    "cmk.v2.Standard": {
      /**
       * @description Standard cluster type.
       *      (enum property replaced by openapi-typescript)
       * @enum {string}
       */
      kind: "Standard";
    };
    /** @description The enterprise cluster type.
     *      */
    "cmk.v2.Enterprise": {
      /**
       * @description Enterprise cluster type.
       *      (enum property replaced by openapi-typescript)
       * @enum {string}
       */
      kind: "Enterprise";
    };
    /** @description A dedicated cluster with its parameters.
     *      */
    "cmk.v2.Dedicated": {
      /**
       * @description Dedicated cluster type.
       *      (enum property replaced by openapi-typescript)
       * @enum {string}
       */
      kind: "Dedicated";
      /**
       * Format: int32
       * @description The number of Confluent Kafka Units (CKUs) for Dedicated cluster types.
       *     MULTI_ZONE dedicated clusters must have at least two CKUs.
       *
       * @example 2
       */
      cku: number;
      /**
       * @deprecated
       * @description The id of the encryption key that is used to encrypt the data in the Kafka cluster.
       *     (e.g. for Amazon Web Services, the Amazon Resource Name of the key).
       *
       * @example arn:aws:kms:us-west-2:000000000000:key/0000xxxx-00xx-00xx-00xx-0000000000xx
       */
      encryption_key?: string;
      /**
       * @description The list of zones the cluster is in.
       *
       *     On AWS, zones are AWS [AZ IDs](https://docs.aws.amazon.com/ram/latest/userguide/working-with-az-ids.html)
       *      (e.g. use1-az3)
       *
       *     On GCP, zones are GCP [zones](https://cloud.google.com/compute/docs/regions-zones)
       *      (e.g. us-central1-c).
       *
       * @example [
       *       "us-central1-a",
       *       "us-central1-b",
       *       "us-central1-c"
       *     ]
       */
      readonly zones?: string[];
    };
    /** @description A freight cluster with its parameters.
     *      */
    "cmk.v2.Freight": {
      /**
       * @description Freight cluster type.
       *      (enum property replaced by openapi-typescript)
       * @enum {string}
       */
      kind: "Freight";
      /**
       * @description The list of zones the cluster is in.
       *
       *     On AWS, zones are AWS [AZ IDs](https://docs.aws.amazon.com/ram/latest/userguide/working-with-az-ids.html)
       *      (e.g. use1-az3)
       *
       *     On GCP, zones are GCP [zones](https://cloud.google.com/compute/docs/regions-zones)
       *      (e.g. us-central1-c).
       *
       * @example [
       *       "us-central1-a",
       *       "us-central1-b",
       *       "us-central1-c"
       *     ]
       */
      readonly zones?: string[];
    };
    /** @description `Clusters` objects represent Apache Kafka Clusters on Confluent Cloud.
     *
     *     The API allows you to list, create, read, update, and delete your Kafka clusters.
     *
     *
     *     Related guide: [Confluent Cloud Cluster Management for Apache Kafka APIs](https://docs.confluent.io/cloud/current/clusters/cluster-api.html).
     *
     *     ## The Clusters Model
     *     <SchemaDefinition schemaRef="#/components/schemas/cmk.v2.Cluster" />
     *
     *     ## Quotas and Limits
     *     This resource is subject to the [following quotas](https://docs.confluent.io/cloud/current/quotas/overview.html):
     *
     *     | Quota | Description |
     *     | --- | --- |
     *     | `kafka_clusters_per_environment` | Number of clusters in one Confluent Cloud environment | */
    "cmk.v2.ClusterList": {
      /**
       * @description APIVersion defines the schema version of this representation of a resource.
       * @enum {string}
       */
      readonly api_version: "cmk/v2";
      /**
       * @description Kind defines the object this REST resource represents.
       * @enum {string}
       */
      readonly kind: "ClusterList";
      metadata: components["schemas"]["ListMeta"] & {
        /** @example https://api.confluent.cloud/cmk/v2/clusters */
        first?: unknown;
        /** @example https://api.confluent.cloud/cmk/v2/clusters?page_token=bcAOehAY8F16YD84Z1wT */
        last?: unknown;
        /** @example https://api.confluent.cloud/cmk/v2/clusters?page_token=YIXRY97wWYmwzrax4dld */
        prev?: unknown;
        /** @example https://api.confluent.cloud/cmk/v2/clusters?page_token=UvmDWOB1iwfAIBPj6EYb */
        next?: unknown;
      };
      /** @description A data property that contains an array of resource items. Each entry in the array is a separate resource. */
      data: (components["schemas"]["cmk.v2.Cluster"] & {
        spec: Record<string, unknown>;
      })[];
    };
    /** @description The desired state of the Cluster */
    "cmk.v2.ClusterSpec": {
      /**
       * @description The name of the cluster.
       * @example ProdKafkaCluster
       */
      display_name?: string;
      /**
       * @description The availability zone configuration of the cluster
       *
       * @example SINGLE_ZONE
       */
      availability?: string;
      /**
       * @description The cloud service provider in which the cluster is running.
       * @example GCP
       */
      cloud?: string;
      /**
       * @description The cloud service provider region where the cluster is running.
       * @example us-east4
       */
      region?: string;
      /**
       * @description The configuration of the Kafka cluster.
       *
       *     Note: Clusters can be upgraded from Basic to Standard, but cannot be downgraded from Standard to Basic.
       *
       * @default {
       *       "kind": "Basic"
       *     }
       * @example {
       *       "kind": "Basic"
       *     }
       */
      config:
        | components["schemas"]["cmk.v2.Basic"]
        | components["schemas"]["cmk.v2.Standard"]
        | components["schemas"]["cmk.v2.Dedicated"]
        | components["schemas"]["cmk.v2.Enterprise"]
        | components["schemas"]["cmk.v2.Freight"];
      /**
       * @description The bootstrap endpoint used by Kafka clients to connect to the cluster.
       * @example lkc-00000-00000.us-central1.gcp.glb.confluent.cloud:9092
       */
      readonly kafka_bootstrap_endpoint?: string;
      /**
       * Format: uri
       * @description The cluster HTTP request URL.
       * @example https://lkc-00000-00000.us-central1.gcp.glb.confluent.cloud
       */
      readonly http_endpoint?: string;
      /**
       * @description The Kafka API cluster endpoint used by Kafka clients to connect to the cluster.
       * @example https://pkac-00000.us-west-2.aws.confluent.cloud
       */
      readonly api_endpoint?: string;
      /** @description The environment to which this belongs. */
      environment?: components["schemas"]["EnvScopedObjectReference"];
      /** @description The network associated with this object. */
      network?: components["schemas"]["EnvScopedObjectReference"];
      /** @description The byok associated with this object. */
      byok?: components["schemas"]["GlobalObjectReference"];
    };
    /** @description ObjectReference provides information for you to locate the referred object */
    EnvScopedObjectReference: {
      /** @description ID of the referred resource */
      id: string;
      /** @description Environment of the referred resource, if env-scoped */
      environment?: string;
      /**
       * Format: uri
       * @description API URL for accessing or modifying the referred object
       */
      readonly related: string;
      /**
       * Format: uri
       * @description CRN reference to the referred resource
       */
      readonly resource_name: string;
    };
    /** @description `Cluster` represents a ksqlDB runtime that you can issue queries to using its API endpoint.
     *     It executes SQL statements and queries which under the hood get built into corresponding
     *     Kafka Streams topologies. The API allows you to list, create, read, and delete your ksqlDB clusters.
     *
     *
     *     Related guide: [ksqlDB in Confluent Cloud](https://docs.confluent.io/cloud/current/ksqldb/ksqldb-cluster-api.html).
     *
     *     ## The Clusters Model
     *     <SchemaDefinition schemaRef="#/components/schemas/ksqldbcm.v2.Cluster" />
     *
     *     ## Quotas and Limits
     *     This resource is subject to the following quotas:
     *
     *     | Quota | Description |
     *     | --- | --- |
     *     | `ksql.limits.max_apps_per_cluster` | Clusters in one Confluent Cloud Kafka Cluster. | */
    "ksqldbcm.v2.Cluster": {
      /**
       * @description APIVersion defines the schema version of this representation of a resource.
       * @enum {string}
       */
      readonly api_version?: "ksqldbcm/v2";
      /**
       * @description Kind defines the object this REST resource represents.
       * @enum {string}
       */
      readonly kind?: "Cluster";
      /**
       * @description ID is the "natural identifier" for an object within its scope/namespace; it is normally unique across time but not space. That is, you can assume that the ID will not be reclaimed and reused after an object is deleted ("time"); however, it may collide with IDs for other object `kinds` or objects of the same `kind` within a different scope/namespace ("space").
       * @example dlz-f3a90de
       */
      readonly id?: string;
      metadata?: components["schemas"]["ObjectMeta"] & {
        /** @example https://api.confluent.cloud/ksqldbcm/v2/clusters/lksqlc-12345 */
        self?: unknown;
        /** @example crn://confluent.cloud/organization=9bb441c4-edef-46ac-8a41-c49e44a3fd9a/environment=env-abc123/cloud-cluster=lksqlc-12345 */
        resource_name?: unknown;
      };
      spec?: components["schemas"]["ksqldbcm.v2.ClusterSpec"];
      status?: components["schemas"]["ksqldbcm.v2.ClusterStatus"];
    };
    /** @description The status of the Cluster */
    "ksqldbcm.v2.ClusterStatus": {
      /**
       * @description The dataplane endpoint of the ksqlDB cluster.
       * @example https://pksqlc-00000.us-central1.gcp.glb.confluent.cloud
       */
      readonly http_endpoint?: string;
      /**
       * @description Status of the ksqlDB cluster.
       * @example PROVISIONING
       */
      readonly phase: string;
      /** @description Tells you if the cluster has been paused */
      readonly is_paused: boolean;
      /**
       * Format: int32
       * @description Amount of storage (in GB) provisioned to this cluster
       * @example 125
       */
      readonly storage: number;
      /**
       * @description Topic name prefix used by this ksqlDB cluster. Used to assign ACLs for this ksqlDB cluster to use.
       * @example pksqlc-00000
       */
      readonly topic_prefix?: string;
    };
    /** @description `Cluster` represents a ksqlDB runtime that you can issue queries to using its API endpoint.
     *     It executes SQL statements and queries which under the hood get built into corresponding
     *     Kafka Streams topologies. The API allows you to list, create, read, and delete your ksqlDB clusters.
     *
     *
     *     Related guide: [ksqlDB in Confluent Cloud](https://docs.confluent.io/cloud/current/ksqldb/ksqldb-cluster-api.html).
     *
     *     ## The Clusters Model
     *     <SchemaDefinition schemaRef="#/components/schemas/ksqldbcm.v2.Cluster" />
     *
     *     ## Quotas and Limits
     *     This resource is subject to the following quotas:
     *
     *     | Quota | Description |
     *     | --- | --- |
     *     | `ksql.limits.max_apps_per_cluster` | Clusters in one Confluent Cloud Kafka Cluster. | */
    "ksqldbcm.v2.ClusterList": {
      /**
       * @description APIVersion defines the schema version of this representation of a resource.
       * @enum {string}
       */
      readonly api_version: "ksqldbcm/v2";
      /**
       * @description Kind defines the object this REST resource represents.
       * @enum {string}
       */
      readonly kind: "ClusterList";
      metadata: components["schemas"]["ListMeta"] & {
        /** @example https://api.confluent.cloud/ksqldbcm/v2/clusters */
        first?: unknown;
        /** @example https://api.confluent.cloud/ksqldbcm/v2/clusters?page_token=bcAOehAY8F16YD84Z1wT */
        last?: unknown;
        /** @example https://api.confluent.cloud/ksqldbcm/v2/clusters?page_token=YIXRY97wWYmwzrax4dld */
        prev?: unknown;
        /** @example https://api.confluent.cloud/ksqldbcm/v2/clusters?page_token=UvmDWOB1iwfAIBPj6EYb */
        next?: unknown;
      };
      /** @description A data property that contains an array of resource items. Each entry in the array is a separate resource. */
      data: (components["schemas"]["ksqldbcm.v2.Cluster"] & {
        spec: Record<string, unknown>;
      })[];
    };
    /** @description The desired state of the Cluster */
    "ksqldbcm.v2.ClusterSpec": {
      /**
       * @description The name of the ksqlDB cluster.
       * @example ksqlDB_cluster_0
       */
      display_name?: string;
      /**
       * @description This flag controls whether you want to include the row data in the processing log topic. Turn it off if you
       *     don't want to emit sensitive information to the processing log
       *
       * @default true
       */
      use_detailed_processing_log: boolean;
      /**
       * Format: int32
       * @description The number of CSUs (Confluent Streaming Units) in a ksqlDB cluster.
       * @example 4
       */
      csu?: number;
      /** @description The kafka_cluster to which this belongs. */
      kafka_cluster?: components["schemas"]["EnvScopedObjectReference"];
      /** @description The credential_identity to which this belongs. The credential_identity can be one of iam.v2.User, iam.v2.ServiceAccount. */
      credential_identity?: components["schemas"]["TypedGlobalObjectReference"];
      /** @description The environment to which this belongs. */
      environment?: components["schemas"]["GlobalObjectReference"];
    };
    "connect.v1.ConnectorError": {
      /** @description Connector Error with error code and message. */
      error?: {
        /** @description Error code for the type of error */
        code?: number;
        /** @description Human readable error message */
        message?: string;
      };
    };
    "connect.v1.Connector": {
      /** @description Name of the connector */
      name: string;
      /** @description Configuration parameters for the connector. These configurations
       *     are the minimum set of key-value pairs (KVP) which can be used to
       *     define how the connector connects Kafka to the external system.
       *     Some of these KVPs are common to all the connectors, such as
       *     connection parameters to Kafka, connector metadata, etc. The list
       *     of common connector configurations is as follows
       *
       *     - cloud.environment
       *     - cloud.provider
       *     - connector.class
       *     - kafka.api.key
       *     - kafka.api.secret
       *     - kafka.endpoint
       *     - kafka.region
       *     - name
       *
       *     A specific connector such as `GcsSink` would have additional
       *     parameters such as `gcs.bucket.name`, `flush.size`, etc. */
      config: {
        /** @description The cloud environment type. */
        "cloud.environment": string;
        /** @description The cloud service provider, e.g. aws, azure, etc. */
        "cloud.provider": string;
        /** @description The connector class name. E.g. BigQuerySink, GcsSink, etc. */
        "connector.class": string;
        /** @description Name or alias of the class (plugin) for this connector. */
        name: string;
        /** @description The kafka cluster endpoint. */
        "kafka.endpoint": string;
        /** @description The kafka cluster region. */
        "kafka.region": string;
        /** @description The kafka cluster api key. */
        "kafka.api.key": string;
        /** @description The kafka cluster api secret key. */
        "kafka.api.secret": string;
      } & {
        [key: string]: string;
      };
      /** @description List of active tasks generated by the connector */
      tasks?: {
        /** @description The name of the connector the task belongs to */
        connector: string;
        /** @description Task ID within the connector */
        task: number;
      }[];
      /**
       * @description Type of connector, sink or source
       * @enum {string}
       */
      type?: "sink" | "source";
    };
    "connect.v1.ConnectorWithOffsets": {
      /** @description Name of the connector */
      name: string;
      /** @description Configuration parameters for the connector. These configurations
       *     are the minimum set of key-value pairs which can be used to
       *     define how the connector connects Kafka to the external system.
       *     Some of these key-value pairs are common to all the connectors, such as
       *     connection parameters to Kafka, connector metadata, etc. The list
       *     of common connector configurations is as follows
       *     - cloud.environment
       *     - cloud.provider
       *     - connector.class
       *     - kafka.api.key
       *     - kafka.api.secret
       *     - kafka.endpoint
       *     - kafka.region
       *     - name
       *     A specific connector such as `GcsSink` would have additional
       *     parameters such as `gcs.bucket.name`, `flush.size`, etc. */
      config: {
        /** @description The cloud environment type. */
        "cloud.environment": string;
        /** @description The cloud service provider, e.g. aws, azure, etc. */
        "cloud.provider": string;
        /** @description The connector class name. E.g. BigQuerySink, GcsSink, etc. */
        "connector.class": string;
        /** @description Name or alias of the class (plugin) for this connector. */
        name: string;
        /** @description The Kafka cluster endpoint. */
        "kafka.endpoint": string;
        /** @description The Kafka cluster region. */
        "kafka.region": string;
        /** @description The Kafka cluster API key. */
        "kafka.api.key": string;
        /** @description The Kafka cluster API secret. */
        "kafka.api.secret": string;
      } & {
        [key: string]: string;
      };
      /** @description List of active tasks generated by the connector */
      tasks?: {
        /** @description The name of the connector the task belongs to */
        connector: string;
        /** @description Task ID within the connector */
        task: number;
      }[];
      /**
       * @description Type of connector, sink or source
       * @enum {string}
       */
      type?: "sink" | "source";
      offsets?: components["schemas"]["connect.v1.Offsets"];
    };
    /** @description List of active task configs that have been created by the connector */
    "connect.v1.Connectors": {
      /** @description The ID of task. */
      id?: {
        /** @description The name of the connector the task belongs to. */
        connector?: string;
        /** @description Task ID within the connector. */
        task?: number;
      };
      /** @description Configuration parameters for the connector. These configurations
       *     are the minimum set of key-value pairs (KVP) which can be used to
       *     define how the connector connects Kafka to the external system.
       *     Some of these KVPs are common to all the connectors, such as
       *     connection parameters to Kafka, connector metadata, etc. The list
       *     of common connector configurations is as follows
       *
       *       - cloud.environment
       *       - cloud.provider
       *       - connector.class
       *       - kafka.api.key
       *       - kafka.api.secret
       *       - kafka.endpoint
       *       - kafka.region
       *       - name
       *
       *     A specific connector such as `GcsSink` would have additional
       *     parameters such as `gcs.bucket.name`, `flush.size`, etc. */
      config?: {
        /** @description The cloud environment type. */
        "cloud.environment": string;
        /** @description The cloud service provider, e.g. aws, azure, etc. */
        "cloud.provider": string;
        /** @description The connector class name. E.g. BigQuerySink, GcsSink, etc. */
        "connector.class": string;
        /** @description Name or alias of the class (plugin) for this connector. */
        name: string;
        /** @description The kafka cluster endpoint. */
        "kafka.endpoint": string;
        /** @description The kafka cluster region. */
        "kafka.region": string;
        /** @description The kafka cluster api key. */
        "kafka.api.key": string;
        /** @description The kafka cluster api secret key. */
        "kafka.api.secret": string;
      } & {
        [key: string]: string;
      };
    }[];
    "connect.v1.ConnectorExpansionMap": {
      [key: string]: components["schemas"]["connect.v1.ConnectorExpansion"];
    };
    /** @description Name of connector */
    "connect.v1.ConnectorExpansion": {
      /** @description The ID of connector. */
      id?: {
        /** @description The ID of the connector. */
        id?: string;
        /** @description Type of the value in the `id` property. */
        id_type?: string;
      };
      /** @description Metadata of the connector. */
      info?: {
        /** @description Name of the connector. */
        name?: string;
        /** @description Configuration parameters for the connector. These configurations
         *     are the minimum set of key-value pairs (KVP) which are used to
         *     define how the connector connects Kafka to the external system.
         *     Some of these KVPs are common to all the connectors, such as
         *     connection parameters to Kafka, connector metadata, etc. The list
         *     of common connector configurations is as follows
         *
         *       - cloud.environment
         *       - cloud.provider
         *       - connector.class
         *       - kafka.api.key
         *       - kafka.api.secret
         *       - kafka.endpoint
         *       - kafka.region
         *       - name
         *
         *     For example, a connector like `GcsSink` would have additional
         *     parameters such as `gcs.bucket.name`, `flush.size`, etc. */
        config?: {
          /** @description The cloud environment type. */
          "cloud.environment": string;
          /** @description The cloud service provider, e.g. aws, azure, etc. */
          "cloud.provider": string;
          /** @description The connector class name. E.g. BigQuerySink, GcsSink, etc. */
          "connector.class": string;
          /** @description Name or alias of the class (plugin) for this connector. */
          name: string;
          /** @description The kafka cluster endpoint. */
          "kafka.endpoint": string;
          /** @description The kafka cluster region. */
          "kafka.region": string;
          /** @description The kafka cluster api key. */
          "kafka.api.key": string;
          /** @description The kafka cluster api secret key. */
          "kafka.api.secret": string;
        } & {
          [key: string]: string;
        };
      };
      /** @description Status of the connector and its tasks. */
      status?: {
        /** @description The name of the connector. */
        name: string;
        /**
         * @description Type of connector, sink or source.
         * @enum {string}
         */
        type: "sink" | "source";
        /** @description A map containing connector status. */
        connector: {
          /**
           * @description The state of the connector.
           * @enum {string}
           */
          state:
            | "NONE"
            | "PROVISIONING"
            | "RUNNING"
            | "DEGRADED"
            | "FAILED"
            | "PAUSED"
            | "DELETED";
          /** @description The worker ID of the connector. */
          worker_id: string;
          /** @description Exception message in case of an error. */
          trace?: string;
        };
        /** @description A map containing the task status. */
        tasks?: {
          /** @description The ID of task. */
          id: number;
          /** @description The state of the task. */
          state: string;
          /** @description The worker ID of the task. */
          worker_id: string;
          msg?: string;
        }[];
      };
    };
    /** @description Array of offsets which are categorised into partitions. */
    "connect.v1.Offsets": {
      /** @description The partition information. For sink connectors this is the kafka topic and
       *     partition. For source connectors this is depends on the partitions defined by the
       *     source connector. For example, the table which this task is pulling data from in a
       *     JDBC based MySQL source connector.
       *     Please refer to the [documentation](https://docs.confluent.io/cloud/current/connectors/offsets.html#manage-offsets-for-fully-managed-connectors-in-ccloud) for
       *     more information. */
      partition?: {
        [key: string]: unknown;
      };
      /** @description The offset of the partition. For sink connectors this is the kafka offset. For
       *     source connectors this is depends on the offset defined by the source connector.
       *     For example, the timestamp and incrementing column info in a table, for a JDBC based
       *     MySQL source connector.
       *     Please refer to the [documentation](https://docs.confluent.io/cloud/current/connectors/offsets.html#manage-offsets-for-fully-managed-connectors-in-ccloud) for
       *     more information. */
      offset?: {
        [key: string]: unknown;
      };
    }[];
    /** @description Offsets for a connector */
    "connect.v1.ConnectorOffsets": {
      /** @description The name of the connector. */
      name?: string;
      /** @description The ID of the connector. */
      id?: string;
      offsets?: components["schemas"]["connect.v1.Offsets"];
      /** @description Metadata of the connector offset. */
      metadata?: {
        /**
         * Format: date-time
         * @description The time at which the offsets were observed. The time is in UTC, ISO 8601 format.
         * @example 2024-02-20T15:14:19Z
         */
        readonly observed_at?: string;
      };
    };
    /**
     * @description The type of alter operation. PATCH will update the offset to the provided values.
     *     The update will only happen for the partitions provided in the request.
     *     DELETE will delete the offset for the provided partitions and reset them back to the
     *     base state. It is as if, a fresh new connector was created.
     *
     *     For sink connectors PATCH/DELETE will move the offsets to the provided point in the
     *     topic partition. If the offset provided is not present in the topic partition it will
     *     by default reset to the earliest offset in the topic partition.
     *
     *     For source connectors, post PATCH/DELETE the connector will attempt to read from the
     *     position defined in the altered offsets.
     * @enum {string}
     */
    "connect.v1.AlterOffsetRequestType": "PATCH" | "DELETE";
    /** @description Request to alter the offset of a connector. The offsets parameter is options for DELETE type. */
    "connect.v1.AlterOffsetRequest": {
      type: components["schemas"]["connect.v1.AlterOffsetRequestType"];
      offsets?: components["schemas"]["connect.v1.Offsets"];
    };
    /** @description The request made to alter offsets. */
    "connect.v1.AlterOffsetRequestInfo": {
      /** @description The ID of the connector. */
      id: string;
      /** @description The name of the connector. */
      name: string;
      offsets?: components["schemas"]["connect.v1.Offsets"];
      /**
       * Format: date-time
       * @description The time at which the request was made. The time is in UTC, ISO 8601 format.
       * @example 2024-02-20T15:14:19Z
       */
      readonly requested_at: string;
      type: components["schemas"]["connect.v1.AlterOffsetRequestType"];
    };
    /** @description Status of the alter offset operation. The previous offsets in the response
     *     is the offsets that the connector last processed, before the offsets were altered,
     *     via a patch or delete operation. */
    "connect.v1.AlterOffsetStatus": {
      request: components["schemas"]["connect.v1.AlterOffsetRequestInfo"];
      /** @description The response of the alter offsets operation. */
      status: {
        /** @description The phase of the alter offset operation.
         *
         *     PENDING: The offset alter operation is in progress.
         *
         *     APPLIED: The offset alter operation has been applied to the connector.
         *
         *     FAILED:  The offset alter operation has failed to be applied to the connector. */
        phase: string;
        /** @description An info message from the alter offset operation. */
        message?: string;
      };
      previous_offsets?: components["schemas"]["connect.v1.Offsets"];
      /**
       * Format: date-time
       * @description The time at which the offsets were applied. The time is in UTC, ISO 8601 format.
       * @example 2024-02-20T15:14:19Z
       */
      readonly applied_at?: string | null;
    };
    /** @description CustomConnectorPlugins objects represent Custom Connector Plugins on Confluent Cloud.
     *     The API allows you to list, create, read, update, and delete your Custom Connector Plugins.
     *     Related guide:
     *     [Custom Connector Plugin API](https://docs.confluent.io/cloud/current/connectors/connect-api-section.html).
     *
     *
     *     ## The Custom Connector Plugins Model
     *     <SchemaDefinition schemaRef="#/components/schemas/connect.v1.CustomConnectorPlugin" /> */
    "connect.v1.CustomConnectorPlugin": {
      /**
       * @description APIVersion defines the schema version of this representation of a resource.
       * @enum {string}
       */
      readonly api_version?: "connect/v1";
      /**
       * @description Kind defines the object this REST resource represents.
       * @enum {string}
       */
      readonly kind?: "CustomConnectorPlugin";
      /**
       * @description ID is the "natural identifier" for an object within its scope/namespace; it is normally unique across time but not space. That is, you can assume that the ID will not be reclaimed and reused after an object is deleted ("time"); however, it may collide with IDs for other object `kinds` or objects of the same `kind` within a different scope/namespace ("space").
       * @example dlz-f3a90de
       */
      readonly id?: string;
      metadata?: components["schemas"]["ObjectMeta"] & {
        /** @example https://api.confluent.cloud/connect/v1/custom-connector-plugins/ccp-12345 */
        self?: unknown;
        /** @example crn://confluent.cloud/organization=9bb441c4-edef-46ac-8a41-c49e44a3fd9a/custom-connector-plugin=ccp-12345 */
        resource_name?: unknown;
      };
      /** @description Display name of Custom Connector Plugin. */
      display_name?: string;
      /**
       * @description Archive format of Custom Connector Plugin.
       * @example ZIP
       */
      readonly content_format?: string;
      /** @description Description of Custom Connector Plugin. */
      description?: string;
      /**
       * @description Document link of Custom Connector Plugin.
       * @example https://github.com/confluentinc/kafka-connect-datagen
       */
      documentation_link?: string;
      /**
       * @description Java class or alias for connector. You can get connector class from connector documentation provided by developer.
       * @example io.confluent.kafka.connect.datagen.DatagenConnector
       */
      connector_class?: string;
      /**
       * @description Custom Connector type.
       *
       * @example SOURCE
       */
      connector_type?: string;
      /**
       * @description Cloud provider where the Custom Connector Plugin archive is uploaded.
       * @default AWS
       * @example AWS
       */
      cloud: string;
      /**
       * @description A sensitive property is a connector configuration property that must be hidden after a user enters property value when setting up connector.
       * @example [
       *       "passwords",
       *       "keys",
       *       "tokens"
       *     ]
       */
      sensitive_config_properties?: string[];
      /** @description [immutable] Upload source of Custom Connector Plugin. Only required in `create` request, will be ignored in `read`, `update` or `list`. */
      upload_source?: components["schemas"]["connect.v1.UploadSource.PresignedUrl"];
    };
    /** @description Request a presigned upload URL for new Custom Connector Plugin. Note that
     *     the URL policy expires in one hour. If the policy expires, you can request
     *     a new presigned upload URL.
     *
     *     Related guide:
     *     [Custom Connector Plugin API](https://docs.confluent.io/cloud/current/connectors/connect-api-section.html).
     *
     *
     *     ## The Presigned Urls Model
     *     <SchemaDefinition schemaRef="#/components/schemas/connect.v1.PresignedUrl" /> */
    "connect.v1.PresignedUrl": {
      /**
       * @description APIVersion defines the schema version of this representation of a resource.
       * @enum {string}
       */
      readonly api_version?: "connect/v1";
      /**
       * @description Kind defines the object this REST resource represents.
       * @enum {string}
       */
      readonly kind?: "PresignedUrl";
      /**
       * @description Content format of the Custom Connector Plugin archive.
       * @example ZIP
       */
      readonly content_format?: string;
      /**
       * @description Cloud provider where the Custom Connector Plugin archive is uploaded.
       * @example AWS
       */
      readonly cloud?: string;
      /**
       * @description Unique identifier of this upload.
       * @example e53bb2e8-8de3-49fa-9fb1-4e3fd9a16b66
       */
      readonly upload_id?: string;
      /**
       * Format: uri
       * @description Upload URL for the Custom Connector Plugin archive.
       * @example https://confluent-custom-connectors-stag-us-west-2.s3.dualstack.us-west-2.amazonaws.com/
       */
      readonly upload_url?: string;
      /**
       * @description Upload form data of the Custom Connector Plugin. All values should be strings.
       * @example {
       *       "bucket": "confluent-custom-connectors-stag-us-west-2",
       *       "key": "staging/custom-plugin/2f37f0b6-f8da-4e8b-bc5f-282ebb0511be/connect-e53bb2e8-8de3-49fa-9fb1-4e3fd9a16b66/plugin.zip",
       *       "policy": "string",
       *       "x-amz-algorithm": "AWS4-HMAC-SHA256",
       *       "x-amz-credential": "string",
       *       "x-amz-date": "20230725T013857Z",
       *       "x-amz-security-token": "string",
       *       "x-amz-signature": "string"
       *     }
       */
      readonly upload_form_data?: Record<string, unknown>;
    };
    /** @description Request schema of the presigned upload URL.
     *      */
    "connect.v1.PresignedUrlRequest": {
      /**
       * @description APIVersion defines the schema version of this representation of a resource.
       * @enum {string}
       */
      readonly api_version?: "connect/v1";
      /**
       * @description Kind defines the object this REST resource represents.
       * @enum {string}
       */
      readonly kind?: "PresignedUrlRequest";
      /**
       * @description ID is the "natural identifier" for an object within its scope/namespace; it is normally unique across time but not space. That is, you can assume that the ID will not be reclaimed and reused after an object is deleted ("time"); however, it may collide with IDs for other object `kinds` or objects of the same `kind` within a different scope/namespace ("space").
       * @example dlz-f3a90de
       */
      readonly id?: string;
      metadata?: components["schemas"]["ObjectMeta"] & {
        /** @example https://api.confluent.cloud/connect/v1/presigned-url-requests/pur-12345 */
        self?: unknown;
        /** @example crn://confluent.cloud/organization=9bb441c4-edef-46ac-8a41-c49e44a3fd9a/presigned-url-request=pur-12345 */
        resource_name?: unknown;
      };
      /**
       * @description Archive format of the Custom Connector Plugin.
       * @example ZIP
       */
      content_format?: string;
      /**
       * @description Cloud provider where the Custom Connector Plugin archive is uploaded.
       * @default AWS
       * @example AWS
       */
      cloud: string;
    };
    /** @description Presigned URL of the uploaded Custom Connector Plugin archive. */
    "connect.v1.UploadSource.PresignedUrl": {
      /**
       * @description Location of the Custom Connector Plugin source.
       *      (enum property replaced by openapi-typescript)
       * @enum {string}
       */
      location: "PRESIGNED_URL_LOCATION";
      /**
       * @description Upload ID returned by the `/presigned-upload-url` API. This field returns an empty string in all responses.
       * @example e53bb2e8-8de3-49fa-9fb1-4e3fd9a16b66
       */
      upload_id: string;
    };
    /** @description CustomConnectorPlugins objects represent Custom Connector Plugins on Confluent Cloud.
     *     The API allows you to list, create, read, update, and delete your Custom Connector Plugins.
     *     Related guide:
     *     [Custom Connector Plugin API](https://docs.confluent.io/cloud/current/connectors/connect-api-section.html).
     *
     *
     *     ## The Custom Connector Plugins Model
     *     <SchemaDefinition schemaRef="#/components/schemas/connect.v1.CustomConnectorPlugin" /> */
    "connect.v1.CustomConnectorPluginList": {
      /**
       * @description APIVersion defines the schema version of this representation of a resource.
       * @enum {string}
       */
      readonly api_version: "connect/v1";
      /**
       * @description Kind defines the object this REST resource represents.
       * @enum {string}
       */
      readonly kind: "CustomConnectorPluginList";
      metadata: components["schemas"]["ListMeta"] & {
        /** @example https://api.confluent.cloud/connect/v1/custom-connector-plugins */
        first?: unknown;
        /** @example https://api.confluent.cloud/connect/v1/custom-connector-plugins?page_token=bcAOehAY8F16YD84Z1wT */
        last?: unknown;
        /** @example https://api.confluent.cloud/connect/v1/custom-connector-plugins?page_token=YIXRY97wWYmwzrax4dld */
        prev?: unknown;
        /** @example https://api.confluent.cloud/connect/v1/custom-connector-plugins?page_token=UvmDWOB1iwfAIBPj6EYb */
        next?: unknown;
      };
      /** @description A data property that contains an array of resource items. Each entry in the array is a separate resource. */
      data: (components["schemas"]["connect.v1.CustomConnectorPlugin"] &
        Record<string, unknown>)[];
    };
    AbstractConfigData: components["schemas"]["Resource"] & {
      cluster_id: string;
      name: string;
      value?: string | null;
      is_default: boolean;
      is_read_only: boolean;
      is_sensitive: boolean;
      source: components["schemas"]["ConfigSource"];
      synonyms: components["schemas"]["ConfigSynonymData"][];
    };
    AclData: components["schemas"]["Resource"] & {
      cluster_id: string;
      resource_type: components["schemas"]["AclResourceType"];
      resource_name: string;
      pattern_type: components["schemas"]["AclPatternType"];
      principal: string;
      host: string;
      operation: components["schemas"]["AclOperation"];
      permission: components["schemas"]["AclPermission"];
    };
    AclDataList: components["schemas"]["ResourceCollection"] & {
      data: components["schemas"]["AclData"][];
    };
    AclOperation: string;
    AclPatternType: string;
    AclPermission: string;
    /** @enum {string} */
    AclResourceType:
      | "UNKNOWN"
      | "ANY"
      | "TOPIC"
      | "GROUP"
      | "CLUSTER"
      | "TRANSACTIONAL_ID"
      | "DELEGATION_TOKEN";
    AlterConfigBatchRequestData: {
      data: {
        name: string;
        value?: string | null;
        operation?: string | null;
      }[];
      validate_only?: boolean;
    };
    AnyValue: unknown;
    AuthorizedOperations: string[];
    BrokerConfigData: components["schemas"]["AbstractConfigData"] & {
      broker_id: number;
    };
    BrokerConfigDataList: components["schemas"]["ResourceCollection"] & {
      data: components["schemas"]["BrokerConfigData"][];
    };
    BrokerData: components["schemas"]["Resource"] & {
      cluster_id: string;
      broker_id: number;
      host?: string | null;
      port?: number | null;
      rack?: string | null;
      configs: components["schemas"]["Relationship"];
      partition_replicas: components["schemas"]["Relationship"];
    };
    BrokerDataList: components["schemas"]["ResourceCollection"] & {
      data: components["schemas"]["BrokerData"][];
    };
    ClusterConfigData: components["schemas"]["AbstractConfigData"] & {
      config_type: components["schemas"]["ClusterConfigType"];
    };
    ClusterConfigDataList: components["schemas"]["ResourceCollection"] & {
      data: components["schemas"]["ClusterConfigData"][];
    };
    ClusterConfigType: string;
    ClusterData: components["schemas"]["Resource"] & {
      cluster_id: string;
      controller?: components["schemas"]["Relationship"];
      acls: components["schemas"]["Relationship"];
      brokers: components["schemas"]["Relationship"];
      broker_configs: components["schemas"]["Relationship"];
      consumer_groups: components["schemas"]["Relationship"];
      topics: components["schemas"]["Relationship"];
      partition_reassignments: components["schemas"]["Relationship"];
    };
    ClusterDataList: components["schemas"]["ResourceCollection"] & {
      data: components["schemas"]["ClusterData"][];
    };
    CreateAclRequestData: {
      resource_type: components["schemas"]["AclResourceType"];
      resource_name: string;
      pattern_type: components["schemas"]["AclPatternType"];
      principal: string;
      host: string;
      operation: components["schemas"]["AclOperation"];
      permission: components["schemas"]["AclPermission"];
    };
    CreateAclRequestDataList: {
      data: components["schemas"]["CreateAclRequestData"][];
    };
    CreateTopicRequestData: {
      topic_name: string;
      partitions_count?: number;
      replication_factor?: number;
      configs?: {
        name: string;
        value?: string | null;
      }[];
      validate_only?: boolean;
    };
    ConfigSource: string;
    ConfigSynonymData: {
      name: string;
      value?: string | null;
      source: components["schemas"]["ConfigSource"];
    };
    ConsumerAssignmentData: components["schemas"]["Resource"] & {
      cluster_id: string;
      consumer_group_id: string;
      consumer_id: string;
      topic_name: string;
      partition_id: number;
      partition: components["schemas"]["Relationship"];
      lag: components["schemas"]["Relationship"];
    };
    ConsumerAssignmentDataList: components["schemas"]["ResourceCollection"] & {
      data: components["schemas"]["ConsumerAssignmentData"][];
    };
    ConsumerData: components["schemas"]["Resource"] & {
      cluster_id: string;
      consumer_group_id: string;
      consumer_id: string;
      instance_id?: string | null;
      client_id: string;
      assignments: components["schemas"]["Relationship"];
    };
    ConsumerDataList: components["schemas"]["ResourceCollection"] & {
      data: components["schemas"]["ConsumerData"][];
    };
    ConsumerGroupData: components["schemas"]["Resource"] & {
      cluster_id: string;
      consumer_group_id: string;
      is_simple: boolean;
      partition_assignor: string;
      state: components["schemas"]["ConsumerGroupState"];
      coordinator: components["schemas"]["Relationship"];
      consumer?: components["schemas"]["Relationship"];
      lag_summary: components["schemas"]["Relationship"];
    };
    ConsumerGroupDataList: components["schemas"]["ResourceCollection"] & {
      data: components["schemas"]["ConsumerGroupData"][];
    };
    ConsumerGroupState: string;
    ConsumerLagData: components["schemas"]["Resource"] & {
      cluster_id: string;
      consumer_group_id: string;
      topic_name: string;
      partition_id: number;
      /** Format: int64 */
      current_offset: number;
      /** Format: int64 */
      log_end_offset: number;
      /** Format: int64 */
      lag: number;
      consumer_id: string;
      instance_id?: string | null;
      client_id: string;
    };
    ConsumerLagDataList: components["schemas"]["ResourceCollection"] & {
      data: components["schemas"]["ConsumerLagData"][];
    };
    ConsumerGroupLagSummaryData: components["schemas"]["Resource"] & {
      cluster_id: string;
      consumer_group_id: string;
      max_lag_consumer_id: string;
      max_lag_instance_id?: string | null;
      max_lag_client_id: string;
      max_lag_topic_name: string;
      max_lag_partition_id: number;
      /** Format: int64 */
      max_lag: number;
      /** Format: int64 */
      total_lag: number;
      max_lag_consumer: components["schemas"]["Relationship"];
      max_lag_partition: components["schemas"]["Relationship"];
    };
    PartitionData: components["schemas"]["Resource"] & {
      cluster_id: string;
      topic_name: string;
      partition_id: number;
      leader?: components["schemas"]["Relationship"];
      replicas: components["schemas"]["Relationship"];
      reassignment: components["schemas"]["Relationship"];
    };
    PartitionDataList: components["schemas"]["ResourceCollection"] & {
      data: components["schemas"]["PartitionData"][];
    };
    ProduceResponse: {
      /** Format: int32 */
      error_code: number;
      message?: string;
      cluster_id?: string;
      topic_name?: string;
      /** Format: int32 */
      partition_id?: number;
      /** Format: int64 */
      offset?: number;
      /** Format: date-time */
      timestamp?: string | null;
      key?: components["schemas"]["ProduceResponseData"];
      value?: components["schemas"]["ProduceResponseData"];
    };
    ProduceResponseData: {
      size: number;
      type: string;
    } | null;
    ProduceRequest: {
      /** Format: int32 */
      partition_id?: number | null;
      headers?: components["schemas"]["ProduceRequestHeader"][];
      key?: components["schemas"]["ProduceRequestData"];
      value?: components["schemas"]["ProduceRequestData"];
      /** Format: date-time */
      timestamp?: string | null;
    };
    ProduceRequestData: {
      type?: string;
      data?: components["schemas"]["AnyValue"];
    } | null;
    ProduceRequestHeader: {
      name: string;
      /** Format: byte */
      value?: string | null;
    };
    ReassignmentData: components["schemas"]["Resource"] & {
      cluster_id: string;
      topic_name: string;
      partition_id: number;
      adding_replicas: number[];
      removing_replicas: number[];
      replicas: components["schemas"]["Relationship"];
    };
    ReassignmentDataList: components["schemas"]["ResourceCollection"] & {
      data: components["schemas"]["ReassignmentData"][];
    };
    Relationship: {
      related: string;
    };
    ReplicaData: components["schemas"]["Resource"] & {
      cluster_id: string;
      topic_name: string;
      partition_id: number;
      broker_id: number;
      is_leader: boolean;
      is_in_sync: boolean;
      broker: components["schemas"]["Relationship"];
    };
    ReplicaDataList: components["schemas"]["ResourceCollection"] & {
      data: components["schemas"]["ReplicaData"][];
    };
    Resource: {
      kind: string;
      metadata: components["schemas"]["ResourceMetadata"];
    };
    ResourceCollection: {
      kind: string;
      metadata: components["schemas"]["ResourceCollectionMetadata"];
    };
    ResourceCollectionMetadata: {
      self: string;
      next?: string | null;
    };
    ResourceMetadata: {
      self: string;
      resource_name?: string | null;
    };
    TopicConfigData: components["schemas"]["AbstractConfigData"] & {
      topic_name: string;
    };
    TopicConfigDataList: components["schemas"]["ResourceCollection"] & {
      data: components["schemas"]["TopicConfigData"][];
    };
    TopicData: components["schemas"]["Resource"] & {
      cluster_id: string;
      topic_name: string;
      is_internal: boolean;
      replication_factor: number;
      partitions_count: number;
      partitions: components["schemas"]["Relationship"];
      configs: components["schemas"]["Relationship"];
      partition_reassignments: components["schemas"]["Relationship"];
      authorized_operations?: components["schemas"]["AuthorizedOperations"];
    };
    TopicDataList: components["schemas"]["ResourceCollection"] & {
      data: components["schemas"]["TopicData"][];
    };
    UpdateConfigRequestData: {
      value?: string | null;
    };
    UpdatePartitionCountRequestData: {
      /** Format: int32 */
      partitions_count: number;
    };
    ReplicaStatusData: components["schemas"]["Resource"] & {
      cluster_id: string;
      topic_name: string;
      /** Format: int32 */
      broker_id: number;
      /** Format: int32 */
      partition_id: number;
      is_leader: boolean;
      is_observer: boolean;
      is_isr_eligible: boolean;
      is_in_isr: boolean;
      is_caught_up: boolean;
      /** Format: int64 */
      log_start_offset: number;
      /** Format: int64 */
      log_end_offset: number;
      /** Format: int64 */
      last_caught_up_time_ms: number;
      /** Format: int64 */
      last_fetch_time_ms: number;
      link_name?: string;
    };
    ReplicaStatusDataList: components["schemas"]["ResourceCollection"] & {
      data: components["schemas"]["ReplicaStatusData"][];
    };
    AnyUnevenLoadData: components["schemas"]["Resource"] & {
      cluster_id: string;
      status: components["schemas"]["AnyUnevenLoadStatus"];
      previous_status: components["schemas"]["AnyUnevenLoadStatus"];
      /**
       * Format: date-time
       * @description The date and time at which this task was created.
       * @example 2019-10-12T07:20:50Z
       */
      readonly status_updated_at: string;
      /**
       * Format: date-time
       * @description The date and time at which this task was created.
       * @example 2019-10-12T07:20:50Z
       */
      readonly previous_status_updated_at: string;
      error_code?: number | null;
      error_message?: string | null;
      broker_tasks: components["schemas"]["Relationship"];
    };
    BalancerStatusData: components["schemas"]["Resource"] & {
      cluster_id: string;
      status: components["schemas"]["BalancerStatus"];
      error_code?: number | null;
      error_message?: string | null;
      any_uneven_load: components["schemas"]["Relationship"];
      broker_tasks: components["schemas"]["Relationship"];
    };
    BrokerRemovalData: components["schemas"]["Resource"] & {
      cluster_id: string;
      broker_id: number;
      broker_task: components["schemas"]["Relationship"];
      broker: components["schemas"]["Relationship"];
    };
    BrokerRemovalDataList: components["schemas"]["ResourceCollection"] & {
      data: components["schemas"]["BrokerRemovalData"][];
    };
    BrokerTaskData: components["schemas"]["Resource"] & {
      cluster_id: string;
      broker_id: number;
      task_type: components["schemas"]["BrokerTaskType"];
      task_status: components["schemas"]["BrokerTaskStatus"];
      shutdown_scheduled?: boolean | null;
      sub_task_statuses: {
        [key: string]: string;
      };
      /**
       * Format: date-time
       * @description The date and time at which this task was created.
       * @example 2019-10-12T07:20:50Z
       */
      readonly created_at: string;
      /**
       * Format: date-time
       * @description The date and time at which this task was last updated.
       * @example 2019-10-12T07:20:50Z
       */
      readonly updated_at: string;
      error_code?: number | null;
      error_message?: string | null;
      broker: components["schemas"]["Relationship"];
    };
    BrokerTaskDataList: components["schemas"]["ResourceCollection"] & {
      data: components["schemas"]["BrokerTaskData"][];
    };
    BrokerReplicaExclusionRequestData: {
      broker_id: number;
      reason: string;
    };
    BrokerReplicaExclusionBatchRequestData: {
      data: components["schemas"]["BrokerReplicaExclusionRequestData"][];
    };
    BrokerReplicaExclusionData: components["schemas"]["Resource"] & {
      cluster_id: string;
      broker_id: number;
      reason: string;
      broker: components["schemas"]["Relationship"];
    };
    BrokerReplicaExclusionDataList: components["schemas"]["ResourceCollection"] & {
      data: components["schemas"]["BrokerReplicaExclusionData"][];
    };
    AlterBrokerReplicaExclusionData: components["schemas"]["Resource"] & {
      cluster_id: string;
      broker_id: number;
      exclusion: components["schemas"]["ExclusionOp"];
      reason: string;
      error_code?: number | null;
      error_message?: string | null;
      broker: components["schemas"]["Relationship"];
    };
    AlterBrokerReplicaExclusionDataList: components["schemas"]["ResourceCollection"] & {
      data: components["schemas"]["AlterBrokerReplicaExclusionData"][];
    };
    RemoveBrokerTaskData: components["schemas"]["Resource"] & {
      cluster_id: string;
      broker_id: number;
      shutdown_scheduled: boolean;
      broker_replica_exclusion_status: components["schemas"]["BrokerReplicaExclusionStatus"];
      partition_reassignment_status: components["schemas"]["DeprecatedPartitionReassignmentStatus"];
      broker_shutdown_status: components["schemas"]["DeprecatedBrokerShutdownStatus"];
      error_code?: number | null;
      error_message?: string | null;
      broker: components["schemas"]["Relationship"];
    };
    RemoveBrokerTaskDataList: components["schemas"]["ResourceCollection"] & {
      data: components["schemas"]["RemoveBrokerTaskData"][];
    };
    /** @example {
     *       "name": "name",
     *       "value": "value"
     *     } */
    ConfigData: {
      name: string;
      value: string | null;
    };
    CreateLinkRequestData: {
      source_cluster_id?: string;
      destination_cluster_id?: string;
      /** @description The expected remote cluster ID. */
      remote_cluster_id?: string;
      /** @description The expected cluster link ID. Can be provided when creating the second side of a bidirectional link for validating the link ID is as expected. If it's not provided, it's inferred from the remote cluster. */
      cluster_link_id?: string;
      configs?: components["schemas"]["ConfigData"][];
    };
    UpdateLinkConfigRequestData: {
      value: string;
    };
    LinkState: string;
    LinkError: string;
    LinkTask: {
      task_name: string;
      state: components["schemas"]["LinkTaskState"];
      errors: components["schemas"]["LinkTaskError"][];
    };
    LinkTaskError: {
      error_code: string;
      error_message: string;
    };
    LinkTaskState: string;
    LinkTaskErrorCode: string;
    ListLinksResponseData: components["schemas"]["Resource"] & {
      source_cluster_id?: string | null;
      destination_cluster_id?: string | null;
      remote_cluster_id?: string | null;
      link_name: string;
      /** @deprecated */
      link_id?: string;
      cluster_link_id: string;
      topic_names: string[];
      link_error?: components["schemas"]["LinkError"];
      link_error_message?: string | null;
      link_state?: components["schemas"]["LinkState"];
      tasks?: components["schemas"]["LinkTask"][] | null;
    };
    ListLinksResponseDataList: components["schemas"]["ResourceCollection"] & {
      data: components["schemas"]["ListLinksResponseData"][];
    };
    ListLinkConfigsResponseData: components["schemas"]["Resource"] & {
      cluster_id: string;
      name: string;
      value: string;
      read_only: boolean;
      sensitive: boolean;
      source: string;
      synonyms: string[];
      link_name: string;
    };
    ListLinkConfigsResponseDataList: components["schemas"]["ResourceCollection"] & {
      data: components["schemas"]["ListLinkConfigsResponseData"][];
    };
    CreateMirrorTopicRequestData: {
      source_topic_name: string;
      mirror_topic_name?: string;
      replication_factor?: number;
      configs?: components["schemas"]["ConfigData"][];
    };
    AlterMirrorsRequestData: {
      /** @description The mirror topics specified as a list of topic names. */
      mirror_topic_names?: string[];
      /** @description The mirror topics specified as a pattern. */
      mirror_topic_name_pattern?: string;
    };
    ListMirrorTopicsResponseData: components["schemas"]["Resource"] & {
      link_name: string;
      mirror_topic_name: string;
      source_topic_name: string;
      num_partitions: number;
      mirror_lags: components["schemas"]["MirrorLags"];
      mirror_status: components["schemas"]["MirrorTopicStatus"];
      /** Format: int64 */
      state_time_ms: number;
      mirror_state_transition_errors?: components["schemas"]["LinkTaskError"][];
    };
    ListMirrorTopicsResponseDataList: components["schemas"]["ResourceCollection"] & {
      data: components["schemas"]["ListMirrorTopicsResponseData"][];
    };
    AlterMirrorStatusResponseData: components["schemas"]["Resource"] & {
      mirror_topic_name: string;
      error_message: string | null;
      error_code: number | null;
      mirror_lags: components["schemas"]["MirrorLags"];
      /** Format: int64 */
      messages_truncated: number | null;
      partition_level_truncation_data: components["schemas"]["PartitionLevelTruncationDataList"];
    };
    AlterMirrorStatusResponseDataList: components["schemas"]["ResourceCollection"] & {
      data: components["schemas"]["AlterMirrorStatusResponseData"][];
    };
    RemoveBrokersRequestData: {
      broker_ids: number[];
    };
    PartitionLevelTruncationDataList: components["schemas"]["PartitionLevelTruncationData"][];
    PartitionLevelTruncationData: {
      partition_id: number;
      /** Format: int64 */
      offset_truncated_to: number;
      /** Format: int64 */
      messages_truncated: number;
    };
    MirrorLags: components["schemas"]["MirrorLag"][];
    MirrorLag: {
      partition: number;
      /** Format: int64 */
      lag: number;
      /** Format: int64 */
      last_source_fetch_offset: number;
    };
    /** @enum {string} */
    MirrorTopicStatus:
      | "ACTIVE"
      | "FAILED"
      | "LINK_FAILED"
      | "LINK_PAUSED"
      | "PAUSED"
      | "PENDING_STOPPED"
      | "SOURCE_UNAVAILABLE"
      | "STOPPED"
      | "PENDING_MIRROR"
      | "PENDING_SYNCHRONIZE"
      | "PENDING_SETUP_FOR_RESTORE"
      | "PENDING_RESTORE";
    AnyUnevenLoadStatus: string;
    BalancerStatus: string;
    /** @enum {string} */
    BrokerTaskType: "add-broker" | "remove-broker";
    BrokerTaskStatus: string;
    ExclusionOp: string;
    BrokerReplicaExclusionStatus: string;
    DeprecatedPartitionReassignmentStatus: string;
    DeprecatedBrokerShutdownStatus: string;
    /** @description A `quota` object represents a quota configuration for a specific Confluent Cloud resource.
     *     Use this API to retrieve an individual quota or list of quotas for a given scope.
     *
     *
     *     Related guide: [Service Quotas for Confluent Cloud](https://docs.confluent.io/cloud/current/quotas/index.html).
     *
     *     ## The Applied Quotas Model
     *     <SchemaDefinition schemaRef="#/components/schemas/service-quota.v1.AppliedQuota" /> */
    "service-quota.v1.AppliedQuota": {
      /**
       * @description APIVersion defines the schema version of this representation of a resource.
       * @enum {string}
       */
      readonly api_version?: "service-quota/v1";
      /**
       * @description Kind defines the object this REST resource represents.
       * @enum {string}
       */
      readonly kind?: "AppliedQuota";
      /**
       * @description ID is the "natural identifier" for an object within its scope/namespace; it is normally unique across time but not space. That is, you can assume that the ID will not be reclaimed and reused after an object is deleted ("time"); however, it may collide with IDs for other object `kinds` or objects of the same `kind` within a different scope/namespace ("space").
       * @example dlz-f3a90de
       */
      readonly id?: string;
      metadata?: components["schemas"]["ObjectMeta"] & {
        /** @example https://api.confluent.cloud/service-quota/v1/applied-quotas/aq-12345 */
        self?: unknown;
        /** @example crn://confluent.cloud/organization=9bb441c4-edef-46ac-8a41-c49e44a3fd9a/applied-quota=aq-12345 */
        resource_name?: unknown;
      };
      /**
       * @description The applied scope that this quota belongs to.
       * @example ORGANIZATION
       */
      scope?: string;
      /**
       * @description A human-readable name for the quota type name.
       * @example Kafka Cluster Per Organization
       */
      display_name?: string;
      /**
       * Format: int32
       * @description The default service quota value.
       *
       */
      default_limit?: number;
      /**
       * Format: int32
       * @description The latest applied service quota value, taking into account any limit adjustments.
       *
       */
      applied_limit?: number;
      /**
       * Format: int32
       * @description Show the quota usage value if the quota usage is available for this quota.
       *
       */
      usage?: number;
      /** @description The user associated with this object. */
      user?: components["schemas"]["GlobalObjectReference"];
      /** @description A unique organization id to associate a specific organization to this quota. */
      organization?: components["schemas"]["GlobalObjectReference"] | null;
      /** @description The environment ID the quota is associated with.
       *      */
      environment?: components["schemas"]["GlobalObjectReference"] | null;
      /** @description The network ID the quota is associated with.
       *      */
      network?: components["schemas"]["EnvScopedObjectReference"] | null;
      /** @description The kafka cluster ID the quota is associated with.
       *      */
      kafka_cluster?: components["schemas"]["EnvScopedObjectReference"] | null;
    };
    /** @description Gets a list of all available scopes for applied quotas.
     *
     *
     *     Related guide: [Quota Scopes](https://docs.confluent.io/cloud/current/quotas/quotas.html#query-for-scopes).
     *
     *     ## The Scopes Model
     *     <SchemaDefinition schemaRef="#/components/schemas/service-quota.v1.Scope" /> */
    "service-quota.v1.Scope": {
      /**
       * @description APIVersion defines the schema version of this representation of a resource.
       * @enum {string}
       */
      readonly api_version?: "service-quota/v1";
      /**
       * @description Kind defines the object this REST resource represents.
       * @enum {string}
       */
      readonly kind?: "Scope";
      /**
       * @description ID is the "natural identifier" for an object within its scope/namespace; it is normally unique across time but not space. That is, you can assume that the ID will not be reclaimed and reused after an object is deleted ("time"); however, it may collide with IDs for other object `kinds` or objects of the same `kind` within a different scope/namespace ("space").
       * @example dlz-f3a90de
       */
      readonly id?: string;
      metadata?: components["schemas"]["ObjectMeta"] & {
        /** @example https://api.confluent.cloud/service-quota/v1/scopes/s-12345 */
        self?: unknown;
        /** @example crn://confluent.cloud/organization=9bb441c4-edef-46ac-8a41-c49e44a3fd9a/scope=s-12345 */
        resource_name?: unknown;
      };
      /**
       * @description the quota scope for listing quotas queries
       * @example ORGANIZATION scope that quotas would be applied to
       */
      description?: string;
    };
    /** @description A `quota` object represents a quota configuration for a specific Confluent Cloud resource.
     *     Use this API to retrieve an individual quota or list of quotas for a given scope.
     *
     *
     *     Related guide: [Service Quotas for Confluent Cloud](https://docs.confluent.io/cloud/current/quotas/index.html).
     *
     *     ## The Applied Quotas Model
     *     <SchemaDefinition schemaRef="#/components/schemas/service-quota.v1.AppliedQuota" /> */
    "service-quota.v1.AppliedQuotaList": {
      /**
       * @description APIVersion defines the schema version of this representation of a resource.
       * @enum {string}
       */
      readonly api_version: "service-quota/v1";
      /**
       * @description Kind defines the object this REST resource represents.
       * @enum {string}
       */
      readonly kind: "AppliedQuotaList";
      metadata: components["schemas"]["ListMeta"] & {
        /** @example https://api.confluent.cloud/service-quota/v1/applied-quotas */
        first?: unknown;
        /** @example https://api.confluent.cloud/service-quota/v1/applied-quotas?page_token=bcAOehAY8F16YD84Z1wT */
        last?: unknown;
        /** @example https://api.confluent.cloud/service-quota/v1/applied-quotas?page_token=YIXRY97wWYmwzrax4dld */
        prev?: unknown;
        /** @example https://api.confluent.cloud/service-quota/v1/applied-quotas?page_token=UvmDWOB1iwfAIBPj6EYb */
        next?: unknown;
      };
      /** @description A data property that contains an array of resource items. Each entry in the array is a separate resource. */
      data: (components["schemas"]["service-quota.v1.AppliedQuota"] &
        Record<string, unknown>)[];
    };
    /** @description Gets a list of all available scopes for applied quotas.
     *
     *
     *     Related guide: [Quota Scopes](https://docs.confluent.io/cloud/current/quotas/quotas.html#query-for-scopes).
     *
     *     ## The Scopes Model
     *     <SchemaDefinition schemaRef="#/components/schemas/service-quota.v1.Scope" /> */
    "service-quota.v1.ScopeList": {
      /**
       * @description APIVersion defines the schema version of this representation of a resource.
       * @enum {string}
       */
      readonly api_version: "service-quota/v1";
      /**
       * @description Kind defines the object this REST resource represents.
       * @enum {string}
       */
      readonly kind: "ScopeList";
      metadata: components["schemas"]["ListMeta"] & {
        /** @example https://api.confluent.cloud/service-quota/v1/scopes */
        first?: unknown;
        /** @example https://api.confluent.cloud/service-quota/v1/scopes?page_token=bcAOehAY8F16YD84Z1wT */
        last?: unknown;
        /** @example https://api.confluent.cloud/service-quota/v1/scopes?page_token=YIXRY97wWYmwzrax4dld */
        prev?: unknown;
        /** @example https://api.confluent.cloud/service-quota/v1/scopes?page_token=UvmDWOB1iwfAIBPj6EYb */
        next?: unknown;
      };
      /** @description A data property that contains an array of resource items. Each entry in the array is a separate resource. */
      data: (components["schemas"]["service-quota.v1.Scope"] &
        Record<string, unknown>)[];
    };
    /** @description `Entitlement` objects represent metadata about a marketplace entitlement. */
    "partner.v2.Entitlement": {
      /**
       * @description APIVersion defines the schema version of this representation of a resource.
       * @enum {string}
       */
      readonly api_version?: "partner/v2";
      /**
       * @description Kind defines the object this REST resource represents.
       * @enum {string}
       */
      readonly kind?: "Entitlement";
      /**
       * @description ID is the "natural identifier" for an object within its scope/namespace; it is normally unique across time but not space. That is, you can assume that the ID will not be reclaimed and reused after an object is deleted ("time"); however, it may collide with IDs for other object `kinds` or objects of the same `kind` within a different scope/namespace ("space").
       * @example dlz-f3a90de
       */
      readonly id?: string;
      metadata?: components["schemas"]["ObjectMeta"];
      /**
       * @description The unique external ID of the entitlement (this should be unique to customer)
       * @example 1111-2222-3333-4444
       */
      external_id?: string;
      /**
       * @description The name of the entitlement
       * @example Acme Prod Entitlement
       */
      name?: string;
      /**
       * @description The plan ID the entitlement
       * @example confluent-cloud-payg-prod
       */
      plan_id?: string;
      /**
       * @description The product ID of the entitlement
       * @example confluent-cloud-kafka-service-azure
       */
      product_id?: string;
      /**
       * @description The usage reporting ID of the entitlement (if usage reporting uses
       *     a different ID, otherwise, same as external_id)
       *
       * @example 1111-2222-3333-4444
       */
      usage_reporting_id?: string;
      /**
       * @description The resource ID of the entitlement
       * @example 1111-2222-3333-4444
       */
      resource_id?: string;
      /** @description The organization associated with this object. */
      organization?: components["schemas"]["ObjectReference"] & unknown;
    };
    /** @description `Entitlement` objects represent metadata about a marketplace entitlement. */
    "partner.v2.EntitlementList": {
      /**
       * @description APIVersion defines the schema version of this representation of a resource.
       * @enum {string}
       */
      readonly api_version: "partner/v2";
      /**
       * @description Kind defines the object this REST resource represents.
       * @enum {string}
       */
      readonly kind: "EntitlementList";
      metadata: components["schemas"]["ListMeta"];
      data: (components["schemas"]["partner.v2.Entitlement"] &
        Record<string, unknown>)[];
    };
    /** @description `Region` objects represent cloud provider regions available when placing Schema Registry clusters.
     *     The API allows you to list Schema Registry regions.
     *
     *
     *     Related guides:
     *     * [Confluent Cloud providers and region support](https://docs.confluent.io/cloud/current/stream-governance/packages.html#cloud-providers-and-region-support).
     *     * [srcm/v3 Migration Guide](https://docs.confluent.io/cloud/current/stream-governance/packages.html#deprecation-of-srcm-v2-clusters-and-regions-apis-and-upgrade-guide).
     *
     *
     *     ## The Regions Model
     *     <SchemaDefinition schemaRef="#/components/schemas/srcm.v2.Region" /> */
    "srcm.v2.Region": {
      /**
       * @description APIVersion defines the schema version of this representation of a resource.
       * @enum {string}
       */
      readonly api_version?: "srcm/v2";
      /**
       * @description Kind defines the object this REST resource represents.
       * @enum {string}
       */
      readonly kind?: "Region";
      /**
       * @description ID is the "natural identifier" for an object within its scope/namespace; it is normally unique across time but not space. That is, you can assume that the ID will not be reclaimed and reused after an object is deleted ("time"); however, it may collide with IDs for other object `kinds` or objects of the same `kind` within a different scope/namespace ("space").
       * @example dlz-f3a90de
       */
      readonly id?: string;
      metadata?: components["schemas"]["ObjectMeta"] & {
        /** @example https://api.confluent.cloud/srcm/v2/regions/sgreg-12345 */
        self?: unknown;
        /** @example crn://confluent.cloud/organization=9bb441c4-edef-46ac-8a41-c49e44a3fd9a/region=sgreg-12345 */
        resource_name?: unknown;
      };
      spec?: components["schemas"]["srcm.v2.RegionSpec"];
    };
    /** @description `Clusters` objects represent Schema Registry Clusters on Confluent Cloud.
     *
     *     The API allows you to list, create, read, and delete your Schema Registry clusters.
     *
     *
     *     Related guides:
     *     * [Confluent Cloud Schema Registry Cluster APIs](https://docs.confluent.io/cloud/current/stream-governance/clusters-regions-api.html#schema-registry-cluster-management).
     *     * [srcm/v3 Migration Guide](https://docs.confluent.io/cloud/current/stream-governance/packages.html#deprecation-of-srcm-v2-clusters-and-regions-apis-and-upgrade-guide).
     *
     *
     *     ## The Clusters Model
     *     <SchemaDefinition schemaRef="#/components/schemas/srcm.v2.Cluster" /> */
    "srcm.v2.Cluster": {
      /**
       * @description APIVersion defines the schema version of this representation of a resource.
       * @enum {string}
       */
      readonly api_version?: "srcm/v2";
      /**
       * @description Kind defines the object this REST resource represents.
       * @enum {string}
       */
      readonly kind?: "Cluster";
      /**
       * @description ID is the "natural identifier" for an object within its scope/namespace; it is normally unique across time but not space. That is, you can assume that the ID will not be reclaimed and reused after an object is deleted ("time"); however, it may collide with IDs for other object `kinds` or objects of the same `kind` within a different scope/namespace ("space").
       * @example dlz-f3a90de
       */
      readonly id?: string;
      metadata?: components["schemas"]["ObjectMeta"] & {
        /** @example https://api.confluent.cloud/srcm/v2/clusters/lsrc-12345 */
        self?: unknown;
        /** @example crn://confluent.cloud/organization=9bb441c4-edef-46ac-8a41-c49e44a3fd9a/environment=env-abc123/cloud-cluster=lsrc-12345 */
        resource_name?: unknown;
      };
      spec?: components["schemas"]["srcm.v2.ClusterSpec"];
      status?: components["schemas"]["srcm.v2.ClusterStatus"];
    };
    /** @description The status of the Cluster */
    "srcm.v2.ClusterStatus": {
      /**
       * @description The lifecyle phase of the cluster:
       *
       *       PROVISIONED:  cluster is provisioned;
       *
       *       PROVISIONING:  cluster provisioning is in progress;
       *
       *       FAILED:  provisioning failed
       *
       *     Note: Schema Registry Cluster Management is handled through the org/v2 Environments API as of srcm/v3.
       *
       * @example PROVISIONED
       */
      readonly phase: string;
    };
    /** @description `Region` objects represent cloud provider regions available when placing Schema Registry clusters.
     *     The API allows you to list Schema Registry regions.
     *
     *
     *     Related guides:
     *     * [Confluent Cloud providers and region support](https://docs.confluent.io/cloud/current/stream-governance/packages.html#cloud-providers-and-region-support).
     *     * [srcm/v3 Migration Guide](https://docs.confluent.io/cloud/current/stream-governance/packages.html#deprecation-of-srcm-v2-clusters-and-regions-apis-and-upgrade-guide).
     *
     *
     *     ## The Regions Model
     *     <SchemaDefinition schemaRef="#/components/schemas/srcm.v2.Region" /> */
    "srcm.v2.RegionList": {
      /**
       * @description APIVersion defines the schema version of this representation of a resource.
       * @enum {string}
       */
      readonly api_version: "srcm/v2";
      /**
       * @description Kind defines the object this REST resource represents.
       * @enum {string}
       */
      readonly kind: "RegionList";
      metadata: components["schemas"]["ListMeta"] & {
        /** @example https://api.confluent.cloud/srcm/v2/regions */
        first?: unknown;
        /** @example https://api.confluent.cloud/srcm/v2/regions?page_token=bcAOehAY8F16YD84Z1wT */
        last?: unknown;
        /** @example https://api.confluent.cloud/srcm/v2/regions?page_token=YIXRY97wWYmwzrax4dld */
        prev?: unknown;
        /** @example https://api.confluent.cloud/srcm/v2/regions?page_token=UvmDWOB1iwfAIBPj6EYb */
        next?: unknown;
      };
      /** @description A data property that contains an array of resource items. Each entry in the array is a separate resource. */
      data: (components["schemas"]["srcm.v2.Region"] & {
        spec: Record<string, unknown>;
      })[];
    };
    /** @description The desired state of the Region */
    "srcm.v2.RegionSpec": {
      /**
       * @description The display name.
       * @example Ohio (us-east-2)
       */
      readonly display_name?: string;
      /**
       * @description The cloud service provider that hosts the region.
       * @example AWS
       */
      readonly cloud?: string;
      /**
       * @description The region name.
       * @example us-east-2
       */
      readonly region_name?: string;
      /**
       * @description List of Stream Governance packages allowing placement in this region.
       * @example [
       *       "ESSENTIALS",
       *       "ADVANCED"
       *     ]
       */
      readonly packages?: string[];
    };
    /** @description `Clusters` objects represent Schema Registry Clusters on Confluent Cloud.
     *
     *     The API allows you to list, create, read, and delete your Schema Registry clusters.
     *
     *
     *     Related guides:
     *     * [Confluent Cloud Schema Registry Cluster APIs](https://docs.confluent.io/cloud/current/stream-governance/clusters-regions-api.html#schema-registry-cluster-management).
     *     * [srcm/v3 Migration Guide](https://docs.confluent.io/cloud/current/stream-governance/packages.html#deprecation-of-srcm-v2-clusters-and-regions-apis-and-upgrade-guide).
     *
     *
     *     ## The Clusters Model
     *     <SchemaDefinition schemaRef="#/components/schemas/srcm.v2.Cluster" /> */
    "srcm.v2.ClusterList": {
      /**
       * @description APIVersion defines the schema version of this representation of a resource.
       * @enum {string}
       */
      readonly api_version: "srcm/v2";
      /**
       * @description Kind defines the object this REST resource represents.
       * @enum {string}
       */
      readonly kind: "ClusterList";
      metadata: components["schemas"]["ListMeta"] & {
        /** @example https://api.confluent.cloud/srcm/v2/clusters */
        first?: unknown;
        /** @example https://api.confluent.cloud/srcm/v2/clusters?page_token=bcAOehAY8F16YD84Z1wT */
        last?: unknown;
        /** @example https://api.confluent.cloud/srcm/v2/clusters?page_token=YIXRY97wWYmwzrax4dld */
        prev?: unknown;
        /** @example https://api.confluent.cloud/srcm/v2/clusters?page_token=UvmDWOB1iwfAIBPj6EYb */
        next?: unknown;
      };
      /** @description A data property that contains an array of resource items. Each entry in the array is a separate resource. */
      data: (components["schemas"]["srcm.v2.Cluster"] & {
        spec: Record<string, unknown>;
      })[];
    };
    /** @description The desired state of the Cluster */
    "srcm.v2.ClusterSpec": {
      /**
       * @description The cluster name.
       * @example Stream Governance package
       */
      readonly display_name?: string;
      /**
       * @description The billing package.
       *
       *     Note: Clusters can be upgraded from ESSENTIALS to ADVANCED, but cannot be
       *     downgraded from ADVANCED to ESSENTIALS.
       *
       * @example ESSENTIALS
       */
      package?: string;
      /**
       * Format: uri
       * @description The cluster HTTP request URL.
       * @example https://psrc-00000.us-central1.gcp.confluent.cloud
       */
      readonly http_endpoint?: string;
      /** @description The environment to which this belongs. */
      environment?: components["schemas"]["GlobalObjectReference"];
      /** @description The region to which this belongs. */
      region?: components["schemas"]["GlobalObjectReference"];
    };
    /** @description `Clusters` objects represent Schema Registry Clusters on Confluent Cloud.
     *
     *     The API allows you to list and read your Schema Registry clusters.
     *
     *
     *     Related guide: [Confluent Cloud Schema Registry Cluster APIs](https://docs.confluent.io/cloud/current/stream-governance/clusters-regions-api.html#schema-registry-cluster-management).
     *
     *     ## The Clusters Model
     *     <SchemaDefinition schemaRef="#/components/schemas/srcm.v3.Cluster" /> */
    "srcm.v3.Cluster": {
      /**
       * @description APIVersion defines the schema version of this representation of a resource.
       * @enum {string}
       */
      readonly api_version?: "srcm/v3";
      /**
       * @description Kind defines the object this REST resource represents.
       * @enum {string}
       */
      readonly kind?: "Cluster";
      /**
       * @description ID is the "natural identifier" for an object within its scope/namespace; it is normally unique across time but not space. That is, you can assume that the ID will not be reclaimed and reused after an object is deleted ("time"); however, it may collide with IDs for other object `kinds` or objects of the same `kind` within a different scope/namespace ("space").
       * @example dlz-f3a90de
       */
      readonly id?: string;
      metadata?: components["schemas"]["ObjectMeta"] & {
        /** @example https://api.confluent.cloud/srcm/v3/clusters/lsrc-12345 */
        self?: unknown;
        /** @example crn://confluent.cloud/organization=9bb441c4-edef-46ac-8a41-c49e44a3fd9a/environment=env-abc123/cloud-cluster=lsrc-12345 */
        resource_name?: unknown;
      };
      spec?: components["schemas"]["srcm.v3.ClusterSpec"];
      status?: components["schemas"]["srcm.v3.ClusterStatus"];
    };
    /** @description The status of the Cluster */
    "srcm.v3.ClusterStatus": {
      /**
       * @description The lifecyle phase of the cluster:
       *
       *       PROVISIONED:  cluster is provisioned;
       *
       *       PROVISIONING:  cluster provisioning is in progress;
       *
       *       FAILED:  provisioning failed
       *
       * @example PROVISIONED
       */
      readonly phase: string;
    };
    /** @description `Clusters` objects represent Schema Registry Clusters on Confluent Cloud.
     *
     *     The API allows you to list and read your Schema Registry clusters.
     *
     *
     *     Related guide: [Confluent Cloud Schema Registry Cluster APIs](https://docs.confluent.io/cloud/current/stream-governance/clusters-regions-api.html#schema-registry-cluster-management).
     *
     *     ## The Clusters Model
     *     <SchemaDefinition schemaRef="#/components/schemas/srcm.v3.Cluster" /> */
    "srcm.v3.ClusterList": {
      /**
       * @description APIVersion defines the schema version of this representation of a resource.
       * @enum {string}
       */
      readonly api_version: "srcm/v3";
      /**
       * @description Kind defines the object this REST resource represents.
       * @enum {string}
       */
      readonly kind: "ClusterList";
      metadata: components["schemas"]["ListMeta"] & {
        /** @example https://api.confluent.cloud/srcm/v3/clusters */
        first?: unknown;
        /** @example https://api.confluent.cloud/srcm/v3/clusters?page_token=bcAOehAY8F16YD84Z1wT */
        last?: unknown;
        /** @example https://api.confluent.cloud/srcm/v3/clusters?page_token=YIXRY97wWYmwzrax4dld */
        prev?: unknown;
        /** @example https://api.confluent.cloud/srcm/v3/clusters?page_token=UvmDWOB1iwfAIBPj6EYb */
        next?: unknown;
      };
      /** @description A data property that contains an array of resource items. Each entry in the array is a separate resource. */
      data: (components["schemas"]["srcm.v3.Cluster"] & {
        spec: Record<string, unknown>;
      })[];
    };
    /** @description The desired state of the Cluster */
    "srcm.v3.ClusterSpec": {
      /**
       * @description The cluster name.
       * @example Stream Governance package
       */
      readonly display_name?: string;
      /**
       * @description The billing package.
       *
       *     Note: Clusters can be upgraded from ESSENTIALS to ADVANCED, but cannot be
       *     downgraded from ADVANCED to ESSENTIALS.
       *
       * @example ESSENTIALS
       */
      package?: string;
      /**
       * Format: uri
       * @description The cluster HTTP request URL.
       * @example https://psrc-00000.us-central1.gcp.confluent.cloud
       */
      readonly http_endpoint?: string;
      /**
       * Format: uri
       * @description The cluster's catalog HTTP request URL.
       * @example https://psrc-00000.us-central1.gcp.confluent.cloud
       */
      readonly catalog_http_endpoint?: string;
      /**
       * Format: uri
       * @description The cluster's private HTTP request URL.
       *
       *     DEPRECATED - Please use the `private_networking_config.regional_endpoints` attribute instead,
       *     which supersedes the `private_http_endpoint` attribute.
       *
       * @example https://lsrc-abc.us-central-1.aws.private.confluent.cloud
       */
      readonly private_http_endpoint?: string;
      /**
       * @description Available HTTP request URLs for private connectivity.
       * @example {
       *       "regional_endpoints": {
       *         "us-central-1": "https://lsrc-abc.us-central-1.aws.private.confluent.cloud",
       *         "us-west-2": "https://lsrc-abc.us-west-2.aws.private.confluent.cloud"
       *       }
       *     }
       */
      readonly private_networking_config?: {
        /** @description A map of region identifiers to their corresponding private HTTP request URL. */
        regional_endpoints?: {
          [key: string]: string;
        };
      };
      /**
       * @description The cloud service provider in which the cluster is running.
       * @example GCP
       */
      cloud?: string;
      /**
       * @description The cloud service provider region where the cluster is running.
       * @example us-east4
       */
      region?: string;
      /** @description The environment to which this belongs. */
      environment?: components["schemas"]["GlobalObjectReference"];
    };
    /** @description Cluster Config */
    ClusterConfig: {
      /**
       * Format: int32
       * @description Maximum number of registered schemas allowed
       * @example 20000
       */
      maxSchemas?: number;
      /**
       * Format: int32
       * @description Maximum number of allowed requests per second
       * @example 25
       */
      maxRequestsPerSec?: number;
    };
    /** @description Compatibility check response */
    CompatibilityCheckResponse: {
      /** @description Whether the compared schemas are compatible */
      is_compatible?: boolean;
      /**
       * @description Error messages
       * @example []
       */
      messages?: string[];
    };
    /** @description Error message of this operation */
    ErrorMessage: {
      /**
       * Format: int32
       * @description The error code
       */
      error_code?: number;
      /** @description The error message */
      message?: string;
    };
    /** @description Exporter register request */
    RegisterExporterRequest: {
      /** @description References to other schemas */
      references?: components["schemas"]["ExporterReference"][];
    };
    /** @description Schema register request */
    RegisterSchemaRequest: {
      /**
       * Format: int32
       * @description Version number
       */
      version?: number;
      /**
       * Format: int32
       * @description Globally unique identifier of the schema
       */
      id?: number;
      /** @description Schema type */
      schemaType?: string;
      /** @description References to other schemas */
      references?: components["schemas"]["SchemaReference"][];
      /** @description Schema definition string */
      schema?: string;
      metadata?: components["schemas"]["Metadata"];
      ruleSet?: components["schemas"]["RuleSet"];
    };
    /** @description Exporter update request */
    ExporterUpdateRequest: {
      /**
       * @description Context type of the exporter. One of CUSTOM, NONE or AUTO (default)
       * @example CUSTOM
       */
      contextType?: string;
      /**
       * @description Customized context of the exporter if contextType equals CUSTOM.
       * @example User
       */
      context?: string;
      /** @description Name of each exporter subject */
      subjects?: string[];
      /** @description Format string for the subject name in the destination cluster, which may contain ${subject} as a placeholder for the originating subject name. For example, dc_${subject} for the subject orders will map to the destination subject name dc_orders. */
      subjectRenameFormat?: string;
      /** @description The map containing exporter’s configurations */
      config?: {
        [key: string]: string;
      };
    };
    /** @description Exporter status get request */
    ExporterStatusResponse: {
      /**
       * @description Name of exporter.
       * @example test-exporter
       */
      name?: string;
      /**
       * @description State of the exporter. Could be STARTING, RUNNING or PAUSED
       * @example RUNNING
       */
      state?: string;
      /**
       * Format: int64
       * @description Offset of the exporter
       * @example 100
       */
      offset?: number;
      /**
       * Format: int64
       * @description Timestamp of the exporter
       * @example 1631206325
       */
      ts?: number;
      /**
       * @description Error trace of the exporter
       * @example
       */
      trace?: string;
    };
    /** @description The map containing exporter’s configurations */
    ExporterConfigResponse: {
      /**
       * @description Config SR URL
       * @example <Physical SR Endpoint>
       */
      "schema.registry.url"?: string;
      /**
       * @description Config SR Auth
       * @example USER_INFO
       */
      "basic.auth.credentials.source"?: string;
      /** @description Config SR User Info */
      "basic.auth.user.info"?: string;
    };
    /** @description Schema reference */
    SchemaReference: {
      /**
       * @description Reference name
       * @example io.confluent.kafka.example.User
       */
      name?: string;
      /**
       * @description Name of the referenced subject
       * @example User
       */
      subject?: string;
      /**
       * Format: int32
       * @description Version number of the referenced subject
       * @example 1
       */
      version?: number;
    };
    /** @description The format for a typical exporter object */
    ExporterReference: {
      /**
       * @description Name of the exporter
       * @example test-exporter
       */
      name?: string;
      /**
       * @description Context type of the exporter. One of CUSTOM, NONE or AUTO (default)
       * @example CUSTOM
       */
      contextType?: string;
      /**
       * @description Customized context of the exporter if contextType equals CUSTOM.
       * @example User
       */
      context?: string;
      /** @description Name of each exporter subject */
      subjects?: string[];
      /** @description Format string for the subject name in the destination cluster, which may contain ${subject} as a placeholder for the originating subject name. For example, dc_${subject} for the subject orders will map to the destination subject name dc_orders. */
      subjectRenameFormat?: string;
      /** @description The map containing exporter’s configurations */
      config?: {
        [key: string]: string;
      };
    };
    /** @description Config */
    Config: {
      /** @description If alias is specified, then this subject is an alias for the subject
       *     named by the alias. That means that any reference to this subject
       *     will be replaced by the alias. */
      alias?: string;
      /** @description If true, then schemas are automatically normalized when registered or
       *     when passed during lookups. This means that clients do not have to
       *     pass the "normalize" query parameter to have normalization occur. */
      normalize?: boolean;
      /**
       * @description Compatibility Level
       * @example FULL_TRANSITIVE
       */
      compatibilityLevel?: string;
      /** @description Only schemas that belong to the same compatibility group will be
       *     checked for compatibility. */
      compatibilityGroup?: string;
      /** @description Default value for the metadata to be used during schema registration. */
      defaultMetadata?: {
        /** @description The metadata properties and their new values */
        properties?: Record<string, unknown>;
      };
      /** @description Override value for the metadata to be used during schema registration. */
      overrideMetadata?: {
        /** @description The metadata properties and their new values */
        properties?: Record<string, unknown>;
      };
      /** @description Default value for the ruleSet to be used during schema registration. */
      defaultRuleSet?: {
        /** @description The metadata properties and their new values */
        properties?: Record<string, unknown>;
      };
      /** @description Override value for the ruleSet to be used during schema registration. */
      overrideRuleSet?: {
        /** @description The metadata properties and their new values */
        properties?: Record<string, unknown>;
      };
    };
    /** @description Config update request */
    ConfigUpdateRequest: {
      /** @description If alias is specified, then this subject is an alias for the subject
       *     named by the alias. That means that any reference to this subject
       *     will be replaced by the alias. */
      alias?: string;
      /** @description If true, then schemas are automatically normalized when registered
       *     or when passed during lookups. This means that clients do not have
       *     to pass the "normalize" query parameter to have normalization occur. */
      normalize?: boolean;
      /**
       * @description Compatibility Level
       * @example FULL_TRANSITIVE
       */
      compatibility?: string;
      /** @description Only schemas that belong to the same compatibility group will be
       *     checked for compatibility. */
      compatibilityGroup?: string;
      /** @description Default value for the metadata to be used during schema registration. */
      defaultMetadata?: {
        /** @description The metadata properties and their new values */
        properties?: Record<string, unknown>;
      };
      /** @description Override value for the metadata to be used during schema registration. */
      overrideMetadata?: {
        /** @description The metadata properties and their new values */
        properties?: Record<string, unknown>;
      };
      /** @description Default value for the ruleSet to be used during schema registration. */
      defaultRuleSet?: {
        /** @description The metadata properties and their new values */
        properties?: Record<string, unknown>;
      };
      /** @description Override value for the ruleSet to be used during schema registration. */
      overrideRuleSet?: {
        /** @description The metadata properties and their new values */
        properties?: Record<string, unknown>;
      };
    };
    /** @description Schema Registry operating mode */
    Mode: {
      /**
       * @description Schema Registry operating mode
       * @example READWRITE
       */
      mode?: string;
    };
    /** @description Mode update request */
    ModeUpdateRequest: {
      /**
       * @description Schema Registry operating mode
       * @example READWRITE
       */
      mode?: string;
    };
    /** @description Schema definition */
    SchemaString: {
      /**
       * @description Schema type
       * @example AVRO
       */
      schemaType?: string;
      /**
       * @description Schema string identified by the ID
       * @example {"schema": "{"type": "string"}"}
       */
      schema?: string;
      /** @description References to other schemas */
      references?: components["schemas"]["SchemaReference"][];
      /**
       * Format: int32
       * @description Maximum ID
       * @example 1
       */
      maxId?: number;
    };
    /** @description Schema */
    Schema: {
      /**
       * @description Name of the subject
       * @example User
       */
      subject?: string;
      /**
       * Format: int32
       * @description Version number
       * @example 1
       */
      version?: number;
      /**
       * Format: int32
       * @description Globally unique identifier of the schema
       * @example 100001
       */
      id?: number;
      /**
       * @description Schema type
       * @example AVRO
       */
      schemaType?: string;
      /** @description References to other schemas */
      references?: components["schemas"]["SchemaReference"][];
      /**
       * @description Schema definition string
       * @example {"schema": "{"type": "string"}"}
       */
      schema?: string;
      metadata?: components["schemas"]["Metadata"];
      ruleSet?: components["schemas"]["RuleSet"];
    };
    /** @description Subject version pair */
    SubjectVersion: {
      /**
       * @description Name of the subject
       * @example User
       */
      subject?: string;
      /**
       * Format: int32
       * @description Version number
       * @example 1
       */
      version?: number;
    };
    /** @description Exporter register response */
    ExporterResponse: {
      /**
       * @description Name of the exporter
       * @example test-exporter
       */
      name?: string;
    };
    /** @description Schema register response */
    RegisterSchemaResponse: {
      /**
       * Format: int32
       * @description Globally unique identifier of the schema
       * @example 100001
       */
      id?: number;
    };
    /** @example {
     *       "kekName": "kekName",
     *       "keyMaterial": "keyMaterial",
     *       "deleted": true,
     *       "subject": "subject",
     *       "encryptedKeyMaterial": "encryptedKeyMaterial",
     *       "version": 0,
     *       "algorithm": "AES128_GCM",
     *       "ts": 6
     *     } */
    Dek: {
      /** @description Kek name of the dek */
      kekName?: string;
      /** @description Subject of the dek */
      subject?: string;
      /**
       * Format: int32
       * @description Version of the dek
       */
      version?: number;
      /**
       * @description Algorithm of the dek
       * @enum {string}
       */
      algorithm?: "AES128_GCM" | "AES256_GCM" | "AES256_SIV";
      /** @description Encrypted key material of the dek */
      encryptedKeyMaterial?: string;
      /** @description Raw key material of the dek */
      keyMaterial?: string;
      /**
       * Format: int64
       * @description Timestamp of the dek
       */
      ts?: number;
      /** @description Whether the dek is deleted */
      deleted?: boolean;
    };
    /** @example {
     *       "subject": "subject",
     *       "encryptedKeyMaterial": "encryptedKeyMaterial",
     *       "version": 0,
     *       "algorithm": "AES128_GCM"
     *     } */
    CreateDekRequest: {
      /** @description Subject of the dek */
      subject?: string;
      /**
       * Format: int32
       * @description Version of the dek
       */
      version?: number;
      /**
       * @description Algorithm of the dek
       * @enum {string}
       */
      algorithm?: "AES128_GCM" | "AES256_GCM" | "AES256_SIV";
      /** @description Encrypted key material of the dek */
      encryptedKeyMaterial?: string;
      /** @description Whether the dek is deleted */
      deleted?: boolean;
    };
    /** @example {
     *       "kmsProps": {
     *         "key": "kmsProps"
     *       },
     *       "shared": true,
     *       "deleted": true,
     *       "name": "name",
     *       "doc": "doc",
     *       "kmsKeyId": "kmsKeyId",
     *       "kmsType": "kmsType",
     *       "ts": 0
     *     } */
    Kek: {
      /** @description Name of the kek */
      name?: string;
      /** @description KMS type of the kek */
      kmsType?: string;
      /** @description KMS key ID of the kek */
      kmsKeyId?: string;
      /** @description Properties of the kek */
      kmsProps?: {
        [key: string]: string;
      };
      /** @description Description of the kek */
      doc?: string;
      /** @description Whether the kek is shared */
      shared?: boolean;
      /**
       * Format: int64
       * @description Timestamp of the kek
       */
      ts?: number;
      /** @description Whether the kek is deleted */
      deleted?: boolean;
    };
    /** @example {
     *       "kmsProps": {
     *         "key": "kmsProps"
     *       },
     *       "shared": true,
     *       "name": "name",
     *       "doc": "doc",
     *       "kmsKeyId": "kmsKeyId",
     *       "kmsType": "kmsType"
     *     } */
    CreateKekRequest: {
      /** @description Name of the kek */
      name?: string;
      /** @description KMS type of the kek */
      kmsType?: string;
      /** @description KMS key ID of the kek */
      kmsKeyId?: string;
      /** @description Properties of the kek */
      kmsProps?: {
        [key: string]: string;
      };
      /** @description Description of the kek */
      doc?: string;
      /** @description Whether the kek is shared */
      shared?: boolean;
      /** @description Whether the kek is deleted */
      deleted?: boolean;
    };
    /** @example {
     *       "kmsProps": {
     *         "key": "kmsProps"
     *       },
     *       "shared": true,
     *       "doc": "doc"
     *     } */
    UpdateKekRequest: {
      /** @description Properties of the kek */
      kmsProps?: {
        [key: string]: string;
      };
      /** @description Description of the kek */
      doc?: string;
      /** @description Whether the kek is shared */
      shared?: boolean;
    };
    /** @description User-defined metadata */
    Metadata: {
      tags?: {
        [key: string]: string[];
      };
      properties?: {
        [key: string]: string;
      };
      sensitive?: string[];
    } | null;
    /** @description Schema rule set */
    RuleSet: {
      migrationRules?: components["schemas"]["Rule"][];
      domainRules?: components["schemas"]["Rule"][];
    } | null;
    /** @description Rule */
    Rule: {
      /** @description Rule name */
      name?: string;
      /** @description Rule doc */
      doc?: string;
      /**
       * @description Rule kind
       * @enum {string}
       */
      kind?: "TRANSFORM" | "CONDITION";
      /**
       * @description Rule mode
       * @enum {string}
       */
      mode?:
        | "UPGRADE"
        | "DOWNGRADE"
        | "UPDOWN"
        | "WRITE"
        | "READ"
        | "WRITEREAD";
      /** @description Rule type */
      type?: string;
      /** @description The tags to which this rule applies */
      tags?: string[];
      /** @description Optional params for the rule */
      params?: {
        [key: string]: string;
      };
      /** @description Rule expression */
      expr?: string;
      /** @description Rule action on success */
      onSuccess?: string;
      /** @description Rule action on failure */
      onFailure?: string;
      /** @description Whether the rule is disabled */
      disabled?: boolean;
    };
    Tag: {
      /** @description The tag name */
      typeName?: string;
      /** @description The tag attributes */
      attributes?: Record<string, unknown>;
      /** @description The internal entity guid */
      entityGuid?: string;
      /**
       * @description The entity status
       * @enum {string}
       */
      entityStatus?: "ACTIVE" | "DELETED" | "PURGED";
      /** @description Whether to propagate the tag */
      propagate?: boolean;
      /** @description The validity periods */
      validityPeriods?: components["schemas"]["TimeBoundary"][];
      /** @description Whether to remove propagations on entity delete */
      removePropagationsOnEntityDelete?: boolean;
      /** @description The entity type */
      entityType?: string;
      /** @description The qualified name of the entity */
      entityName?: string;
    };
    TimeBoundary: {
      /** @description The start time of format yyyy/MM/dd HH:mm:ss */
      startTime?: string;
      /** @description The end time of format yyyy/MM/dd HH:mm:ss */
      endTime?: string;
      /** @description The time zone (see java.util.TimeZone) */
      timeZone?: string;
    };
    Classification: {
      /** @description The tag name */
      typeName?: string;
      /** @description The tag attributes */
      attributes?: {
        [key: string]: Record<string, unknown>;
      };
      /** @description The internal entity guid */
      entityGuid?: string;
      /**
       * @description The entity status
       * @enum {string}
       */
      entityStatus?: "ACTIVE" | "DELETED" | "PURGED";
      /** @description Whether to propagate the tag */
      propagate?: boolean;
      /** @description The validity periods */
      validityPeriods?: components["schemas"]["TimeBoundary"][];
      /** @description Whether to remove propagations on entity delete */
      removePropagationsOnEntityDelete?: boolean;
    };
    ClassificationHeader: {
      /** @description The tag name */
      typeName?: string;
      /** @description The internal entity guid */
      entityGuid?: string;
      /**
       * @description The entity status
       * @enum {string}
       */
      entityStatus?: "ACTIVE" | "DELETED" | "PURGED";
      /** @description Whether to propagate the tag */
      propagate?: boolean;
      /** @description Whether to remove propagations on entity delete */
      removePropagationsOnEntityDelete?: boolean;
    };
    /** @description The entity */
    Entity: {
      /** @description The type name */
      typeName?: string;
      /** @description The type attributes */
      attributes?: Record<string, unknown>;
      /** @description The internal guid */
      guid?: string;
      /** @description The home id */
      homeId?: string;
      /** @description Whether is a proxy */
      isProxy?: boolean;
      /** @description Whether is incomplete */
      isIncomplete?: boolean;
      /**
       * Format: int32
       * @description The provenance type
       */
      provenanceType?: number;
      /**
       * @description The status
       * @enum {string}
       */
      status?: "ACTIVE" | "DELETED" | "PURGED";
      /** @description The creator */
      createdBy?: string;
      /** @description The updater */
      updatedBy?: string;
      /**
       * Format: int64
       * @description The create time
       */
      createTime?: number;
      /**
       * Format: int64
       * @description The update time
       */
      updateTime?: number;
      /**
       * Format: int32
       * @description The version
       */
      version?: number;
      /** @description The relationship attributes */
      relationshipAttributes?: Record<string, unknown>;
      /** @description The classifications (tags) */
      classifications?: components["schemas"]["Classification"][];
      /** @description The meanings */
      meanings?: components["schemas"]["TermAssignmentHeader"][];
      /** @description The custom attributes */
      customAttributes?: {
        [key: string]: string;
      };
      /** @description The business attributes */
      businessAttributes?: {
        [key: string]: Record<string, unknown>;
      };
      /** @description The labels */
      labels?: string[];
      /** @description Whether is a proxy */
      proxy?: boolean;
    };
    EntityWithExtInfo: {
      /** @description The referred entities */
      referredEntities?: {
        [key: string]: components["schemas"]["Entity"];
      };
      entity?: components["schemas"]["Entity"];
    };
    /** @description The type name */
    EntityPartialUpdateResponse: {
      mutatedEntities?: components["schemas"]["EntityPartialUpdate"];
    };
    TermAssignmentHeader: {
      /** @description The term guid */
      termGuid?: string;
      /** @description The relation guid */
      relationGuid?: string;
      /** @description The description */
      description?: string;
      /** @description The display text */
      displayText?: string;
      /** @description The expression */
      expression?: string;
      /** @description The creator */
      createdBy?: string;
      /** @description The steward */
      steward?: string;
      /** @description The source */
      source?: string;
      /**
       * Format: int32
       * @description The confidence
       */
      confidence?: number;
      /**
       * @description The status
       * @enum {string}
       */
      status?:
        | "DISCOVERED"
        | "PROPOSED"
        | "IMPORTED"
        | "VALIDATED"
        | "DEPRECATED"
        | "OBSOLETE"
        | "OTHER";
    };
    EntityHeader: {
      /** @description The type name */
      typeName?: string;
      /** @description The attributes */
      attributes?: {
        [key: string]: unknown;
      };
      /** @description The internal guid */
      guid?: string;
      /**
       * @description The status
       * @enum {string}
       */
      status?: "ACTIVE" | "DELETED" | "PURGED";
      /** @description The display text */
      displayText?: string;
      /** @description The classification (tag) names */
      classificationNames?: string[];
      /** @description The classifications (tags) */
      classifications?: components["schemas"]["Classification"][];
      /** @description The meaning names */
      meaningNames?: string[];
      /** @description The meanings */
      meanings?: components["schemas"]["TermAssignmentHeader"][];
      /** @description Whether is incomplete */
      isIncomplete?: boolean;
      /** @description The labels */
      labels?: string[];
    };
    /** @description The updated entities. */
    EntityPartialUpdate: {
      /** @description The updated entities. */
      UPDATE?: components["schemas"]["PartialUpdateParams"][];
    };
    PartialUpdateParams: {
      /** @description The type name */
      typeName?: string;
      /** @description The attributes */
      attributes?: Record<string, unknown>;
      /** @description The internal guid */
      guid?: string;
      /**
       * @description The status
       * @enum {string}
       */
      status?: "ACTIVE" | "DELETED" | "PURGED";
      /** @description The classification (tag) names */
      classificationNames?: string[];
      /** @description The classifications (tags) */
      classifications?: components["schemas"]["ClassificationHeader"][];
      /** @description Whether is incomplete */
      isIncomplete?: boolean;
    };
    /** @description Search paramas to filter results */
    SearchParams: {
      /** @description Whether to include deleted */
      includeDeleted?: boolean;
      /**
       * Format: int32
       * @description The limit
       */
      limit?: number;
      /**
       * Format: int32
       * @description The offset
       */
      offset?: number;
    };
    SearchResult: {
      searchParameters?: components["schemas"]["SearchParams"];
      /** @description The types */
      types?: string[];
      /** @description The entities */
      entities?: components["schemas"]["EntityHeader"][];
      /** @description The referred entities */
      referredEntities?: {
        [key: string]: components["schemas"]["EntityHeader"];
      };
    };
    AttributeDef: {
      /** @description The name */
      name?: string;
      /** @description The type name */
      typeName?: string;
      /** @description Whether is optional */
      isOptional?: boolean;
      /**
       * @description The cardinality
       * @enum {string}
       */
      cardinality?: "SINGLE" | "LIST" | "SET";
      /**
       * Format: int32
       * @description The values min count
       */
      valuesMinCount?: number;
      /**
       * Format: int32
       * @description The values max count
       */
      valuesMaxCount?: number;
      /** @description Whether is unique */
      isUnique?: boolean;
      /** @description Whether is indexable */
      isIndexable?: boolean;
      /** @description Whether to include in notifications */
      includeInNotification?: boolean;
      /** @description The default value */
      defaultValue?: string;
      /** @description The description */
      description?: string;
      /**
       * Format: int32
       * @description The search weight
       */
      searchWeight?: number;
      /**
       * @description The index type
       * @enum {string}
       */
      indexType?: "DEFAULT" | "STRING";
      /** @description The constraints */
      constraints?: components["schemas"]["ConstraintDef"][];
      /** @description The options */
      options?: {
        [key: string]: string;
      };
      /** @description The display name */
      displayName?: string;
    };
    ConstraintDef: {
      /** @description The type */
      type?: string;
      /** @description The params */
      params?: {
        [key: string]: Record<string, unknown>;
      };
    };
    TagDef: {
      /**
       * @description The category
       * @enum {string}
       */
      category?:
        | "PRIMITIVE"
        | "OBJECT_ID_TYPE"
        | "ENUM"
        | "STRUCT"
        | "CLASSIFICATION"
        | "ENTITY"
        | "ARRAY"
        | "MAP"
        | "RELATIONSHIP"
        | "BUSINESS_METADATA";
      /** @description The internal guid */
      guid?: string;
      /** @description The creator */
      createdBy?: string;
      /** @description The updater */
      updatedBy?: string;
      /**
       * Format: int64
       * @description The create time
       */
      createTime?: number;
      /**
       * Format: int64
       * @description The update time
       */
      updateTime?: number;
      /**
       * Format: int32
       * @description The version
       */
      version?: number;
      /** @description The name */
      name?: string;
      /** @description The description */
      description?: string;
      /** @description The type version */
      typeVersion?: string;
      /** @description The service type */
      serviceType?: string;
      /** @description The options */
      options?: {
        [key: string]: string;
      };
      /** @description The attribute definitions */
      attributeDefs?: components["schemas"]["AttributeDef"][];
      /** @description The supertypes */
      superTypes?: string[];
      /** @description The entity types */
      entityTypes?: string[];
      /** @description The subtypes */
      subTypes?: string[];
    };
    BusinessMetadataResponse: {
      /** @description The business metadata name */
      typeName?: string;
      /** @description The business metadata attributes */
      attributes?: Record<string, unknown>;
      /** @description The entity type */
      entityType?: string;
      /** @description The qualified name of the entity */
      entityName?: string;
      error?: components["schemas"]["ErrorMessage"];
    };
    BusinessMetadata: {
      /** @description The business metadata name */
      typeName?: string;
      /** @description The business metadata attributes */
      attributes?: Record<string, unknown>;
      /** @description The entity type */
      entityType?: string;
      /** @description The qualified name of the entity */
      entityName?: string;
    };
    BusinessMetadataDefResponse: {
      /**
       * @description The category
       * @enum {string}
       */
      category?:
        | "PRIMITIVE"
        | "OBJECT_ID_TYPE"
        | "ENUM"
        | "STRUCT"
        | "CLASSIFICATION"
        | "ENTITY"
        | "ARRAY"
        | "MAP"
        | "RELATIONSHIP"
        | "BUSINESS_METADATA";
      /** @description The internal guid */
      guid?: string;
      /** @description The creator */
      createdBy?: string;
      /** @description The updater */
      updatedBy?: string;
      /**
       * Format: int64
       * @description The create time
       */
      createTime?: number;
      /**
       * Format: int64
       * @description The update time
       */
      updateTime?: number;
      /**
       * Format: int32
       * @description The version
       */
      version?: number;
      /** @description The name */
      name?: string;
      /** @description The description */
      description?: string;
      /** @description The type version */
      typeVersion?: string;
      /** @description The service type */
      serviceType?: string;
      /** @description The options */
      options?: {
        [key: string]: string;
      };
      /** @description The attribute definitions */
      attributeDefs?: components["schemas"]["AttributeDef"][];
      error?: components["schemas"]["ErrorMessage"];
    };
    BusinessMetadataDef: {
      /**
       * @description The category
       * @enum {string}
       */
      category?:
        | "PRIMITIVE"
        | "OBJECT_ID_TYPE"
        | "ENUM"
        | "STRUCT"
        | "CLASSIFICATION"
        | "ENTITY"
        | "ARRAY"
        | "MAP"
        | "RELATIONSHIP"
        | "BUSINESS_METADATA";
      /** @description The internal guid */
      guid?: string;
      /** @description The creator */
      createdBy?: string;
      /** @description The updater */
      updatedBy?: string;
      /**
       * Format: int64
       * @description The create time
       */
      createTime?: number;
      /**
       * Format: int64
       * @description The update time
       */
      updateTime?: number;
      /**
       * Format: int32
       * @description The version
       */
      version?: number;
      /** @description The name */
      name?: string;
      /** @description The description */
      description?: string;
      /** @description The type version */
      typeVersion?: string;
      /** @description The service type */
      serviceType?: string;
      /** @description The options */
      options?: {
        [key: string]: string;
      };
      /** @description The attribute definitions */
      attributeDefs?: components["schemas"]["AttributeDef"][];
    };
    TagResponse: {
      /** @description The tag name */
      typeName?: string;
      /** @description The tag attributes */
      attributes?: Record<string, unknown>;
      /** @description The internal entity guid */
      entityGuid?: string;
      /**
       * @description The entity status
       * @enum {string}
       */
      entityStatus?: "ACTIVE" | "DELETED" | "PURGED";
      /** @description Whether to propagate the tag */
      propagate?: boolean;
      /** @description The validity periods */
      validityPeriods?: components["schemas"]["TimeBoundary"][];
      /** @description Whether to remove propagations on entity delete */
      removePropagationsOnEntityDelete?: boolean;
      /** @description The entity type */
      entityType?: string;
      /** @description The qualified name of the entity */
      entityName?: string;
      error?: components["schemas"]["ErrorMessage"];
    };
    TagDefResponse: {
      /**
       * @description The category
       * @enum {string}
       */
      category?:
        | "PRIMITIVE"
        | "OBJECT_ID_TYPE"
        | "ENUM"
        | "STRUCT"
        | "CLASSIFICATION"
        | "ENTITY"
        | "ARRAY"
        | "MAP"
        | "RELATIONSHIP"
        | "BUSINESS_METADATA";
      /** @description The internal guid */
      guid?: string;
      /** @description The creator */
      createdBy?: string;
      /** @description The updater */
      updatedBy?: string;
      /**
       * Format: int64
       * @description The create time
       */
      createTime?: number;
      /**
       * Format: int64
       * @description The update time
       */
      updateTime?: number;
      /**
       * Format: int32
       * @description The version
       */
      version?: number;
      /** @description The name */
      name?: string;
      /** @description The description */
      description?: string;
      /** @description The type version */
      typeVersion?: string;
      /** @description The service type */
      serviceType?: string;
      /** @description The options */
      options?: {
        [key: string]: string;
      };
      /** @description The attribute definitions */
      attributeDefs?: components["schemas"]["AttributeDef"][];
      /** @description The supertypes */
      superTypes?: string[];
      /** @description The entity types */
      entityTypes?: string[];
      /** @description The subtypes */
      subTypes?: string[];
      error?: components["schemas"]["ErrorMessage"];
    };
    /** @description `ProviderSharedResource` object contains details of the data stream
     *     (topic, schema registry subjects, sharing metadata) that you have shared through Stream Sharing.
     *
     *
     *     ## The Provider Shared Resources Model
     *     <SchemaDefinition schemaRef="#/components/schemas/cdx.v1.ProviderSharedResource" /> */
    "cdx.v1.ProviderSharedResource": {
      /**
       * @description APIVersion defines the schema version of this representation of a resource.
       * @enum {string}
       */
      readonly api_version?: "cdx/v1";
      /**
       * @description Kind defines the object this REST resource represents.
       * @enum {string}
       */
      readonly kind?: "ProviderSharedResource";
      /**
       * @description ID is the "natural identifier" for an object within its scope/namespace; it is normally unique across time but not space. That is, you can assume that the ID will not be reclaimed and reused after an object is deleted ("time"); however, it may collide with IDs for other object `kinds` or objects of the same `kind` within a different scope/namespace ("space").
       * @example dlz-f3a90de
       */
      readonly id?: string;
      metadata?: components["schemas"]["ObjectMeta"] & {
        /** @example https://api.confluent.cloud/cdx/v1/provider-shared-resources/psr-12345 */
        self?: unknown;
        /** @example crn://confluent.cloud/organization=9bb441c4-edef-46ac-8a41-c49e44a3fd9a/provider-shared-resource=psr-12345 */
        resource_name?: unknown;
      };
      /**
       * Format: uri
       * @description Deprecated please use resources attribute.
       * @example crn://confluent.cloud/environment=env-123/cloud-cluster=lkc-1111aaa/kafka=lkc-111aaa/topic=my.topic
       */
      crn?: string;
      /** @description List of resource crns that are shared together */
      resources?: string[];
      /**
       * @description Shared resource display name
       * @example Stock Trades
       */
      display_name?: string;
      /**
       * @description Description of shared resource
       * @example This topic provides realtime data for the orders placed through the website
       */
      readonly description?: string;
      /**
       * @description list of tags
       * @example [
       *       "recent",
       *       "pending"
       *     ]
       */
      readonly tags?: string[];
      /** @description List of schemas in JSON format. This field is work in progress and subject to changes. */
      readonly schemas?: (components["schemas"]["cdx.v1.Schema"] &
        Record<string, unknown>)[];
      /**
       * @description Shared resource's organization description
       * @example ABC Corp is the biggest online retailer
       */
      organization_description?: string;
      /**
       * Format: email
       * @description Email of contact person from the organization
       * @example jane.doe@example.com
       */
      organization_contact?: string;
      /**
       * Format: uri
       * @description Resource logo url
       * @example https://confluent.cloud/api/cdx/v1/provider-shared-resources/sr-123/images/logo
       */
      readonly logo_url?: string;
      /**
       * @description Organization to which the shared resource belongs. Deprecated
       * @example ABC Corp
       */
      readonly organization_name?: unknown;
      /**
       * @description The environment name of the shared resource. Deprecated
       * @example Public Env
       */
      readonly environment_name?: string;
      /**
       * @description The cluster display name of the shared resource. Deprecated
       * @example Published Trades
       */
      readonly cluster_name?: string;
      /** @description The cloud cluster to which this belongs. */
      cloud_cluster?: components["schemas"]["EnvScopedObjectReference"];
    };
    /** @description `ProviderShare` object respresents the share that you have created through Stream Sharing.
     *
     *
     *     Related guide: [Provider Stream Shares in Confluent Cloud](https://docs.confluent.io/cloud/current/stream-sharing/produce-shared-data.html#stream-shares).
     *
     *     ## The Provider Shares Model
     *     <SchemaDefinition schemaRef="#/components/schemas/cdx.v1.ProviderShare" /> */
    "cdx.v1.ProviderShare": {
      /**
       * @description APIVersion defines the schema version of this representation of a resource.
       * @enum {string}
       */
      readonly api_version?: "cdx/v1";
      /**
       * @description Kind defines the object this REST resource represents.
       * @enum {string}
       */
      readonly kind?: "ProviderShare";
      /**
       * @description ID is the "natural identifier" for an object within its scope/namespace; it is normally unique across time but not space. That is, you can assume that the ID will not be reclaimed and reused after an object is deleted ("time"); however, it may collide with IDs for other object `kinds` or objects of the same `kind` within a different scope/namespace ("space").
       * @example dlz-f3a90de
       */
      readonly id?: string;
      metadata?: components["schemas"]["ObjectMeta"] & {
        /** @example https://api.confluent.cloud/cdx/v1/provider-shares/ps-12345 */
        self?: unknown;
        /** @example crn://confluent.cloud/organization=9bb441c4-edef-46ac-8a41-c49e44a3fd9a/provider-share=ps-12345 */
        resource_name?: unknown;
      };
      /**
       * @description Name of the consumer
       * @example John Doe
       */
      readonly consumer_user_name?: string;
      /**
       * @description Consumer organization name
       * @example Nasdaq
       */
      readonly consumer_organization_name?: string;
      /**
       * @description Name or email of the provider user. Deprecated
       * @example Jane Doe
       */
      readonly provider_user_name?: string;
      /**
       * @description Method by which the invite will be delivered
       * @example EMAIL
       */
      delivery_method?: string;
      /** @description Restrictions on the consumer that can redeem this token */
      consumer_restriction?: components["schemas"]["cdx.v1.EmailConsumerRestriction"];
      /**
       * Format: date-time
       * @description The date and time at which consumer was invited
       * @example 2006-01-02T15:04:05-07:00
       */
      readonly invited_at?: string;
      /**
       * Format: date-time
       * @description The date and time at which the invitation will expire. Only for invited shares
       * @example 2006-01-02T15:04:05-07:00
       */
      readonly invite_expires_at?: string;
      /**
       * Format: date-time
       * @description The date and time at which the invite was redeemed
       * @example 2006-01-02T15:04:05-07:00
       */
      readonly redeemed_at?: string;
      /** @description The provider user/inviter */
      readonly provider_user?: components["schemas"]["GlobalObjectReference"];
      /** @description The service account associated with this object. */
      service_account?: components["schemas"]["GlobalObjectReference"];
      /** @description The cloud cluster to which this belongs. */
      cloud_cluster?: components["schemas"]["EnvScopedObjectReference"];
      status?: components["schemas"]["cdx.v1.ProviderShareStatus"];
    };
    /** @description The status of the Provider Share */
    "cdx.v1.ProviderShareStatus": {
      /**
       * @description Status of share
       * @example ACTIVE
       */
      readonly phase: string;
    };
    /** @description `ConsumerSharedResource` object contains details of the data stream
     *     (topic, schema registry subjects, sharing metadata) that you received through Stream Sharing.
     *
     *
     *     ## The Consumer Shared Resources Model
     *     <SchemaDefinition schemaRef="#/components/schemas/cdx.v1.ConsumerSharedResource" /> */
    "cdx.v1.ConsumerSharedResource": {
      /**
       * @description APIVersion defines the schema version of this representation of a resource.
       * @enum {string}
       */
      readonly api_version?: "cdx/v1";
      /**
       * @description Kind defines the object this REST resource represents.
       * @enum {string}
       */
      readonly kind?: "ConsumerSharedResource";
      /**
       * @description ID is the "natural identifier" for an object within its scope/namespace; it is normally unique across time but not space. That is, you can assume that the ID will not be reclaimed and reused after an object is deleted ("time"); however, it may collide with IDs for other object `kinds` or objects of the same `kind` within a different scope/namespace ("space").
       * @example dlz-f3a90de
       */
      readonly id?: string;
      metadata?: components["schemas"]["ObjectMeta"] & {
        /** @example https://api.confluent.cloud/cdx/v1/consumer-shared-resources/csr-12345 */
        self?: unknown;
        /** @example crn://confluent.cloud/organization=9bb441c4-edef-46ac-8a41-c49e44a3fd9a/consumer-shared-resource=csr-12345 */
        resource_name?: unknown;
      };
      /**
       * @description The cloud service provider of the provider shared cluster.
       * @example AWS
       */
      readonly cloud?: string;
      /** @description The network connection types of the provider shared cluster. If the shared cluster is on public internet,
       *     then the list will be empty
       *      */
      readonly network_connection_types?: components["schemas"]["cdx.v1.ConnectionType"][];
      /**
       * @description Consumer resource display name
       * @example Stock Trades
       */
      readonly display_name?: string;
      /**
       * @description Description of consumer resource
       * @example This topic provides realtime data for the orders placed through the website
       */
      readonly description?: string;
      /**
       * @description list of tags
       * @example [
       *       "recent",
       *       "pending"
       *     ]
       */
      readonly tags?: string[];
      /** @description List of schemas in JSON format. This field is work in progress and subject to changes. */
      readonly schemas?: (components["schemas"]["cdx.v1.Schema"] &
        Record<string, unknown>)[];
      /**
       * @description Shared resource's organization name
       * @example ABC Corp
       */
      readonly organization_name?: string;
      /**
       * @description Shared resource's organization description
       * @example ABC Corp is the biggest online retailer
       */
      readonly organization_description?: string;
      /**
       * Format: email
       * @description Email of the shared resource's organization contact
       * @example jane.doe@example.com
       */
      readonly organization_contact?: string;
      /**
       * Format: uri
       * @description Resource logo url
       * @example https://confluent.cloud/api/cdx/v1/consumer-shared-resources/sr-123/images/logo
       */
      readonly logo_url?: string;
    };
    /** @description `ConsumerShare` object respresents the share that you received through Stream Sharing.
     *
     *
     *     Related guide: [Consumer Stream Shares in Confluent Cloud](https://docs.confluent.io/cloud/current/stream-sharing/consume-shared-data.html).
     *
     *     ## The Consumer Shares Model
     *     <SchemaDefinition schemaRef="#/components/schemas/cdx.v1.ConsumerShare" /> */
    "cdx.v1.ConsumerShare": {
      /**
       * @description APIVersion defines the schema version of this representation of a resource.
       * @enum {string}
       */
      readonly api_version?: "cdx/v1";
      /**
       * @description Kind defines the object this REST resource represents.
       * @enum {string}
       */
      readonly kind?: "ConsumerShare";
      /**
       * @description ID is the "natural identifier" for an object within its scope/namespace; it is normally unique across time but not space. That is, you can assume that the ID will not be reclaimed and reused after an object is deleted ("time"); however, it may collide with IDs for other object `kinds` or objects of the same `kind` within a different scope/namespace ("space").
       * @example dlz-f3a90de
       */
      readonly id?: string;
      metadata?: components["schemas"]["ObjectMeta"] & {
        /** @example https://api.confluent.cloud/cdx/v1/consumer-shares/cs-12345 */
        self?: unknown;
        /** @example crn://confluent.cloud/organization=9bb441c4-edef-46ac-8a41-c49e44a3fd9a/consumer-share=cs-12345 */
        resource_name?: unknown;
      };
      /**
       * @description Provider organization name
       * @example Nasdaq
       */
      readonly provider_organization_name?: string;
      /**
       * @description Name or email of the provider user
       * @example Jane Doe
       */
      readonly provider_user_name?: string;
      /**
       * Format: date-time
       * @description The date and time at which the invitation will expire. Only for invited shares
       * @example 2006-01-02T15:04:05-07:00
       */
      readonly invite_expires_at?: string;
      /**
       * @description Consumer organization name. Deprecated
       * @example Nasdaq
       */
      readonly consumer_organization_name?: string;
      /**
       * @description Name of the consumer. Deprecated
       * @example John Doe
       */
      readonly consumer_user_name?: string;
      /** @description The consumer user/invitee */
      readonly consumer_user?: components["schemas"]["GlobalObjectReference"];
      status?: components["schemas"]["cdx.v1.ConsumerShareStatus"];
    };
    /** @description The status of the Consumer Share */
    "cdx.v1.ConsumerShareStatus": {
      /**
       * @description Status of share
       * @example ACTIVE
       */
      readonly phase: string;
    };
    /** @description Encrypted Token shared with consumer
     *
     *
     *     ## The Shared Tokens Model
     *     <SchemaDefinition schemaRef="#/components/schemas/cdx.v1.SharedToken" /> */
    "cdx.v1.SharedToken": {
      /**
       * @description APIVersion defines the schema version of this representation of a resource.
       * @enum {string}
       */
      readonly api_version?: "cdx/v1";
      /**
       * @description Kind defines the object this REST resource represents.
       * @enum {string}
       */
      readonly kind?: "SharedToken";
      /**
       * @description ID is the "natural identifier" for an object within its scope/namespace; it is normally unique across time but not space. That is, you can assume that the ID will not be reclaimed and reused after an object is deleted ("time"); however, it may collide with IDs for other object `kinds` or objects of the same `kind` within a different scope/namespace ("space").
       * @example dlz-f3a90de
       */
      readonly id?: string;
      metadata?: components["schemas"]["ObjectMeta"] & {
        /** @example https://api.confluent.cloud/cdx/v1/shared-tokens/st-12345 */
        self?: unknown;
        /** @example crn://confluent.cloud/organization=9bb441c4-edef-46ac-8a41-c49e44a3fd9a/shared-token=st-12345 */
        resource_name?: unknown;
      };
      /** @description The encrypted token */
      token?: string;
    };
    /** @description Stream sharing opt in options
     *
     *     ## The Opt Ins Model
     *     <SchemaDefinition schemaRef="#/components/schemas/cdx.v1.OptIn" /> */
    "cdx.v1.OptIn": {
      /**
       * @description APIVersion defines the schema version of this representation of a resource.
       * @enum {string}
       */
      readonly api_version?: "cdx/v1";
      /**
       * @description Kind defines the object this REST resource represents.
       * @enum {string}
       */
      readonly kind?: "OptIn";
      /** @description Enable stream sharing for the organization */
      stream_share_enabled?: boolean;
    };
    /** @description Create share request */
    "cdx.v1.CreateProviderShareRequest": {
      /**
       * @description APIVersion defines the schema version of this representation of a resource.
       * @enum {string}
       */
      readonly api_version?: "cdx/v1";
      /**
       * @description Kind defines the object this REST resource represents.
       * @enum {string}
       */
      readonly kind?: "CreateProviderShareRequest";
      /**
       * @description ID is the "natural identifier" for an object within its scope/namespace; it is normally unique across time but not space. That is, you can assume that the ID will not be reclaimed and reused after an object is deleted ("time"); however, it may collide with IDs for other object `kinds` or objects of the same `kind` within a different scope/namespace ("space").
       * @example dlz-f3a90de
       */
      readonly id?: string;
      metadata?: components["schemas"]["ObjectMeta"] & {
        /** @example https://api.confluent.cloud/cdx/v1/create-provider-share-requests/cpsr-12345 */
        self?: unknown;
        /** @example crn://confluent.cloud/organization=9bb441c4-edef-46ac-8a41-c49e44a3fd9a/create-provider-share-request=cpsr-12345 */
        resource_name?: unknown;
      };
      /**
       * @description Method by which the invite will be delivered
       * @example EMAIL
       */
      delivery_method?: string;
      /** @description Restrictions on the consumer that can redeem this token */
      consumer_restriction?: components["schemas"]["cdx.v1.EmailConsumerRestriction"];
      /** @description List of resource crns to be shared */
      resources?: string[];
    };
    /** @description Redeem share with token request parameters */
    "cdx.v1.RedeemTokenRequest": {
      /**
       * @description APIVersion defines the schema version of this representation of a resource.
       * @enum {string}
       */
      readonly api_version?: "cdx/v1";
      /**
       * @description Kind defines the object this REST resource represents.
       * @enum {string}
       */
      readonly kind?: "RedeemTokenRequest";
      /**
       * @description ID is the "natural identifier" for an object within its scope/namespace; it is normally unique across time but not space. That is, you can assume that the ID will not be reclaimed and reused after an object is deleted ("time"); however, it may collide with IDs for other object `kinds` or objects of the same `kind` within a different scope/namespace ("space").
       * @example dlz-f3a90de
       */
      readonly id?: string;
      metadata?: components["schemas"]["ObjectMeta"] & {
        /** @example https://api.confluent.cloud/cdx/v1/redeem-token-requests/rtr-12345 */
        self?: unknown;
        /** @example crn://confluent.cloud/organization=9bb441c4-edef-46ac-8a41-c49e44a3fd9a/redeem-token-request=rtr-12345 */
        resource_name?: unknown;
      };
      /** @description The encrypted token */
      token?: string;
      /**
       * @description Consumer's AWS account ID for PrivateLink access.
       * @example 000000000000
       */
      aws_account?: string;
      /**
       * @description Consumer's Azure subscription ID for PrivateLink access.
       * @example 00000000-0000-0000-0000-000000000000
       */
      azure_subscription?: string;
      /** @description Consumer's GCP project ID for Private Service Connect access. */
      gcp_project?: string;
    };
    /** @description Share details for the consumer org or user */
    "cdx.v1.RedeemTokenResponse": {
      /**
       * @description APIVersion defines the schema version of this representation of a resource.
       * @enum {string}
       */
      readonly api_version?: "cdx/v1";
      /**
       * @description Kind defines the object this REST resource represents.
       * @enum {string}
       */
      readonly kind?: "RedeemTokenResponse";
      /**
       * @description ID is the "natural identifier" for an object within its scope/namespace; it is normally unique across time but not space. That is, you can assume that the ID will not be reclaimed and reused after an object is deleted ("time"); however, it may collide with IDs for other object `kinds` or objects of the same `kind` within a different scope/namespace ("space").
       * @example dlz-f3a90de
       */
      readonly id?: string;
      metadata?: components["schemas"]["ObjectMeta"] & {
        /** @example https://api.confluent.cloud/cdx/v1/redeem-token-responses/rtr-12345 */
        self?: unknown;
        /** @example crn://confluent.cloud/organization=9bb441c4-edef-46ac-8a41-c49e44a3fd9a/redeem-token-response=rtr-12345 */
        resource_name?: unknown;
      };
      /** @description The api key */
      readonly api_key?: string;
      /** @description The api key secret */
      readonly secret?: string;
      /**
       * Format: uri
       * @description The kafka cluster bootstrap url
       * @example SASL://pkc-xxxxx.us-west-2.aws.confluent.cloud:9092
       */
      readonly kafka_bootstrap_url?: string;
      /** @description The api key for schema registry */
      readonly schema_registry_api_key?: string;
      /** @description The api key secret for schema registry */
      readonly schema_registry_secret?: string;
      /**
       * Format: uri
       * @description The schema registry endpoint url
       * @example https://psrc-xxxxx.us-west-2.aws.confluent.cloud
       */
      readonly schema_registry_url?: string;
      /** @description List of shared resources */
      resources?: (
        | components["schemas"]["cdx.v1.SharedTopic"]
        | components["schemas"]["cdx.v1.SharedGroup"]
        | components["schemas"]["cdx.v1.SharedSubject"]
      )[];
    };
    /** @description Consumer restrictions limits by authenticated user's email */
    "cdx.v1.EmailConsumerRestriction": {
      /**
       * @description The resource kind (enum property replaced by openapi-typescript)
       * @enum {string}
       */
      kind: "Email";
      /**
       * Format: email
       * @description Email based matching for the consumers
       */
      email: string;
    };
    /** @description The shared resource details */
    "cdx.v1.SharedTopic": {
      /**
       * @description The shared resource kind (enum property replaced by openapi-typescript)
       * @enum {string}
       */
      kind: "Topic";
      /** @description The topic name */
      topic: string;
    };
    /** @description The shared consumer group */
    "cdx.v1.SharedGroup": {
      /**
       * @description The resource kind (enum property replaced by openapi-typescript)
       * @enum {string}
       */
      kind: "Group";
      /** @description The consumer group prefix */
      group_prefix: string;
    };
    /** @description The shared resource details */
    "cdx.v1.SharedSubject": {
      /**
       * @description The shared resource kind (enum property replaced by openapi-typescript)
       * @enum {string}
       */
      kind: "Subject";
      /** @description The subject name */
      subject: string;
    };
    /** @description The shared cluster's network configurations for consumer to setup private link */
    "cdx.v1.Network": {
      /**
       * @description APIVersion defines the schema version of this representation of a resource.
       * @enum {string}
       */
      readonly api_version?: "cdx/v1";
      /**
       * @description Kind defines the object this REST resource represents.
       * @enum {string}
       */
      readonly kind?: "Network";
      /**
       * @description ID is the "natural identifier" for an object within its scope/namespace; it is normally unique across time but not space. That is, you can assume that the ID will not be reclaimed and reused after an object is deleted ("time"); however, it may collide with IDs for other object `kinds` or objects of the same `kind` within a different scope/namespace ("space").
       * @example dlz-f3a90de
       */
      readonly id?: string;
      metadata?: components["schemas"]["ObjectMeta"] & {
        /** @example https://api.confluent.cloud/cdx/v1/networks/n-12345 */
        self?: unknown;
        /** @example crn://confluent.cloud/organization=9bb441c4-edef-46ac-8a41-c49e44a3fd9a/environment=env-abc123/network=n-12345 */
        resource_name?: unknown;
      };
      /**
       * Format: uri
       * @description The kafka cluster bootstrap url
       * @example SASL://pkc-xxxxx.us-west-2.aws.confluent.cloud:9092
       */
      readonly kafka_bootstrap_url?: string;
      /**
       * @description The 3 availability zones for this network. They can optionally be specified for AWS networks
       *     used with PrivateLink. Otherwise, they are automatically chosen by Confluent Cloud.
       *
       *     On AWS, zones are AWS [AZ IDs](https://docs.aws.amazon.com/ram/latest/userguide/working-with-az-ids.html)
       *      (e.g. use1-az3)
       *
       *     On GCP, zones are GCP [zones](https://cloud.google.com/compute/docs/regions-zones)
       *      (e.g. us-central1-c).
       *
       *     On Azure, zones are Confluent-chosen names (e.g. 1, 2, 3) since Azure does not
       *      have universal zone identifiers.
       *
       * @example [
       *       "use1-az1",
       *       "use1-az2",
       *       "use1-az3"
       *     ]
       */
      zones?: string[];
      /**
       * @description The root DNS domain for the network if applicable.
       * @example 00000.us-east-1.aws.glb.confluent.cloud
       */
      readonly dns_domain?: string;
      /**
       * @description The DNS subdomain for each zone. Present on networks that support PrivateLink. Keys are zones and
       *     values are DNS domains.
       *
       * @example {
       *       "use1-az1": "use1-az1.00000.us-east-1.aws.confluent.cloud",
       *       "use1-az4": "use1-az4.00000.us-east-1.aws.confluent.cloud",
       *       "use1-az5": "use1-az5.00000.us-east-1.aws.confluent.cloud"
       *     }
       */
      readonly zonal_subdomains?: {
        [key: string]: string;
      };
      /** @description The cloud-specific network details. These will be populated when the network reaches the READY state. */
      readonly cloud?:
        | components["schemas"]["cdx.v1.AwsNetwork"]
        | components["schemas"]["cdx.v1.AzureNetwork"]
        | components["schemas"]["cdx.v1.GcpNetwork"];
    };
    /** @description The AWS network details. */
    "cdx.v1.AwsNetwork": {
      /**
       * @description Network kind type. (enum property replaced by openapi-typescript)
       * @enum {string}
       */
      kind: "AwsNetwork";
      /**
       * @description The AWS VPC endpoint service for the network (used for PrivateLink) if available.
       * @example com.amazonaws.vpce.eu-west-3.vpce-00000000000000000
       */
      readonly private_link_endpoint_service?: string;
    };
    /** @description The Azure network details. */
    "cdx.v1.AzureNetwork": {
      /**
       * @description Network kind type. (enum property replaced by openapi-typescript)
       * @enum {string}
       */
      kind: "AzureNetwork";
      /**
       * @description The mapping of zones to PrivateLink Service Aliases if available.  Keys are zones
       *     and values are [Azure PrivateLink Service
       *     Aliases](https://docs.microsoft.com/en-us/azure/private-link/private-link-service-overview#share-your-service)
       *
       * @example {
       *       "1": "0-00000-privatelink-1.00000000-0000-0000-0000-000000000000.westeurope.azure.privatelinkservice",
       *       "2": "0-00000-privatelink-2.00000000-0000-0000-0000-000000000000.westeurope.azure.privatelinkservice",
       *       "3": "0-00000-privatelink-3.00000000-0000-0000-0000-000000000000.westeurope.azure.privatelinkservice"
       *     }
       */
      readonly private_link_service_aliases?: {
        [key: string]: string;
      };
    };
    /** @description The GCP network details. */
    "cdx.v1.GcpNetwork": {
      /**
       * @description Network kind type. (enum property replaced by openapi-typescript)
       * @enum {string}
       */
      kind: "GcpNetwork";
      /**
       * @description The mapping of zones to Private Service Connect Service
       *     Attachments if available. Keys are zones and values are
       *     [GCP Private Service Connect Service
       *     Attachment](https://cloud.google.com/vpc/docs/configure-private-service-connect-producer#api_7)
       *
       * @example {
       *       "us-central1-a": "projects/cc-prod/regions/us-central1/serviceAttachments/s-7jjm9-service-attachment-us-central1-a",
       *       "us-central1-b": "projects/cc-prod/regions/us-central1/serviceAttachments/s-7jjm9-service-attachment-us-central1-b",
       *       "us-central1-c": "projects/cc-prod/regions/us-central1/serviceAttachments/s-7jjm9-service-attachment-us-central1-c"
       *     }
       */
      readonly private_service_connect_service_attachments?: {
        [key: string]: string;
      };
    };
    /**
     * @description Network connection type.
     * @example PRIVATELINK
     */
    "cdx.v1.ConnectionType": string;
    /** @description Schema */
    "cdx.v1.Schema": {
      /**
       * @description Name of the subject
       * @example User
       */
      subject?: string;
      /**
       * Format: int32
       * @description Version number
       * @example 1
       */
      version?: number;
      /**
       * Format: int32
       * @description Globally unique identifier of the schema
       * @example 100001
       */
      id?: number;
      /**
       * @description Schema type
       * @example AVRO
       */
      schema_type?: string;
      /**
       * @description Schema definition string
       * @example {"schema": "{"type": "string"}"}
       */
      schema?: string;
    };
    /** @description Filter for whether this value is true or false. */
    BooleanFilter: boolean;
    /** @description `ProviderSharedResource` object contains details of the data stream
     *     (topic, schema registry subjects, sharing metadata) that you have shared through Stream Sharing.
     *
     *
     *     ## The Provider Shared Resources Model
     *     <SchemaDefinition schemaRef="#/components/schemas/cdx.v1.ProviderSharedResource" /> */
    "cdx.v1.ProviderSharedResourceList": {
      /**
       * @description APIVersion defines the schema version of this representation of a resource.
       * @enum {string}
       */
      readonly api_version: "cdx/v1";
      /**
       * @description Kind defines the object this REST resource represents.
       * @enum {string}
       */
      readonly kind: "ProviderSharedResourceList";
      metadata: components["schemas"]["ListMeta"] & {
        /** @example https://api.confluent.cloud/cdx/v1/provider-shared-resources */
        first?: unknown;
        /** @example https://api.confluent.cloud/cdx/v1/provider-shared-resources?page_token=bcAOehAY8F16YD84Z1wT */
        last?: unknown;
        /** @example https://api.confluent.cloud/cdx/v1/provider-shared-resources?page_token=YIXRY97wWYmwzrax4dld */
        prev?: unknown;
        /** @example https://api.confluent.cloud/cdx/v1/provider-shared-resources?page_token=UvmDWOB1iwfAIBPj6EYb */
        next?: unknown;
      };
      /** @description A data property that contains an array of resource items. Each entry in the array is a separate resource. */
      data: (components["schemas"]["cdx.v1.ProviderSharedResource"] &
        Record<string, unknown>)[];
    };
    /** @description `ProviderShare` object respresents the share that you have created through Stream Sharing.
     *
     *
     *     Related guide: [Provider Stream Shares in Confluent Cloud](https://docs.confluent.io/cloud/current/stream-sharing/produce-shared-data.html#stream-shares).
     *
     *     ## The Provider Shares Model
     *     <SchemaDefinition schemaRef="#/components/schemas/cdx.v1.ProviderShare" /> */
    "cdx.v1.ProviderShareList": {
      /**
       * @description APIVersion defines the schema version of this representation of a resource.
       * @enum {string}
       */
      readonly api_version: "cdx/v1";
      /**
       * @description Kind defines the object this REST resource represents.
       * @enum {string}
       */
      readonly kind: "ProviderShareList";
      metadata: components["schemas"]["ListMeta"] & {
        /** @example https://api.confluent.cloud/cdx/v1/provider-shares */
        first?: unknown;
        /** @example https://api.confluent.cloud/cdx/v1/provider-shares?page_token=bcAOehAY8F16YD84Z1wT */
        last?: unknown;
        /** @example https://api.confluent.cloud/cdx/v1/provider-shares?page_token=YIXRY97wWYmwzrax4dld */
        prev?: unknown;
        /** @example https://api.confluent.cloud/cdx/v1/provider-shares?page_token=UvmDWOB1iwfAIBPj6EYb */
        next?: unknown;
      };
      /** @description A data property that contains an array of resource items. Each entry in the array is a separate resource. */
      data: (components["schemas"]["cdx.v1.ProviderShare"] &
        Record<string, unknown>)[];
    };
    /** @description `ConsumerSharedResource` object contains details of the data stream
     *     (topic, schema registry subjects, sharing metadata) that you received through Stream Sharing.
     *
     *
     *     ## The Consumer Shared Resources Model
     *     <SchemaDefinition schemaRef="#/components/schemas/cdx.v1.ConsumerSharedResource" /> */
    "cdx.v1.ConsumerSharedResourceList": {
      /**
       * @description APIVersion defines the schema version of this representation of a resource.
       * @enum {string}
       */
      readonly api_version: "cdx/v1";
      /**
       * @description Kind defines the object this REST resource represents.
       * @enum {string}
       */
      readonly kind: "ConsumerSharedResourceList";
      metadata: components["schemas"]["ListMeta"] & {
        /** @example https://api.confluent.cloud/cdx/v1/consumer-shared-resources */
        first?: unknown;
        /** @example https://api.confluent.cloud/cdx/v1/consumer-shared-resources?page_token=bcAOehAY8F16YD84Z1wT */
        last?: unknown;
        /** @example https://api.confluent.cloud/cdx/v1/consumer-shared-resources?page_token=YIXRY97wWYmwzrax4dld */
        prev?: unknown;
        /** @example https://api.confluent.cloud/cdx/v1/consumer-shared-resources?page_token=UvmDWOB1iwfAIBPj6EYb */
        next?: unknown;
      };
      /** @description A data property that contains an array of resource items. Each entry in the array is a separate resource. */
      data: (components["schemas"]["cdx.v1.ConsumerSharedResource"] &
        Record<string, unknown>)[];
    };
    /** @description `ConsumerShare` object respresents the share that you received through Stream Sharing.
     *
     *
     *     Related guide: [Consumer Stream Shares in Confluent Cloud](https://docs.confluent.io/cloud/current/stream-sharing/consume-shared-data.html).
     *
     *     ## The Consumer Shares Model
     *     <SchemaDefinition schemaRef="#/components/schemas/cdx.v1.ConsumerShare" /> */
    "cdx.v1.ConsumerShareList": {
      /**
       * @description APIVersion defines the schema version of this representation of a resource.
       * @enum {string}
       */
      readonly api_version: "cdx/v1";
      /**
       * @description Kind defines the object this REST resource represents.
       * @enum {string}
       */
      readonly kind: "ConsumerShareList";
      metadata: components["schemas"]["ListMeta"] & {
        /** @example https://api.confluent.cloud/cdx/v1/consumer-shares */
        first?: unknown;
        /** @example https://api.confluent.cloud/cdx/v1/consumer-shares?page_token=bcAOehAY8F16YD84Z1wT */
        last?: unknown;
        /** @example https://api.confluent.cloud/cdx/v1/consumer-shares?page_token=YIXRY97wWYmwzrax4dld */
        prev?: unknown;
        /** @example https://api.confluent.cloud/cdx/v1/consumer-shares?page_token=UvmDWOB1iwfAIBPj6EYb */
        next?: unknown;
      };
      /** @description A data property that contains an array of resource items. Each entry in the array is a separate resource. */
      data: (components["schemas"]["cdx.v1.ConsumerShare"] &
        Record<string, unknown>)[];
    };
    /** @description `Organizations` objects represent an entire Confluent Cloud organization. */
    "partner.v2.Organization": {
      /**
       * @description APIVersion defines the schema version of this representation of a resource.
       * @enum {string}
       */
      readonly api_version?: "partner/v2";
      /**
       * @description Kind defines the object this REST resource represents.
       * @enum {string}
       */
      readonly kind?: "Organization";
      /**
       * @description ID is the "natural identifier" for an object within its scope/namespace; it is normally unique across time but not space. That is, you can assume that the ID will not be reclaimed and reused after an object is deleted ("time"); however, it may collide with IDs for other object `kinds` or objects of the same `kind` within a different scope/namespace ("space").
       * @example dlz-f3a90de
       */
      readonly id?: string;
      metadata?: components["schemas"]["ObjectMeta"];
      /**
       * @description The name of the organization
       * @example Acme Organization
       */
      name?: string;
      /**
       * Format: uri
       * @description The login URL for the customer to access Confluent Cloud
       * @example https://confluent.cloud/login/sso/AzureAD-OIDC-Conn
       */
      readonly sso_url?: string;
      sso_config?: components["schemas"]["AzureSSOConfig"];
    };
    AzureSSOConfig: {
      /**
       * @description discriminator enum property added by openapi-typescript
       * @enum {string}
       */
      kind: "AzureSSOConfig";
      /**
       * @description The Azure AD tenant ID
       * @example b3a17773-05cc-4431-9560-433fb4613da8
       */
      tenant_id: string;
    };
    /** @description `Organizations` objects represent an entire Confluent Cloud organization. */
    "partner.v2.OrganizationList": {
      /**
       * @description APIVersion defines the schema version of this representation of a resource.
       * @enum {string}
       */
      readonly api_version: "partner/v2";
      /**
       * @description Kind defines the object this REST resource represents.
       * @enum {string}
       */
      readonly kind: "OrganizationList";
      metadata: components["schemas"]["ListMeta"];
      data: (components["schemas"]["partner.v2.Organization"] &
        Record<string, unknown>)[];
    };
    /** @description The partner signup request */
    PartnerSignupRequest: {
      organization: components["schemas"]["partner.v2.Organization"] & unknown;
      user?: components["schemas"]["v2.User"] & unknown;
      entitlement:
        | (components["schemas"]["partner.v2.Entitlement"] & unknown)
        | (components["schemas"]["ObjectReference"] & unknown);
    };
    /** @description The partner signup response */
    PartnerSignupResponse: {
      /**
       * @description The ID of the organization
       * @example b3a17773-05cc-4431-9560-433fb4613da8
       */
      organization_id: string;
      /**
       * Format: uri
       * @description The login URL for the customer to access Confluent Cloud
       * @example https://confluent.cloud/login/sso/AzureAD-OIDC-Conn
       */
      sso_url: string;
      /**
       * @description The display message contains useful information which is shown on the Marketplace UI to the customers.
       * @example Your support plan will remain the same, to change the plan, follow this [link](https://docs.confluent.io/cloud/current/faq.html#how-do-i-change-support-plans).
       */
      display_message?: string;
    };
    /** @description The partner signup activation request */
    ActivatePartnerSignupRequest: {
      user: components["schemas"]["v2.User"] & unknown;
      /**
       * @description The ID of the organization
       * @example b3a17773-05cc-4431-9560-433fb4613da8
       */
      organization_id: string;
    };
    /** @description The partner linking request */
    PartnerLinkRequest: {
      /**
       * @description The linking token that was generated.
       * @example eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiIxMjM0NTY3ODkwIiwibmFtZSI6IkpvaG4gRG9lIiwiaWF0IjoxNTE2MjM5MDIyfQ.SflKxwRJSMeKKF2QT4fwpMeJf36POk6yJV_adQssw5c
       */
      token: string;
      organization: components["schemas"]["partner.v2.Organization"] & unknown;
      entitlement:
        | (components["schemas"]["partner.v2.Entitlement"] & unknown)
        | (components["schemas"]["ObjectReference"] & unknown);
    };
    "v2.User": Record<string, unknown>;
    /** @description `Network` represents a network (VPC) in Confluent Cloud. All Networks exist within Confluent-managed cloud
     *     provider accounts. Dedicated networks support more networking options but can only contain Dedicated clusters.
     *     Shared networks can contain any cluster type.
     *
     *     The API allows you to list, create, read, update, and delete your networks.
     *
     *
     *     Related guide: [APIs to manage networks in Confluent Cloud](https://docs.confluent.io/cloud/current/networking/overview.html).
     *
     *     ## The Networks Model
     *     <SchemaDefinition schemaRef="#/components/schemas/networking.v1.Network" />
     *
     *     ## Quotas and Limits
     *     This resource is subject to the [following quotas](https://docs.confluent.io/cloud/current/quotas/overview.html):
     *
     *     | Quota | Description |
     *     | --- | --- |
     *     | `dedicated_networks_per_environment` | Number of dedicated networks per Confluent Cloud environment | */
    "networking.v1.Network": {
      /**
       * @description APIVersion defines the schema version of this representation of a resource.
       * @enum {string}
       */
      readonly api_version?: "networking/v1";
      /**
       * @description Kind defines the object this REST resource represents.
       * @enum {string}
       */
      readonly kind?: "Network";
      /**
       * @description ID is the "natural identifier" for an object within its scope/namespace; it is normally unique across time but not space. That is, you can assume that the ID will not be reclaimed and reused after an object is deleted ("time"); however, it may collide with IDs for other object `kinds` or objects of the same `kind` within a different scope/namespace ("space").
       * @example dlz-f3a90de
       */
      readonly id?: string;
      metadata?: components["schemas"]["ObjectMeta"] & {
        /** @example https://api.confluent.cloud/networking/v1/networks/n-12345 */
        self?: unknown;
        /** @example crn://confluent.cloud/organization=9bb441c4-edef-46ac-8a41-c49e44a3fd9a/environment=env-abc123/network=n-12345 */
        resource_name?: unknown;
      };
      spec?: components["schemas"]["networking.v1.NetworkSpec"];
      status?: components["schemas"]["networking.v1.NetworkStatus"];
    };
    /** @description The status of the Network */
    "networking.v1.NetworkStatus": {
      /**
       * @description The lifecyle phase of the network:
       *
       *     PROVISIONING:  network provisioning is in progress;
       *
       *     READY:  network is ready;
       *
       *     FAILED: provisioning failed;
       *
       *     DEPROVISIONING: network deprovisioning is in progress;
       *
       * @example READY
       */
      readonly phase: string;
      /** @description The connection types this network supports. */
      readonly supported_connection_types: components["schemas"]["networking.v1.ConnectionType"][];
      /** @description The connection types requested for use with the network. */
      readonly active_connection_types: components["schemas"]["networking.v1.ConnectionType"][];
      /**
       * @description Error code if network is in a failed state. May be used for programmatic error checking.
       * @example insufficient_capacity
       */
      readonly error_code?: string;
      /**
       * @description Displayable error message if network is in a failed state
       * @example Could not provision cloud resources
       */
      readonly error_message?: string;
      /**
       * @description The root DNS domain for the network if applicable. Present on networks that support PrivateLink.
       * @example 00000.us-east-1.aws.glb.confluent.cloud
       */
      readonly dns_domain?: string;
      /**
       * @description The DNS subdomain for each zone. Present on networks that support PrivateLink. Keys are zones and
       *     values are DNS domains.
       *
       * @example {
       *       "use1-az1": "use1-az1.00000.us-east-1.aws.confluent.cloud",
       *       "use1-az4": "use1-az4.00000.us-east-1.aws.confluent.cloud",
       *       "use1-az5": "use1-az5.00000.us-east-1.aws.confluent.cloud"
       *     }
       */
      readonly zonal_subdomains?: {
        [key: string]: string;
      };
      /** @description The cloud-specific network details. These will be populated when the network reaches the READY state. */
      readonly cloud?:
        | components["schemas"]["networking.v1.AwsNetwork"]
        | components["schemas"]["networking.v1.GcpNetwork"]
        | components["schemas"]["networking.v1.AzureNetwork"];
      /**
       * Format: date-time
       * @description The date and time when the network becomes idle
       * @example 2024-01-01T00:00:00Z
       */
      readonly idle_since?: string;
    };
    /** @description Add or remove VPC/VNet peering connections between your VPC/VNet and Confluent Cloud.
     *
     *     Related guides:
     *     * [Use VPC peering connections with Confluent Cloud on AWS](https://docs.confluent.io/cloud/current/networking/peering/aws-peering.html).
     *     * [Use VNet peering connections with Confluent Cloud on Azure](https://docs.confluent.io/cloud/current/networking/peering/azure-peering.html).
     *     * [Use VPC peering connections with Confluent Cloud on Google Cloud](https://docs.confluent.io/cloud/current/networking/peering/gcp-peering.html).
     *
     *
     *     ## The Peerings Model
     *     <SchemaDefinition schemaRef="#/components/schemas/networking.v1.Peering" />
     *
     *     ## Quotas and Limits
     *     This resource is subject to the [following quotas](https://docs.confluent.io/cloud/current/quotas/overview.html):
     *
     *     | Quota | Description |
     *     | --- | --- |
     *     | `peerings_per_network` | Number of peerings per network | */
    "networking.v1.Peering": {
      /**
       * @description APIVersion defines the schema version of this representation of a resource.
       * @enum {string}
       */
      readonly api_version?: "networking/v1";
      /**
       * @description Kind defines the object this REST resource represents.
       * @enum {string}
       */
      readonly kind?: "Peering";
      /**
       * @description ID is the "natural identifier" for an object within its scope/namespace; it is normally unique across time but not space. That is, you can assume that the ID will not be reclaimed and reused after an object is deleted ("time"); however, it may collide with IDs for other object `kinds` or objects of the same `kind` within a different scope/namespace ("space").
       * @example dlz-f3a90de
       */
      readonly id?: string;
      metadata?: components["schemas"]["ObjectMeta"] & {
        /** @example https://api.confluent.cloud/networking/v1/peerings/p-12345 */
        self?: unknown;
        /** @example crn://confluent.cloud/organization=9bb441c4-edef-46ac-8a41-c49e44a3fd9a/environment=env-abc123/network=n-456xyz/peering=p-12345 */
        resource_name?: unknown;
      };
      spec?: components["schemas"]["networking.v1.PeeringSpec"];
      status?: components["schemas"]["networking.v1.PeeringStatus"];
    };
    /** @description The status of the Peering */
    "networking.v1.PeeringStatus": {
      /**
       * @description The lifecycle phase of the peering:
       *
       *       PROVISIONING: peering provisioning is in progress;
       *
       *       PENDING_ACCEPT: peering connection request is pending acceptance by the customer;
       *
       *       READY:  peering is ready;
       *
       *       FAILED: peering is in a failed state;
       *
       *       DEPROVISIONING: peering deprovisioning is in progress;
       *
       *       DISCONNECTED: peering has been disconnected in the cloud provider by the customer;
       *
       * @example READY
       */
      readonly phase: string;
      /** @description Error code if peering is in a failed state. May be used for programmatic error checking. */
      readonly error_code?: string;
      /** @description Displayable error message if peering is in a failed state */
      readonly error_message?: string;
    };
    /** @description AWS Transit Gateway Attachments
     *
     *     Related guide: [APIs to manage AWS Transit Gateway Attachments](https://docs.confluent.io/cloud/current/networking/aws-transit-gateway.html).
     *
     *     ## The Transit Gateway Attachments Model
     *     <SchemaDefinition schemaRef="#/components/schemas/networking.v1.TransitGatewayAttachment" />
     *
     *     ## Quotas and Limits
     *     This resource is subject to the [following quotas](https://docs.confluent.io/cloud/current/quotas/overview.html):
     *
     *     | Quota | Description |
     *     | --- | --- |
     *     | `tgw_attachments_per_network` | Number of TGW attachments per network | */
    "networking.v1.TransitGatewayAttachment": {
      /**
       * @description APIVersion defines the schema version of this representation of a resource.
       * @enum {string}
       */
      readonly api_version?: "networking/v1";
      /**
       * @description Kind defines the object this REST resource represents.
       * @enum {string}
       */
      readonly kind?: "TransitGatewayAttachment";
      /**
       * @description ID is the "natural identifier" for an object within its scope/namespace; it is normally unique across time but not space. That is, you can assume that the ID will not be reclaimed and reused after an object is deleted ("time"); however, it may collide with IDs for other object `kinds` or objects of the same `kind` within a different scope/namespace ("space").
       * @example dlz-f3a90de
       */
      readonly id?: string;
      metadata?: components["schemas"]["ObjectMeta"] & {
        /** @example https://api.confluent.cloud/networking/v1/transit-gateway-attachments/tga-12345 */
        self?: unknown;
        /** @example crn://confluent.cloud/organization=9bb441c4-edef-46ac-8a41-c49e44a3fd9a/environment=env-abc123/network=n-456xyz/transit-gateway-attachment=tga-12345 */
        resource_name?: unknown;
      };
      spec?: components["schemas"]["networking.v1.TransitGatewayAttachmentSpec"];
      status?: components["schemas"]["networking.v1.TransitGatewayAttachmentStatus"];
    };
    /** @description The status of the Transit Gateway Attachment */
    "networking.v1.TransitGatewayAttachmentStatus": {
      /**
       * @description The lifecycle phase of the TGW attachment:
       *
       *       PROVISIONING: attachment provisioning is in progress;
       *
       *       PENDING_ACCEPT: attachment request is pending acceptance by the customer;
       *
       *       READY:  attachment is ready;
       *
       *       FAILED: attachment is in a failed state;
       *
       *       DEPROVISIONING: attachment deprovisioning is in progress;
       *
       *       DISCONNECTED: attachment was manually deleted directly in the cloud provider by the customer;
       *
       *       ERROR: invalid customer input during attachment creation.
       *
       * @example READY
       */
      readonly phase: string;
      /** @description Error code if TGW attachment is in a failed state. May be used for programmatic error checking. */
      readonly error_code?: string;
      /** @description Displayable error message if TGW attachment is in a failed state */
      readonly error_message?: string;
      /** @description The cloud-specific TGW attachment details. */
      readonly cloud?: components["schemas"]["networking.v1.AwsTransitGatewayAttachmentStatus"];
    };
    /** @description Add or remove access to PrivateLink endpoints by AWS account, Azure subscription and GCP project ID.
     *
     *     Related guides:
     *     * [Use Google Cloud Private Service Connect with Confluent Cloud](https://docs.confluent.io/cloud/current/networking/private-links/gcp-private-service-connect.html).
     *     * [Use Azure Private Link with Confluent Cloud](https://docs.confluent.io/cloud/current/networking/private-links/azure-privatelink.html).
     *     * [Use AWS PrivateLink with Confluent Cloud](https://docs.confluent.io/cloud/current/networking/private-links/aws-privatelink.html).
     *
     *
     *     ## The Private Link Accesses Model
     *     <SchemaDefinition schemaRef="#/components/schemas/networking.v1.PrivateLinkAccess" />
     *
     *     ## Quotas and Limits
     *     This resource is subject to the [following quotas](https://docs.confluent.io/cloud/current/quotas/overview.html):
     *
     *     | Quota | Description |
     *     | --- | --- |
     *     | `private_link_accounts_per_network` | Number of AWS accounts per network |
     *     | `private_link_subscriptions_per_network` | Number of Azure subscriptions per network |
     *     | `private_service_connect_projects_per_network` | Number of GCP projects per network | */
    "networking.v1.PrivateLinkAccess": {
      /**
       * @description APIVersion defines the schema version of this representation of a resource.
       * @enum {string}
       */
      readonly api_version?: "networking/v1";
      /**
       * @description Kind defines the object this REST resource represents.
       * @enum {string}
       */
      readonly kind?: "PrivateLinkAccess";
      /**
       * @description ID is the "natural identifier" for an object within its scope/namespace; it is normally unique across time but not space. That is, you can assume that the ID will not be reclaimed and reused after an object is deleted ("time"); however, it may collide with IDs for other object `kinds` or objects of the same `kind` within a different scope/namespace ("space").
       * @example dlz-f3a90de
       */
      readonly id?: string;
      metadata?: components["schemas"]["ObjectMeta"] & {
        /** @example https://api.confluent.cloud/networking/v1/private-link-accesses/pla-12345 */
        self?: unknown;
        /** @example crn://confluent.cloud/organization=9bb441c4-edef-46ac-8a41-c49e44a3fd9a/environment=env-abc123/network=n-456xyz/private-link-access=pla-12345 */
        resource_name?: unknown;
      };
      spec?: components["schemas"]["networking.v1.PrivateLinkAccessSpec"];
      status?: components["schemas"]["networking.v1.PrivateLinkAccessStatus"];
    };
    /** @description The status of the Private Link Access */
    "networking.v1.PrivateLinkAccessStatus": {
      /**
       * @description The lifecycle phase of the PrivateLink access configuration:
       *
       *       PROVISIONING: PrivateLink access provisioning is in progress;
       *
       *       READY:  PrivateLink access is ready;
       *
       *       FAILED: PrivateLink access is in a failed state;
       *
       *       DEPROVISIONING: PrivateLink access deprovisioning is in progress;
       *
       * @example READY
       */
      readonly phase: string;
      /** @description Error code if PrivateLink access is in a failed state. May be used for programmatic error checking. */
      readonly error_code?: string;
      /** @description Displayable error message if PrivateLink access is in a failed state */
      readonly error_message?: string;
    };
    /** @description Network Link Service is associated with a Private Link Confluent Cloud Network.
     *     It enables connectivity from other Private Link Confluent Cloud Networks based on
     *     the configured accept policies.
     *
     *
     *     Related guide: [Network Linking Overview](https://docs.confluent.io/cloud/current/networking/network-linking.html).
     *
     *     ## The Network Link Services Model
     *     <SchemaDefinition schemaRef="#/components/schemas/networking.v1.NetworkLinkService" />
     *
     *     ## Quotas and Limits
     *     This resource is subject to the [following quotas](https://docs.confluent.io/cloud/current/quotas/overview.html):
     *
     *     | Quota | Description |
     *     | --- | --- |
     *     | `network_link_service_per_network` | Number of network link services per network | */
    "networking.v1.NetworkLinkService": {
      /**
       * @description APIVersion defines the schema version of this representation of a resource.
       * @enum {string}
       */
      readonly api_version?: "networking/v1";
      /**
       * @description Kind defines the object this REST resource represents.
       * @enum {string}
       */
      readonly kind?: "NetworkLinkService";
      /**
       * @description ID is the "natural identifier" for an object within its scope/namespace; it is normally unique across time but not space. That is, you can assume that the ID will not be reclaimed and reused after an object is deleted ("time"); however, it may collide with IDs for other object `kinds` or objects of the same `kind` within a different scope/namespace ("space").
       * @example dlz-f3a90de
       */
      readonly id?: string;
      metadata?: components["schemas"]["ObjectMeta"] & {
        /** @example https://api.confluent.cloud/networking/v1/network-link-services/nls-12345 */
        self?: unknown;
        /** @example crn://confluent.cloud/organization=9bb441c4-edef-46ac-8a41-c49e44a3fd9a/environment=env-abc123/network=n-456xyz/network-link-service=nls-12345 */
        resource_name?: unknown;
      };
      spec?: components["schemas"]["networking.v1.NetworkLinkServiceSpec"];
      status?: components["schemas"]["networking.v1.NetworkLinkServiceStatus"];
    };
    /** @description The status of the Network Link Service */
    "networking.v1.NetworkLinkServiceStatus": {
      /**
       * @description The lifecycle phase of the network link service:
       *
       *     READY:  network link service is ready;
       *
       * @example READY
       */
      readonly phase: string;
      /** @description Error code if network link service is in a failed state.
       *     May be used for programmatic error checking.
       *      */
      readonly error_code?: string;
      /** @description Displayable error message if network link service is in a failed state */
      readonly error_message?: string;
    };
    /** @description A Network Link Enpoint is associated with a Private Link Confluent Cloud Network at the origin and a
     *     Network Link Service (associated with another Private Link Confluent Cloud Network) at the target.
     *     It enables connectivity between the origin network and the target network.
     *     It can only be associated with a Private Link network.
     *
     *
     *     Related guide: [Network Linking Overview](https://docs.confluent.io/cloud/current/networking/network-linking.html).
     *
     *     ## The Network Link Endpoints Model
     *     <SchemaDefinition schemaRef="#/components/schemas/networking.v1.NetworkLinkEndpoint" />
     *
     *     ## Quotas and Limits
     *     This resource is subject to the [following quotas](https://docs.confluent.io/cloud/current/quotas/overview.html):
     *
     *     | Quota | Description |
     *     | --- | --- |
     *     | `network_link_endpoints_per_network` | Number of network link endpoints per network | */
    "networking.v1.NetworkLinkEndpoint": {
      /**
       * @description APIVersion defines the schema version of this representation of a resource.
       * @enum {string}
       */
      readonly api_version?: "networking/v1";
      /**
       * @description Kind defines the object this REST resource represents.
       * @enum {string}
       */
      readonly kind?: "NetworkLinkEndpoint";
      /**
       * @description ID is the "natural identifier" for an object within its scope/namespace; it is normally unique across time but not space. That is, you can assume that the ID will not be reclaimed and reused after an object is deleted ("time"); however, it may collide with IDs for other object `kinds` or objects of the same `kind` within a different scope/namespace ("space").
       * @example dlz-f3a90de
       */
      readonly id?: string;
      metadata?: components["schemas"]["ObjectMeta"] & {
        /** @example https://api.confluent.cloud/networking/v1/network-link-endpoints/nle-12345 */
        self?: unknown;
        /** @example crn://confluent.cloud/organization=9bb441c4-edef-46ac-8a41-c49e44a3fd9a/environment=env-abc123/network=n-456xyz/network-link-endpoint=nle-12345 */
        resource_name?: unknown;
      };
      spec?: components["schemas"]["networking.v1.NetworkLinkEndpointSpec"];
      status?: components["schemas"]["networking.v1.NetworkLinkEndpointStatus"];
    };
    /** @description The status of the Network Link Endpoint */
    "networking.v1.NetworkLinkEndpointStatus": {
      /**
       * @description The lifecycle phase of the network link endpoint:
       *
       *       PROVISIONING: network link endpoint provisioning is in progress;
       *
       *       PENDING_ACCEPT: network link endpoint request is pending acceptance by the the owner of the target;
       *
       *       READY:  network link endpoint is ready;
       *
       *       FAILED: network link endpoint is in a failed state;
       *
       *       DEPROVISIONING: network link endpoint deprovisioning is in progress;
       *
       *       EXPIRED: network link endpoint request is expired, can only be deleted;
       *
       *       DISCONNECTED: network link endpoint is in a disconnected state, target owner has removed the permissions;
       *
       *       DISCONNECTING: network link endpoint disconnection is in progress;
       *
       *       INACTIVE: network link endpoint is created, but not active since there are no clusters in the network;
       *
       * @example READY
       */
      readonly phase: string;
      /** @description Error code if network link is in a failed state. May be used for programmatic error checking. */
      readonly error_code?: string;
      /** @description Displayable error message if network link is in a failed state */
      readonly error_message?: string;
      /**
       * Format: date-time
       * @description The date and time when the request expires if it is not accepted by the target network admin.
       * @example 2024-01-01T00:00:00Z
       */
      readonly expires_at?: string;
    };
    /** @description List of incoming Network Link Enpoints associated with the Network Link Service.
     *
     *
     *     Related guide: [Network Linking Overview](https://docs.confluent.io/cloud/current/networking/network-linking.html).
     *
     *     ## The Network Link Service Associations Model
     *     <SchemaDefinition schemaRef="#/components/schemas/networking.v1.NetworkLinkServiceAssociation" /> */
    "networking.v1.NetworkLinkServiceAssociation": {
      /**
       * @description APIVersion defines the schema version of this representation of a resource.
       * @enum {string}
       */
      readonly api_version?: "networking/v1";
      /**
       * @description Kind defines the object this REST resource represents.
       * @enum {string}
       */
      readonly kind?: "NetworkLinkServiceAssociation";
      /**
       * @description ID is the "natural identifier" for an object within its scope/namespace; it is normally unique across time but not space. That is, you can assume that the ID will not be reclaimed and reused after an object is deleted ("time"); however, it may collide with IDs for other object `kinds` or objects of the same `kind` within a different scope/namespace ("space").
       * @example dlz-f3a90de
       */
      readonly id?: string;
      metadata?: components["schemas"]["ObjectMeta"] & {
        /** @example https://api.confluent.cloud/networking/v1/network-link-service-associations/nlsa-12345 */
        self?: unknown;
        /** @example crn://confluent.cloud/organization=9bb441c4-edef-46ac-8a41-c49e44a3fd9a/environment=env-abc123/network=n-456xyz/network-link-service=nls-12345/network-link-endpoint=nle-12345 */
        resource_name?: unknown;
      };
      spec?: components["schemas"]["networking.v1.NetworkLinkServiceAssociationSpec"];
      status?: components["schemas"]["networking.v1.NetworkLinkServiceAssociationStatus"];
    };
    /** @description The status of the Network Link Service Association */
    "networking.v1.NetworkLinkServiceAssociationStatus": {
      /**
       * @description The lifecycle phase of the network link endpoint:
       *
       *       PROVISIONING: network link endpoint provisioning is in progress;
       *
       *       PENDING_ACCEPT: network link endpoint request is pending acceptance by the the owner of the target;
       *
       *       READY:  network link endpoint is ready;
       *
       *       FAILED: network link endpoint is in a failed state;
       *
       *       DEPROVISIONING: network link endpoint deprovisioning is in progress;
       *
       *       EXPIRED: network link endpoint request is expired, can only be deleted;
       *
       *       DISCONNECTED: network link endpoint is in a disconnected state, target owner has removed the permissions;
       *
       *       DISCONNECTING: network link endpoint disconnection is in progress;
       *
       *       INACTIVE: network link endpoint is created, but not active since there are no clusters in the network;
       *
       * @example READY
       */
      readonly phase: string;
      /** @description Error code if network link is in a failed state. May be used for programmatic error checking. */
      readonly error_code?: string;
      /** @description Displayable error message if network link is in a failed state */
      readonly error_message?: string;
      /**
       * Format: date-time
       * @description The date and time when the request expires if it is not accepted by the target network admin.
       * @example 2024-01-01T00:00:00Z
       */
      readonly expires_at?: string;
    };
    /**
     * @description IPv4 CIDR block
     * @example 10.200.0.0/16
     */
    "networking.v1.Cidr": string;
    /**
     * @description Network connection type.
     * @example PRIVATELINK
     */
    "networking.v1.ConnectionType": string;
    /** @description The network DNS config */
    "networking.v1.DnsConfig": {
      /** @description Network DNS resolution type. */
      resolution: string;
    };
    /** @description The AWS network details. */
    "networking.v1.AwsNetwork": {
      /**
       * @description Network kind type. (enum property replaced by openapi-typescript)
       * @enum {string}
       */
      kind: "AwsNetwork";
      /**
       * @description The Confluent Cloud VPC ID.
       * @example vpc-00000000000000000
       */
      readonly vpc: string;
      /**
       * @description The AWS account ID associated with the Confluent Cloud VPC.
       * @example 000000000000
       */
      readonly account: string;
      /**
       * @description The endpoint service of the Confluent Cloud VPC. (used for PrivateLink) if available.
       * @example com.amazonaws.vpce.eu-west-3.vpce-00000000000000000
       */
      readonly private_link_endpoint_service?: string;
    };
    /** @description The GCP network details. */
    "networking.v1.GcpNetwork": {
      /**
       * @description Network kind type. (enum property replaced by openapi-typescript)
       * @enum {string}
       */
      kind: "GcpNetwork";
      /**
       * @description The GCP Project ID associated with the Confluent Cloud VPC.
       * @example cc-prod-3
       */
      readonly project: string;
      /**
       * @description The network name of the Confluent Cloud VPC.
       * @example prod-network
       */
      readonly vpc_network: string;
      /**
       * @description The mapping of zones to Private Service Connect Service
       *     Attachments if available. Keys are zones and values are
       *     [GCP Private Service Connect Service
       *     Attachment](https://cloud.google.com/vpc/docs/configure-private-service-connect-producer#api_7)
       *
       * @example {
       *       "us-central1-a": "projects/cc-prod/regions/us-central1/serviceAttachments/s-7jjm9-service-attachment-us-central1-a",
       *       "us-central1-b": "projects/cc-prod/regions/us-central1/serviceAttachments/s-7jjm9-service-attachment-us-central1-b",
       *       "us-central1-c": "projects/cc-prod/regions/us-central1/serviceAttachments/s-7jjm9-service-attachment-us-central1-c"
       *     }
       */
      readonly private_service_connect_service_attachments?: {
        [key: string]: string;
      };
    };
    /** @description The Azure network details. */
    "networking.v1.AzureNetwork": {
      /**
       * @description Network kind type. (enum property replaced by openapi-typescript)
       * @enum {string}
       */
      kind: "AzureNetwork";
      /**
       * @description The resource ID of the Confluent Cloud VNet.
       * @example /subscriptions/00000000-0000-0000-0000-000000000000/resourceGroups/prod-group/providers/Microsoft.Network/virtualNetworks/prod-network
       */
      readonly vnet: string;
      /**
       * @description The Azure Subscription ID associated with the Confluent Cloud VPC.
       * @example 00000000-0000-0000-0000-000000000000
       */
      readonly subscription: string;
      /**
       * @description The mapping of zones to Private Link Service Aliases if available. Keys are zones
       *     and values are [Azure Private Link Service
       *     Aliases](https://docs.microsoft.com/en-us/azure/private-link/private-link-service-overview#share-your-service).
       *
       * @example {
       *       "1": "0-00000-privatelink-1.00000000-0000-0000-0000-000000000000.westeurope.azure.privatelinkservice",
       *       "2": "0-00000-privatelink-2.00000000-0000-0000-0000-000000000000.westeurope.azure.privatelinkservice",
       *       "3": "0-00000-privatelink-3.00000000-0000-0000-0000-000000000000.westeurope.azure.privatelinkservice"
       *     }
       */
      readonly private_link_service_aliases?: {
        [key: string]: string;
      };
      /**
       * @description The mapping of zones to Private Link Service Resource IDs if available. Keys are zones
       *     and values are [Azure Private Link Service Resource
       *     IDs](https://docs.microsoft.com/en-us/azure/private-link/private-link-service-overview#share-your-service).
       *
       * @example {
       *       "1": "/subscriptions/00000000-0000-0000-0000-000000000000/resourceGroups/0-00000/providers/Microsoft.Network/privateLinkServices/0-00000-privatelink-1",
       *       "2": "/subscriptions/00000000-0000-0000-0000-000000000000/resourceGroups/0-00000/providers/Microsoft.Network/privateLinkServices/0-00000-privatelink-2",
       *       "3": "/subscriptions/00000000-0000-0000-0000-000000000000/resourceGroups/0-00000/providers/Microsoft.Network/privateLinkServices/0-00000-privatelink-3"
       *     }
       */
      readonly private_link_service_resource_ids?: {
        [key: string]: string;
      };
    };
    /**
     * AWS
     * @description AWS VPC Peering.
     */
    "networking.v1.AwsPeering": {
      /**
       * @description Peering kind type. (enum property replaced by openapi-typescript)
       * @enum {string}
       */
      kind: "AwsPeering";
      /**
       * @description The AWS account ID associated with the VPC you are peering with Confluent Cloud network.
       * @example 000000000000
       */
      account: string;
      /**
       * @description The VPC ID you are peering with Confluent Cloud network.
       * @example vpc-00000000000000000
       */
      vpc: string;
      /**
       * @description The [CIDR blocks](https://en.wikipedia.org/wiki/Classless_Inter-Domain_Routing) of the VPC you are peering
       *     with Confluent Cloud network. This is used by Confluent Cloud network to route traffic back to your network.
       *     The CIDR block must be a private range and cannot overlap with the Confluent Cloud CIDR block.
       *
       * @example [
       *       "10.108.16.0/21"
       *     ]
       */
      routes: components["schemas"]["networking.v1.Cidr"][];
      /**
       * @description The region of the VPC you are peering with Confluent Cloud network.
       * @example us-east-1
       */
      customer_region: string;
    };
    /**
     * GCP
     * @description GCP VPC Peering.
     */
    "networking.v1.GcpPeering": {
      /**
       * @description Peering kind type. (enum property replaced by openapi-typescript)
       * @enum {string}
       */
      kind: "GcpPeering";
      /**
       * @description The Google Cloud project ID associated with the VPC that you are peering with Confluent Cloud network.
       *
       * @example my-gcp-project
       */
      project: string;
      /**
       * @description The name of the VPC that you are peering with Confluent Cloud network.
       * @example my-gcp-network
       */
      vpc_network: string;
      /**
       * @description Enable customer route import. For more information, see
       *     [Importing custom routes](https://cloud.google.com/vpc/docs/vpc-peering#importing-exporting-routes).
       *
       * @default false
       * @example true
       */
      import_custom_routes: boolean;
    };
    /**
     * AZURE
     * @description Azure VNet Peering.
     */
    "networking.v1.AzurePeering": {
      /**
       * @description Peering kind type. (enum property replaced by openapi-typescript)
       * @enum {string}
       */
      kind: "AzurePeering";
      /** @description The Azure Tenant ID in which your Azure Subscription exists.
       *     Represents an organization in Azure Active Directory. You can find your Azure Tenant ID in the Azure Portal
       *     under
       *     [Azure Active Directory](https://portal.azure.com/#blade/Microsoft_AAD_IAM/ActiveDirectoryMenuBlade/Overview).
       *     Must be a valid **32 character UUID string**.
       *      */
      tenant: string;
      /**
       * @description The resource ID of the VNet that you are peering with Confluent Cloud. You can find the name of your Azure VNet in the [Azure Portal on the Overview tab of your Azure Virtual Network](https://portal.azure.com/#blade/HubsExtension/BrowseResource/resourceType/Microsoft.Network%2FvirtualNetworks).
       * @example /subscriptions/00000000-0000-0000-0000-000000000000/resourceGroups/my-rg/providers/Microsoft.Network/virtualNetworks/my-vnet
       */
      vnet: string;
      /**
       * @description The region of the VNet you are peering with Confluent Cloud network.
       * @example eastus2
       */
      customer_region: string;
    };
    /**
     * AWS
     * @description AWS Transit Gateway Attachment.
     */
    "networking.v1.AwsTransitGatewayAttachment": {
      /**
       * @description AWS Transit Gateway Attachment kind type. (enum property replaced by openapi-typescript)
       * @enum {string}
       */
      kind: "AwsTransitGatewayAttachment";
      /**
       * @description The full AWS Resource Name (ARN) for the AWS Resource Access Manager (RAM) Share of the Transit Gateways that you want Confluent Cloud to be attached to.
       * @example arn:aws:ram:us-west-3:000000000000:resource-share/xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxx
       */
      ram_share_arn: string;
      /**
       * @description The ID of the AWS Transit Gateway that you want Confluent CLoud to be attached to.
       * @example tgw-xxxxxxxxxxxxxxxxx
       */
      transit_gateway_id: string;
      /**
       * @description List of destination routes.
       * @example [
       *       "100.64.0.0/10",
       *       "10.0.0.0/8",
       *       "192.168.0.0/16",
       *       "172.16.0.0/12"
       *     ]
       */
      routes: components["schemas"]["networking.v1.Cidr"][];
    };
    /**
     * AWS
     * @description AWS Transit Gateway Attachment details generated by AWS.
     */
    "networking.v1.AwsTransitGatewayAttachmentStatus": {
      /**
       * @description AWS Transit Gateway Attachment Status kind type. (enum property replaced by openapi-typescript)
       * @enum {string}
       */
      kind: "AwsTransitGatewayAttachmentStatus";
      /**
       * @description The ID of the AWS Transit Gateway VPC Attachment that attaches Confluent VPC to Transit Gateway.
       * @example tgw-attach-xxxxx
       */
      readonly transit_gateway_attachment_id: string;
    };
    /**
     * AWS
     * @description AWS PrivateLink access configuration.
     */
    "networking.v1.AwsPrivateLinkAccess": {
      /**
       * @description PrivateLink kind type. (enum property replaced by openapi-typescript)
       * @enum {string}
       */
      kind: "AwsPrivateLinkAccess";
      /**
       * @description The AWS account ID for the account containing the VPCs you want to connect from using AWS PrivateLink.
       *     You can find your AWS account ID [here](https://console.aws.amazon.com/billing/home?#/account)
       *     under **My Account** in your AWS Management Console. Must be a **12 character string**.
       *
       * @example 000000000000
       */
      account: string;
    };
    /**
     * AZURE
     * @description Azure PrivateLink access configuration.
     */
    "networking.v1.AzurePrivateLinkAccess": {
      /**
       * @description PrivateLink kind type. (enum property replaced by openapi-typescript)
       * @enum {string}
       */
      kind: "AzurePrivateLinkAccess";
      /** @description The Azure subscription ID for the account containing the VNets you want to connect from using
       *     Azure Private Link. You can find your Azure subscription ID in the subscription section of your
       *     [Microsoft Azure Portal](https://portal.azure.com/#blade/Microsoft_Azure_Billing/SubscriptionsBlade).
       *     Must be a valid **32 character UUID string**.
       *      */
      subscription: string;
    };
    /**
     * GCP
     * @description GCP Private Service Connect access configuration.
     */
    "networking.v1.GcpPrivateServiceConnectAccess": {
      /**
       * @description PrivateLink kind type. (enum property replaced by openapi-typescript)
       * @enum {string}
       */
      kind: "GcpPrivateServiceConnectAccess";
      /** @description The GCP project ID for the account containing the VPCs that you want to connect from
       *     using Private Service Connect. You can find your Google Cloud Project ID under **Project ID** section of
       *     your [Google Cloud Console dashboard](https://console.cloud.google.com/home/dashboard).
       *      */
      project: string;
    };
    /**
     * Network Link Service
     * @description List of environments/networks from which connections can be accepted on this network link service.
     *
     */
    "networking.v1.NetworkLinkServiceAcceptPolicy": {
      /** @description List of environments from which connections can be accepted.
       *     All networks win the list of environment will be allowed.
       *      */
      environments?: string[];
      /** @description List of networks from which connections can be accepted.
       *      */
      networks?: string[];
    };
    /** @description Cloud provider zone metadata. */
    "networking.v1.ZoneInfo": {
      /**
       * @description Cloud provider zone id
       * @example use1-az3
       */
      zone_id?: string;
      /**
       * @description The IPv4 [CIDR block](https://en.wikipedia.org/wiki/Classless_Inter-Domain_Routing) to used for this network.
       *     Must be a `/27`. Required for VPC peering and AWS TransitGateway.
       *
       * @example 10.20.0.0/27
       */
      cidr?: string;
    };
    /** @description `Network` represents a network (VPC) in Confluent Cloud. All Networks exist within Confluent-managed cloud
     *     provider accounts. Dedicated networks support more networking options but can only contain Dedicated clusters.
     *     Shared networks can contain any cluster type.
     *
     *     The API allows you to list, create, read, update, and delete your networks.
     *
     *
     *     Related guide: [APIs to manage networks in Confluent Cloud](https://docs.confluent.io/cloud/current/networking/overview.html).
     *
     *     ## The Networks Model
     *     <SchemaDefinition schemaRef="#/components/schemas/networking.v1.Network" />
     *
     *     ## Quotas and Limits
     *     This resource is subject to the [following quotas](https://docs.confluent.io/cloud/current/quotas/overview.html):
     *
     *     | Quota | Description |
     *     | --- | --- |
     *     | `dedicated_networks_per_environment` | Number of dedicated networks per Confluent Cloud environment | */
    "networking.v1.NetworkList": {
      /**
       * @description APIVersion defines the schema version of this representation of a resource.
       * @enum {string}
       */
      readonly api_version: "networking/v1";
      /**
       * @description Kind defines the object this REST resource represents.
       * @enum {string}
       */
      readonly kind: "NetworkList";
      metadata: components["schemas"]["ListMeta"] & {
        /** @example https://api.confluent.cloud/networking/v1/networks */
        first?: unknown;
        /** @example https://api.confluent.cloud/networking/v1/networks?page_token=bcAOehAY8F16YD84Z1wT */
        last?: unknown;
        /** @example https://api.confluent.cloud/networking/v1/networks?page_token=YIXRY97wWYmwzrax4dld */
        prev?: unknown;
        /** @example https://api.confluent.cloud/networking/v1/networks?page_token=UvmDWOB1iwfAIBPj6EYb */
        next?: unknown;
      };
      /** @description A data property that contains an array of resource items. Each entry in the array is a separate resource. */
      data: (components["schemas"]["networking.v1.Network"] & {
        spec: Record<string, unknown>;
      })[];
    };
    /** @description The desired state of the Network */
    "networking.v1.NetworkSpec": {
      /**
       * @description The name of the network
       * @example prod-aws-us-east1
       */
      display_name?: string;
      /**
       * @description The cloud service provider in which the network exists.
       * @example AWS
       */
      cloud?: string;
      /**
       * @description The cloud service provider region in which the network exists.
       * @example us-east-1
       */
      region?: string;
      /** @description The connection types requested for use with the network. */
      connection_types?: components["schemas"]["networking.v1.ConnectionType"][];
      /**
       * @description The IPv4 [CIDR block](https://en.wikipedia.org/wiki/Classless_Inter-Domain_Routing) to used for this network.
       *     Must be `/16`. Required for VPC peering and AWS TransitGateway.
       *
       * @example 10.200.0.0/16
       */
      cidr?: string;
      /**
       * @description The 3 availability zones for this network. They can optionally be specified for AWS networks
       *     used with PrivateLink, for GCP networks used with Private Service Connect, and for AWS and GCP
       *     networks used with Peering.
       *     Otherwise, they are automatically chosen by Confluent Cloud.
       *
       *     On AWS, zones are AWS [AZ IDs](https://docs.aws.amazon.com/ram/latest/userguide/working-with-az-ids.html)
       *      (e.g. use1-az3)
       *
       *     On GCP, zones are GCP [zones](https://cloud.google.com/compute/docs/regions-zones)
       *      (e.g. us-central1-c).
       *
       *     On Azure, zones are Confluent-chosen names (e.g. 1, 2, 3) since Azure does not
       *      have universal zone identifiers.
       *
       * @example [
       *       "use1-az1",
       *       "use1-az2",
       *       "use1-az3"
       *     ]
       */
      zones?: string[];
      /** @description Each item represents information related to a single zone.
       *
       *     Note - The attribute is in a [Limited Availability lifecycle stage](https://docs.confluent.io/cloud/current/api.html#section/Versioning/API-Lifecycle-Policy)
       *      */
      zones_info?: components["schemas"]["networking.v1.ZoneInfo"][];
      /** @description DNS config only applies to PrivateLink network connection type.
       *
       *     When resolution is CHASED_PRIVATE, clusters in this network require both public and private DNS
       *      to resolve cluster endpoints.
       *
       *     When resolution is PRIVATE, clusters in this network only require private DNS
       *      to resolve cluster endpoints.
       *      */
      dns_config?: components["schemas"]["networking.v1.DnsConfig"];
      /**
       * @description The reserved CIDR config is used only by AWS networks with connection_types = Vpc_Peering or Transit_Gateway
       *
       *     An IPv4 [CIDR](https://en.wikipedia.org/wiki/Classless_Inter-Domain_Routing)
       *       reserved for Confluent Cloud Network. Must be \24.
       *       If not specified, Confluent Cloud Network uses 172.20.255.0/24
       *
       *     Note - The attribute is in a [Limited Availability lifecycle stage](https://docs.confluent.io/cloud/current/api.html#section/Versioning/API-Lifecycle-Policy)
       *
       * @example 172.20.255.0/24
       */
      reserved_cidr?: string;
      /** @description The environment to which this belongs. */
      environment?: components["schemas"]["ObjectReference"];
      /** @description The gateway associated with this object. The gateway can be one of networking.v1.Gateway. May be `null` or omitted if not associated with a gateway. */
      readonly gateway?:
        | components["schemas"]["TypedEnvScopedObjectReference"]
        | null;
    };
    /** @description Add or remove VPC/VNet peering connections between your VPC/VNet and Confluent Cloud.
     *
     *     Related guides:
     *     * [Use VPC peering connections with Confluent Cloud on AWS](https://docs.confluent.io/cloud/current/networking/peering/aws-peering.html).
     *     * [Use VNet peering connections with Confluent Cloud on Azure](https://docs.confluent.io/cloud/current/networking/peering/azure-peering.html).
     *     * [Use VPC peering connections with Confluent Cloud on Google Cloud](https://docs.confluent.io/cloud/current/networking/peering/gcp-peering.html).
     *
     *
     *     ## The Peerings Model
     *     <SchemaDefinition schemaRef="#/components/schemas/networking.v1.Peering" />
     *
     *     ## Quotas and Limits
     *     This resource is subject to the [following quotas](https://docs.confluent.io/cloud/current/quotas/overview.html):
     *
     *     | Quota | Description |
     *     | --- | --- |
     *     | `peerings_per_network` | Number of peerings per network | */
    "networking.v1.PeeringList": {
      /**
       * @description APIVersion defines the schema version of this representation of a resource.
       * @enum {string}
       */
      readonly api_version: "networking/v1";
      /**
       * @description Kind defines the object this REST resource represents.
       * @enum {string}
       */
      readonly kind: "PeeringList";
      metadata: components["schemas"]["ListMeta"] & {
        /** @example https://api.confluent.cloud/networking/v1/peerings */
        first?: unknown;
        /** @example https://api.confluent.cloud/networking/v1/peerings?page_token=bcAOehAY8F16YD84Z1wT */
        last?: unknown;
        /** @example https://api.confluent.cloud/networking/v1/peerings?page_token=YIXRY97wWYmwzrax4dld */
        prev?: unknown;
        /** @example https://api.confluent.cloud/networking/v1/peerings?page_token=UvmDWOB1iwfAIBPj6EYb */
        next?: unknown;
      };
      /** @description A data property that contains an array of resource items. Each entry in the array is a separate resource. */
      data: (components["schemas"]["networking.v1.Peering"] & {
        spec: Record<string, unknown>;
      })[];
    };
    /** @description The desired state of the Peering */
    "networking.v1.PeeringSpec": {
      /**
       * @description The name of the peering
       * @example prod-peering-use1
       */
      display_name?: string;
      /** @description The cloud-specific peering details. */
      cloud?:
        | components["schemas"]["networking.v1.AwsPeering"]
        | components["schemas"]["networking.v1.GcpPeering"]
        | components["schemas"]["networking.v1.AzurePeering"];
      /** @description The environment to which this belongs. */
      environment?: components["schemas"]["ObjectReference"];
      /** @description The network to which this belongs. */
      network?: components["schemas"]["ObjectReference"];
    };
    /** @description AWS Transit Gateway Attachments
     *
     *     Related guide: [APIs to manage AWS Transit Gateway Attachments](https://docs.confluent.io/cloud/current/networking/aws-transit-gateway.html).
     *
     *     ## The Transit Gateway Attachments Model
     *     <SchemaDefinition schemaRef="#/components/schemas/networking.v1.TransitGatewayAttachment" />
     *
     *     ## Quotas and Limits
     *     This resource is subject to the [following quotas](https://docs.confluent.io/cloud/current/quotas/overview.html):
     *
     *     | Quota | Description |
     *     | --- | --- |
     *     | `tgw_attachments_per_network` | Number of TGW attachments per network | */
    "networking.v1.TransitGatewayAttachmentList": {
      /**
       * @description APIVersion defines the schema version of this representation of a resource.
       * @enum {string}
       */
      readonly api_version: "networking/v1";
      /**
       * @description Kind defines the object this REST resource represents.
       * @enum {string}
       */
      readonly kind: "TransitGatewayAttachmentList";
      metadata: components["schemas"]["ListMeta"] & {
        /** @example https://api.confluent.cloud/networking/v1/transit-gateway-attachments */
        first?: unknown;
        /** @example https://api.confluent.cloud/networking/v1/transit-gateway-attachments?page_token=bcAOehAY8F16YD84Z1wT */
        last?: unknown;
        /** @example https://api.confluent.cloud/networking/v1/transit-gateway-attachments?page_token=YIXRY97wWYmwzrax4dld */
        prev?: unknown;
        /** @example https://api.confluent.cloud/networking/v1/transit-gateway-attachments?page_token=UvmDWOB1iwfAIBPj6EYb */
        next?: unknown;
      };
      /** @description A data property that contains an array of resource items. Each entry in the array is a separate resource. */
      data: (components["schemas"]["networking.v1.TransitGatewayAttachment"] & {
        spec: Record<string, unknown>;
      })[];
    };
    /** @description The desired state of the Transit Gateway Attachment */
    "networking.v1.TransitGatewayAttachmentSpec": {
      /**
       * @description The name of the TGW attachment
       * @example prod-tgw-use1
       */
      display_name?: string;
      /** @description The cloud-specific Transit Gateway details. */
      cloud?: components["schemas"]["networking.v1.AwsTransitGatewayAttachment"];
      /** @description The environment to which this belongs. */
      environment?: components["schemas"]["ObjectReference"];
      /** @description The network to which this belongs. */
      network?: components["schemas"]["ObjectReference"];
    };
    /** @description Add or remove access to PrivateLink endpoints by AWS account, Azure subscription and GCP project ID.
     *
     *     Related guides:
     *     * [Use Google Cloud Private Service Connect with Confluent Cloud](https://docs.confluent.io/cloud/current/networking/private-links/gcp-private-service-connect.html).
     *     * [Use Azure Private Link with Confluent Cloud](https://docs.confluent.io/cloud/current/networking/private-links/azure-privatelink.html).
     *     * [Use AWS PrivateLink with Confluent Cloud](https://docs.confluent.io/cloud/current/networking/private-links/aws-privatelink.html).
     *
     *
     *     ## The Private Link Accesses Model
     *     <SchemaDefinition schemaRef="#/components/schemas/networking.v1.PrivateLinkAccess" />
     *
     *     ## Quotas and Limits
     *     This resource is subject to the [following quotas](https://docs.confluent.io/cloud/current/quotas/overview.html):
     *
     *     | Quota | Description |
     *     | --- | --- |
     *     | `private_link_accounts_per_network` | Number of AWS accounts per network |
     *     | `private_link_subscriptions_per_network` | Number of Azure subscriptions per network |
     *     | `private_service_connect_projects_per_network` | Number of GCP projects per network | */
    "networking.v1.PrivateLinkAccessList": {
      /**
       * @description APIVersion defines the schema version of this representation of a resource.
       * @enum {string}
       */
      readonly api_version: "networking/v1";
      /**
       * @description Kind defines the object this REST resource represents.
       * @enum {string}
       */
      readonly kind: "PrivateLinkAccessList";
      metadata: components["schemas"]["ListMeta"] & {
        /** @example https://api.confluent.cloud/networking/v1/private-link-accesses */
        first?: unknown;
        /** @example https://api.confluent.cloud/networking/v1/private-link-accesses?page_token=bcAOehAY8F16YD84Z1wT */
        last?: unknown;
        /** @example https://api.confluent.cloud/networking/v1/private-link-accesses?page_token=YIXRY97wWYmwzrax4dld */
        prev?: unknown;
        /** @example https://api.confluent.cloud/networking/v1/private-link-accesses?page_token=UvmDWOB1iwfAIBPj6EYb */
        next?: unknown;
      };
      /** @description A data property that contains an array of resource items. Each entry in the array is a separate resource. */
      data: (components["schemas"]["networking.v1.PrivateLinkAccess"] & {
        spec: Record<string, unknown>;
      })[];
    };
    /** @description The desired state of the Private Link Access */
    "networking.v1.PrivateLinkAccessSpec": {
      /**
       * @description The name of the PrivateLink access
       * @example prod-pl-use1
       */
      display_name?: string;
      /** @description The cloud-specific PrivateLink details. */
      cloud?:
        | components["schemas"]["networking.v1.AwsPrivateLinkAccess"]
        | components["schemas"]["networking.v1.AzurePrivateLinkAccess"]
        | components["schemas"]["networking.v1.GcpPrivateServiceConnectAccess"];
      /** @description The environment to which this belongs. */
      environment?: components["schemas"]["ObjectReference"];
      /** @description The network to which this belongs. */
      network?: components["schemas"]["ObjectReference"];
    };
    /** @description Network Link Service is associated with a Private Link Confluent Cloud Network.
     *     It enables connectivity from other Private Link Confluent Cloud Networks based on
     *     the configured accept policies.
     *
     *
     *     Related guide: [Network Linking Overview](https://docs.confluent.io/cloud/current/networking/network-linking.html).
     *
     *     ## The Network Link Services Model
     *     <SchemaDefinition schemaRef="#/components/schemas/networking.v1.NetworkLinkService" />
     *
     *     ## Quotas and Limits
     *     This resource is subject to the [following quotas](https://docs.confluent.io/cloud/current/quotas/overview.html):
     *
     *     | Quota | Description |
     *     | --- | --- |
     *     | `network_link_service_per_network` | Number of network link services per network | */
    "networking.v1.NetworkLinkServiceList": {
      /**
       * @description APIVersion defines the schema version of this representation of a resource.
       * @enum {string}
       */
      readonly api_version: "networking/v1";
      /**
       * @description Kind defines the object this REST resource represents.
       * @enum {string}
       */
      readonly kind: "NetworkLinkServiceList";
      metadata: components["schemas"]["ListMeta"] & {
        /** @example https://api.confluent.cloud/networking/v1/network-link-services */
        first?: unknown;
        /** @example https://api.confluent.cloud/networking/v1/network-link-services?page_token=bcAOehAY8F16YD84Z1wT */
        last?: unknown;
        /** @example https://api.confluent.cloud/networking/v1/network-link-services?page_token=YIXRY97wWYmwzrax4dld */
        prev?: unknown;
        /** @example https://api.confluent.cloud/networking/v1/network-link-services?page_token=UvmDWOB1iwfAIBPj6EYb */
        next?: unknown;
      };
      /** @description A data property that contains an array of resource items. Each entry in the array is a separate resource. */
      data: (components["schemas"]["networking.v1.NetworkLinkService"] & {
        spec: Record<string, unknown>;
      })[];
    };
    /** @description The desired state of the Network Link Service */
    "networking.v1.NetworkLinkServiceSpec": {
      /**
       * @description The name of the network link service
       * @example prod-net-1-nls
       */
      display_name?: string;
      /**
       * @description The description of the network link service
       * @example Allow connections from analytics hub
       */
      description?: string;
      /** @description Network Link Service Accept policy */
      accept?: components["schemas"]["networking.v1.NetworkLinkServiceAcceptPolicy"];
      /** @description The environment to which this belongs. */
      environment?: components["schemas"]["GlobalObjectReference"];
      /** @description The network to which this belongs. */
      network?: components["schemas"]["EnvScopedObjectReference"];
    };
    /** @description A Network Link Enpoint is associated with a Private Link Confluent Cloud Network at the origin and a
     *     Network Link Service (associated with another Private Link Confluent Cloud Network) at the target.
     *     It enables connectivity between the origin network and the target network.
     *     It can only be associated with a Private Link network.
     *
     *
     *     Related guide: [Network Linking Overview](https://docs.confluent.io/cloud/current/networking/network-linking.html).
     *
     *     ## The Network Link Endpoints Model
     *     <SchemaDefinition schemaRef="#/components/schemas/networking.v1.NetworkLinkEndpoint" />
     *
     *     ## Quotas and Limits
     *     This resource is subject to the [following quotas](https://docs.confluent.io/cloud/current/quotas/overview.html):
     *
     *     | Quota | Description |
     *     | --- | --- |
     *     | `network_link_endpoints_per_network` | Number of network link endpoints per network | */
    "networking.v1.NetworkLinkEndpointList": {
      /**
       * @description APIVersion defines the schema version of this representation of a resource.
       * @enum {string}
       */
      readonly api_version: "networking/v1";
      /**
       * @description Kind defines the object this REST resource represents.
       * @enum {string}
       */
      readonly kind: "NetworkLinkEndpointList";
      metadata: components["schemas"]["ListMeta"] & {
        /** @example https://api.confluent.cloud/networking/v1/network-link-endpoints */
        first?: unknown;
        /** @example https://api.confluent.cloud/networking/v1/network-link-endpoints?page_token=bcAOehAY8F16YD84Z1wT */
        last?: unknown;
        /** @example https://api.confluent.cloud/networking/v1/network-link-endpoints?page_token=YIXRY97wWYmwzrax4dld */
        prev?: unknown;
        /** @example https://api.confluent.cloud/networking/v1/network-link-endpoints?page_token=UvmDWOB1iwfAIBPj6EYb */
        next?: unknown;
      };
      /** @description A data property that contains an array of resource items. Each entry in the array is a separate resource. */
      data: (components["schemas"]["networking.v1.NetworkLinkEndpoint"] & {
        spec: Record<string, unknown>;
      })[];
    };
    /** @description The desired state of the Network Link Endpoint */
    "networking.v1.NetworkLinkEndpointSpec": {
      /**
       * @description The name of the network link endpoint
       * @example prod-net-1-nle
       */
      display_name?: string;
      /**
       * @description The description of the network link endpoint
       * @example Connect to Network - analytics hub
       */
      description?: string;
      /** @description The environment to which this belongs. */
      environment?: components["schemas"]["GlobalObjectReference"];
      /** @description The network to which this belongs. */
      network?: components["schemas"]["EnvScopedObjectReference"];
      /** @description The network_link_service to which this belongs. */
      network_link_service?: components["schemas"]["EnvScopedObjectReference"];
    };
    /** @description List of incoming Network Link Enpoints associated with the Network Link Service.
     *
     *
     *     Related guide: [Network Linking Overview](https://docs.confluent.io/cloud/current/networking/network-linking.html).
     *
     *     ## The Network Link Service Associations Model
     *     <SchemaDefinition schemaRef="#/components/schemas/networking.v1.NetworkLinkServiceAssociation" /> */
    "networking.v1.NetworkLinkServiceAssociationList": {
      /**
       * @description APIVersion defines the schema version of this representation of a resource.
       * @enum {string}
       */
      readonly api_version: "networking/v1";
      /**
       * @description Kind defines the object this REST resource represents.
       * @enum {string}
       */
      readonly kind: "NetworkLinkServiceAssociationList";
      metadata: components["schemas"]["ListMeta"] & {
        /** @example https://api.confluent.cloud/networking/v1/network-link-service-associations */
        first?: unknown;
        /** @example https://api.confluent.cloud/networking/v1/network-link-service-associations?page_token=bcAOehAY8F16YD84Z1wT */
        last?: unknown;
        /** @example https://api.confluent.cloud/networking/v1/network-link-service-associations?page_token=YIXRY97wWYmwzrax4dld */
        prev?: unknown;
        /** @example https://api.confluent.cloud/networking/v1/network-link-service-associations?page_token=UvmDWOB1iwfAIBPj6EYb */
        next?: unknown;
      };
      /** @description A data property that contains an array of resource items. Each entry in the array is a separate resource. */
      data: (components["schemas"]["networking.v1.NetworkLinkServiceAssociation"] & {
        spec: Record<string, unknown>;
      })[];
    };
    /** @description The desired state of the Network Link Service Association */
    "networking.v1.NetworkLinkServiceAssociationSpec": {
      /**
       * @description The name of the network link endpoint
       * @example prod-net-1-nle
       */
      readonly display_name?: string;
      /**
       * @description The description of the network link endpoint
       * @example Connect to Network - analytics hub
       */
      readonly description?: string;
      /**
       * @description ID of the Network link endpoint.
       * @example prod-net-1-nle
       */
      readonly network_link_endpoint?: string;
      /** @description The network_link_service to which this belongs. */
      network_link_service?: components["schemas"]["EnvScopedObjectReference"];
      /** @description The environment to which this belongs. */
      environment?: components["schemas"]["GlobalObjectReference"];
    };
    /** @description IP Addresses
     *
     *     Related guide: [Use Public Egress IP addresses on Confluent Cloud](https://docs.confluent.io/cloud/current/networking/static-egress-ip-addresses.html)
     *
     *     ## The IP Addresses Model
     *     <SchemaDefinition schemaRef="#/components/schemas/networking.v1.IpAddress" /> */
    "networking.v1.IpAddress": {
      /**
       * @description APIVersion defines the schema version of this representation of a resource.
       * @enum {string}
       */
      readonly api_version?: "networking/v1";
      /**
       * @description Kind defines the object this REST resource represents.
       * @enum {string}
       */
      readonly kind?: "IpAddress";
      /**
       * @description The IP Address range.
       * @example 10.200.0.0/28
       */
      ip_prefix?: string;
      /**
       * @description The cloud service provider in which the address exists.
       * @example AWS
       */
      cloud?: string;
      /**
       * @description The region/location where the IP Address is in use.
       * @example us-east-1
       */
      region?: string;
      /** @description The service types that will use the address. */
      services?: string[];
      /**
       * @description Whether the address is used for egress or ingress.
       * @example EGRESS
       */
      address_type?: string;
    };
    /** @description IP Addresses
     *
     *     Related guide: [Use Public Egress IP Addresses on Confluent Cloud](https://docs.confluent.io/cloud/current/networking/static-egress-ip-addresses.html)
     *
     *     ## The IP Addresses Model
     *     <SchemaDefinition schemaRef="#/components/schemas/networking.v1.IpAddress" /> */
    "networking.v1.IpAddressList": {
      /**
       * @description APIVersion defines the schema version of this representation of a resource.
       * @enum {string}
       */
      readonly api_version: "networking/v1";
      /**
       * @description Kind defines the object this REST resource represents.
       * @enum {string}
       */
      readonly kind: "IpAddressList";
      metadata: components["schemas"]["ListMeta"] & {
        /** @example https://api.confluent.cloud/networking/v1/ip-addresses */
        first?: unknown;
        /** @example https://api.confluent.cloud/networking/v1/ip-addresses?page_token=bcAOehAY8F16YD84Z1wT */
        last?: unknown;
        /** @example https://api.confluent.cloud/networking/v1/ip-addresses?page_token=YIXRY97wWYmwzrax4dld */
        prev?: unknown;
        /** @example https://api.confluent.cloud/networking/v1/ip-addresses?page_token=UvmDWOB1iwfAIBPj6EYb */
        next?: unknown;
      };
      /** @description A data property that contains an array of resource items. Each entry in the array is a separate resource. */
      data: (components["schemas"]["networking.v1.IpAddress"] &
        Record<string, unknown>)[];
    };
    /** @description PrivateLink attachment objects represent reservations to establish PrivateLink connections
     *     to a cloud region in order to access resources that belong to a Confluent Cloud Environment.
     *     The API allows you to list, create, read update and delete your PrivateLink attachments.
     *
     *
     *     ## The Private Link Attachments Model
     *     <SchemaDefinition schemaRef="#/components/schemas/networking.v1.PrivateLinkAttachment" />
     *
     *     ## Quotas and Limits
     *     This resource is subject to the [following quotas](https://docs.confluent.io/cloud/current/quotas/overview.html):
     *
     *     | Quota | Description |
     *     | --- | --- |
     *     | `private_link_attachments_per_environment` | Number of PrivateLink Attachments per environment | */
    "networking.v1.PrivateLinkAttachment": {
      /**
       * @description APIVersion defines the schema version of this representation of a resource.
       * @enum {string}
       */
      readonly api_version?: "networking/v1";
      /**
       * @description Kind defines the object this REST resource represents.
       * @enum {string}
       */
      readonly kind?: "PrivateLinkAttachment";
      /**
       * @description ID is the "natural identifier" for an object within its scope/namespace; it is normally unique across time but not space. That is, you can assume that the ID will not be reclaimed and reused after an object is deleted ("time"); however, it may collide with IDs for other object `kinds` or objects of the same `kind` within a different scope/namespace ("space").
       * @example dlz-f3a90de
       */
      readonly id?: string;
      metadata?: components["schemas"]["ObjectMeta"] & {
        /** @example https://api.confluent.cloud/networking/v1/private-link-attachments/platt-12345 */
        self?: unknown;
        /** @example crn://confluent.cloud/organization=9bb441c4-edef-46ac-8a41-c49e44a3fd9a/private-link-attachment=platt-12345 */
        resource_name?: unknown;
      };
      spec?: components["schemas"]["networking.v1.PrivateLinkAttachmentSpec"];
      status?: components["schemas"]["networking.v1.PrivateLinkAttachmentStatus"];
    };
    /** @description The status of the Private Link Attachment */
    "networking.v1.PrivateLinkAttachmentStatus": {
      /**
       * @description The lifecycle phase of the PrivateLink attachment:
       *
       *       PROVISIONING: PrivateLink attachment provisioning is in progress;
       *
       *       WAITING_FOR_CONNECTIONS: PrivateLink attachment is waiting for connections;
       *
       *       READY: PrivateLink attachment is ready;
       *
       *       FAILED: PrivateLink attachment is in a failed state;
       *
       *       EXPIRED: PrivateLink attachment has timed out waiting for connections, can only be deleted;
       *
       *       DEPROVISIONING: PrivateLink attachment deprovisioning is in progress;
       *
       * @example READY
       */
      readonly phase: string;
      /** @description Error code if PrivateLink attachment is in a failed state. May be used for programmatic error checking. */
      readonly error_code?: string;
      /** @description Displayable error message if PrivateLink attachment is in a failed state. */
      readonly error_message?: string;
      /**
       * @description The root DNS domain for the PrivateLink attachment.
       * @example us-east-1.aws.private.confluent.cloud
       */
      readonly dns_domain?: string;
      /** @description The cloud specific status of the PrivateLink attachment. These will be populated when the PrivateLink attachment reaches the WAITING_FOR_CONNECTIONS state. */
      readonly cloud?:
        | components["schemas"]["networking.v1.AwsPrivateLinkAttachmentStatus"]
        | components["schemas"]["networking.v1.AzurePrivateLinkAttachmentStatus"]
        | components["schemas"]["networking.v1.GcpPrivateLinkAttachmentStatus"];
    };
    /** @description PrivateLink attachment connection objects represent connections established to a cloud region
     *     in order to access resources that belong to a Confluent Cloud Environment.
     *     The API allows you to list, create, read update and delete your PrivateLink attachment connections.
     *
     *
     *     ## The Private Link Attachment Connections Model
     *     <SchemaDefinition schemaRef="#/components/schemas/networking.v1.PrivateLinkAttachmentConnection" /> */
    "networking.v1.PrivateLinkAttachmentConnection": {
      /**
       * @description APIVersion defines the schema version of this representation of a resource.
       * @enum {string}
       */
      readonly api_version?: "networking/v1";
      /**
       * @description Kind defines the object this REST resource represents.
       * @enum {string}
       */
      readonly kind?: "PrivateLinkAttachmentConnection";
      /**
       * @description ID is the "natural identifier" for an object within its scope/namespace; it is normally unique across time but not space. That is, you can assume that the ID will not be reclaimed and reused after an object is deleted ("time"); however, it may collide with IDs for other object `kinds` or objects of the same `kind` within a different scope/namespace ("space").
       * @example dlz-f3a90de
       */
      readonly id?: string;
      metadata?: components["schemas"]["ObjectMeta"] & {
        /** @example https://api.confluent.cloud/networking/v1/private-link-attachment-connections/plattc-12345 */
        self?: unknown;
        /** @example crn://confluent.cloud/organization=9bb441c4-edef-46ac-8a41-c49e44a3fd9a/private-link-attachment-connection=plattc-12345 */
        resource_name?: unknown;
      };
      spec?: components["schemas"]["networking.v1.PrivateLinkAttachmentConnectionSpec"];
      status?: components["schemas"]["networking.v1.PrivateLinkAttachmentConnectionStatus"];
    };
    /** @description The status of the Private Link Attachment Connection */
    "networking.v1.PrivateLinkAttachmentConnectionStatus": {
      /**
       * @description The lifecycle phase of the PrivateLink attachment:
       *
       *       PROVISIONING: PrivateLink attachment connection provisioning is in progress;
       *
       *       READY: PrivateLink attachment connection is ready;
       *
       *       FAILED: PrivateLink attachment connection is in a failed state;
       *
       *       DEPROVISIONING: PrivateLink attachment connection deprovisioning is in progress;
       *
       *       DISCONNECTED:|
       *         PrivateLink attachment connection is in a disconnected state. This means the
       *         private endpoint associated with this PrivateLink attachment connection has been deleted;
       *
       * @example READY
       */
      readonly phase: string;
      /** @description Error code if PrivateLink attachment connection is in a failed state. May be used for programmatic error checking. */
      readonly error_code?: string;
      /** @description Displayable error message if PrivateLink attachment connection is in a failed state. */
      readonly error_message?: string;
      /** @description The cloud specific status of the PrivateLink attachment connection. */
      readonly cloud?:
        | components["schemas"]["networking.v1.AwsPrivateLinkAttachmentConnectionStatus"]
        | components["schemas"]["networking.v1.AzurePrivateLinkAttachmentConnectionStatus"]
        | components["schemas"]["networking.v1.GcpPrivateLinkAttachmentConnectionStatus"];
    };
    /** @description AWS PrivateLink attachment represents reserved capacity in an
     *     AWS VPC Endpoint Service that can be used to establish PrivateLink
     *     connections.
     *      */
    "networking.v1.AwsPrivateLinkAttachmentStatus": {
      /**
       * @description PrivateLinkAttachmentStatus kind. (enum property replaced by openapi-typescript)
       * @enum {string}
       */
      kind: "AwsPrivateLinkAttachmentStatus";
      /** @description AWS VPC Endpoint Service that can be used to establish connections for all zones.
       *      */
      readonly vpc_endpoint_service: components["schemas"]["networking.v1.AwsVpcEndpointService"];
    };
    /** @description AWS VPC Endpoint service that can be used to create VPC Endpoints.
     *      */
    "networking.v1.AwsVpcEndpointService": {
      /** @description Id of the VPC Endpoint service. */
      readonly vpc_endpoint_service_name: string;
    };
    /** @description Azure PrivateLink attachment represents reserved capacity in a
     *     PrivateLink service that can be used to establish PrivateLink
     *      */
    "networking.v1.AzurePrivateLinkAttachmentStatus": {
      /**
       * @description PrivateLinkAttachmentStatus kind. (enum property replaced by openapi-typescript)
       * @enum {string}
       */
      kind: "AzurePrivateLinkAttachmentStatus";
      /** @description Azure PrivateLink service that can be used to connect to a PrivateEndpoint.
       *      */
      readonly private_link_service: components["schemas"]["networking.v1.AzurePrivateLinkService"];
    };
    /** @description Azure Private Link Service with reserved capacity to connect a Private Endpoint.
     *      */
    "networking.v1.AzurePrivateLinkService": {
      /**
       * @description Azure PrivateLink service alias.
       * @example pls-plt-abcdef-az3.38748da8-3322-42f7-b97a-6448c21af653.centralus.azure.privatelinkservice
       */
      readonly private_link_service_alias: string;
      /**
       * @description Azure PrivateLink service resource id.
       * @example /subscriptions/00000000-0000-0000-0000-000000000000/resourceGroups/s-abcde/providers/Microsoft.Network/privateLinkServices/pls-plt-abcdef
       */
      readonly private_link_service_resource_id: string;
    };
    /** @description GCP PrivateLink attachment represents reserved capacity in a
     *     GCP PSC Service attachment.  A PSC Endpoint can be connected to
     *     the Service attachment.
     *      */
    "networking.v1.GcpPrivateLinkAttachmentStatus": {
      /**
       * @description PrivateLinkAttachmentStatus kind. (enum property replaced by openapi-typescript)
       * @enum {string}
       */
      kind: "GcpPrivateLinkAttachmentStatus";
      /** @description GCP PSC Service attachment that can be used to connect
       *     to a PSC Endpoint.
       *      */
      readonly service_attachment: components["schemas"]["networking.v1.GcpPscServiceAttachment"];
    };
    /** @description GCP PSC Service attachment with reserved capacity to
     *     connect a PSC Endpoint.
     *      */
    "networking.v1.GcpPscServiceAttachment": {
      /**
       * @description Id of a Private Service Connect Service Attachment in Confluent Cloud.
       * @example projects/example-project/regions/us-central1/serviceAttachments/plt-abcdef-service-attachment-us-central1
       */
      readonly private_service_connect_service_attachment: string;
    };
    /** @description Status of a connection to an AWS PrivateLink attachment. */
    "networking.v1.AwsPrivateLinkAttachmentConnectionStatus": {
      /**
       * @description PrivateLinkAttachmentConnectionStatus kind. (enum property replaced by openapi-typescript)
       * @enum {string}
       */
      kind: "AwsPrivateLinkAttachmentConnectionStatus";
      /**
       * @description Id of the VPC Endpoint service used for PrivateLink.
       * @example com.amazonaws.vpce.us-west-2.vpce-svc-00000000000000000
       */
      readonly vpc_endpoint_service_name: string;
      /**
       * @description Id of the VPC Endpoint (if any) that is connected to the VPC Endpoint service.
       * @example vpce-00000000000000000
       */
      readonly vpc_endpoint_id: string;
    };
    /** @description Status of a Azure PrivateLink attachment connection. */
    "networking.v1.AzurePrivateLinkAttachmentConnectionStatus": {
      /**
       * @description PrivateLinkAttachmentConnectionStatus kind. (enum property replaced by openapi-typescript)
       * @enum {string}
       */
      kind: "AzurePrivateLinkAttachmentConnectionStatus";
      /**
       * @description Azure PrivateLink service alias.
       * @example pls-plt-abcdef-az3.38748da8-3322-42f7-b97a-6448c21af653.centralus.azure.privatelinkservice
       */
      readonly private_link_service_alias: string;
      /**
       * @description Azure PrivateLink service resource id.
       * @example /subscriptions/00000000-0000-0000-0000-000000000000/resourceGroups/s-abcde/providers/Microsoft.Network/privateLinkServices/pls-plt-abcdef-az3
       */
      readonly private_link_service_resource_id: string;
      /**
       * @description Resource Id of the PrivateEndpoint (if any) that is connected to
       *     the PrivateLink service.
       *
       * @example /subscriptions/00000000-0000-0000-0000-000000000000/resourceGroups/testvpc/providers/Microsoft.Network/privateEndpoints/pe-plt-abcdef-az3
       */
      readonly private_endpoint_resource_id: string;
    };
    /** @description Status of GCP PrivateLink attachment connection. */
    "networking.v1.GcpPrivateLinkAttachmentConnectionStatus": {
      /**
       * @description PrivateLinkAttachmentConnectionStatus kind. (enum property replaced by openapi-typescript)
       * @enum {string}
       */
      kind: "GcpPrivateLinkAttachmentConnectionStatus";
      /**
       * @description GCP Private Service Connect ServiceAttachment.
       * @example projects/example-project/regions/us-central1/serviceAttachments/plt-abcdef-service-attachment-us-central1-a
       */
      readonly private_service_connect_service_attachment: string;
      /**
       * @description Id of the Private Service connection.
       * @example 00000000000000000
       */
      readonly private_service_connect_connection_id: string;
    };
    /** @description Represents a connection between an AWS VPC Endpoint and an Endpoint service. */
    "networking.v1.AwsPrivateLinkAttachmentConnection": {
      /**
       * @description PrivateLinkAttachmentConnection kind. (enum property replaced by openapi-typescript)
       * @enum {string}
       */
      kind: "AwsPrivateLinkAttachmentConnection";
      /**
       * @description Id of a VPC Endpoint that is connected to the VPC Endpoint service.
       * @example vpce-00000000000000000
       */
      vpc_endpoint_id: string;
    };
    /** @description Represents a connection between an Azure PrivateLink service and a PrivateEndpoint. */
    "networking.v1.AzurePrivateLinkAttachmentConnection": {
      /**
       * @description PrivateLinkAttachmentConnection kind. (enum property replaced by openapi-typescript)
       * @enum {string}
       */
      kind: "AzurePrivateLinkAttachmentConnection";
      /**
       * @description Resource Id of the PrivateEndpoint that is connected to the PrivateLink service.
       *
       * @example /subscriptions/00000000-0000-0000-0000-000000000000/resourceGroups/testvpc/providers/Microsoft.Network/privateEndpoints/pe-plt-abcdef-az3
       */
      private_endpoint_resource_id: string;
    };
    /** @description Represents a connection between a GCP PSC Service Attachment and a PSC Endpoint. */
    "networking.v1.GcpPrivateLinkAttachmentConnection": {
      /**
       * @description PrivateLinkAttachmentConnection kind. (enum property replaced by openapi-typescript)
       * @enum {string}
       */
      kind: "GcpPrivateLinkAttachmentConnection";
      /**
       * @description Id of the Private Service connection.
       * @example 00000000000000000
       */
      private_service_connect_connection_id: string;
    };
    /** @description PrivateLink attachment objects represent reservations to establish PrivateLink connections
     *     to a cloud region in order to access resources that belong to a Confluent Cloud Environment.
     *     The API allows you to list, create, read update and delete your PrivateLink attachments.
     *
     *
     *     ## The Private Link Attachments Model
     *     <SchemaDefinition schemaRef="#/components/schemas/networking.v1.PrivateLinkAttachment" />
     *
     *     ## Quotas and Limits
     *     This resource is subject to the [following quotas](https://docs.confluent.io/cloud/current/quotas/overview.html):
     *
     *     | Quota | Description |
     *     | --- | --- |
     *     | `private_link_attachments_per_environment` | Number of PrivateLink Attachments per environment | */
    "networking.v1.PrivateLinkAttachmentList": {
      /**
       * @description APIVersion defines the schema version of this representation of a resource.
       * @enum {string}
       */
      readonly api_version: "networking/v1";
      /**
       * @description Kind defines the object this REST resource represents.
       * @enum {string}
       */
      readonly kind: "PrivateLinkAttachmentList";
      metadata: components["schemas"]["ListMeta"] & {
        /** @example https://api.confluent.cloud/networking/v1/private-link-attachments */
        first?: unknown;
        /** @example https://api.confluent.cloud/networking/v1/private-link-attachments?page_token=bcAOehAY8F16YD84Z1wT */
        last?: unknown;
        /** @example https://api.confluent.cloud/networking/v1/private-link-attachments?page_token=YIXRY97wWYmwzrax4dld */
        prev?: unknown;
        /** @example https://api.confluent.cloud/networking/v1/private-link-attachments?page_token=UvmDWOB1iwfAIBPj6EYb */
        next?: unknown;
      };
      /** @description A data property that contains an array of resource items. Each entry in the array is a separate resource. */
      data: (components["schemas"]["networking.v1.PrivateLinkAttachment"] & {
        spec: Record<string, unknown>;
      })[];
    };
    /** @description The desired state of the Private Link Attachment */
    "networking.v1.PrivateLinkAttachmentSpec": {
      /**
       * @description The name of the PrivateLink attachment.
       * @example prod-aws-us-east1
       */
      display_name?: string;
      /**
       * @description The cloud service provider that hosts the resources to access with the PrivateLink attachment.
       *
       * @example AWS
       */
      cloud?: string;
      /**
       * @description The cloud service provider region where the resources to be accessed
       *     using the PrivateLink attachment are located.
       *
       * @example us-east-1
       */
      region?: string;
      /** @description The environment to which this belongs. */
      environment?: components["schemas"]["ObjectReference"];
    };
    /** @description PrivateLink attachment connection objects represent connections established to a cloud region
     *     in order to access resources that belong to a Confluent Cloud Environment.
     *     The API allows you to list, create, read update and delete your PrivateLink attachment connections.
     *
     *
     *     ## The Private Link Attachment Connections Model
     *     <SchemaDefinition schemaRef="#/components/schemas/networking.v1.PrivateLinkAttachmentConnection" /> */
    "networking.v1.PrivateLinkAttachmentConnectionList": {
      /**
       * @description APIVersion defines the schema version of this representation of a resource.
       * @enum {string}
       */
      readonly api_version: "networking/v1";
      /**
       * @description Kind defines the object this REST resource represents.
       * @enum {string}
       */
      readonly kind: "PrivateLinkAttachmentConnectionList";
      metadata: components["schemas"]["ListMeta"] & {
        /** @example https://api.confluent.cloud/networking/v1/private-link-attachment-connections */
        first?: unknown;
        /** @example https://api.confluent.cloud/networking/v1/private-link-attachment-connections?page_token=bcAOehAY8F16YD84Z1wT */
        last?: unknown;
        /** @example https://api.confluent.cloud/networking/v1/private-link-attachment-connections?page_token=YIXRY97wWYmwzrax4dld */
        prev?: unknown;
        /** @example https://api.confluent.cloud/networking/v1/private-link-attachment-connections?page_token=UvmDWOB1iwfAIBPj6EYb */
        next?: unknown;
      };
      /** @description A data property that contains an array of resource items. Each entry in the array is a separate resource. */
      data: (components["schemas"]["networking.v1.PrivateLinkAttachmentConnection"] & {
        spec: Record<string, unknown>;
      })[];
    };
    /** @description The desired state of the Private Link Attachment Connection */
    "networking.v1.PrivateLinkAttachmentConnectionSpec": {
      /**
       * @description The name of the PrivateLink attachment connection.
       * @example prod-gcp-us-central1-a
       */
      display_name?: string;
      /** @description The cloud-specific PrivateLink attachment connection details. */
      cloud?:
        | components["schemas"]["networking.v1.AwsPrivateLinkAttachmentConnection"]
        | components["schemas"]["networking.v1.AzurePrivateLinkAttachmentConnection"]
        | components["schemas"]["networking.v1.GcpPrivateLinkAttachmentConnection"];
      /** @description The environment to which this belongs. */
      environment?: components["schemas"]["ObjectReference"];
      /** @description The private_link_attachment to which this belongs. */
      private_link_attachment?: components["schemas"]["ObjectReference"];
    };
    /** @description `IdentityProvider` objects represent external OAuth-OIDC providers in Confluent Cloud.
     *
     *     The API allows you to list, create, read, update, and delete your Identity Provider.
     *
     *
     *     Related guide: [OAuth for Confluent Cloud](https://docs.confluent.io/cloud/current/access-management/authenticate/oauth/overview.html).
     *
     *     ## The Identity Providers Model
     *     <SchemaDefinition schemaRef="#/components/schemas/iam.v2.IdentityProvider" />
     *
     *     ## Quotas and Limits
     *     This resource is subject to the [following quotas](https://docs.confluent.io/cloud/current/quotas/overview.html):
     *
     *     | Quota | Description |
     *     | --- | --- |
     *     | `identity_providers_per_org` | Number of OAuth identity providers per organization |
     *     | `public_keys_per_provider` | Number of public keys saved per identity provider | */
    "iam.v2.IdentityProvider": {
      /**
       * @description APIVersion defines the schema version of this representation of a resource.
       * @enum {string}
       */
      readonly api_version?: "iam/v2";
      /**
       * @description Kind defines the object this REST resource represents.
       * @enum {string}
       */
      readonly kind?: "IdentityProvider";
      /**
       * @description ID is the "natural identifier" for an object within its scope/namespace; it is normally unique across time but not space. That is, you can assume that the ID will not be reclaimed and reused after an object is deleted ("time"); however, it may collide with IDs for other object `kinds` or objects of the same `kind` within a different scope/namespace ("space").
       * @example dlz-f3a90de
       */
      readonly id?: string;
      metadata?: components["schemas"]["ObjectMeta"] & {
        /** @example https://api.confluent.cloud/iam/v2/identity-providers/ip-12345 */
        self?: unknown;
        /** @example crn://confluent.cloud/organization=9bb441c4-edef-46ac-8a41-c49e44a3fd9a/identity-provider=ip-12345 */
        resource_name?: unknown;
      };
      /**
       * @description The human-readable name of the OAuth identity provider.
       * @example My OIDC Provider
       */
      display_name?: string;
      /** @description A description of the identity provider. */
      description?: string;
      /**
       * @description The JSON Web Token (JWT) claim to extract the authenticating identity to Confluent resources from
       *     [Registered Claim Names](https://datatracker.ietf.org/doc/html/rfc7519#section-4.1). This appears
       *     in audit log records. Note: if the client specifies mapping to one identity pool ID, the identity
       *     claim configured with that pool will be used instead.
       *     Note - The attribute is in an [Early Access lifecycle stage]
       *     (https://docs.confluent.io/cloud/current/api.html#section/Versioning/API-Lifecycle-Policy)
       * @example claims.sub
       */
      identity_claim?: string;
      /**
       * @description The current state of the identity provider.
       * @example ENABLED
       */
      readonly state?: string;
      /**
       * Format: uri
       * @description A publicly accessible URL uniquely identifying the OAuth
       *     identity provider authorized to issue access tokens.
       * @example https://login.microsoftonline.com/{tenantid}/v2.0
       */
      issuer?: string;
      /**
       * Format: uri
       * @description A publicly accessible JSON Web Key Set (JWKS) URI for the OAuth
       *     identity provider. JWKS provides a set of crypotgraphic keys
       *     used to verify the authenticity and integrity of JSON Web
       *     Tokens (JWTs) issued by the OAuth identity provider.
       * @example https://login.microsoftonline.com/common/discovery/v2.0/keys
       */
      jwks_uri?: string;
      /** @description The JWKS issued by the OAuth identity provider. Only `kid` (key ID)
       *     and `alg` (algorithm) properties for each key set are included. */
      readonly keys?: components["schemas"]["iam.v2.JwksObject"][];
    };
    /** @description `JWKS` objects represent public key sets for a specific OAuth/OpenID Connect provider within
     *     Confluent Cloud.
     *
     *     The API allows you to refresh JWKS public key data.
     *
     *
     *     Related guide: [OAuth for Confluent Cloud](https://docs.confluent.io/cloud/current/access-management/authenticate/oauth/overview.html).
     *
     *     ## The Jwks Model
     *     <SchemaDefinition schemaRef="#/components/schemas/iam.v2.Jwks" /> */
    "iam.v2.Jwks": {
      /**
       * @description APIVersion defines the schema version of this representation of a resource.
       * @enum {string}
       */
      readonly api_version?: "iam/v2";
      /**
       * @description Kind defines the object this REST resource represents.
       * @enum {string}
       */
      readonly kind?: "Jwks";
      spec?: components["schemas"]["iam.v2.JwksSpec"];
      status?: components["schemas"]["iam.v2.JwksStatus"];
    };
    /** @description The status of the Jwks */
    "iam.v2.JwksStatus": {
      /**
       * @description The actual state of the public key data
       * @example REFRESHED
       */
      jwks_status?: string;
      /**
       * Format: date-time
       * @description The last successful refresh time for the public key data
       * @example 2006-01-02T15:04:05-07:00
       */
      jwks_last_refresh_at?: string;
    };
    /** @description `IdentityPool` objects represent groups of identities tied to a given a `IdentityProvider`
     *     that authorizes them to Confluent Cloud resources.
     *
     *     It provides a mapping functionality of your `Identity Provider` user to a Confluent identity pool that
     *     is then used to provide access to Confluent Resources.
     *
     *
     *     Related guide: [Use identity pools with your OAuth provider](https://docs.confluent.io/cloud/current/access-management/authenticate/oauth/identity-pools.html).
     *
     *     ## The Identity Pools Model
     *     <SchemaDefinition schemaRef="#/components/schemas/iam.v2.IdentityPool" />
     *
     *     ## Quotas and Limits
     *     This resource is subject to the [following quotas](https://docs.confluent.io/cloud/current/quotas/overview.html):
     *
     *     | Quota | Description |
     *     | --- | --- |
     *     | `identity_pools_per_provider` | Number of Identity Pools per Identity Provider | */
    "iam.v2.IdentityPool": {
      /**
       * @description APIVersion defines the schema version of this representation of a resource.
       * @enum {string}
       */
      readonly api_version?: "iam/v2";
      /**
       * @description Kind defines the object this REST resource represents.
       * @enum {string}
       */
      readonly kind?: "IdentityPool";
      /**
       * @description ID is the "natural identifier" for an object within its scope/namespace; it is normally unique across time but not space. That is, you can assume that the ID will not be reclaimed and reused after an object is deleted ("time"); however, it may collide with IDs for other object `kinds` or objects of the same `kind` within a different scope/namespace ("space").
       * @example dlz-f3a90de
       */
      readonly id?: string;
      metadata?: components["schemas"]["ObjectMeta"] & {
        /** @example https://api.confluent.cloud/iam/v2/identity-pools/ip-12345 */
        self?: unknown;
        /** @example crn://confluent.cloud/organization=9bb441c4-edef-46ac-8a41-c49e44a3fd9a/identity-pool=ip-12345 */
        resource_name?: unknown;
      };
      /**
       * @description The name of the `IdentityPool`.
       * @example My Identity Pool
       */
      display_name?: string;
      /**
       * @description A description of how this `IdentityPool` is used
       * @example Prod Access to Kafka clusters to Release Engineering
       */
      description?: string;
      /**
       * @description The JSON Web Token (JWT) claim to extract the authenticating identity to Confluent resources from
       *     (see [Registered Claim Names](https://datatracker.ietf.org/doc/html/rfc7519#section-4.1) for more details).
       *     This appears in the audit log records, showing, for example, that "identity Z used identity pool X to access
       *     topic A".
       * @example claims.sub
       */
      identity_claim?: string;
      /**
       * @description A filter expression in [Supported Common Expression Language (CEL)](https://docs.confluent.io/cloud/current/access-management/authenticate/oauth/identity-pools.html#supported-common-expression-language-cel-filters) that specifies which identities can authenticate using your identity pool (see [Set identity pool filters](https://docs.confluent.io/cloud/current/access-management/authenticate/oauth/identity-pools.html#set-identity-pool-filters) for more details).
       * @example claims.aud=="confluent" && claims.group!="invalid_group"
       */
      filter?: string;
      /**
       * @description Represents the federated identity associated with this pool.
       * @example pool-abc
       */
      readonly principal?: string;
      /**
       * @description The current state of the identity pool
       * @example ENABLED
       */
      readonly state?: string;
    };
    /** @description `JWKS` contains the published keys for the given OpenIDProvider */
    "iam.v2.JwksObject": {
      /**
       * @description Specifies the cryptographic algorithm family used with the key
       * @example RSA
       */
      kty: string;
      /**
       * @description Specifies the key-id issued by the OpenIDProvider for the particular tenant
       * @example nOo3ZDrODXEK1jKWhXslHR_KXEg
       */
      kid: string;
      /**
       * @description Specifies the algorithm to be used to generate the public key
       * @example RS256
       */
      alg: string;
      /**
       * @description Specifies the intended usage of the key
       * @example sig
       */
      use?: string;
      /** @description Specifies the modulus of the RSA public key. Represented as a Base64urlUInt-encoded value */
      n?: string;
      /**
       * @description Specifies the exponent of the RSA public key.
       * @example AQAB
       */
      e?: string;
    };
    /** @description `IdentityProvider` objects represent external OAuth-OIDC providers in Confluent Cloud.
     *
     *     The API allows you to list, create, read, update, and delete your Identity Provider.
     *
     *
     *     Related guide: [OAuth for Confluent Cloud](https://docs.confluent.io/cloud/current/access-management/authenticate/oauth/overview.html).
     *
     *     ## The Identity Providers Model
     *     <SchemaDefinition schemaRef="#/components/schemas/iam.v2.IdentityProvider" />
     *
     *     ## Quotas and Limits
     *     This resource is subject to the [following quotas](https://docs.confluent.io/cloud/current/quotas/overview.html):
     *
     *     | Quota | Description |
     *     | --- | --- |
     *     | `identity_providers_per_org` | Number of OAuth identity providers per organization |
     *     | `public_keys_per_provider` | Number of public keys saved per identity provider | */
    "iam.v2.IdentityProviderList": {
      /**
       * @description APIVersion defines the schema version of this representation of a resource.
       * @enum {string}
       */
      readonly api_version: "iam/v2";
      /**
       * @description Kind defines the object this REST resource represents.
       * @enum {string}
       */
      readonly kind: "IdentityProviderList";
      metadata: components["schemas"]["ListMeta"] & {
        /** @example https://api.confluent.cloud/iam/v2/identity-providers */
        first?: unknown;
        /** @example https://api.confluent.cloud/iam/v2/identity-providers?page_token=bcAOehAY8F16YD84Z1wT */
        last?: unknown;
        /** @example https://api.confluent.cloud/iam/v2/identity-providers?page_token=YIXRY97wWYmwzrax4dld */
        prev?: unknown;
        /** @example https://api.confluent.cloud/iam/v2/identity-providers?page_token=UvmDWOB1iwfAIBPj6EYb */
        next?: unknown;
      };
      /** @description A data property that contains an array of resource items. Each entry in the array is a separate resource. */
      data: (components["schemas"]["iam.v2.IdentityProvider"] &
        Record<string, unknown>)[];
    };
    /** @description The desired state of the Jwks */
    "iam.v2.JwksSpec": {
      /**
       * @description The desired state of the public key data
       * @example REFRESHED
       */
      jwks_status?: string;
    };
    /** @description `IdentityPool` objects represent groups of identities tied to a given a `IdentityProvider`
     *     that authorizes them to Confluent Cloud resources.
     *
     *     It provides a mapping functionality of your `Identity Provider` user to a Confluent identity pool that
     *     is then used to provide access to Confluent Resources.
     *
     *
     *     Related guide: [Use identity pools with your OAuth provider](https://docs.confluent.io/cloud/current/access-management/authenticate/oauth/identity-pools.html).
     *
     *     ## The Identity Pools Model
     *     <SchemaDefinition schemaRef="#/components/schemas/iam.v2.IdentityPool" />
     *
     *     ## Quotas and Limits
     *     This resource is subject to the [following quotas](https://docs.confluent.io/cloud/current/quotas/overview.html):
     *
     *     | Quota | Description |
     *     | --- | --- |
     *     | `identity_pools_per_provider` | Number of Identity Pools per Identity Provider | */
    "iam.v2.IdentityPoolList": {
      /**
       * @description APIVersion defines the schema version of this representation of a resource.
       * @enum {string}
       */
      readonly api_version: "iam/v2";
      /**
       * @description Kind defines the object this REST resource represents.
       * @enum {string}
       */
      readonly kind: "IdentityPoolList";
      metadata: components["schemas"]["ListMeta"] & {
        /** @example https://api.confluent.cloud/iam/v2/identity-pools */
        first?: unknown;
        /** @example https://api.confluent.cloud/iam/v2/identity-pools?page_token=bcAOehAY8F16YD84Z1wT */
        last?: unknown;
        /** @example https://api.confluent.cloud/iam/v2/identity-pools?page_token=YIXRY97wWYmwzrax4dld */
        prev?: unknown;
        /** @example https://api.confluent.cloud/iam/v2/identity-pools?page_token=UvmDWOB1iwfAIBPj6EYb */
        next?: unknown;
      };
      /** @description A data property that contains an array of resource items. Each entry in the array is a separate resource. */
      data: (components["schemas"]["iam.v2.IdentityPool"] &
        Record<string, unknown>)[];
    };
    /** @description token exchange request parameters */
    "sts.v1.TokenExchangeRequest": {
      /**
       * @description APIVersion defines the schema version of this representation of a resource.
       * @enum {string}
       */
      readonly api_version?: "sts/v1";
      /**
       * @description Kind defines the object this REST resource represents.
       * @enum {string}
       */
      readonly kind?: "TokenExchangeRequest";
      /**
       * @description ID is the "natural identifier" for an object within its scope/namespace; it is normally unique across time but not space. That is, you can assume that the ID will not be reclaimed and reused after an object is deleted ("time"); however, it may collide with IDs for other object `kinds` or objects of the same `kind` within a different scope/namespace ("space").
       * @example dlz-f3a90de
       */
      readonly id?: string;
      metadata?: components["schemas"]["ObjectMeta"] & {
        /** @example https://api.confluent.cloud/sts/v1/token-exchange-requests/ter-12345 */
        self?: unknown;
        /** @example crn://confluent.cloud/organization=9bb441c4-edef-46ac-8a41-c49e44a3fd9a/token-exchange-request=ter-12345 */
        resource_name?: unknown;
      };
      /**
       * @description The grant type. Must be urn:ietf:params:oauth:grant-type:token-exchange, which indicates a token exchange.
       *
       * @example urn:ietf:params:oauth:grant-type:token-exchange
       */
      grant_type?: string;
      /**
       * @description Confluent Cloud only accepts JSON Web Token (JWT) access tokens from customer identity provider
       * @example test_jwt_token
       */
      subject_token?: string;
      /**
       * @description Identity pool is a group of external identities that are assigned a certain level of access based on policy
       *
       * @example pool_1
       */
      identity_pool_id?: string;
      /**
       * @description An identifier for the type of requested security token. Supported values
       *     is urn:ietf:params:oauth:token-type:jwt.
       *
       * @example urn:ietf:params:oauth:token-type:jwt
       */
      subject_token_type?: string;
      /**
       * @description An identifier for the type of requested security token.
       *     Supported values is urn:ietf:params:oauth:token-type:access_token.
       *
       * @example urn:ietf:params:oauth:token-type:access_token
       */
      requested_token_type?: string;
      /**
       * Format: int32
       * @description The amount of time, in seconds, between the time when the access token was issued
       *     and the time when the access token will expire
       *
       * @default 900
       */
      expires_in: number;
    };
    /** @description token exchange response */
    "sts.v1.TokenExchangeReply": {
      /** @description An JWT access token, issued by Confluent, in response to the token exchange request.
       *     Client application could use the access token to access confluent public api
       *      */
      access_token: string;
      /**
       * @description The token type. Always matches the value of requested_token_type from the request.
       * @example urn:ietf:params:oauth:token-type:access_token
       */
      issued_token_type: string;
      /**
       * @description Indicates the token type value. The only type that Confluent supports is Bearer
       * @example Bearer
       */
      token_type: string;
      /**
       * Format: int32
       * @description The length of time, in seconds, that the access token is valid.
       * @example 3600
       */
      expires_in: number;
    };
    /** @description `ClientQuota` objects represent Client Quotas you can set at the service account level.
     *
     *     The API allows you to list, create, read, update, and delete your client quotas.
     *
     *
     *     Related guide: [Client Quotas in Confluent Cloud](https://docs.confluent.io/cloud/current/clusters/client-quotas.html).
     *
     *     ## The Client Quotas Model
     *     <SchemaDefinition schemaRef="#/components/schemas/kafka-quotas.v1.ClientQuota" /> */
    "kafka-quotas.v1.ClientQuota": {
      /**
       * @description APIVersion defines the schema version of this representation of a resource.
       * @enum {string}
       */
      readonly api_version?: "kafka-quotas/v1";
      /**
       * @description Kind defines the object this REST resource represents.
       * @enum {string}
       */
      readonly kind?: "ClientQuota";
      /**
       * @description ID is the "natural identifier" for an object within its scope/namespace; it is normally unique across time but not space. That is, you can assume that the ID will not be reclaimed and reused after an object is deleted ("time"); however, it may collide with IDs for other object `kinds` or objects of the same `kind` within a different scope/namespace ("space").
       * @example dlz-f3a90de
       */
      readonly id?: string;
      metadata?: components["schemas"]["ObjectMeta"] & {
        /** @example https://api.confluent.cloud/kafka-quotas/v1/client-quotas/cq-12345 */
        self?: unknown;
        /** @example crn://confluent.cloud/organization=9bb441c4-edef-46ac-8a41-c49e44a3fd9a/client-quota=cq-12345 */
        resource_name?: unknown;
      };
      spec?: components["schemas"]["kafka-quotas.v1.ClientQuotaSpec"];
    };
    /** @description Quotas on maximum throughput */
    "kafka-quotas.v1.Throughput": {
      /**
       * Format: int64
       * @description Ingress throughput limit for principals specified in bytes per second.
       * @example 5
       */
      ingress_byte_rate: string;
      /**
       * Format: int64
       * @description Egress throughput limit for principals specified in bytes per second.
       * @example 5
       */
      egress_byte_rate: string;
    };
    /** @description `ClientQuota` objects represent Client Quotas you can set at the service account level.
     *
     *     The API allows you to list, create, read, update, and delete your client quotas.
     *
     *
     *     Related guide: [Client Quotas in Confluent Cloud](https://docs.confluent.io/cloud/current/clusters/client-quotas.html).
     *
     *     ## The Client Quotas Model
     *     <SchemaDefinition schemaRef="#/components/schemas/kafka-quotas.v1.ClientQuota" /> */
    "kafka-quotas.v1.ClientQuotaList": {
      /**
       * @description APIVersion defines the schema version of this representation of a resource.
       * @enum {string}
       */
      readonly api_version: "kafka-quotas/v1";
      /**
       * @description Kind defines the object this REST resource represents.
       * @enum {string}
       */
      readonly kind: "ClientQuotaList";
      metadata: components["schemas"]["ListMeta"] & {
        /** @example https://api.confluent.cloud/kafka-quotas/v1/client-quotas */
        first?: unknown;
        /** @example https://api.confluent.cloud/kafka-quotas/v1/client-quotas?page_token=bcAOehAY8F16YD84Z1wT */
        last?: unknown;
        /** @example https://api.confluent.cloud/kafka-quotas/v1/client-quotas?page_token=YIXRY97wWYmwzrax4dld */
        prev?: unknown;
        /** @example https://api.confluent.cloud/kafka-quotas/v1/client-quotas?page_token=UvmDWOB1iwfAIBPj6EYb */
        next?: unknown;
      };
      /** @description A data property that contains an array of resource items. Each entry in the array is a separate resource. */
      data: (components["schemas"]["kafka-quotas.v1.ClientQuota"] & {
        spec: Record<string, unknown>;
      })[];
    };
    /** @description The desired state of the Client Quota */
    "kafka-quotas.v1.ClientQuotaSpec": {
      /**
       * @description The name of the client quota.
       * @example QuotaForSA1
       */
      display_name?: string;
      /**
       * @description A human readable description for the client quota.
       * @example This quota defines limits on how much the target principals can use cluster lkc-xxxxx
       */
      description?: string;
      /** @description Throughput for the client quota. */
      throughput?: components["schemas"]["kafka-quotas.v1.Throughput"];
      /** @description The ID of the Dedicated Kafka cluster where the client quota is applied.
       *      */
      cluster?: components["schemas"]["EnvScopedObjectReference"];
      /** @description A list of principals to apply a client quota to.
       *     Use `"<default>"` to apply a client quota to all service accounts
       *     (see [Control application usage with Client Quotas](https://docs.confluent.io/cloud/current/clusters/client-quotas.html#control-application-usage-with-client-quotas) for more details).
       *      */
      principals?: components["schemas"]["GlobalObjectReference"][];
      /** @description The environment to which this belongs. */
      environment?: components["schemas"]["GlobalObjectReference"];
    };
    /** @description `Key` objects represent customer managed keys on dedicated Confluent Cloud clusters.
     *
     *     Keys are used to protect data at rest stored in your dedicated Confluent Cloud clusters on AWS, Azure, and GCP.
     *     This API allows you to upload and retrieve self-managed keys on Confluent Cloud.
     *
     *
     *     Related guide: [Confluent Cloud Bring Your Own Key (BYOK) Management API](https://docs.confluent.io/cloud/current/clusters/byok/index.html).
     *
     *     ## The Keys Model
     *     <SchemaDefinition schemaRef="#/components/schemas/byok.v1.Key" />
     *
     *     ## Quotas and Limits
     *     This resource is subject to the [following quotas](https://docs.confluent.io/cloud/current/quotas/overview.html):
     *
     *     | Quota | Description |
     *     | --- | --- |
     *     | `byok.max_keys.per_org` | BYOK keys in one Confluent Cloud organisation. | */
    "byok.v1.Key": {
      /**
       * @description APIVersion defines the schema version of this representation of a resource.
       * @enum {string}
       */
      readonly api_version?: "byok/v1";
      /**
       * @description Kind defines the object this REST resource represents.
       * @enum {string}
       */
      readonly kind?: "Key";
      /**
       * @description ID is the "natural identifier" for an object within its scope/namespace; it is normally unique across time but not space. That is, you can assume that the ID will not be reclaimed and reused after an object is deleted ("time"); however, it may collide with IDs for other object `kinds` or objects of the same `kind` within a different scope/namespace ("space").
       * @example dlz-f3a90de
       */
      readonly id?: string;
      metadata?: components["schemas"]["ObjectMeta"] & {
        /** @example https://api.confluent.cloud/byok/v1/keys/cck-12345 */
        self?: unknown;
        /** @example crn://confluent.cloud/organization=9bb441c4-edef-46ac-8a41-c49e44a3fd9a/key=cck-12345 */
        resource_name?: unknown;
      };
      /** @description The cloud-specific key details.
       *
       *     For AWS, provide the corresponding `key_arn`.
       *
       *     For Azure, provide the corresponding `key_id`.
       *
       *     For GCP, provide the corresponding `key_id`.
       *      */
      key?:
        | components["schemas"]["byok.v1.AwsKey"]
        | components["schemas"]["byok.v1.AzureKey"]
        | components["schemas"]["byok.v1.GcpKey"];
      /**
       * @description The cloud provider of the Key.
       * @example AWS
       */
      readonly provider?: string;
      /**
       * @description The state of the key:
       *       AVAILABLE: key can be used for a Kafka cluster provisioning
       *       IN_USE: key is already in use by a Kafka cluster provisioning
       *
       * @example IN_USE
       */
      readonly state?: string;
    };
    /** @description The AWS BYOK details
     *      */
    "byok.v1.AwsKey": {
      /**
       * @description The Amazon Resource Name (ARN) of an AWS KMS key.
       *
       * @example arn:aws:kms:us-west-2:111122223333:key/1234abcd-12ab-34cd-56ef-1234567890ab
       */
      key_arn: string;
      /**
       * @description The Amazon Resource Names (ARNs) of IAM Roles created for this key-environment combination.
       *
       * @example [
       *       "arn:aws:iam::123456789876:role/block_storage_manager",
       *       "arn:aws:iam::987654321234:role/cc-kafka-1111aaaa-11aa-11aa-11aa-111111aaaaaa"
       *     ]
       */
      readonly roles?: string[];
      /**
       * @description BYOK kind type.
       *      (enum property replaced by openapi-typescript)
       * @enum {string}
       */
      kind: "AwsKey";
    };
    /** @description The Azure BYOK details.
     *      */
    "byok.v1.AzureKey": {
      /** @description The Application ID created for this key-environment combination.
       *      */
      readonly application_id?: string;
      /**
       * @description The unique Key Object Identifier URL without version of an Azure Key Vault key.
       *
       * @example https://vault-name.vault.azure.net/keys/key-name
       */
      key_id: string;
      /**
       * @description Key Vault ID containing the key
       *
       * @example /subscriptions/00000000-0000-0000-0000-000000000000/resourceGroups/resourcegroup-name/providers/Microsoft.KeyVault/vaults/vault-name
       */
      key_vault_id: string;
      /**
       * @description BYOK kind type.
       *      (enum property replaced by openapi-typescript)
       * @enum {string}
       */
      kind: "AzureKey";
      /**
       * @description Tenant ID (uuid) hosting the Key Vault containing the key
       *
       * @example 00000000-0000-0000-0000-000000000000
       */
      tenant_id: string;
    };
    /** @description The GCP BYOK details
     *      */
    "byok.v1.GcpKey": {
      /**
       * @description The Google Cloud Platform key ID.
       *
       * @example projects/exampleproject/locations/us-central1/keyRings/testkeyring/cryptoKeys/testbyokkey/cryptoKeyVersions/3
       */
      key_id: string;
      /**
       * @description The Google security group created for this key.
       *
       * @example testgroupid@domain.com
       */
      readonly security_group?: string;
      /**
       * @description BYOK kind type.
       *      (enum property replaced by openapi-typescript)
       * @enum {string}
       */
      kind: "GcpKey";
    };
    /** @description `Key` objects represent customer managed keys on dedicated Confluent Cloud clusters.
     *
     *     Keys are used to protect data at rest stored in your dedicated Confluent Cloud clusters on AWS, Azure, and GCP.
     *     This API allows you to upload and retrieve self-managed keys on Confluent Cloud.
     *
     *
     *     Related guide: [Confluent Cloud Bring Your Own Key (BYOK) Management API](https://docs.confluent.io/cloud/current/clusters/byok/index.html).
     *
     *     ## The Keys Model
     *     <SchemaDefinition schemaRef="#/components/schemas/byok.v1.Key" />
     *
     *     ## Quotas and Limits
     *     This resource is subject to the [following quotas](https://docs.confluent.io/cloud/current/quotas/overview.html):
     *
     *     | Quota | Description |
     *     | --- | --- |
     *     | `byok.max_keys.per_org` | BYOK keys in one Confluent Cloud organisation. | */
    "byok.v1.KeyList": {
      /**
       * @description APIVersion defines the schema version of this representation of a resource.
       * @enum {string}
       */
      readonly api_version: "byok/v1";
      /**
       * @description Kind defines the object this REST resource represents.
       * @enum {string}
       */
      readonly kind: "KeyList";
      metadata: components["schemas"]["ListMeta"] & {
        /** @example https://api.confluent.cloud/byok/v1/keys */
        first?: unknown;
        /** @example https://api.confluent.cloud/byok/v1/keys?page_token=bcAOehAY8F16YD84Z1wT */
        last?: unknown;
        /** @example https://api.confluent.cloud/byok/v1/keys?page_token=YIXRY97wWYmwzrax4dld */
        prev?: unknown;
        /** @example https://api.confluent.cloud/byok/v1/keys?page_token=UvmDWOB1iwfAIBPj6EYb */
        next?: unknown;
      };
      /** @description A data property that contains an array of resource items. Each entry in the array is a separate resource. */
      data: (components["schemas"]["byok.v1.Key"] & Record<string, unknown>)[];
    };
    /** @description `Cost` objects represent the aggregated billing costs for an organization
     *
     *
     *     Related guide: [Retrieve costs for a range of dates](https://docs.confluent.io/cloud/current/billing/overview.html#retrieve-costs-for-a-range-of-dates).
     *
     *     ## The Costs Model
     *     <SchemaDefinition schemaRef="#/components/schemas/billing.v1.Cost" /> */
    "billing.v1.Cost": {
      /**
       * @description APIVersion defines the schema version of this representation of a resource.
       * @enum {string}
       */
      readonly api_version?: "billing/v1";
      /**
       * @description Kind defines the object this REST resource represents.
       * @enum {string}
       */
      readonly kind?: "Cost";
      /**
       * @description ID is the "natural identifier" for an object within its scope/namespace; it is normally unique across time but not space. That is, you can assume that the ID will not be reclaimed and reused after an object is deleted ("time"); however, it may collide with IDs for other object `kinds` or objects of the same `kind` within a different scope/namespace ("space").
       * @example dlz-f3a90de
       */
      readonly id?: string;
      /**
       * Format: date
       * @description Start date of time period (inclusive) to retrieve billing costs. It is represented in RFC3339 format and is in UTC.
       * @example 2022-10-12
       */
      start_date?: string;
      /**
       * Format: date
       * @description End date of time period (exclusive) to retrieve billing costs. It is represented in RFC3339 format and is in UTC.
       * @example 2022-10-15
       */
      end_date?: string;
      /**
       * @description Granularity at which each line item is aggregated.
       * @default DAILY
       */
      granularity: string;
      /**
       * @description Network access type for the cluster.
       * @example INTERNET
       */
      network_access_type?: string;
      /**
       * @description Product name.
       * @example KAFKA
       */
      product?: string;
      /**
       * @description Type of the line item.
       * @example KAFKA_NUM_CKUS
       */
      line_type?: string;
      /**
       * Format: double
       * @description Price for the line item in dollars.
       * @example 1.5
       */
      price?: number;
      /**
       * @description Unit of the line item.
       * @example GB
       */
      unit?: string;
      /**
       * Format: double
       * @description Quantity of the line item.
       * @example 99.9
       */
      quantity?: number;
      /**
       * Format: double
       * @description Original amount accrued for this line item.
       * @example 149.85
       */
      original_amount?: number;
      /**
       * Format: double
       * @description Amount discounted from the original amount in dollars.
       * @example 20.85
       */
      discount_amount?: number;
      /**
       * Format: double
       * @description Final amount after deducting discounts.
       * @example 129
       */
      amount?: number;
      /** @description The resource for a given object */
      resource?: components["schemas"]["billing.v1.Resource"];
    };
    /** @description The resource associated with this object. The resource can be one of Kafka Cluster ID (example: lkc-12345),
     *     Connector ID (example:
     *         lcc-12345), Schema Registry Cluster ID (example: lsrc-12345), or ksqlDB Cluster ID
     *     (example: lksqlc-12345).
     *     May be null or omitted if not associated with a resource.
     *      */
    "billing.v1.Resource": {
      /**
       * @description ID of the resource.
       * @example lkc-12345
       */
      id?: string;
      /**
       * @description Display name of the resource.
       * @example prod-kafka-cluster
       */
      display_name?: string;
      /** @description The environment associated with this resource */
      environment?: components["schemas"]["billing.v1.Environment"] | null;
    };
    /** @description The details of the environment for a given resource.
     *      */
    "billing.v1.Environment": {
      /**
       * @description ID of the environment.
       * @example env-123
       */
      id?: string;
    };
    /** @description `Cost` objects represent the aggregated billing costs for an organization
     *
     *
     *     Related guide: [Retrieve costs for a range of dates](https://docs.confluent.io/cloud/current/billing/overview.html#retrieve-costs-for-a-range-of-dates).
     *
     *     ## The Costs Model
     *     <SchemaDefinition schemaRef="#/components/schemas/billing.v1.Cost" /> */
    "billing.v1.CostList": {
      /**
       * @description APIVersion defines the schema version of this representation of a resource.
       * @enum {string}
       */
      readonly api_version: "billing/v1";
      /**
       * @description Kind defines the object this REST resource represents.
       * @enum {string}
       */
      readonly kind: "CostList";
      metadata: components["schemas"]["CostListMeta"] & {
        /** @example https://api.confluent.cloud/billing/v1/costs?page_token=UvmDWOB1iwfAIBPj6EYb */
        next?: unknown;
      };
      /** @description A data property that contains an array of resource items. Each entry in the array is a separate resource. */
      data: (components["schemas"]["billing.v1.Cost"] &
        Record<string, unknown>)[];
    };
    /** @description CostListMeta describes metadata that resource collections may have */
    CostListMeta: {
      /**
       * Format: uri
       * @description A link to the next page of results. If a response does not contain a next link, then there is no more data available.
       * @example https://api.confluent.cloud/v2/resourcekinds?page_token=UvmDWOB1iwfAIBPj6EYb
       */
      next?: string | null;
    };
    /** @description `GroupMapping` objects establish relationships between user groups in your SSO
     *     identity provider and specific RBAC roles in Confluent Cloud.
     *
     *     Group mappings enable automated and secure access control to Confluent Cloud resources,
     *     reducing administrative workload by streamlining user provisioning and authorization.
     *
     *
     *     Related guide: [Use group mappings with your SSO identity provider](https://docs.confluent.io/cloud/current/access-management/authenticate/sso/group-mapping/overview.html).
     *
     *     ## The Group Mappings Model
     *     <SchemaDefinition schemaRef="#/components/schemas/iam.v2.sso.GroupMapping" />
     *
     *     ## Quotas and Limits
     *     This resource is subject to the [following quotas](https://docs.confluent.io/cloud/current/quotas/overview.html):
     *
     *     | Quota | Description |
     *     | --- | --- |
     *     | `group_mappings_per_org` | Number of group mappings per organization | */
    "iam.v2.sso.GroupMapping": {
      /**
       * @description APIVersion defines the schema version of this representation of a resource.
       * @enum {string}
       */
      readonly api_version?: "iam.v2/sso";
      /**
       * @description Kind defines the object this REST resource represents.
       * @enum {string}
       */
      readonly kind?: "GroupMapping";
      /**
       * @description ID is the "natural identifier" for an object within its scope/namespace; it is normally unique across time but not space. That is, you can assume that the ID will not be reclaimed and reused after an object is deleted ("time"); however, it may collide with IDs for other object `kinds` or objects of the same `kind` within a different scope/namespace ("space").
       * @example dlz-f3a90de
       */
      readonly id?: string;
      metadata?: components["schemas"]["ObjectMeta"] & {
        /** @example https://api.confluent.cloud/iam.v2/sso/group-mappings/gm-12345 */
        self?: unknown;
        /** @example crn://confluent.cloud/organization=9bb441c4-edef-46ac-8a41-c49e44a3fd9a/group-mapping=gm-12345 */
        resource_name?: unknown;
      };
      /**
       * @description The name of the group mapping.
       * @example Application Developers
       */
      display_name?: string;
      /**
       * @description A description explaining the purpose and use of the group mapping.
       * @example Admin access to production environment for Engineering
       */
      description?: string;
      /**
       * @description A single group identifier or a condition based on [supported CEL operators](https://docs.confluent.io/cloud/current/access-management/authenticate/sso/group-mapping/overview.html#supported-cel-operators-for-group-mapping) that defines which groups are included.
       * @example "kafka" in groups && "all" in groups || "everyone" in groups
       */
      filter?: string;
      /**
       * @description The unique federated identity associated with this group mapping.
       * @example group-a1b2
       */
      readonly principal?: string;
      /**
       * @description The current state of the group mapping.
       * @example ENABLED
       */
      readonly state?: string;
    };
    /** @description `GroupMapping` objects establish relationships between user groups in your SSO
     *     identity provider and specific RBAC roles in Confluent Cloud.
     *
     *     Group mappings enable automated and secure access control to Confluent Cloud resources,
     *     reducing administrative workload by streamlining user provisioning and authorization.
     *
     *
     *     Related guide: [Use group mappings with your SSO identity provider](https://docs.confluent.io/cloud/current/access-management/authenticate/sso/group-mapping/overview.html).
     *
     *     ## The Group Mappings Model
     *     <SchemaDefinition schemaRef="#/components/schemas/iam.v2.sso.GroupMapping" />
     *
     *     ## Quotas and Limits
     *     This resource is subject to the [following quotas](https://docs.confluent.io/cloud/current/quotas/overview.html):
     *
     *     | Quota | Description |
     *     | --- | --- |
     *     | `group_mappings_per_org` | Number of group mappings per organization | */
    "iam.v2.sso.GroupMappingList": {
      /**
       * @description APIVersion defines the schema version of this representation of a resource.
       * @enum {string}
       */
      readonly api_version: "iam.v2/sso";
      /**
       * @description Kind defines the object this REST resource represents.
       * @enum {string}
       */
      readonly kind: "GroupMappingList";
      metadata: components["schemas"]["ListMeta"] & {
        /** @example https://api.confluent.cloud/iam.v2/sso/group-mappings */
        first?: unknown;
        /** @example https://api.confluent.cloud/iam.v2/sso/group-mappings?page_token=bcAOehAY8F16YD84Z1wT */
        last?: unknown;
        /** @example https://api.confluent.cloud/iam.v2/sso/group-mappings?page_token=YIXRY97wWYmwzrax4dld */
        prev?: unknown;
        /** @example https://api.confluent.cloud/iam.v2/sso/group-mappings?page_token=UvmDWOB1iwfAIBPj6EYb */
        next?: unknown;
      };
      /** @description A data property that contains an array of resource items. Each entry in the array is a separate resource. */
      data: (components["schemas"]["iam.v2.sso.GroupMapping"] &
        Record<string, unknown>)[];
    };
    /** @description A Compute Pool represents a set of compute resources that is used to run your Queries.
     *     The resources (CPUs, memory,…) provided by a Compute Pool are shared between all Queries that use it.
     *     Note that the Compute Pool API supports a limited pagination API, only the `next` field will be populated.
     *
     *
     *     ## The Compute Pools Model
     *     <SchemaDefinition schemaRef="#/components/schemas/fcpm.v2.ComputePool" /> */
    "fcpm.v2.ComputePool": {
      /**
       * @description APIVersion defines the schema version of this representation of a resource.
       * @enum {string}
       */
      readonly api_version?: "fcpm/v2";
      /**
       * @description Kind defines the object this REST resource represents.
       * @enum {string}
       */
      readonly kind?: "ComputePool";
      /**
       * @description ID is the "natural identifier" for an object within its scope/namespace; it is normally unique across time but not space. That is, you can assume that the ID will not be reclaimed and reused after an object is deleted ("time"); however, it may collide with IDs for other object `kinds` or objects of the same `kind` within a different scope/namespace ("space").
       * @example dlz-f3a90de
       */
      readonly id?: string;
      metadata?: components["schemas"]["ObjectMeta"] & {
        /** @example https://api.confluent.cloud/fcpm/v2/compute-pools/lfcp-12345 */
        self?: unknown;
        /** @example crn://confluent.cloud/organization=9bb441c4-edef-46ac-8a41-c49e44a3fd9a/environment=env-abc123/flink-region=aws.us-east-2/compute-pool=lfcp-12345 */
        resource_name?: unknown;
      };
      spec?: components["schemas"]["fcpm.v2.ComputePoolSpec"];
      status?: components["schemas"]["fcpm.v2.ComputePoolStatus"];
    };
    /** @description The status of the Compute Pool */
    "fcpm.v2.ComputePoolStatus": {
      /**
       * @description Status of the Flink compute pool.
       * @example PROVISIONING
       */
      readonly phase: string;
      /**
       * Format: int32
       * @description The number of Confluent Flink Units (CFUs) currently allocated to this Flink compute pool.
       * @example 4
       */
      readonly current_cfu: number;
    };
    /** @description `Region` objects represent cloud provider regions available when placing Flink compute pools.
     *     The API allows you to list Flink regions.
     *
     *
     *     ## The Regions Model
     *     <SchemaDefinition schemaRef="#/components/schemas/fcpm.v2.Region" /> */
    "fcpm.v2.Region": {
      /**
       * @description APIVersion defines the schema version of this representation of a resource.
       * @enum {string}
       */
      readonly api_version?: "fcpm/v2";
      /**
       * @description Kind defines the object this REST resource represents.
       * @enum {string}
       */
      readonly kind?: "Region";
      /**
       * @description ID is the "natural identifier" for an object within its scope/namespace; it is normally unique across time but not space. That is, you can assume that the ID will not be reclaimed and reused after an object is deleted ("time"); however, it may collide with IDs for other object `kinds` or objects of the same `kind` within a different scope/namespace ("space").
       * @example dlz-f3a90de
       */
      readonly id?: string;
      metadata?: components["schemas"]["ObjectMeta"] & {
        /** @example https://api.confluent.cloud/fcpm/v2/regions/r-12345 */
        self?: unknown;
        /** @example crn://confluent.cloud/organization=9bb441c4-edef-46ac-8a41-c49e44a3fd9a/region=r-12345 */
        resource_name?: unknown;
      };
      /**
       * @description The display name.
       * @example Ohio (us-east-2)
       */
      readonly display_name?: string;
      /**
       * @description The cloud service provider that hosts the region.
       * @example AWS
       */
      readonly cloud?: string;
      /**
       * @description The region name.
       * @example us-east-2
       */
      readonly region_name?: string;
      /**
       * Format: uri
       * @description The regional API endpoint for Flink compute pools.
       */
      readonly http_endpoint?: string;
      /**
       * Format: uri
       * @description The private regional API endpoint for Flink compute pools.
       */
      readonly private_http_endpoint?: string;
    };
    /** @description A Compute Pool represents a set of compute resources that is used to run your Queries.
     *     The resources (CPUs, memory,…) provided by a Compute Pool are shared between all Queries that use it.
     *     Note that the Compute Pool API supports a limited pagination API, only the `next` field will be populated.
     *
     *
     *     ## The Compute Pools Model
     *     <SchemaDefinition schemaRef="#/components/schemas/fcpm.v2.ComputePool" /> */
    "fcpm.v2.ComputePoolList": {
      /**
       * @description APIVersion defines the schema version of this representation of a resource.
       * @enum {string}
       */
      readonly api_version: "fcpm/v2";
      /**
       * @description Kind defines the object this REST resource represents.
       * @enum {string}
       */
      readonly kind: "ComputePoolList";
      metadata: components["schemas"]["ListMeta"] & {
        /** @example https://api.confluent.cloud/fcpm/v2/compute-pools */
        first?: unknown;
        /** @example https://api.confluent.cloud/fcpm/v2/compute-pools?page_token=bcAOehAY8F16YD84Z1wT */
        last?: unknown;
        /** @example https://api.confluent.cloud/fcpm/v2/compute-pools?page_token=YIXRY97wWYmwzrax4dld */
        prev?: unknown;
        /** @example https://api.confluent.cloud/fcpm/v2/compute-pools?page_token=UvmDWOB1iwfAIBPj6EYb */
        next?: unknown;
      };
      /** @description A data property that contains an array of resource items. Each entry in the array is a separate resource. */
      data: (components["schemas"]["fcpm.v2.ComputePool"] & {
        spec: Record<string, unknown>;
      })[];
    };
    /** @description The desired state of the Compute Pool */
    "fcpm.v2.ComputePoolSpec": {
      /**
       * @description The name of the Flink compute pool.
       * @example flink_compute_pool_0
       */
      display_name?: string;
      /**
       * @description The cloud service provider that runs the compute pool.
       * @example AWS
       */
      cloud?: string;
      /**
       * @description Flink compute pools in the region provided will be able to use this identity pool
       * @example us-west-1
       */
      region?: string;
      /**
       * Format: int32
       * @description Maximum number of Confluent Flink Units (CFUs) that the Flink compute pool should auto-scale to.
       *
       * @example 5
       */
      max_cfu?: number;
      /**
       * @description The flag to enable AI computing using Ray for the Flink compute pool. It's available in the Early Access API
       *     lifecycle stage only.
       *
       * @default false
       */
      enable_ai: boolean;
      /** @description The environment to which this belongs. */
      environment?: components["schemas"]["GlobalObjectReference"];
      /** @description The network to which this belongs. */
      network?: components["schemas"]["EnvScopedObjectReference"];
    };
    /** @description `Region` objects represent cloud provider regions available when placing Flink compute pools.
     *     The API allows you to list Flink regions.
     *
     *
     *     ## The Regions Model
     *     <SchemaDefinition schemaRef="#/components/schemas/fcpm.v2.Region" /> */
    "fcpm.v2.RegionList": {
      /**
       * @description APIVersion defines the schema version of this representation of a resource.
       * @enum {string}
       */
      readonly api_version: "fcpm/v2";
      /**
       * @description Kind defines the object this REST resource represents.
       * @enum {string}
       */
      readonly kind: "RegionList";
      metadata: components["schemas"]["ListMeta"] & {
        /** @example https://api.confluent.cloud/fcpm/v2/regions */
        first?: unknown;
        /** @example https://api.confluent.cloud/fcpm/v2/regions?page_token=bcAOehAY8F16YD84Z1wT */
        last?: unknown;
        /** @example https://api.confluent.cloud/fcpm/v2/regions?page_token=YIXRY97wWYmwzrax4dld */
        prev?: unknown;
        /** @example https://api.confluent.cloud/fcpm/v2/regions?page_token=UvmDWOB1iwfAIBPj6EYb */
        next?: unknown;
      };
      /** @description A data property that contains an array of resource items. Each entry in the array is a separate resource. */
      data: (components["schemas"]["fcpm.v2.Region"] &
        Record<string, unknown>)[];
    };
    /** @description `Connection` models a reusable endpoint and auth token to authenticate the caller to
     *     use that endpoint.
     *     Only `OrgAdmins` and `EnvAdmins` will have the permissions to create, update and delete `Connections`.
     *     `FlinkDevelopers` and `ModelResourceOwners` can later reference a `Connection` resource within their Model
     *     creation statements.
     *     The API allows you to list, create, read, and delete your connections.
     *     ## The Connections Model
     *     <SchemaDefinition schemaRef="#/components/schemas/sql.v1.Connection" /> */
    "sql.v1.Connection": {
      /**
       * @description APIVersion defines the schema version of this representation of a resource.
       * @example sql/v1
       * @enum {string}
       */
      readonly api_version?: "sql/v1";
      /**
       * @description Kind defines the object this REST resource represents.
       * @enum {string}
       */
      readonly kind?: "Connection";
      metadata?: components["schemas"]["ObjectMeta"] & {
        /** @example https://flink.us-west1.aws.confluent.cloud/sql/v1/organizations/org-abc/environments/env-123/connections/my-openai-connection */
        self?: unknown;
        /** @example 12345678-1234-1234-1234-123456789012 */
        uid?: unknown;
        /** @example a23av */
        resource_version?: unknown;
        /** @example  */
        resource_name?: unknown;
      };
      /**
       * @description The user provided name of the resource, unique within this environment.
       * @example my-openai-connection
       */
      name?: string;
      spec?: components["schemas"]["sql.v1.ConnectionSpec"];
      status?: components["schemas"]["sql.v1.ConnectionStatus"];
    };
    /** @description `Connection` models a reusable endpoint and auth token to authenticate the caller to
     *     use that endpoint.
     *     Only `OrgAdmins` and `EnvAdmins` will have the permissions to create, update and delete `Connections`.
     *     `FlinkDevelopers` and `ModelResourceOwners` can later reference a `Connection` resource within their Model
     *     creation statements.
     *     The API allows you to list, create, read, and delete your connections.
     *     ## The Connection Model
     *     <SchemaDefinition schemaRef="#/components/schemas/sql.v1.Connection" /> */
    "sql.v1.ConnectionList": {
      /**
       * @description APIVersion defines the schema version of this representation of a resource.
       * @example sql/v1
       * @enum {string}
       */
      api_version: "sql/v1";
      /**
       * @description Kind defines the object this REST resource represents.
       * @enum {string}
       */
      kind: "ConnectionList";
      metadata: components["schemas"]["ListMeta"] & {
        /** @example https://flink.us-west1.aws.confluent.cloud/sql/v1/environments/env-123/connections */
        self?: unknown;
        /** @example https://flink.us-west1.aws.confluent.cloud/sql/v1/environments/env-abc123/connections */
        first?: unknown;
        /** @example  */
        last?: unknown;
        /** @example  */
        prev?: unknown;
        /** @example https://flink.us-west1.aws.confluent.cloud/sql/v1/environments/env-abc123/connections?page_token=UvmDWOB1iwfAIBPj6EYb */
        next?: unknown;
      };
      /** @description A data property that contains an array of resource items. Each entry in the array is a separate resource. */
      data: (components["schemas"]["sql.v1.Connection"] & {
        spec: Record<string, unknown>;
      })[];
    };
    /** @description The status of the Connection */
    "sql.v1.ConnectionStatus": {
      /**
       * @description Describes the status of the connection:
       *
       *     READY: The Connection is usable;
       *
       *     UNREACHABLE: The Connection endpoint is unreachable;
       *
       *     INVALID_AUTH: The Connection auth token is invalid;
       *
       * @example READY
       */
      readonly phase: string;
      /**
       * @description Details about why connection transitioned into a given status.
       * @example Lookup failed: ai.openai.com
       */
      readonly detail?: string;
    };
    /** @description Describes a sensitive piece of information passed in plaintext.
     *
     *     Confluent only accepts authentication tokens of supported model providers from OrgAdmins and EnvAdmins.
     *     For now, only 'PlainText' provider is supported. It stores authentication token details as opaque bytes in an encrypted form.
     *     This option offers limited security as it only provides a single level of encryption.
     *      */
    "sql.v1.PlaintextProvider": {
      /**
       * @description Plaintext Provider Kind Type
       *      (enum property replaced by openapi-typescript)
       * @enum {string}
       */
      kind: "PlaintextProvider";
      /**
       * Format: byte
       * @description Base64 encoded opaque piece of sensitive information.
       *
       *     Scoped to an endpoint of a `Connection` resource.
       *
       */
      data?: string;
    };
    /** @description Encapsulates the model provider access details */
    "sql.v1.ConnectionSpec": {
      /**
       * @description The type of this connection.
       * @example OPENAI
       */
      connection_type?: string;
      /**
       * @description The endpoint that is used to run model inferencing.
       * @example https://api.openai.com/v1/chat/completions
       */
      endpoint?: string;
      /** @description The vendor specific authentication token details
       *
       *     The contents are stored as opaque bytes given in plaintext by an EnvAdmin.
       *     In future, we would support more secure methods for distributing authentication tokens.
       *      */
      auth_data?: components["schemas"]["sql.v1.PlaintextProvider"];
    };
    /** @description `Statement` represents a core resource used to model SQL statements for execution.
     *     A statement generalizes DDL, DML, DQL, etc., but doesn’t attempt to handle session
     *     management or any higher-level functionality.
     *     The API allows you to list, create, read, and delete your statements.
     *     ## The Statements Model
     *     <SchemaDefinition schemaRef="#/components/schemas/sql.v1.Statement" /> */
    "sql.v1.Statement": {
      /**
       * @description APIVersion defines the schema version of this representation of a resource.
       * @example sql/v1
       * @enum {string}
       */
      readonly api_version?: "sql/v1";
      /**
       * @description Kind defines the object this REST resource represents.
       * @enum {string}
       */
      readonly kind?: "Statement";
      metadata?: components["schemas"]["StatementObjectMeta"] & {
        /** @example https://flink.us-west1.aws.confluent.cloud/sql/v1/environments/env-123/statements/my-statement */
        self?: unknown;
        /** @example 12345678-1234-1234-1234-123456789012 */
        uid?: unknown;
        /** @example a23av */
        resource_version?: unknown;
        /** @example  */
        resource_name?: unknown;
        labels?: {
          [key: string]: string;
        };
      };
      /**
       * @description The user provided name of the resource, unique within this environment.
       * @example sql123
       */
      name?: string;
      /**
       * Format: uuid
       * @description The unique identifier for the organization.
       */
      organization_id?: string;
      /** @description The unique identifier for the environment. */
      environment_id?: string;
      spec?: components["schemas"]["sql.v1.StatementSpec"];
      status?: components["schemas"]["sql.v1.StatementStatus"];
      result?: components["schemas"]["sql.v1.StatementResult"];
    };
    /** @description The status of the Statement */
    "sql.v1.StatementStatus": {
      /**
       * @description The lifecycle phase of the submitted SQL statement:
       *
       *     PENDING: SQL statement is pending execution;
       *
       *     RUNNING: SQL statement execution is in progress;
       *
       *     COMPLETED: SQL statement is completed;
       *
       *     DELETING: SQL statement deletion is in progress;
       *
       *     FAILING: SQL statement is failing;
       *
       *     FAILED: SQL statement execution has failed;
       *
       *     STOPPED: SQL statement execution has successfully been stopped;
       *
       * @example RUNNING
       */
      readonly phase: string;
      scaling_status?: components["schemas"]["sql.v1.ScalingStatus"];
      /**
       * @description Details about the execution status of this statement.
       * @example Statement is running successfully
       */
      readonly detail?: string;
      traits?: components["schemas"]["sql.v1.StatementTraits"];
      /**
       * @description The networking type used by the submitted SQL statement:
       *
       *     PUBLIC: SQL statement is using public networking;
       *
       *     PRIVATE: SQL statement is using private networking;
       *
       * @example PUBLIC
       */
      readonly network_kind?: string;
      /**
       * @description The last Kafka offsets that a statement has processed. Represented by a mapping from Kafka topic to a
       *     string representation of partitions mapped to offsets.
       *
       * @example {
       *       "topic-1": "partition:0,offset:100;partition:1,offset:200",
       *       "topic-2": "partition:0,offset:50"
       *     }
       */
      readonly latest_offsets?: {
        [key: string]: string;
      };
      /**
       * Format: date-time
       * @description The date and time at which the Kafka topic offsets were added to the statement status. It is represented in RFC3339 format and is in UTC.
       * @example 2023-03-31T00:00:00-00:00
       */
      readonly latest_offsets_timestamp?: string;
    };
    /** @description StatementTraits contains detailed information about the properties of a Statement */
    "sql.v1.StatementTraits": {
      /**
       * @description Categorizes the SQL statement. The result is Confluent-specific but inspired by SQL. It uses underscores for separating concepts e.g. "CREATE_TABLE".
       * @example SELECT
       */
      sql_kind?: string;
      /** @description Indicates the special case where results of a statement are bounded. */
      is_bounded?: boolean;
      /** @description Indicates the special case where results of a statement are insert/append only. */
      is_append_only?: boolean;
      /** @description Defines the column indices clients can use as upsert keys. */
      upsert_columns?: number[];
      schema?: components["schemas"]["sql.v1.ResultSchema"];
    };
    /** @description `Statement` represents a core resource used to model SQL statements for execution.
     *     A statement generalizes DDL, DML, DQL, etc., but doesn’t attempt to handle session
     *     management or any higher-level functionality.
     *     The API allows you to list, create, read, and delete your statements.
     *     ## The Statements Model
     *     <SchemaDefinition schemaRef="#/components/schemas/sql.v1.Statement" /> */
    "sql.v1.StatementList": {
      /**
       * @description APIVersion defines the schema version of this representation of a resource.
       * @example sql/v1
       * @enum {string}
       */
      api_version: "sql/v1";
      /**
       * @description Kind defines the object this REST resource represents.
       * @enum {string}
       */
      kind: "StatementList";
      metadata: components["schemas"]["ListMeta"] & {
        /** @example https://flink.us-west1.aws.confluent.cloud/sql/v1/environments/env-123/statements */
        self?: unknown;
        /** @example https://flink.us-west1.aws.confluent.cloud/sql/v1/environments/env-abc123/statements */
        first?: unknown;
        /** @example  */
        last?: unknown;
        /** @example  */
        prev?: unknown;
        /** @example https://flink.us-west1.aws.confluent.cloud/sql/v1/environments/env-abc123/statements?page_token=UvmDWOB1iwfAIBPj6EYb */
        next?: unknown;
      };
      /** @description A data property that contains an array of resource items. Each entry in the array is a separate resource. */
      data: (components["schemas"]["sql.v1.Statement"] & {
        spec: Record<string, unknown>;
      })[];
    };
    /** @description `Statement Result` represents a resource used to model results of SQL statements.
     *     The API allows you to read your SQL statement result. */
    "sql.v1.StatementResult": {
      /**
       * @description APIVersion defines the schema version of this representation of a resource.
       * @example sql/v1
       * @enum {string}
       */
      api_version: "sql/v1";
      /**
       * @description Kind defines the object this REST resource represents.
       * @enum {string}
       */
      kind: "StatementResult";
      metadata: components["schemas"]["ResultListMeta"];
      results?: components["schemas"]["sql.v1.StatementResultResults"];
    };
    /** @description A results property that contains a data property that contains an array of results. */
    "sql.v1.StatementResultResults": {
      /**
       * @description A data property that contains an array of results. Each entry in the array is a separate result.
       *
       *     The value of `op` attribute (if present) represents the kind of change that a row can describe in a changelog:
       *
       *     `0`: represents `INSERT` (`+I`), i.e. insertion operation;
       *
       *     `1`: represents `UPDATE_BEFORE` (`-U`), i.e. update operation with the previous content of the updated row.
       *     This kind should occur together with `UPDATE_AFTER` for modelling an update that needs to retract
       *     the previous row first. It is useful in cases of a non-idempotent update, i.e., an update of a row that is not
       *     uniquely identifiable by a key;
       *
       *     `2`: represents `UPDATE_AFTER` (`+U`), i.e. update operation with new content of the updated row;
       *     This kind CAN occur together with `UPDATE_BEFORE` for modelling an update that
       *     needs to retract the previous row first or it describes an idempotent update, i.e., an
       *     update of a row that is uniquely identifiable by a key;
       *
       *     `3`: represents `DELETE` (`-D`), i.e. deletion operation;
       *
       *     Defaults to `0`.
       *
       * @example [
       *       {
       *         "op": 0,
       *         "row": [
       *           "101",
       *           "Jay",
       *           [
       *             null,
       *             "abc"
       *           ],
       *           [
       *             null,
       *             "456"
       *           ],
       *           "1990-01-12 12:00.12",
       *           [
       *             [
       *               null,
       *               "Alice"
       *             ],
       *             [
       *               "42",
       *               "Bob"
       *             ]
       *           ]
       *         ]
       *       }
       *     ]
       */
      data?: unknown[];
    };
    /** @description The specs of the Statement */
    "sql.v1.StatementSpec": {
      /**
       * @description The raw SQL text statement.
       * @example SELECT * FROM TABLE WHERE VALUE1 = VALUE2;
       */
      statement?: string;
      /**
       * @description A map (key-value pairs) of statement properties.
       * @example {
       *       "sql.current-catalog": "my_environment",
       *       "sql.current-database": "my_kafka_cluster"
       *     }
       */
      properties?: {
        [key: string]: string;
      };
      /**
       * @description The id associated with the compute pool in context.
       * @example fcp-00000
       */
      compute_pool_id?: string;
      /**
       * @description The id of a principal this statement runs as.
       * @example sa-abc123
       */
      principal?: string;
      /**
       * @description Indicates whether the statement should be stopped.
       * @example false
       */
      stopped?: boolean;
    };
    /** @description The metadata of the statement. */
    StatementObjectMeta: {
      /**
       * Format: uri
       * @description Self is a Uniform Resource Locator (URL) at which an object can be addressed. This URL encodes the service location, API version, and other particulars necessary to locate the resource at a point in time
       * @example https://flink.us-west1.aws.confluent.cloud/sql/v1/environments/env-123/statements/my-statement
       */
      self: string;
      /**
       * Format: date-time
       * @description The date and time at which this object was created. It is represented in RFC3339 format and is in UTC.
       * @example 1996-03-19T01:02:03-04:05
       */
      created_at?: string;
      /**
       * Format: date-time
       * @description The date and time at which this object was last updated. It is represented in RFC3339 format and is in UTC.
       * @example 2023-03-31T00:00:00-00:00
       */
      updated_at?: string;
      /**
       * @description A system generated globally unique identifier for this resource.
       * @example 12345678-1234-1234-1234-123456789012
       */
      uid?: string;
      /**
       * @description A system generated string that uniquely identifies the version of this resource.
       * @example a23av
       */
      resource_version?: string;
      /**
       * @description A map of key-value pairs that describe the resource.
       * @example {
       *       "user.confluent.io/hidden": "true"
       *     }
       */
      labels?: {
        [key: string]: string;
      };
    };
    /** @description ListMeta describes metadata that resource collections may have */
    ResultListMeta: {
      /**
       * @description Self is a Uniform Resource Locator (URL) at which an object can be addressed. This URL encodes the service location, API version, and other particulars necessary to locate the resource at a point in time
       * @example https://flink.us-west1.aws.confluent.cloud/sql/v1/environments/env-123/statements
       */
      self?: string;
      /**
       * @description A URL that can be followed to get the next batch of results.
       * @example https://flink.us-west1.aws.confluent.cloud/sql/v1/environments/env-abc123/statements?page_token=UvmDWOB1iwfAIBPj6EYb
       */
      next?: string;
      /**
       * Format: date-time
       * @description The date and time at which this object was created. It is represented in RFC3339 format and is in UTC.
       * @example 2006-01-02T15:04:05-07:00
       */
      readonly created_at?: string;
    };
    /** @description Scaling status for this statement. */
    "sql.v1.ScalingStatus": {
      /**
       * @description OK: The statement runs at the right scale.
       *
       *     PENDING_SCALE_DOWN: The statement requires less resources, and will be scaled down in the near future.
       *
       *     PENDING_SCALE_UP: The statement requires more resources, and will be scaled up in the near future.
       *
       *     POOL_EXHAUSTED: The statement requires more resources, but not enough resources are available.
       *
       * @example OK
       */
      readonly scaling_state?: string;
      /**
       * Format: date-time
       * @description The last time the scaling status was updated.
       * @example 1996-03-19T01:02:03-04:05
       */
      readonly last_updated?: string;
    };
    /** @description The table columns of the results schema. */
    "sql.v1.ResultSchema": {
      /** @description The properties of each SQL column in the schema. */
      columns?: components["schemas"]["ColumnDetails"][];
    };
    /** @description A column in the results schema. */
    ColumnDetails: {
      /**
       * @description The name of the SQL table column.
       * @example Column_Name
       */
      name: string;
      /**
       * @description JSON object in TableSchema format; describes the data returned by the results serving API.
       * @example {
       *       "type": "CHAR",
       *       "nullable": true,
       *       "length": 8
       *     }
       */
      type: components["schemas"]["DataType"];
    };
    DataType: {
      /** @description The data type of the column. */
      type: string;
      /** @description Indicates whether values in this column can be null. */
      nullable: boolean;
      /**
       * Format: int32
       * @description The length of the data type.
       */
      length?: number;
      /**
       * Format: int32
       * @description The precision of the data type.
       */
      precision?: number;
      /**
       * Format: int32
       * @description The scale of the data type.
       */
      scale?: number;
      /** @description The type of the key in the data type (if applicable). */
      key_type?: components["schemas"]["DataType"];
      /** @description The type of the value in the data type (if applicable). */
      value_type?: components["schemas"]["DataType"];
      /** @description The type of the element in the data type (if applicable). */
      element_type?: components["schemas"]["DataType"];
      /** @description The fields of the element in the data type (if applicable). */
      fields?: components["schemas"]["RowFieldType"][];
      /** @description The resolution of the data type (if applicable). */
      resolution?: string;
      /**
       * Format: int32
       * @description The fractional precision of the data type (if applicable).
       */
      fractional_precision?: number;
    };
    RowFieldType: {
      /** @description The name of the field. */
      name: string;
      /** @description The data type of the field. */
      field_type: components["schemas"]["DataType"];
      /** @description The description of the field. */
      description?: string;
    };
    /** @description ListMeta describes metadata that resource collections may have */
    ExceptionListMeta: {
      /**
       * @description Self is a Uniform Resource Locator (URL) at which an object can be addressed. This URL encodes the service location, API version, and other particulars necessary to locate the resource at a point in time
       * @example https://flink.us-west1.aws.confluent.cloud/sql/v1/environments/env-123/statements/sql123/exceptions
       */
      self?: string;
    };
    /** @description StatementExceptionList is a list of exceptions coming from FAILED or FAILING Statements created by
     *     the SQL Statements API. */
    "sql.v1.StatementExceptionList": {
      /**
       * @description APIVersion defines the schema version of this representation of a resource.
       * @example sql/v1
       * @enum {string}
       */
      api_version: "sql/v1";
      /**
       * @description Kind defines the object this REST resource represents.
       * @enum {string}
       */
      kind: "StatementExceptionList";
      metadata: components["schemas"]["ExceptionListMeta"];
      /** @description A data property that contains an array of resource items. Each entry in the array is a separate resource. */
      data: components["schemas"]["sql.v1.StatementException"][];
    };
    "sql.v1.StatementException": {
      /**
       * @description Kind defines the object this REST resource represents.
       * @enum {string}
       */
      kind?: "StatementException";
      /**
       * @description Name of the SQL statement exception.
       * @example java.lang.RuntimeException
       */
      readonly name?: string;
      /**
       * @description Error message of the statement exception.
       * @example java.lang.RuntimeException: An error occurred
       */
      readonly message?: string;
      /**
       * Format: date-time
       * @description The date and time at which the exception occurred. It is represented in RFC3339 format and is in UTC.
       * @example 2023-03-31T00:00:00-00:00
       */
      readonly timestamp?: string;
    };
    /** @description PatchRequest represent a json-patch request to be applied to the Statement. See https://tools.ietf.org/html/rfc6902 */
    PatchRequest: (
      | components["schemas"]["JsonPatchRequestAddReplace"]
      | components["schemas"]["JsonPatchRequestRemove"]
      | components["schemas"]["JsonPatchRequestMoveCopy"]
    )[];
    /** @description This option is used to add or replace a value for a field */
    JsonPatchRequestAddReplace: {
      /** @description A JSON Pointer path. */
      path: string;
      /** @description The value to add, replace or test. */
      value: unknown;
      /**
       * @description The operation to perform.
       * @enum {string}
       */
      op: "ADD" | "REPLACE" | "TEST";
    };
    /** @description This option is used to remove a field */
    JsonPatchRequestRemove: {
      /** @description A JSON Pointer path. */
      path: string;
      /**
       * @description The operation to perform.
       * @enum {string}
       */
      op: "REMOVE";
    };
    /** @description This option is used to move or copy a field */
    JsonPatchRequestMoveCopy: {
      /** @description A JSON Pointer path. */
      path: string;
      /**
       * @description The operation to perform.
       * @enum {string}
       */
      op: "MOVE" | "COPY";
      /** @description A JSON Pointer path. */
      from: string;
    };
    /** @description Add, remove, and update DNS forwarder for your gateway.
     *
     *     Related guides:
     *     * [Use VPC peering connections with Confluent Cloud on AWS](https://docs.confluent.io/cloud/current/networking/peering/aws-peering.html).
     *     * [Use VNet peering connections with Confluent Cloud on Azure](https://docs.confluent.io/cloud/current/networking/peering/azure-peering.html).
     *
     *
     *     ## The DNS Forwarders Model
     *     <SchemaDefinition schemaRef="#/components/schemas/networking.v1.DnsForwarder" /> */
    "networking.v1.DnsForwarder": {
      /**
       * @description APIVersion defines the schema version of this representation of a resource.
       * @enum {string}
       */
      readonly api_version?: "networking/v1";
      /**
       * @description Kind defines the object this REST resource represents.
       * @enum {string}
       */
      readonly kind?: "DnsForwarder";
      /**
       * @description ID is the "natural identifier" for an object within its scope/namespace; it is normally unique across time but not space. That is, you can assume that the ID will not be reclaimed and reused after an object is deleted ("time"); however, it may collide with IDs for other object `kinds` or objects of the same `kind` within a different scope/namespace ("space").
       * @example dlz-f3a90de
       */
      readonly id?: string;
      metadata?: components["schemas"]["ObjectMeta"] & {
        /** @example https://api.confluent.cloud/networking/v1/dns-forwarders/df-12345 */
        self?: unknown;
        /** @example crn://confluent.cloud/organization=9bb441c4-edef-46ac-8a41-c49e44a3fd9a/environment=env-abc123/gateway=gw-456xyz/dns-forwarder=df-12345 */
        resource_name?: unknown;
      };
      spec?: components["schemas"]["networking.v1.DnsForwarderSpec"];
      status?: components["schemas"]["networking.v1.DnsForwarderStatus"];
    };
    /** @description The status of the Dns Forwarder */
    "networking.v1.DnsForwarderStatus": {
      /**
       * @description The lifecycle phase of the DNS forwarder:
       *
       *       PROVISIONING: DNS forwarder provisioning is in progress;
       *
       *       CREATED: DNS forwarder is created. It will automatically become ready once a Kafka cluster is provisioned;
       *
       *       READY: DNS forwarder is ready;
       *
       *       FAILED: DNS forwarder is in a failed state;
       *
       *       DEGRADED: DNS forwarder is in a degraded state, transitioning from 'READY' due to unreachable DNS resolvers;
       *
       *       DEPROVISIONING: DNS forwarder deprovisioning is in progress;
       *
       * @example READY
       */
      readonly phase: string;
      /** @description Error code if dns forwarder is in a failed state. May be used for programmatic error checking. */
      readonly error_code?: string;
      /** @description Displayable error message if dns forwarder is in a failed state */
      readonly error_message?: string;
    };
    /**
     * @description IPv4 Address
     * @example 10.200.0.0
     */
    "networking.v1.Ip": string;
    /**
     * ForwardViaIp
     * @description DNS Forwarder Configured via DNS Server IPs.
     */
    "networking.v1.ForwardViaIp": {
      /**
       * @description DNS Forwarder Configured via DNS Server IPs kind type. (enum property replaced by openapi-typescript)
       * @enum {string}
       */
      kind: "ForwardViaIp";
      /**
       * @description List of IP addresses of the DNS server
       * @example [
       *       "10.200.0.0",
       *       "10.200.0.1"
       *     ]
       */
      dns_server_ips: components["schemas"]["networking.v1.Ip"][];
    };
    /** @description Add, remove, and update DNS forwarder for your gateway.
     *
     *     Related guides:
     *     * [Use VPC peering connections with Confluent Cloud on AWS](https://docs.confluent.io/cloud/current/networking/peering/aws-peering.html).
     *     * [Use VNet peering connections with Confluent Cloud on Azure](https://docs.confluent.io/cloud/current/networking/peering/azure-peering.html).
     *
     *
     *     ## The DNS Forwarders Model
     *     <SchemaDefinition schemaRef="#/components/schemas/networking.v1.DnsForwarder" /> */
    "networking.v1.DnsForwarderList": {
      /**
       * @description APIVersion defines the schema version of this representation of a resource.
       * @enum {string}
       */
      readonly api_version: "networking/v1";
      /**
       * @description Kind defines the object this REST resource represents.
       * @enum {string}
       */
      readonly kind: "DnsForwarderList";
      metadata: components["schemas"]["ListMeta"] & {
        /** @example https://api.confluent.cloud/networking/v1/dns-forwarders */
        first?: unknown;
        /** @example https://api.confluent.cloud/networking/v1/dns-forwarders?page_token=bcAOehAY8F16YD84Z1wT */
        last?: unknown;
        /** @example https://api.confluent.cloud/networking/v1/dns-forwarders?page_token=YIXRY97wWYmwzrax4dld */
        prev?: unknown;
        /** @example https://api.confluent.cloud/networking/v1/dns-forwarders?page_token=UvmDWOB1iwfAIBPj6EYb */
        next?: unknown;
      };
      /** @description A data property that contains an array of resource items. Each entry in the array is a separate resource. */
      data: (components["schemas"]["networking.v1.DnsForwarder"] & {
        spec: Record<string, unknown>;
      })[];
    };
    /** @description The desired state of the Dns Forwarder */
    "networking.v1.DnsForwarderSpec": {
      /**
       * @description The name of the DNS forwarder
       * @example prod-dnsf-1
       */
      display_name?: string;
      /**
       * @description List of domains for the DNS forwarder to use
       * @example [
       *       "example.com",
       *       "domainname.com"
       *     ]
       */
      domains?: string[];
      /** @description The specific details of different kinds of configuration for DNS Forwarder. */
      config?: components["schemas"]["networking.v1.ForwardViaIp"];
      /** @description The environment to which this belongs. */
      environment?: components["schemas"]["ObjectReference"];
      /** @description The gateway to which this belongs. */
      gateway?: components["schemas"]["ObjectReference"];
    };
    /** @description AccessPoint objects represent network connections in and out of Gateways.
     *     This API allows you to list, create, read, update, and delete your access points.
     *
     *
     *     ## The Access Points Model
     *     <SchemaDefinition schemaRef="#/components/schemas/networking.v1.AccessPoint" /> */
    "networking.v1.AccessPoint": {
      /**
       * @description APIVersion defines the schema version of this representation of a resource.
       * @enum {string}
       */
      readonly api_version?: "networking/v1";
      /**
       * @description Kind defines the object this REST resource represents.
       * @enum {string}
       */
      readonly kind?: "AccessPoint";
      /**
       * @description ID is the "natural identifier" for an object within its scope/namespace; it is normally unique across time but not space. That is, you can assume that the ID will not be reclaimed and reused after an object is deleted ("time"); however, it may collide with IDs for other object `kinds` or objects of the same `kind` within a different scope/namespace ("space").
       * @example dlz-f3a90de
       */
      readonly id?: string;
      metadata?: components["schemas"]["ObjectMeta"] & {
        /** @example https://api.confluent.cloud/networking/v1/access-points/ap-12345 */
        self?: unknown;
        /** @example crn://confluent.cloud/organization=9bb441c4-edef-46ac-8a41-c49e44a3fd9a/environment=env-abc123/gateway=gw-456xyz/access-point=ap-12345 */
        resource_name?: unknown;
      };
      spec?: components["schemas"]["networking.v1.AccessPointSpec"];
      status?: components["schemas"]["networking.v1.AccessPointStatus"];
    };
    /** @description The status of the Access Point */
    "networking.v1.AccessPointStatus": {
      /**
       * @description The lifecycle phase of the access point:
       *
       *       PROVISIONING: Access point provisioning is in progress;
       *
       *       PENDING_ACCEPT: Access point connection request is pending acceptance by the customer;
       *
       *       READY:  Access point is ready;
       *
       *       FAILED: Access point is in a failed state;
       *
       *       DEPROVISIONING: Access point deprovisioning is in progress;
       *
       *       DISCONNECTED: Access Point has been disconnected in the cloud provider by the customer;
       *
       *       DEGRADED: Access Point is experiencing reduced performance or partial failure;
       *
       *       ERROR: Invalid customer input during Access Point creation;
       *
       * @example READY
       */
      readonly phase: string;
      /** @description Error code if access point is in a failed state. May be used for programmatic error checking. */
      readonly error_code?: string;
      /** @description Displayable error message if access point is in a failed state. */
      readonly error_message?: string;
      /** @description Cloud specific status of the access point. */
      readonly config?:
        | components["schemas"]["networking.v1.AwsEgressPrivateLinkEndpointStatus"]
        | components["schemas"]["networking.v1.AzureEgressPrivateLinkEndpointStatus"]
        | components["schemas"]["networking.v1.GcpEgressPrivateServiceConnectEndpointStatus"];
    };
    /** @description DNS record objects are associated with Confluent Cloud networking resources. This API allows you to list, create, read, update, and delete your DNS records.
     *
     *     ## The DNS Records Model
     *     <SchemaDefinition schemaRef="#/components/schemas/networking.v1.DnsRecord" /> */
    "networking.v1.DnsRecord": {
      /**
       * @description APIVersion defines the schema version of this representation of a resource.
       * @enum {string}
       */
      readonly api_version?: "networking/v1";
      /**
       * @description Kind defines the object this REST resource represents.
       * @enum {string}
       */
      readonly kind?: "DnsRecord";
      /**
       * @description ID is the "natural identifier" for an object within its scope/namespace; it is normally unique across time but not space. That is, you can assume that the ID will not be reclaimed and reused after an object is deleted ("time"); however, it may collide with IDs for other object `kinds` or objects of the same `kind` within a different scope/namespace ("space").
       * @example dlz-f3a90de
       */
      readonly id?: string;
      metadata?: components["schemas"]["ObjectMeta"] & {
        /** @example https://api.confluent.cloud/networking/v1/dns-records/dnsrec-12345 */
        self?: unknown;
        /** @example crn://confluent.cloud/organization=9bb441c4-edef-46ac-8a41-c49e44a3fd9a/environment=env-abc123/gateway=gw-456xyz/dns-record=dnsrec-12345 */
        resource_name?: unknown;
      };
      spec?: components["schemas"]["networking.v1.DnsRecordSpec"];
      status?: components["schemas"]["networking.v1.DnsRecordStatus"];
    };
    /** @description The status of the Dns Record */
    "networking.v1.DnsRecordStatus": {
      /**
       * @description The lifecycle phase of the DNS record:
       *
       *       PROVISIONING: DNS record provisioning is in progress;
       *
       *       CREATED: DNS record is created. It will automatically become ready once a Kafka cluster is provisioned;
       *
       *       READY: DNS record is ready;
       *
       *       FAILED: DNS record is in a failed state;
       *
       *       DEPROVISIONING: DNS record deprovisioning is in progress;
       *
       * @example READY
       */
      readonly phase: string;
      /** @description Error code if the DNS record is in a failed state. May be used for programmatic error checking. */
      readonly error_code?: string;
      /** @description Displayable error message if the DNS record is in a failed state. */
      readonly error_message?: string;
    };
    /** @description AWS VPC Endpoint. */
    "networking.v1.AwsEgressPrivateLinkEndpoint": {
      /**
       * @description AwsEgressPrivateLinkEndpoint kind. (enum property replaced by openapi-typescript)
       * @enum {string}
       */
      kind: "AwsEgressPrivateLinkEndpoint";
      /**
       * @description ID of the VPC Endpoint service used for PrivateLink.
       * @example com.amazonaws.vpce.us-west-2.vpce-svc-00000000000000000
       */
      vpc_endpoint_service_name: string;
      /**
       * @description Whether a resource should be provisioned with high availability. Endpoints deployed with high availability have network interfaces deployed in multiple AZs.
       * @example false
       */
      enable_high_availability?: boolean;
      /**
       * @description [Used by the Confluent Cloud Console] The target system or service that the PrivateLink Endpoint connects to (e.g. "MONGODB" or "SNOWFLAKE").
       * @example S3
       */
      target_system?: string;
    };
    /** @description Azure Private Endpoint. */
    "networking.v1.AzureEgressPrivateLinkEndpoint": {
      /**
       * @description AzureEgressPrivateLinkEndpoint kind. (enum property replaced by openapi-typescript)
       * @enum {string}
       */
      kind: "AzureEgressPrivateLinkEndpoint";
      /**
       * @description Resource ID of the Azure Private Link service.
       * @example /subscriptions/00000000-0000-0000-0000-000000000000/resourceGroups/s-abcde/providers/Microsoft.Network/privateLinkServices/pls-plt-abcdef-az3
       */
      private_link_service_resource_id: string;
      /**
       * @description Name of the subresource for the Private Endpoint to connect to.
       * @example sqlServer
       */
      private_link_subresource_name?: string;
      /**
       * @description [Used by the Confluent Cloud Console] The target system or service that the PrivateLink Endpoint connects to (e.g. "MONGODB" or "SNOWFLAKE").
       * @example SNOWFLAKE
       */
      target_system?: string;
    };
    /** @description GCP Private Service Connect Endpoint. */
    "networking.v1.GcpEgressPrivateServiceConnectEndpoint": {
      /**
       * @description GcpEgressPrivateServiceConnectEndpoint kind. (enum property replaced by openapi-typescript)
       * @enum {string}
       */
      kind: "GcpEgressPrivateServiceConnectEndpoint";
      /**
       * @description URI of the service attachment for the published service that the Private Service Connect Endpoint connects to or "ALL_GOOGLE_APIS" for global Google APIs.
       * @example projects/project-name/regions/us-central1/serviceAttachments/service-attachment-name
       */
      private_service_connect_endpoint_target: string;
      /**
       * @description [Used by the Confluent Cloud Console] The target system or service that the PrivateLink Endpoint connects to (e.g. "GCS" or "SNOWFLAKE").
       * @example GCS
       */
      target_system?: string;
    };
    /**
     * AWS
     * @description Status of an AWS PrivateLink Endpoint.
     */
    "networking.v1.AwsEgressPrivateLinkEndpointStatus": {
      /**
       * @description AwsEgressPrivateLinkEndpointStatus kind. (enum property replaced by openapi-typescript)
       * @enum {string}
       */
      kind: "AwsEgressPrivateLinkEndpointStatus";
      /**
       * @description ID of a VPC Endpoint (if any) that is connected to the VPC Endpoint service.
       * @example vpce-00000000000000000
       */
      readonly vpc_endpoint_id: string;
      /**
       * @description DNS name of a VPC Endpoint (if any) that is connected to the VPC Endpoint service.
       * @example vpce-00000000000000000-00000000.vpce-svc-00000000000000000.us-west-2.vpce.amazonaws.com
       */
      readonly vpc_endpoint_dns_name: string;
    };
    /** @description Status of an Azure Private Endpoint. */
    "networking.v1.AzureEgressPrivateLinkEndpointStatus": {
      /**
       * @description AzureEgressPrivateLinkEndpointStatus kind. (enum property replaced by openapi-typescript)
       * @enum {string}
       */
      kind: "AzureEgressPrivateLinkEndpointStatus";
      /**
       * @description Resource ID of the Private Endpoint (if any) that is connected to the Private Link service.
       * @example /subscriptions/00000000-0000-0000-0000-000000000000/resourceGroups/testvpc/providers/Microsoft.Network/privateEndpoints/pe-plt-abcdef-az3
       */
      readonly private_endpoint_resource_id: string;
      /**
       * @description Domain of the Private Endpoint (if any) that is connected to the Private Link service.
       * @example dbname.database.windows.net
       */
      readonly private_endpoint_domain?: string;
      /**
       * @description IP address of the Private Endpoint (if any) that is connected to the Private Link service.
       * @example 10.2.0.68
       */
      readonly private_endpoint_ip_address: string;
      /**
       * @description Domains of the Private Endpoint (if any) based off FQDNs in Azure custom DNS configs, which are required in your private DNS setup.
       * @example [
       *       "dbname.database.windows.net",
       *       "dbname-region.database.windows.net"
       *     ]
       */
      readonly private_endpoint_custom_dns_config_domains?: string[];
    };
    /** @description Status of a GCP Private Service Connect Endpoint. */
    "networking.v1.GcpEgressPrivateServiceConnectEndpointStatus": {
      /**
       * @description GcpEgressPrivateServiceConnectEndpointStatus kind. (enum property replaced by openapi-typescript)
       * @enum {string}
       */
      kind: "GcpEgressPrivateServiceConnectEndpointStatus";
      /**
       * @description Connection ID of the Private Service Connect Endpoint (if any) that is connected to the endpoint target.
       * @example
       */
      readonly private_service_connect_endpoint_connection_id: string;
      /**
       * @description Name of the Private Service Connect Endpoint (if any) that is connected to the endpoint target.
       * @example plap-123456
       */
      readonly private_service_connect_endpoint_name: string;
      /**
       * @description IP address of the Private Service Connect Endpoint (if any) that is connected to the endpoint target.
       * @example 10.2.0.68
       */
      readonly private_service_connect_endpoint_ip_address: string;
    };
    /** @description DNS record that is associated with a PrivateLink access point. */
    "networking.v1.PrivateLinkAccessPoint": {
      /**
       * @description PrivateLinkAccessPoint kind. (enum property replaced by openapi-typescript)
       * @enum {string}
       */
      kind: "PrivateLinkAccessPoint";
      /**
       * @description ID of the target resource.
       * @example ap-12345
       */
      resource_id: string;
    };
    /** @description Confluent Private Network Interface powered by AWS ENI. */
    "networking.v1.AwsPrivateNetworkInterface": {
      /**
       * @description AwsPrivateNetworkInterface kind. (enum property replaced by openapi-typescript)
       * @enum {string}
       */
      kind: "AwsPrivateNetworkInterface";
      /**
       * @description List of the IDs of the Elastic Network Interfaces.
       * @example [
       *       "eni-00000000000000000",
       *       "eni-00000000000000001",
       *       "eni-00000000000000002",
       *       "eni-00000000000000003",
       *       "eni-00000000000000004",
       *       "eni-00000000000000005",
       *       "eni-00000000000000006",
       *       "eni-00000000000000007",
       *       "eni-00000000000000008",
       *       "eni-00000000000000009",
       *       "eni-00000000000000010",
       *       "eni-00000000000000011",
       *       "eni-00000000000000012",
       *       "eni-00000000000000013",
       *       "eni-00000000000000014",
       *       "eni-00000000000000015",
       *       "eni-00000000000000016",
       *       "eni-00000000000000017",
       *       "eni-00000000000000018",
       *       "eni-00000000000000019",
       *       "eni-00000000000000020",
       *       "eni-00000000000000021",
       *       "eni-00000000000000022",
       *       "eni-00000000000000023",
       *       "eni-00000000000000024",
       *       "eni-00000000000000025",
       *       "eni-00000000000000026",
       *       "eni-00000000000000027",
       *       "eni-00000000000000028",
       *       "eni-00000000000000029",
       *       "eni-00000000000000030",
       *       "eni-00000000000000031",
       *       "eni-00000000000000032",
       *       "eni-00000000000000033",
       *       "eni-00000000000000034",
       *       "eni-00000000000000035",
       *       "eni-00000000000000036",
       *       "eni-00000000000000037",
       *       "eni-00000000000000038",
       *       "eni-00000000000000039",
       *       "eni-00000000000000040",
       *       "eni-00000000000000041",
       *       "eni-00000000000000042",
       *       "eni-00000000000000043",
       *       "eni-00000000000000044",
       *       "eni-00000000000000045",
       *       "eni-00000000000000046",
       *       "eni-00000000000000047",
       *       "eni-00000000000000048",
       *       "eni-00000000000000049",
       *       "eni-00000000000000050"
       *     ]
       */
      network_interfaces?: string[];
      /**
       * @description The AWS account ID associated with the ENIs you are using for the Confluent Private Network Interface.
       * @example 000000000000
       */
      account?: string;
    };
    /** @description AccessPoint objects represent network connections in and out of Gateways.
     *     This API allows you to list, create, read, update, and delete your access points.
     *
     *
     *     ## The Access Points Model
     *     <SchemaDefinition schemaRef="#/components/schemas/networking.v1.AccessPoint" /> */
    "networking.v1.AccessPointList": {
      /**
       * @description APIVersion defines the schema version of this representation of a resource.
       * @enum {string}
       */
      readonly api_version: "networking/v1";
      /**
       * @description Kind defines the object this REST resource represents.
       * @enum {string}
       */
      readonly kind: "AccessPointList";
      metadata: components["schemas"]["ListMeta"] & {
        /** @example https://api.confluent.cloud/networking/v1/access-points */
        first?: unknown;
        /** @example https://api.confluent.cloud/networking/v1/access-points?page_token=bcAOehAY8F16YD84Z1wT */
        last?: unknown;
        /** @example https://api.confluent.cloud/networking/v1/access-points?page_token=YIXRY97wWYmwzrax4dld */
        prev?: unknown;
        /** @example https://api.confluent.cloud/networking/v1/access-points?page_token=UvmDWOB1iwfAIBPj6EYb */
        next?: unknown;
      };
      /** @description A data property that contains an array of resource items. Each entry in the array is a separate resource. */
      data: (components["schemas"]["networking.v1.AccessPoint"] & {
        spec: Record<string, unknown>;
      })[];
    };
    /** @description The desired state of the Access Point */
    "networking.v1.AccessPointSpec": {
      /**
       * @description The name of the access point.
       * @example prod-ap-egress-usw2
       */
      display_name?: string;
      /** @description The specific details of the different access point configurations. */
      config?:
        | components["schemas"]["networking.v1.AwsEgressPrivateLinkEndpoint"]
        | components["schemas"]["networking.v1.AzureEgressPrivateLinkEndpoint"]
        | components["schemas"]["networking.v1.AwsPrivateNetworkInterface"]
        | components["schemas"]["networking.v1.GcpEgressPrivateServiceConnectEndpoint"];
      /** @description The environment to which this belongs. */
      environment?: components["schemas"]["ObjectReference"];
      /** @description The gateway to which this belongs. */
      gateway?: components["schemas"]["ObjectReference"];
    };
    /** @description DNS record objects are associated with Confluent Cloud networking resources. This API allows you to list, create, read, update, and delete your DNS records.
     *
     *     ## The DNS Records Model
     *     <SchemaDefinition schemaRef="#/components/schemas/networking.v1.DnsRecord" /> */
    "networking.v1.DnsRecordList": {
      /**
       * @description APIVersion defines the schema version of this representation of a resource.
       * @enum {string}
       */
      readonly api_version: "networking/v1";
      /**
       * @description Kind defines the object this REST resource represents.
       * @enum {string}
       */
      readonly kind: "DnsRecordList";
      metadata: components["schemas"]["ListMeta"] & {
        /** @example https://api.confluent.cloud/networking/v1/dns-records */
        first?: unknown;
        /** @example https://api.confluent.cloud/networking/v1/dns-records?page_token=bcAOehAY8F16YD84Z1wT */
        last?: unknown;
        /** @example https://api.confluent.cloud/networking/v1/dns-records?page_token=YIXRY97wWYmwzrax4dld */
        prev?: unknown;
        /** @example https://api.confluent.cloud/networking/v1/dns-records?page_token=UvmDWOB1iwfAIBPj6EYb */
        next?: unknown;
      };
      /** @description A data property that contains an array of resource items. Each entry in the array is a separate resource. */
      data: (components["schemas"]["networking.v1.DnsRecord"] & {
        spec: Record<string, unknown>;
      })[];
    };
    /** @description The desired state of the Dns Record */
    "networking.v1.DnsRecordSpec": {
      /**
       * @description The name of the DNS record.
       * @example prod-dnsrec-1
       */
      display_name?: string;
      /**
       * @description The fully qualified domain name of the DNS record.
       * @example example.com
       */
      domain?: string;
      /** @description The config of the DNS record. */
      config?: components["schemas"]["networking.v1.PrivateLinkAccessPoint"];
      /** @description The environment to which this belongs. */
      environment?: components["schemas"]["ObjectReference"];
      /** @description The gateway to which this belongs. */
      gateway?: components["schemas"]["TypedEnvScopedObjectReference"];
    };
    /** @description `CertificateAuthority` objects represent signing certificate authorities in Confluent Cloud.
     *
     *     The API allows you to list, create, read, update, and delete your Certificate Authority.
     *      */
    "iam.v2.CertificateAuthority": {
      /**
       * @description APIVersion defines the schema version of this representation of a resource.
       * @enum {string}
       */
      readonly api_version?: "iam/v2";
      /**
       * @description Kind defines the object this REST resource represents.
       * @enum {string}
       */
      readonly kind?: "CertificateAuthority";
      /**
       * @description ID is the "natural identifier" for an object within its scope/namespace; it is normally unique across time but not space. That is, you can assume that the ID will not be reclaimed and reused after an object is deleted ("time"); however, it may collide with IDs for other object `kinds` or objects of the same `kind` within a different scope/namespace ("space").
       * @example dlz-f3a90de
       */
      readonly id?: string;
      metadata?: components["schemas"]["ObjectMeta"] & {
        /** @example https://api.confluent.cloud/iam/v2/certificate-authorities/op-12345 */
        self?: unknown;
        /** @example crn://confluent.cloud/organization=9bb441c4-edef-46ac-8a41-c49e44a3fd9a/certificate-authority=op-12345 */
        resource_name?: unknown;
      };
      /**
       * @description The human-readable name of the certificate authority.
       * @example My Certificate Authority
       */
      display_name?: string;
      /**
       * @description A description of the certificate authority.
       * @example Sample description text
       */
      description?: string;
      /**
       * @description The fingerprints for each certificate in the certificate chain. These are SHA-1 encoded
       *     strings that act as unique identifiers for the certificates in the chain.
       * @example [
       *       "B1BC968BD4f49D622AA89A81F2150152A41D829C"
       *     ]
       */
      readonly fingerprints?: string[];
      /**
       * @description The expiration dates of certificates in the chain.
       * @example [
       *       "2017-07-21T17:32:28Z"
       *     ]
       */
      readonly expiration_dates?: string[];
      /**
       * @description The serial numbers for each certificate in the certificate chain.
       * @example [
       *       "219C542DE8f6EC7177FA4EE8C3705797"
       *     ]
       */
      readonly serial_numbers?: string[];
      /**
       * @description The file name of the uploaded pem file for this certificate authority.
       * @example certificate.pem
       */
      readonly certificate_chain_filename?: string;
      /**
       * @description The source specifies whether the Certificate Revocation List (CRL) is updated from
       *     either local file uploaded (LOCAL) or from url of CRL (URL).
       * @example LOCAL
       */
      readonly crl_source?: string;
      /**
       * Format: uri
       * @description The url from which to fetch the CRL for the certificate authority if crl_source is URL.
       */
      readonly crl_url?: string;
      /**
       * Format: date-time
       * @description The timestamp for when CRL was last updated.
       * @example 2017-07-21T17:32:28Z
       */
      readonly crl_updated_at?: string;
      /**
       * @description The current state of the certificate authority.
       * @example ENABLED
       */
      readonly state?: string;
    };
    /** @description `Identitypool` objects represent workload identities in Confluent Cloud.
     *
     *     The API allows you to list, create, read, update, and delete your identity pools associated
     *     with Certificate Authorities
     *
     *
     *     Related guide: [Manage Certificate Identity Pools for Granular Client Access Management](https://docs.confluent.io/cloud/current/access-management/authenticate/mtls/configure.html#step-2-create-certificate-identity-pools-for-granular-access-control).
     *
     *     ## The Certificate Identity Pools Model
     *     <SchemaDefinition schemaRef="#/components/schemas/iam.v2.CertificateIdentityPool" />
     *
     *     ## Quotas and Limits
     *     This resource is subject to the [following quotas](https://docs.confluent.io/cloud/current/quotas/overview.html):
     *
     *     | Quota | Description |
     *     | --- | --- |
     *     | `identity_pools_per_certificate_authority` | Number of Identity Pools per Certificate Authority | */
    "iam.v2.CertificateIdentityPool": {
      /**
       * @description APIVersion defines the schema version of this representation of a resource.
       * @enum {string}
       */
      readonly api_version?: "iam/v2";
      /**
       * @description Kind defines the object this REST resource represents.
       * @enum {string}
       */
      readonly kind?: "CertificateIdentityPool";
      /**
       * @description ID is the "natural identifier" for an object within its scope/namespace; it is normally unique across time but not space. That is, you can assume that the ID will not be reclaimed and reused after an object is deleted ("time"); however, it may collide with IDs for other object `kinds` or objects of the same `kind` within a different scope/namespace ("space").
       * @example dlz-f3a90de
       */
      readonly id?: string;
      metadata?: components["schemas"]["ObjectMeta"] & {
        /** @example https://api.confluent.cloud/iam/v2/certificate-identity-pools/pool-12345 */
        self?: unknown;
        /** @example crn://confluent.cloud/organization=9bb441c4-edef-46ac-8a41-c49e44a3fd9a/certificate-identity-pool=pool-12345 */
        resource_name?: unknown;
      };
      /**
       * @description The name of the `IdentityPool`.
       * @example My Identity Pool
       */
      display_name?: string;
      /**
       * @description A description of how this `IdentityPool` is used
       * @example Prod Access to Kafka clusters to Release Engineering
       */
      description?: string;
      /**
       * @description The certificate field that will be used to represent the
       *     pool's external identifier for audit logging.
       * @example UID
       */
      external_identifier?: string;
      /**
       * @description A filter expression in [Supported Common Expression Language (CEL)](https://docs.confluent.io/cloud/current/access-management/authenticate/mtls/cel-filters.html) that specifies which identities can authenticate using your certificate identity pool (see [CEL filter for mTLS](https://docs.confluent.io/cloud/current/access-management/authenticate/mtls/cel-filters.html) for more details).
       * @example C=='Canada' && O=='Confluent'
       */
      filter?: string;
      /**
       * @description Represents the federated identity associated with this pool.
       * @example pool-abc
       */
      readonly principal?: string;
      /**
       * @description The current state of the identity pool
       * @example ENABLED
       */
      readonly state?: string;
    };
    /** @description This contains the json schema used to create a Certificate Authority */
    "iam.v2.CreateCertRequest": {
      /**
       * @description APIVersion defines the schema version of this representation of a resource.
       * @enum {string}
       */
      readonly api_version?: "iam/v2";
      /**
       * @description Kind defines the object this REST resource represents.
       * @enum {string}
       */
      readonly kind?: "CreateCertRequest";
      /**
       * @description ID is the "natural identifier" for an object within its scope/namespace; it is normally unique across time but not space. That is, you can assume that the ID will not be reclaimed and reused after an object is deleted ("time"); however, it may collide with IDs for other object `kinds` or objects of the same `kind` within a different scope/namespace ("space").
       * @example dlz-f3a90de
       */
      readonly id?: string;
      metadata?: components["schemas"]["ObjectMeta"] & {
        /** @example https://api.confluent.cloud/iam/v2/create-cert-requests/ccr-12345 */
        self?: unknown;
        /** @example crn://confluent.cloud/organization=9bb441c4-edef-46ac-8a41-c49e44a3fd9a/create-cert-request=ccr-12345 */
        resource_name?: unknown;
      };
      /**
       * @description The human-readable name of the certificate authority.
       * @example My Certificate Authority
       */
      display_name?: string;
      /**
       * @description A description of the certificate authority.
       * @example Sample description text
       */
      description?: string;
      /**
       * @description The PEM encoded string containing the signing certificate chain
       *     used to validate client certs.
       * @example -----BEGIN CERTIFICATE-----
       *     MIIDdTCCAl2gAwIBAgILBAAAAAABFUtaw5QwDQYJKoZIhvcNAQEFBQAwVzELMAkGA1UEBhMCQkUx
       *     GTAXBgNVBAoTEEdsb2JhbFNpZ24gbnYtc2ExEDAOBgNVBAsTB1Jvb3QgQ0ExGzAZBgNVBAMTEkds
       *     b2JhbFNpZ24gUm9vdCBDQTAeFw05ODA5MDExMjAwMDBaFw0yODAxMjgxMjAwMDBaMFcxCzAJBgNV
       *     BAYTAkJFMRkwFwYDVQQKExBHbG9iYWxTaWduIG52LXNhMRAwDgYDVQQLEwdSb290IENBMRswGQYD
       *     VQQDExJHbG9iYWxTaWduIFJvb3QgQ0EwggEiMA0GCSqGSIb3DQEBAQUAA4IBDwAwggEKAoIBAQDa
       *     DuaZjc6j40+Kfvvxi4Mla+pIH/EqsLmVEQS98GPR4mdmzxzdzxtIK+6NiY6arymAZavpxy0Sy6sc
       *     THAHoT0KMM0VjU/43dSMUBUc71DuxC73/OlS8pF94G3VNTCOXkNz8kHp1Wrjsok6Vjk4bwY8iGlb
       *     Kk3Fp1S4bInMm/k8yuX9ifUSPJJ4ltbcdG6TRGHRjcdGsnUOhugZitVtbNV4FpWi6cgKOOvyJBNP
       *     c1STE4U6G7weNLWLBYy5d4ux2x8gkasJU26Qzns3dLlwR5EiUWMWea6xrkEmCMgZK9FGqkjWZCrX
       *     gzT/LCrBbBlDSgeF59N89iFo7+ryUp9/k5DPAgMBAAGjQjBAMA4GA1UdDwEB/wQEAwIBBjAPBgNV
       *     HRMBAf8EBTADAQH/MB0GA1UdDgQWBBRge2YaRQ2XyolQL30EzTSo//z9SzANBgkqhkiG9w0BAQUF
       *     AAOCAQEA1nPnfE920I2/7LqivjTFKDK1fPxsnCwrvQmeU79rXqoRSLblCKOzyj1hTdNGCbM+w6Dj
       *     Y1Ub8rrvrTnhQ7k4o+YviiY776BQVvnGCv04zcQLcFGUl5gE38NflNUVyRRBnMRddWQVDf9VMOyG
       *     j/8N7yy5Y0b2qvzfvGn9LhJIZJrglfCm7ymPAbEVtQwdpf5pLGkkeB6zpxxxYu7KyJesF12KwvhH
       *     hm4qxFYxldBniYUr+WymXUadDKqC5JlR3XC321Y9YeRq4VzW9v493kHMB65jUr9TU/Qr6cf9tveC
       *     X4XSQRjbgbMEHMUfpIBvFSDJ3gyICh3WZlXi/EjJKSZp4A==
       *     -----END CERTIFICATE-----
       */
      certificate_chain?: string;
      /**
       * @description The name of the certificate file.
       * @example certificate.pem
       */
      certificate_chain_filename?: string;
      /**
       * Format: uri
       * @description The url from which to fetch the CRL for the certificate authority if crl_source is URL.
       */
      crl_url?: string;
      /**
       * @description The PEM encoded string containing the CRL for this certificate authority.
       *     Defaults to this over `crl_url` if available.
       * @example -----BEGIN X509 CRL-----
       *     MIICNTCCAR0CAQEwDQYJKoZIhvcNAQELBQAwgbExCzAJBgNVBAYTAlVTMQswCQYD
       *     VQQIDAJDQTEWMBQGA1UEBwwNTW91bnRhaW4gVmlldzESMBAGA1UECgwJQ29uZmx1
       *     ZW50MRMwEQYDVQQLDApzZWN1cml0eS0xMSYwJAYDVQQDDB1tdGxzMS5zZWN1cml0
       *     eS0xLmNvbmZsdWVudC5pbzEsMCoGCSqGSIb3DQEJARYdbXRsczFAc2VjdXJpdHkt
       *     MS5jb25mbHVlbnQuaW8XDTI0MDgyNTE3NTYyNloXDTI0MTEyMzE3NTYyNlowJzAl
       *     AhQERu3UxH2q3eUglbdeQY8y0vT7rRcNMjQwODI1MTc1NTE2WqAOMAwwCgYDVR0U
       *     BAMCAQEwDQYJKoZIhvcNAQELBQADggEBAGvmflwxVAnqZbRx8njb2t6yXqeIOBaX
       *     CKhMq5CUWrWhMX/JrV5NhVfzeB2tgCCfM4J7gbKSArOKqjYpQBFL+r5eCjPBBcG4
       *     xqh1J60l5DDsiUcXQM5FtlWTBBZFxvvvWsLP4qA/0meYRY69YQNqgEQgQ65l0Ehl
       *     gIUx8WkEo82A8MDY/t91PaFHufnffPKu4CxFtcpGwuvA2n9mpxB2TsSTiV8THsfE
       *     jatuFwYgumI6t5wIWb71j/1oqQDYtbgpgUvX9gD+g7HlCC4u6Dynd0q8lsimrbf6
       *     cGf5Vs3JfMcr1kYNruT7kg4f4hc3p4CcuWtxYmHOcWNyZbi+W9Fdakg=
       *     -----END X509 CRL-----
       */
      crl_chain?: string;
    };
    /** @description This contains the form fields used to update a Certificate Authority */
    "iam.v2.UpdateCertRequest": {
      /**
       * @description APIVersion defines the schema version of this representation of a resource.
       * @enum {string}
       */
      readonly api_version?: "iam/v2";
      /**
       * @description Kind defines the object this REST resource represents.
       * @enum {string}
       */
      readonly kind?: "UpdateCertRequest";
      /**
       * @description ID is the "natural identifier" for an object within its scope/namespace; it is normally unique across time but not space. That is, you can assume that the ID will not be reclaimed and reused after an object is deleted ("time"); however, it may collide with IDs for other object `kinds` or objects of the same `kind` within a different scope/namespace ("space").
       * @example dlz-f3a90de
       */
      readonly id?: string;
      metadata?: components["schemas"]["ObjectMeta"] & {
        /** @example https://api.confluent.cloud/iam/v2/update-cert-requests/ucr-12345 */
        self?: unknown;
        /** @example crn://confluent.cloud/organization=9bb441c4-edef-46ac-8a41-c49e44a3fd9a/update-cert-request=ucr-12345 */
        resource_name?: unknown;
      };
      /**
       * @description The human-readable name of the certificate authority.
       * @example My Certificate Authority
       */
      display_name?: string;
      /**
       * @description A description of the certificate authority.
       * @example Sample description text
       */
      description?: string;
      /**
       * @description The PEM encoded string containing the signing certificate chain
       *     used to validate client certs.
       * @example -----BEGIN CERTIFICATE-----
       *     MIIDdTCCAl2gAwIBAgILBAAAAAABFUtaw5QwDQYJKoZIhvcNAQEFBQAwVzELMAkGA1UEBhMCQkUx
       *     GTAXBgNVBAoTEEdsb2JhbFNpZ24gbnYtc2ExEDAOBgNVBAsTB1Jvb3QgQ0ExGzAZBgNVBAMTEkds
       *     b2JhbFNpZ24gUm9vdCBDQTAeFw05ODA5MDExMjAwMDBaFw0yODAxMjgxMjAwMDBaMFcxCzAJBgNV
       *     BAYTAkJFMRkwFwYDVQQKExBHbG9iYWxTaWduIG52LXNhMRAwDgYDVQQLEwdSb290IENBMRswGQYD
       *     VQQDExJHbG9iYWxTaWduIFJvb3QgQ0EwggEiMA0GCSqGSIb3DQEBAQUAA4IBDwAwggEKAoIBAQDa
       *     DuaZjc6j40+Kfvvxi4Mla+pIH/EqsLmVEQS98GPR4mdmzxzdzxtIK+6NiY6arymAZavpxy0Sy6sc
       *     THAHoT0KMM0VjU/43dSMUBUc71DuxC73/OlS8pF94G3VNTCOXkNz8kHp1Wrjsok6Vjk4bwY8iGlb
       *     Kk3Fp1S4bInMm/k8yuX9ifUSPJJ4ltbcdG6TRGHRjcdGsnUOhugZitVtbNV4FpWi6cgKOOvyJBNP
       *     c1STE4U6G7weNLWLBYy5d4ux2x8gkasJU26Qzns3dLlwR5EiUWMWea6xrkEmCMgZK9FGqkjWZCrX
       *     gzT/LCrBbBlDSgeF59N89iFo7+ryUp9/k5DPAgMBAAGjQjBAMA4GA1UdDwEB/wQEAwIBBjAPBgNV
       *     HRMBAf8EBTADAQH/MB0GA1UdDgQWBBRge2YaRQ2XyolQL30EzTSo//z9SzANBgkqhkiG9w0BAQUF
       *     AAOCAQEA1nPnfE920I2/7LqivjTFKDK1fPxsnCwrvQmeU79rXqoRSLblCKOzyj1hTdNGCbM+w6Dj
       *     Y1Ub8rrvrTnhQ7k4o+YviiY776BQVvnGCv04zcQLcFGUl5gE38NflNUVyRRBnMRddWQVDf9VMOyG
       *     j/8N7yy5Y0b2qvzfvGn9LhJIZJrglfCm7ymPAbEVtQwdpf5pLGkkeB6zpxxxYu7KyJesF12KwvhH
       *     hm4qxFYxldBniYUr+WymXUadDKqC5JlR3XC321Y9YeRq4VzW9v493kHMB65jUr9TU/Qr6cf9tveC
       *     X4XSQRjbgbMEHMUfpIBvFSDJ3gyICh3WZlXi/EjJKSZp4A==
       *     -----END CERTIFICATE-----
       */
      certificate_chain?: string;
      /**
       * @description The name of the certificate file. Must be set if certificate is updated.
       * @example certificate.pem
       */
      certificate_chain_filename?: string;
      /**
       * Format: uri
       * @description The url from which to fetch the CRL for the certificate authority if crl_source is URL.
       */
      crl_url?: string;
      /**
       * @description The PEM encoded string containing the CRL for this certificate authority.
       *     Defaults to this over `crl_url` if available.
       * @example -----BEGIN X509 CRL-----
       *     MIICNTCCAR0CAQEwDQYJKoZIhvcNAQELBQAwgbExCzAJBgNVBAYTAlVTMQswCQYD
       *     VQQIDAJDQTEWMBQGA1UEBwwNTW91bnRhaW4gVmlldzESMBAGA1UECgwJQ29uZmx1
       *     ZW50MRMwEQYDVQQLDApzZWN1cml0eS0xMSYwJAYDVQQDDB1tdGxzMS5zZWN1cml0
       *     eS0xLmNvbmZsdWVudC5pbzEsMCoGCSqGSIb3DQEJARYdbXRsczFAc2VjdXJpdHkt
       *     MS5jb25mbHVlbnQuaW8XDTI0MDgyNTE3NTYyNloXDTI0MTEyMzE3NTYyNlowJzAl
       *     AhQERu3UxH2q3eUglbdeQY8y0vT7rRcNMjQwODI1MTc1NTE2WqAOMAwwCgYDVR0U
       *     BAMCAQEwDQYJKoZIhvcNAQELBQADggEBAGvmflwxVAnqZbRx8njb2t6yXqeIOBaX
       *     CKhMq5CUWrWhMX/JrV5NhVfzeB2tgCCfM4J7gbKSArOKqjYpQBFL+r5eCjPBBcG4
       *     xqh1J60l5DDsiUcXQM5FtlWTBBZFxvvvWsLP4qA/0meYRY69YQNqgEQgQ65l0Ehl
       *     gIUx8WkEo82A8MDY/t91PaFHufnffPKu4CxFtcpGwuvA2n9mpxB2TsSTiV8THsfE
       *     jatuFwYgumI6t5wIWb71j/1oqQDYtbgpgUvX9gD+g7HlCC4u6Dynd0q8lsimrbf6
       *     cGf5Vs3JfMcr1kYNruT7kg4f4hc3p4CcuWtxYmHOcWNyZbi+W9Fdakg=
       *     -----END X509 CRL-----
       */
      crl_chain?: string;
    };
    /** @description `CertificateAuthority` objects represent signing certificate authorities in Confluent Cloud.
     *
     *     The API allows you to list, create, read, update, and delete your Certificate Authority.
     *      */
    "iam.v2.CertificateAuthorityList": {
      /**
       * @description APIVersion defines the schema version of this representation of a resource.
       * @enum {string}
       */
      readonly api_version: "iam/v2";
      /**
       * @description Kind defines the object this REST resource represents.
       * @enum {string}
       */
      readonly kind: "CertificateAuthorityList";
      metadata: components["schemas"]["ListMeta"] & {
        /** @example https://api.confluent.cloud/iam/v2/certificate-authorities */
        first?: unknown;
        /** @example https://api.confluent.cloud/iam/v2/certificate-authorities?page_token=bcAOehAY8F16YD84Z1wT */
        last?: unknown;
        /** @example https://api.confluent.cloud/iam/v2/certificate-authorities?page_token=YIXRY97wWYmwzrax4dld */
        prev?: unknown;
        /** @example https://api.confluent.cloud/iam/v2/certificate-authorities?page_token=UvmDWOB1iwfAIBPj6EYb */
        next?: unknown;
      };
      /** @description A data property that contains an array of resource items. Each entry in the array is a separate resource. */
      data: (components["schemas"]["iam.v2.CertificateAuthority"] &
        Record<string, unknown>)[];
    };
    /** @description `Identitypool` objects represent workload identities in Confluent Cloud.
     *
     *     The API allows you to list, create, read, update, and delete your identity pools associated
     *     with Certificate Authorities
     *
     *
     *     Related guide: [Manage Certificate Identity Pools for Granular Client Access Management](https://docs.confluent.io/cloud/current/access-management/authenticate/mtls/configure.html#step-2-create-certificate-identity-pools-for-granular-access-control).
     *
     *     ## The Certificate Identity Pools Model
     *     <SchemaDefinition schemaRef="#/components/schemas/iam.v2.CertificateIdentityPool" />
     *
     *     ## Quotas and Limits
     *     This resource is subject to the [following quotas](https://docs.confluent.io/cloud/current/quotas/overview.html):
     *
     *     | Quota | Description |
     *     | --- | --- |
     *     | `identity_pools_per_certificate_authority` | Number of Identity Pools per Certificate Authority | */
    "iam.v2.CertificateIdentityPoolList": {
      /**
       * @description APIVersion defines the schema version of this representation of a resource.
       * @enum {string}
       */
      readonly api_version: "iam/v2";
      /**
       * @description Kind defines the object this REST resource represents.
       * @enum {string}
       */
      readonly kind: "CertificateIdentityPoolList";
      metadata: components["schemas"]["ListMeta"] & {
        /** @example https://api.confluent.cloud/iam/v2/certificate-identity-pools */
        first?: unknown;
        /** @example https://api.confluent.cloud/iam/v2/certificate-identity-pools?page_token=bcAOehAY8F16YD84Z1wT */
        last?: unknown;
        /** @example https://api.confluent.cloud/iam/v2/certificate-identity-pools?page_token=YIXRY97wWYmwzrax4dld */
        prev?: unknown;
        /** @example https://api.confluent.cloud/iam/v2/certificate-identity-pools?page_token=UvmDWOB1iwfAIBPj6EYb */
        next?: unknown;
      };
      /** @description A data property that contains an array of resource items. Each entry in the array is a separate resource. */
      data: (components["schemas"]["iam.v2.CertificateIdentityPool"] &
        Record<string, unknown>)[];
    };
    /** @description `Provider Integration` objects represent access to public cloud service provider (CSP) resources
     *     that may be accessed by Confluent resources (for example, connectors).
     *
     *     The API allows you to create, retrieve, and delete individual integrations, and also obtain a
     *     list of all your provider integrations.
     *
     *
     *     Related guide: [Provider Integration in Confluent Cloud](https://docs.confluent.io/home/overview.html).
     *
     *     ## The Integrations Model
     *     <SchemaDefinition schemaRef="#/components/schemas/pim.v1.Integration" /> */
    "pim.v1.Integration": {
      /**
       * @description APIVersion defines the schema version of this representation of a resource.
       * @enum {string}
       */
      readonly api_version?: "pim/v1";
      /**
       * @description Kind defines the object this REST resource represents.
       * @enum {string}
       */
      readonly kind?: "Integration";
      /**
       * @description ID is the "natural identifier" for an object within its scope/namespace; it is normally unique across time but not space. That is, you can assume that the ID will not be reclaimed and reused after an object is deleted ("time"); however, it may collide with IDs for other object `kinds` or objects of the same `kind` within a different scope/namespace ("space").
       * @example dlz-f3a90de
       */
      readonly id?: string;
      /**
       * @description Display name of Provider Integration.
       * @example s3_provider_integration
       */
      display_name?: string;
      /**
       * @description Cloud provider to which access is provided through provider integration.
       * @default AWS
       * @example AWS
       */
      provider: string;
      /** @description Cloud provider specific configs for provider integration */
      config?: components["schemas"]["pim.v1.AwsIntegrationConfig"];
      /** @description List of resource crns where this integration is being used. */
      readonly usages?: string[];
      /** @description The environment to which this belongs. */
      environment?: components["schemas"]["GlobalObjectReference"];
    };
    /** @description config schema for AWS cloud service provider.
     *      */
    "pim.v1.AwsIntegrationConfig": {
      /**
       * @description Amazon Resource Name (ARN) that identifies the Amazon Web Services (AWS)
       *     Identity and Access Management (IAM) role that Confluent Cloud uses to assume
       *     customer IAM role when it accesses resources in your AWS account.
       *
       * @example arn:aws:iam::000000000000:role/my-test-aws-role
       */
      readonly iam_role_arn?: string;
      /**
       * Format: uuid
       * @description Unique external ID that Confluent Cloud uses when it assumes the IAM role
       *     in your Amazon Web Services (AWS) account.
       *
       */
      readonly external_id?: string;
      /**
       * @description Amazon Resource Name (ARN) that identifies the Amazon Web Services (AWS)
       *     Identity and Access Management (IAM) role that Confluent Cloud assumes when
       *     it accesses resources in your AWS account.
       *
       * @example arn:aws:iam::000000000000:role/my-test-aws-role
       */
      customer_iam_role_arn?: string;
      /**
       * @description Cloud provider specific config to which access is provided through provider integration. (enum property replaced by openapi-typescript)
       * @enum {string}
       */
      kind: "AwsIntegrationConfig";
    };
    /** @description `Provider Integration` objects represent access to public cloud service provider (CSP) resources
     *     that may be accessed by Confluent resources (for example, connectors).
     *
     *     The API allows you to create, retrieve, and delete individual integrations, and also obtain a
     *     list of all your provider integrations.
     *
     *
     *     Related guide: [Provider Integration in Confluent Cloud](https://docs.confluent.io/home/overview.html).
     *
     *     ## The Integrations Model
     *     <SchemaDefinition schemaRef="#/components/schemas/pim.v1.Integration" /> */
    "pim.v1.IntegrationList": {
      /**
       * @description APIVersion defines the schema version of this representation of a resource.
       * @enum {string}
       */
      readonly api_version: "pim/v1";
      /**
       * @description Kind defines the object this REST resource represents.
       * @enum {string}
       */
      readonly kind: "IntegrationList";
      metadata: components["schemas"]["ListMeta"] & {
        /** @example https://api.confluent.cloud/pim/v1/integrations */
        first?: unknown;
        /** @example https://api.confluent.cloud/pim/v1/integrations?page_token=bcAOehAY8F16YD84Z1wT */
        last?: unknown;
        /** @example https://api.confluent.cloud/pim/v1/integrations?page_token=YIXRY97wWYmwzrax4dld */
        prev?: unknown;
        /** @example https://api.confluent.cloud/pim/v1/integrations?page_token=UvmDWOB1iwfAIBPj6EYb */
        next?: unknown;
      };
      /** @description A data property that contains an array of resource items. Each entry in the array is a separate resource. */
      data: (components["schemas"]["pim.v1.Integration"] &
        Record<string, unknown>)[];
    };
    /** @description FlinkArtifact objects represent Flink Artifacts on Confluent Cloud.
     *
     *
     *     ## The Flink Artifacts Model
     *     <SchemaDefinition schemaRef="#/components/schemas/artifact.v1.FlinkArtifact" /> */
    "artifact.v1.FlinkArtifact": {
      /**
       * @description APIVersion defines the schema version of this representation of a resource.
       * @enum {string}
       */
      readonly api_version?: "artifact/v1";
      /**
       * @description Kind defines the object this REST resource represents.
       * @enum {string}
       */
      readonly kind?: "FlinkArtifact";
      /**
       * @description ID is the "natural identifier" for an object within its scope/namespace; it is normally unique across time but not space. That is, you can assume that the ID will not be reclaimed and reused after an object is deleted ("time"); however, it may collide with IDs for other object `kinds` or objects of the same `kind` within a different scope/namespace ("space").
       * @example dlz-f3a90de
       */
      readonly id?: string;
      metadata?: components["schemas"]["ObjectMeta"] & {
        /** @example https://api.confluent.cloud/artifact/v1/flink-artifacts/fa-12345 */
        self?: unknown;
        /** @example crn://confluent.cloud/organization=9bb441c4-edef-46ac-8a41-c49e44a3fd9a/flink-artifact=fa-12345 */
        resource_name?: unknown;
      };
      /**
       * @description Cloud provider where the Flink Artifact archive is uploaded.
       * @example AWS
       */
      cloud?: string;
      /**
       * @description The Cloud provider region the Flink Artifact archive is uploaded.
       * @example us-east-1
       */
      region?: string;
      /**
       * @description Environment the Flink Artifact belongs to.
       * @example env-00000
       */
      environment?: string;
      /** @description Unique name of the Flink Artifact per cloud, region, environment scope. */
      display_name?: string;
      /**
       * @deprecated
       * @description Java class or alias for the artifact as provided by developer. Deprecated
       * @example io.confluent.example.SumScalarFunction
       */
      class?: string;
      /**
       * @description Archive format of the Flink Artifact.
       * @example JAR
       */
      content_format?: string;
      /** @description Description of the Flink Artifact. */
      description?: string;
      /** @description Documentation link of the Flink Artifact. */
      documentation_link?: string;
      /**
       * @description Runtime language of the Flink Artifact.
       * @default JAVA
       * @example JAVA
       */
      runtime_language: string;
      /** @description Versions associated with this Flink Artifact. */
      versions?: components["schemas"]["artifact.v1.FlinkArtifactVersion"][];
    };
    /** @description Request a presigned upload URL for new Flink Artifact. Note that
     *     the URL policy expires in one hour. If the policy expires, you can request
     *     a new presigned upload URL.
     *
     *
     *     ## The Presigned Urls Model
     *     <SchemaDefinition schemaRef="#/components/schemas/artifact.v1.PresignedUrl" /> */
    "artifact.v1.PresignedUrl": {
      /**
       * @description APIVersion defines the schema version of this representation of a resource.
       * @enum {string}
       */
      readonly api_version?: "artifact/v1";
      /**
       * @description Kind defines the object this REST resource represents.
       * @enum {string}
       */
      readonly kind?: "PresignedUrl";
      /**
       * @description Content format of the Flink Artifact archive.
       * @example JAR
       */
      readonly content_format?: string;
      /**
       * @description Cloud provider where the Flink Artifact archive is uploaded.
       * @example AWS
       */
      readonly cloud?: string;
      /**
       * @description The Cloud provider region the Flink Artifact archive is uploaded.
       * @example us-east-1
       */
      readonly region?: string;
      /**
       * @description The Environment the uploaded Flink Artifact belongs to.
       * @example env-00000
       */
      readonly environment?: string;
      /**
       * @description Unique identifier of this upload.
       * @example e53bb2e8-8de3-49fa-9fb1-4e3fd9a16b66
       */
      readonly upload_id?: string;
      /**
       * Format: uri
       * @description Upload URL for the Flink Artifact archive.
       * @example https://confluent-flink-artifacts-stag-us-west-2.s3.dualstack.us-west-2.amazonaws.com/
       */
      readonly upload_url?: string;
      /**
       * @description Upload form data of the Flink Artifact. All values should be strings.
       * @example {
       *       "bucket": "confluent-flink-artifacts-stag-us-west-2",
       *       "key": "staging/flink-artifact/2f37f0b6-f8da-4e8b-bc5f-282ebb0511be/flink-e53bb2e8-8de3-49fa-9fb1-4e3fd9a16b66/artifact.jar",
       *       "policy": "string",
       *       "x-amz-algorithm": "AWS4-HMAC-SHA256",
       *       "x-amz-credential": "string",
       *       "x-amz-date": "20230725T013857Z",
       *       "x-amz-security-token": "string",
       *       "x-amz-signature": "string"
       *     }
       */
      readonly upload_form_data?: Record<string, unknown>;
    };
    /** @description Version of the Flink Artifact
     *      */
    "artifact.v1.FlinkArtifactVersion": {
      /**
       * @description Version id of the Flink Artifact.
       * @example cfa-ver-001
       */
      version: string;
      /** @description Release Notes of the Flink Artifact version. */
      release_notes?: string;
      /** @description Flag to specify stability of the version */
      is_beta?: boolean;
      /** @description The Flink Artifact this version belongs to. */
      artifact_id: components["schemas"]["artifact.v1.FlinkArtifact"];
      /** @description Upload source of the Flink Artifact Version. */
      upload_source: components["schemas"]["artifact.v1.UploadSource.PresignedUrl"];
    };
    /** @description Request schema of the presigned upload URL.
     *      */
    "artifact.v1.PresignedUrlRequest": {
      /**
       * @description APIVersion defines the schema version of this representation of a resource.
       * @enum {string}
       */
      readonly api_version?: "artifact/v1";
      /**
       * @description Kind defines the object this REST resource represents.
       * @enum {string}
       */
      readonly kind?: "PresignedUrlRequest";
      /**
       * @description ID is the "natural identifier" for an object within its scope/namespace; it is normally unique across time but not space. That is, you can assume that the ID will not be reclaimed and reused after an object is deleted ("time"); however, it may collide with IDs for other object `kinds` or objects of the same `kind` within a different scope/namespace ("space").
       * @example dlz-f3a90de
       */
      readonly id?: string;
      metadata?: components["schemas"]["ObjectMeta"] & {
        /** @example https://api.confluent.cloud/artifact/v1/presigned-url-requests/pur-12345 */
        self?: unknown;
        /** @example crn://confluent.cloud/organization=9bb441c4-edef-46ac-8a41-c49e44a3fd9a/presigned-url-request=pur-12345 */
        resource_name?: unknown;
      };
      /**
       * @description Archive format of the Flink Artifact.
       * @example JAR
       */
      content_format?: string;
      /**
       * @description Cloud provider where the Flink Artifact archive is uploaded.
       * @example AWS
       */
      cloud?: string;
      /**
       * @description The Cloud provider region the Flink Artifact archive is uploaded.
       * @example us-east-1
       */
      region?: string;
      /**
       * @description The Environment the uploaded Flink Artifact belongs to.
       * @example env-00000
       */
      environment?: string;
    };
    /** @description Request a presigned upload URL for new Flink Artifact. Note that
     *     the URL policy expires in one hour. If the policy expires, you can request
     *     a new presigned upload URL.
     *
     *
     *     ## The Presigned Urls Model
     *     <SchemaDefinition schemaRef="#/components/schemas/artifact.v1.PresignedUrl" /> */
    "artifact.v1.UploadSource.PresignedUrl": {
      /**
       * @description APIVersion defines the schema version of this representation of a resource.
       * @enum {string}
       */
      readonly api_version?: "artifact.v1/UploadSource";
      /**
       * @description Kind defines the object this REST resource represents.
       * @enum {string}
       */
      readonly kind?: "PresignedUrl";
      /**
       * @description ID is the "natural identifier" for an object within its scope/namespace; it is normally unique across time but not space. That is, you can assume that the ID will not be reclaimed and reused after an object is deleted ("time"); however, it may collide with IDs for other object `kinds` or objects of the same `kind` within a different scope/namespace ("space").
       * @example dlz-f3a90de
       */
      readonly id?: string;
      metadata?: components["schemas"]["ObjectMeta"] & {
        /** @example https://api.confluent.cloud/artifact.v1/UploadSource/presigned-urls/pu-12345 */
        self?: unknown;
        /** @example crn://confluent.cloud/organization=9bb441c4-edef-46ac-8a41-c49e44a3fd9a/presigned-url=pu-12345 */
        resource_name?: unknown;
      };
      /**
       * @description Location of the Flink Artifact source.
       *      (enum property replaced by openapi-typescript)
       * @enum {string}
       */
      location: "PRESIGNED_URL_LOCATION";
      /**
       * @description Upload ID returned by the `/presigned-upload-url` API. This field returns an empty string in all responses.
       * @example e53bb2e8-8de3-49fa-9fb1-4e3fd9a16b66
       */
      upload_id?: string;
    };
    /** @description FlinkArtifact objects represent Flink Artifacts on Confluent Cloud.
     *
     *
     *     ## The Flink Artifacts Model
     *     <SchemaDefinition schemaRef="#/components/schemas/artifact.v1.FlinkArtifact" /> */
    "artifact.v1.FlinkArtifactList": {
      /**
       * @description APIVersion defines the schema version of this representation of a resource.
       * @enum {string}
       */
      readonly api_version: "artifact/v1";
      /**
       * @description Kind defines the object this REST resource represents.
       * @enum {string}
       */
      readonly kind: "FlinkArtifactList";
      metadata: components["schemas"]["ListMeta"] & {
        /** @example https://api.confluent.cloud/artifact/v1/flink-artifacts */
        first?: unknown;
        /** @example https://api.confluent.cloud/artifact/v1/flink-artifacts?page_token=bcAOehAY8F16YD84Z1wT */
        last?: unknown;
        /** @example https://api.confluent.cloud/artifact/v1/flink-artifacts?page_token=YIXRY97wWYmwzrax4dld */
        prev?: unknown;
        /** @example https://api.confluent.cloud/artifact/v1/flink-artifacts?page_token=UvmDWOB1iwfAIBPj6EYb */
        next?: unknown;
      };
      /** @description A data property that contains an array of resource items. Each entry in the array is a separate resource. */
      data: (components["schemas"]["artifact.v1.FlinkArtifact"] &
        Record<string, unknown>)[];
    };
    /** @description A Gateway represents a slice of traffic capacity in a region that is reserved for a customer.
     *
     *
     *     ## The Gateways Model
     *     <SchemaDefinition schemaRef="#/components/schemas/networking.v1.Gateway" />
     *
     *     ## Quotas and Limits
     *     This resource is subject to the [following quotas](https://docs.confluent.io/cloud/current/quotas/overview.html):
     *
     *     | Quota | Description |
     *     | --- | --- |
     *     | `gateways_per_region_per_environment` | Number of Gateways per region per environment | */
    "networking.v1.Gateway": {
      /**
       * @description APIVersion defines the schema version of this representation of a resource.
       * @enum {string}
       */
      readonly api_version?: "networking/v1";
      /**
       * @description Kind defines the object this REST resource represents.
       * @enum {string}
       */
      readonly kind?: "Gateway";
      /**
       * @description ID is the "natural identifier" for an object within its scope/namespace; it is normally unique across time but not space. That is, you can assume that the ID will not be reclaimed and reused after an object is deleted ("time"); however, it may collide with IDs for other object `kinds` or objects of the same `kind` within a different scope/namespace ("space").
       * @example dlz-f3a90de
       */
      readonly id?: string;
      metadata?: components["schemas"]["ObjectMeta"] & {
        /** @example https://api.confluent.cloud/networking/v1/gateways/gw-12345 */
        self?: unknown;
        /** @example crn://confluent.cloud/organization=9bb441c4-edef-46ac-8a41-c49e44a3fd9a/environment=env-abc123/gateway=gw-12345 */
        resource_name?: unknown;
      };
      spec?: components["schemas"]["networking.v1.GatewaySpec"];
      status?: components["schemas"]["networking.v1.GatewayStatus"];
    };
    /** @description The status of the Gateway */
    "networking.v1.GatewayStatus": {
      /**
       * @description The lifecycle phase of the gateway:
       *
       *       CREATED: gateway exists without an Access Point.
       *
       *       PROVISIONING: gateway provisioning is in progress;
       *
       *       READY:  gateway is ready;
       *
       *       FAILED: gateway is in a failed state;
       *
       *       DEPROVISIONING: gateway deprovisioning is in progress;
       *
       * @example READY
       */
      readonly phase: string;
      /** @description Error code if gateway is in a failed state. May be used for programmatic error checking. */
      readonly error_code?: string;
      /** @description Displayable error message if gateway is in a failed state */
      readonly error_message?: string;
      /** @description Gateway type specific status. */
      readonly cloud_gateway?:
        | components["schemas"]["networking.v1.AwsEgressPrivateLinkGatewayStatus"]
        | components["schemas"]["networking.v1.AwsPrivateNetworkInterfaceGatewayStatus"]
        | components["schemas"]["networking.v1.AzureEgressPrivateLinkGatewayStatus"]
        | components["schemas"]["networking.v1.GcpPeeringGatewayStatus"]
        | components["schemas"]["networking.v1.GcpEgressPrivateServiceConnectGatewayStatus"];
    };
    /** @description AWS Private Network Interface Gateway details from AWS. */
    "networking.v1.AwsPrivateNetworkInterfaceGatewaySpec": {
      /**
       * @description AWS Private Network Interface Gateway Spec kind type. (enum property replaced by openapi-typescript)
       * @enum {string}
       */
      kind: "AwsPrivateNetworkInterfaceGatewaySpec";
      /** @description AWS region of the Private Network Interface Gateway. */
      region: string;
      /** @description AWS availability zone ids of the Private Network Interface Gateway. */
      zones: string[];
    };
    /** @description AWS Peering Gateway details from AWS. */
    "networking.v1.AwsPeeringGatewaySpec": {
      /**
       * @description AWS Peering Gateway Spec kind type. (enum property replaced by openapi-typescript)
       * @enum {string}
       */
      kind: "AwsPeeringGatewaySpec";
      /** @description AWS region of the Peering Gateway. */
      region: string;
    };
    /** @description Azure Peering Gateway details from Azure. */
    "networking.v1.AzurePeeringGatewaySpec": {
      /**
       * @description Azure Peering Gateway Spec kind type. (enum property replaced by openapi-typescript)
       * @enum {string}
       */
      kind: "AzurePeeringGatewaySpec";
      /** @description Azure region of the Peering Gateway. */
      region: string;
    };
    /** @description AWS Egress Private Link Gateway details from AWS. */
    "networking.v1.AwsEgressPrivateLinkGatewaySpec": {
      /**
       * @description AWS Egress Private Link Gateway Spec kind type. (enum property replaced by openapi-typescript)
       * @enum {string}
       */
      kind: "AwsEgressPrivateLinkGatewaySpec";
      /** @description AWS region of the Egress Private Link Gateway. */
      region: string;
    };
    /** @description Azure Egress Private Link Gateway details from Azure. */
    "networking.v1.AzureEgressPrivateLinkGatewaySpec": {
      /**
       * @description Azure Egress Private Link Gateway Spec kind type. (enum property replaced by openapi-typescript)
       * @enum {string}
       */
      kind: "AzureEgressPrivateLinkGatewaySpec";
      /** @description Azure region of the Egress Private Link Gateway. */
      region: string;
    };
    /** @description GCP Peering Gateway details. */
    "networking.v1.GcpPeeringGatewaySpec": {
      /**
       * @description GCP Peering Gateway Spec kind type. (enum property replaced by openapi-typescript)
       * @enum {string}
       */
      kind: "GcpPeeringGatewaySpec";
      /** @description GCP region of the Peering Gateway. */
      region: string;
    };
    /** @description GCP Private Service Connect Gateway details from GCP. */
    "networking.v1.GcpEgressPrivateServiceConnectGatewaySpec": {
      /**
       * @description GCP Private Service Connect Gateway Spec kind type. (enum property replaced by openapi-typescript)
       * @enum {string}
       */
      kind: "GcpEgressPrivateServiceConnectGatewaySpec";
      /** @description GCP region of the Egress Private Service Connect Gateway. */
      region: string;
    };
    /** @description AWS Private Network Interface Gateway details from AWS. */
    "networking.v1.AwsPrivateNetworkInterfaceGatewayStatus": {
      /**
       * @description AWS Private Network Interface Gateway Status kind type. (enum property replaced by openapi-typescript)
       * @enum {string}
       */
      kind: "AwsPrivateNetworkInterfaceGatewayStatus";
      /**
       * @description The AWS account ID associated with the Private Network Interface Gateway.
       * @example 000000000000
       */
      readonly account?: string;
    };
    /** @description AWS Egress Private Link Gateway details from AWS. */
    "networking.v1.AwsEgressPrivateLinkGatewayStatus": {
      /**
       * @description AWS Egress Private Link Gateway Status kind type. (enum property replaced by openapi-typescript)
       * @enum {string}
       */
      kind: "AwsEgressPrivateLinkGatewayStatus";
      /**
       * @description The principal ARN used by the AWS Egress Private Link Gateway.
       * @example arn:aws:iam::123456789012:cc-tenant-1-role
       */
      readonly principal_arn?: string;
    };
    /** @description Azure Egress Private Link Gateway details from Azure. */
    "networking.v1.AzureEgressPrivateLinkGatewayStatus": {
      /**
       * @description Azure Egress Private Link Gateway Status kind type. (enum property replaced by openapi-typescript)
       * @enum {string}
       */
      kind: "AzureEgressPrivateLinkGatewayStatus";
      /**
       * @description The Azure Subscription ID associated with the Confluent Cloud VPC.
       * @example 00000000-0000-0000-0000-000000000000
       */
      readonly subscription?: string;
    };
    /** @description GCP Peering Gateway details from GCP. */
    "networking.v1.GcpPeeringGatewayStatus": {
      /**
       * @description GCP Peering Gateway Status kind type. (enum property replaced by openapi-typescript)
       * @enum {string}
       */
      kind: "GcpPeeringGatewayStatus";
      /**
       * @description The IAM principal email used by the GCP Peering Gateway.
       * @example my-service-account@my-project.iam.gserviceaccount.com
       */
      readonly iam_principal?: string;
    };
    /** @description GCP Private Service Connect Gateway details from GCP. */
    "networking.v1.GcpEgressPrivateServiceConnectGatewayStatus": {
      /**
       * @description GCP Private Service Connect Gateway Status kind type. (enum property replaced by openapi-typescript)
       * @enum {string}
       */
      kind: "GcpEgressPrivateServiceConnectGatewayStatus";
      /**
       * @description The GCP project used by the GCP Private Service Connect Gateway.
       * @example proj-tenant-1
       */
      readonly project?: string;
    };
    /** @description A Gateway represents a slice of traffic capacity in a region that is reserved for a customer.
     *
     *
     *     ## The Gateways Model
     *     <SchemaDefinition schemaRef="#/components/schemas/networking.v1.Gateway" />
     *
     *     ## Quotas and Limits
     *     This resource is subject to the [following quotas](https://docs.confluent.io/cloud/current/quotas/overview.html):
     *
     *     | Quota | Description |
     *     | --- | --- |
     *     | `gateways_per_region_per_environment` | Number of Gateways per region per environment | */
    "networking.v1.GatewayList": {
      /**
       * @description APIVersion defines the schema version of this representation of a resource.
       * @enum {string}
       */
      readonly api_version: "networking/v1";
      /**
       * @description Kind defines the object this REST resource represents.
       * @enum {string}
       */
      readonly kind: "GatewayList";
      metadata: components["schemas"]["ListMeta"] & {
        /** @example https://api.confluent.cloud/networking/v1/gateways */
        first?: unknown;
        /** @example https://api.confluent.cloud/networking/v1/gateways?page_token=bcAOehAY8F16YD84Z1wT */
        last?: unknown;
        /** @example https://api.confluent.cloud/networking/v1/gateways?page_token=YIXRY97wWYmwzrax4dld */
        prev?: unknown;
        /** @example https://api.confluent.cloud/networking/v1/gateways?page_token=UvmDWOB1iwfAIBPj6EYb */
        next?: unknown;
      };
      /** @description A data property that contains an array of resource items. Each entry in the array is a separate resource. */
      data: (components["schemas"]["networking.v1.Gateway"] & {
        spec: Record<string, unknown>;
      })[];
    };
    /** @description The desired state of the Gateway */
    "networking.v1.GatewaySpec": {
      /**
       * @description The name of the gateway.
       * @example prod-gateway
       */
      display_name?: string;
      /** @description Gateway type specific configuration. Please note that Peering configs are not supported in Create requests. */
      config?:
        | components["schemas"]["networking.v1.AwsEgressPrivateLinkGatewaySpec"]
        | components["schemas"]["networking.v1.AwsPrivateNetworkInterfaceGatewaySpec"]
        | components["schemas"]["networking.v1.AwsPeeringGatewaySpec"]
        | components["schemas"]["networking.v1.AzurePeeringGatewaySpec"]
        | components["schemas"]["networking.v1.AzureEgressPrivateLinkGatewaySpec"]
        | components["schemas"]["networking.v1.GcpPeeringGatewaySpec"]
        | components["schemas"]["networking.v1.GcpEgressPrivateServiceConnectGatewaySpec"];
      /** @description The environment to which this belongs. */
      environment?: components["schemas"]["ObjectReference"];
    };
    /** @description CustomCodeLogging objects represent Custom Code Logging on Confluent Cloud.
     *     The API allows you to list, create, read, update, and delete your Custom Code Logging.
     *
     *
     *     ## The Custom Code Loggings Model
     *     <SchemaDefinition schemaRef="#/components/schemas/ccl.v1.CustomCodeLogging" /> */
    "ccl.v1.CustomCodeLogging": {
      /**
       * @description APIVersion defines the schema version of this representation of a resource.
       * @enum {string}
       */
      readonly api_version?: "ccl/v1";
      /**
       * @description Kind defines the object this REST resource represents.
       * @enum {string}
       */
      readonly kind?: "CustomCodeLogging";
      /**
       * @description ID is the "natural identifier" for an object within its scope/namespace; it is normally unique across time but not space. That is, you can assume that the ID will not be reclaimed and reused after an object is deleted ("time"); however, it may collide with IDs for other object `kinds` or objects of the same `kind` within a different scope/namespace ("space").
       * @example dlz-f3a90de
       */
      readonly id?: string;
      metadata?: components["schemas"]["ObjectMeta"] & {
        /** @example https://api.confluent.cloud/ccl/v1/custom-code-loggings/ccl-12345 */
        self?: unknown;
        /** @example crn://confluent.cloud/organization=9bb441c4-edef-46ac-8a41-c49e44a3fd9a/custom-code-logging=ccl-12345 */
        resource_name?: unknown;
      };
      /**
       * @description Cloud provider where the Custom Code Logging is sent.
       * @example AWS
       */
      cloud?: string;
      /**
       * @description The Cloud provider region the Custom Code Logging is sent.
       * @example us-west-2
       */
      region?: string;
      /** @description Destination Settings of the Custom Code Logging. */
      destination_settings?: components["schemas"]["ccl.v1.KafkaDestinationSettings"];
      /** @description The environment to which this belongs. */
      environment?: components["schemas"]["EnvScopedObjectReference"];
    };
    /** @description Kafka Destination Settings of the Custom Code Logging.
     *      */
    "ccl.v1.KafkaDestinationSettings": {
      /**
       * @description The destination where Custom Code Logging is sent. (enum property replaced by openapi-typescript)
       * @enum {string}
       */
      kind: "Kafka";
      /**
       * @description The kafka cluster id where Custom Code Logging is sent.
       * @example lkc-123
       */
      cluster_id: string;
      /**
       * @description The kafka topic where Custom Code Logging is sent.
       * @example topic-123
       */
      topic: string;
      /**
       * @description Minimum log level for Custom Code Logging.
       * @default INFO
       * @example INFO
       */
      log_level: string;
    };
    /** @description CustomCodeLogging objects represent Custom Code Logging on Confluent Cloud.
     *     The API allows you to list, create, read, update, and delete your Custom Code Logging.
     *
     *
     *     ## The Custom Code Loggings Model
     *     <SchemaDefinition schemaRef="#/components/schemas/ccl.v1.CustomCodeLogging" /> */
    "ccl.v1.CustomCodeLoggingList": {
      /**
       * @description APIVersion defines the schema version of this representation of a resource.
       * @enum {string}
       */
      readonly api_version: "ccl/v1";
      /**
       * @description Kind defines the object this REST resource represents.
       * @enum {string}
       */
      readonly kind: "CustomCodeLoggingList";
      metadata: components["schemas"]["ListMeta"] & {
        /** @example https://api.confluent.cloud/ccl/v1/custom-code-loggings */
        first?: unknown;
        /** @example https://api.confluent.cloud/ccl/v1/custom-code-loggings?page_token=bcAOehAY8F16YD84Z1wT */
        last?: unknown;
        /** @example https://api.confluent.cloud/ccl/v1/custom-code-loggings?page_token=YIXRY97wWYmwzrax4dld */
        prev?: unknown;
        /** @example https://api.confluent.cloud/ccl/v1/custom-code-loggings?page_token=UvmDWOB1iwfAIBPj6EYb */
        next?: unknown;
      };
      /** @description A data property that contains an array of resource items. Each entry in the array is a separate resource. */
      data: (components["schemas"]["ccl.v1.CustomCodeLogging"] &
        Record<string, unknown>)[];
    };
    /** @description `Region` objects represent cloud provider regions where Tableflow can be enabled.
     *     This API allows you to list all supported Tableflow regions.
     *
     *
     *     ## The Regions Model
     *     <SchemaDefinition schemaRef="#/components/schemas/tableflow.v1.Region" /> */
    "tableflow.v1.Region": {
      /**
       * @description APIVersion defines the schema version of this representation of a resource.
       * @enum {string}
       */
      readonly api_version?: "tableflow/v1";
      /**
       * @description Kind defines the object this REST resource represents.
       * @enum {string}
       */
      readonly kind?: "Region";
      /**
       * @description ID is the "natural identifier" for an object within its scope/namespace; it is normally unique across time but not space. That is, you can assume that the ID will not be reclaimed and reused after an object is deleted ("time"); however, it may collide with IDs for other object `kinds` or objects of the same `kind` within a different scope/namespace ("space").
       * @example dlz-f3a90de
       */
      readonly id?: string;
      metadata?: components["schemas"]["ObjectMeta"] & {
        /** @example https://api.confluent.cloud/tableflow/v1/regions/r-12345 */
        self?: unknown;
        /** @example crn://confluent.cloud/organization=9bb441c4-edef-46ac-8a41-c49e44a3fd9a/region=r-12345 */
        resource_name?: unknown;
      };
      /**
       * @description The cloud service provider that hosts the region.
       * @example AWS
       */
      readonly cloud?: string;
      /**
       * @description The cloud service provider region.
       * @example us-east-2
       */
      readonly region?: string;
    };
    /** @description A Tableflow Topic represents configuration related to a Tableflow enabled kafka topic
     *
     *
     *     ## The Tableflow Topics Model
     *     <SchemaDefinition schemaRef="#/components/schemas/tableflow.v1.TableflowTopic" /> */
    "tableflow.v1.TableflowTopic": {
      /**
       * @description APIVersion defines the schema version of this representation of a resource.
       * @enum {string}
       */
      readonly api_version?: "tableflow/v1";
      /**
       * @description Kind defines the object this REST resource represents.
       * @enum {string}
       */
      readonly kind?: "TableflowTopic";
      metadata?: components["schemas"]["ObjectMeta"] & {
        /** @example https://api.confluent.cloud/tableflow/v1/tableflow-topics/tt-12345 */
        self?: unknown;
        /** @example crn://confluent.cloud/organization=9bb441c4-edef-46ac-8a41-c49e44a3fd9a/tableflow-topic=tt-12345 */
        resource_name?: unknown;
      };
      spec?: components["schemas"]["tableflow.v1.TableflowTopicSpec"];
      status?: components["schemas"]["tableflow.v1.TableflowTopicStatus"];
    };
    /** @description The status of the Tableflow Topic */
    "tableflow.v1.TableflowTopicStatus": {
      /**
       * @description The lifecycle phase of the Tableflow:
       *
       *       PENDING: Tableflow setup is pending;
       *
       *       RUNNING: Tableflow is currently running;
       *
       *       FAILED: Tableflow failed
       *
       * @example PENDING
       */
      readonly phase?: string;
      /**
       * @description Displayable error message if Tableflow topic is in an error state
       * @example Could not enable catalog integration
       */
      readonly error_message?: string;
    };
    /** @description A Catalog Integration represents configuration related to a catalog integration
     *
     *
     *     ## The Catalog Integrations Model
     *     <SchemaDefinition schemaRef="#/components/schemas/tableflow.v1.CatalogIntegration" /> */
    "tableflow.v1.CatalogIntegration": {
      /**
       * @description APIVersion defines the schema version of this representation of a resource.
       * @enum {string}
       */
      readonly api_version?: "tableflow/v1";
      /**
       * @description Kind defines the object this REST resource represents.
       * @enum {string}
       */
      readonly kind?: "CatalogIntegration";
      /**
       * @description ID is the "natural identifier" for an object within its scope/namespace; it is normally unique across time but not space. That is, you can assume that the ID will not be reclaimed and reused after an object is deleted ("time"); however, it may collide with IDs for other object `kinds` or objects of the same `kind` within a different scope/namespace ("space").
       * @example dlz-f3a90de
       */
      readonly id?: string;
      metadata?: components["schemas"]["ObjectMeta"] & {
        /** @example https://api.confluent.cloud/tableflow/v1/catalog-integrations/tci-12345 */
        self?: unknown;
        /** @example crn://confluent.cloud/organization=9bb441c4-edef-46ac-8a41-c49e44a3fd9a/catalog-integration=tci-12345 */
        resource_name?: unknown;
      };
      spec?: components["schemas"]["tableflow.v1.CatalogIntegrationSpec"];
      status?: components["schemas"]["tableflow.v1.CatalogIntegrationStatus"];
    };
    /** @description The status of the Catalog Integration */
    "tableflow.v1.CatalogIntegrationStatus": {
      /**
       * @description The lifecycle phase of the catalog integration:
       *
       *       PENDING: sync to catalog integration is pending;
       *
       *       CONNECTED: catalog integration is connected and syncing;
       *
       *       FAILED: catalog integration failed.
       *
       * @example CONNECTED
       */
      readonly phase?: string;
      /**
       * @description Displayable error message if catalog integration is in a failed state.
       * @example Could not enable catalog integration
       */
      readonly error_message?: string;
      /** @description The date and time at which the catalog was last synced. It is represented in RFC3339 format and is in UTC.
       *      */
      readonly last_sync_at?: string;
    };
    /** @description The configs for the Tableflow enabled topic */
    "tableflow.v1.TableFlowTopicConfigsSpec": {
      /**
       * @description This flag determines whether to enable compaction for the Tableflow enabled topic.
       * @example true
       */
      readonly enable_compaction?: boolean;
      /**
       * @description This flag determines whether to enable partitioning for the Tableflow enabled topic.
       * @example true
       */
      readonly enable_partitioning?: boolean;
      /**
       * Format: int64
       * @description The maximum age, in milliseconds, of snapshots (for Iceberg) or versions (for Delta)
       *     to retain in the table for the Tableflow-enabled topic (snapshot/version expiration)
       *
       *     The default value is "604800000" milliseconds (equivalent to 7 days).
       *
       *     The minimum allowed value is "86400000" milliseconds (equivalent to 24 hours).
       *
       * @example 7776000000
       */
      retention_ms?: string;
      /**
       * @description The strategy to handle record failures in the Tableflow enabled topic during materialization.
       *
       *     For `SKIP`, we skip the bad records and move to the next record,
       *
       *     and for `SUSPEND`, we suspend the materialization of the topic.
       *
       * @default SUSPEND
       */
      record_failure_strategy: string;
    };
    /** @description The Tableflow storage config for BYOB enabled topic in AWS */
    "tableflow.v1.ByobAwsSpec": {
      /**
       * @description The storage type
       *      (enum property replaced by openapi-typescript)
       * @enum {string}
       */
      kind: "ByobAws";
      /**
       * @description Bucket name
       * @example bucket_1
       */
      bucket_name: string;
      /**
       * @description Bucket region
       * @example us-east-1
       */
      readonly bucket_region?: string;
      /**
       * @description The provider integration id
       * @example cspi-stgce89r7
       */
      provider_integration_id: string;
    };
    /** @description The storage config for confluent managed Tableflow enabled topic. */
    "tableflow.v1.ManagedStorageSpec": {
      /**
       * @description The storage type.
       *      (enum property replaced by openapi-typescript)
       * @enum {string}
       */
      kind: "Managed";
    };
    /** @description The catalog integration Glue connection config. */
    "tableflow.v1.CatalogIntegrationAwsGlueSpec": {
      /**
       * @description The type of the catalog integration. (enum property replaced by openapi-typescript)
       * @enum {string}
       */
      kind: "AwsGlue";
      /**
       * @description The provider integration id.
       * @example cspi-stgce89r7
       */
      provider_integration_id: string;
    };
    /** @description The catalog integration connection config for Snowflake Open Catalog. */
    "tableflow.v1.CatalogIntegrationSnowflakeSpec": {
      /**
       * @description The type of the catalog integration. (enum property replaced by openapi-typescript)
       * @enum {string}
       */
      kind: "Snowflake";
      /**
       * @description The catalog integration connection endpoint for Snowflake Open Catalog.
       *
       * @example https://vuser1_polaris.snowflakecomputing.com/
       */
      endpoint: string;
      /** @description The client ID of the catalog integration. */
      client_id: string;
      /** @description The client secret of the catalog integration. */
      client_secret: string;
      /** @description Warehouse name of the Snowflake Open Catalog. */
      warehouse: string;
      /** @description Allowed scope of the Snowflake Open Catalog. */
      allowed_scope: string;
    };
    /** @description The catalog integration connection config for Snowflake Open Catalog (update operations). */
    "tableflow.v1.CatalogIntegrationSnowflakeUpdateSpec": {
      /**
       * @description The type of the catalog integration. (enum property replaced by openapi-typescript)
       * @enum {string}
       */
      kind: "Snowflake";
      /**
       * @description The catalog integration connection endpoint for Snowflake Open Catalog.
       * @example https://vuser1_polaris.snowflakecomputing.com/
       */
      endpoint?: string;
      /** @description The client ID of the catalog integration. */
      client_id?: string;
      /** @description The client secret of the catalog integration. */
      client_secret?: string;
      /** @description Warehouse name of the Snowflake Open Catalog. */
      warehouse?: string;
      /** @description Allowed scope of the Snowflake Open Catalog. */
      allowed_scope?: string;
    };
    /** @description The catalog integration Glue connection config for update operations. */
    "tableflow.v1.CatalogIntegrationAwsGlueUpdateSpec": {
      /**
       * @description The type of the catalog integration. (enum property replaced by openapi-typescript)
       * @enum {string}
       */
      kind: "AwsGlue";
    };
    /** @description The desired state of the Catalog Integration */
    "tableflow.v1.CatalogIntegrationUpdateRequest": {
      /**
       * @description APIVersion defines the schema version of this representation of a resource.
       * @enum {string}
       */
      readonly api_version?: "tableflow/v1";
      /**
       * @description Kind defines the object this REST resource represents.
       * @enum {string}
       */
      readonly kind?: "CatalogIntegrationUpdateRequest";
      /**
       * @description ID is the "natural identifier" for an object within its scope/namespace; it is normally unique across time but not space. That is, you can assume that the ID will not be reclaimed and reused after an object is deleted ("time"); however, it may collide with IDs for other object `kinds` or objects of the same `kind` within a different scope/namespace ("space").
       * @example dlz-f3a90de
       */
      readonly id?: string;
      metadata?: components["schemas"]["ObjectMeta"] & {
        /** @example https://api.confluent.cloud/tableflow/v1/catalog-integration-update-requests/ciur-12345 */
        self?: unknown;
        /** @example crn://confluent.cloud/organization=9bb441c4-edef-46ac-8a41-c49e44a3fd9a/catalog-integration-update-request=ciur-12345 */
        resource_name?: unknown;
      };
      spec?: components["schemas"]["tableflow.v1.CatalogIntegrationUpdateSpec"];
    };
    /** @description The desired state of the Catalog Integration */
    "tableflow.v1.CatalogIntegrationUpdateSpec": {
      /**
       * @description The name of the catalog integration
       * @example catalog_integration_1
       */
      display_name?: string;
      /**
       * @description Indicates whether the Catalog Integration should be suspended.
       * @example false
       */
      suspended?: boolean;
      /** @description The integration config */
      config?:
        | components["schemas"]["tableflow.v1.CatalogIntegrationAwsGlueUpdateSpec"]
        | components["schemas"]["tableflow.v1.CatalogIntegrationSnowflakeUpdateSpec"];
      /**
       * @description The environment to which the target Kafka cluster belongs.
       * @example {
       *       "id": "env-00000"
       *     }
       */
      environment: components["schemas"]["GlobalObjectReference"];
      /**
       * @description The kafka cluster of the topic for which Tableflow is enabled
       * @example {
       *       "id": "lkc-00000"
       *     }
       */
      kafka_cluster: components["schemas"]["EnvScopedObjectReference"];
    };
    /** @description `Region` objects represent cloud provider regions where Tableflow can be enabled.
     *     This API allows you to list all supported Tableflow regions.
     *
     *
     *     ## The Regions Model
     *     <SchemaDefinition schemaRef="#/components/schemas/tableflow.v1.Region" /> */
    "tableflow.v1.RegionList": {
      /**
       * @description APIVersion defines the schema version of this representation of a resource.
       * @enum {string}
       */
      readonly api_version: "tableflow/v1";
      /**
       * @description Kind defines the object this REST resource represents.
       * @enum {string}
       */
      readonly kind: "RegionList";
      metadata: components["schemas"]["ListMeta"] & {
        /** @example https://api.confluent.cloud/tableflow/v1/regions */
        first?: unknown;
        /** @example https://api.confluent.cloud/tableflow/v1/regions?page_token=bcAOehAY8F16YD84Z1wT */
        last?: unknown;
        /** @example https://api.confluent.cloud/tableflow/v1/regions?page_token=YIXRY97wWYmwzrax4dld */
        prev?: unknown;
        /** @example https://api.confluent.cloud/tableflow/v1/regions?page_token=UvmDWOB1iwfAIBPj6EYb */
        next?: unknown;
      };
      /** @description A data property that contains an array of resource items. Each entry in the array is a separate resource. */
      data: (components["schemas"]["tableflow.v1.Region"] &
        Record<string, unknown>)[];
    };
    /** @description A Tableflow Topic represents configuration related to a Tableflow enabled kafka topic
     *
     *
     *     ## The Tableflow Topics Model
     *     <SchemaDefinition schemaRef="#/components/schemas/tableflow.v1.TableflowTopic" /> */
    "tableflow.v1.TableflowTopicList": {
      /**
       * @description APIVersion defines the schema version of this representation of a resource.
       * @enum {string}
       */
      readonly api_version: "tableflow/v1";
      /**
       * @description Kind defines the object this REST resource represents.
       * @enum {string}
       */
      readonly kind: "TableflowTopicList";
      metadata: components["schemas"]["ListMeta"] & {
        /** @example https://api.confluent.cloud/tableflow/v1/tableflow-topics */
        first?: unknown;
        /** @example https://api.confluent.cloud/tableflow/v1/tableflow-topics?page_token=bcAOehAY8F16YD84Z1wT */
        last?: unknown;
        /** @example https://api.confluent.cloud/tableflow/v1/tableflow-topics?page_token=YIXRY97wWYmwzrax4dld */
        prev?: unknown;
        /** @example https://api.confluent.cloud/tableflow/v1/tableflow-topics?page_token=UvmDWOB1iwfAIBPj6EYb */
        next?: unknown;
      };
      /** @description A data property that contains an array of resource items. Each entry in the array is a separate resource. */
      data: (components["schemas"]["tableflow.v1.TableflowTopic"] & {
        spec: Record<string, unknown>;
      })[];
    };
    /** @description The desired state of the Tableflow Topic */
    "tableflow.v1.TableflowTopicSpec": {
      /**
       * @description The name of the Kafka topic for which Tableflow is enabled.
       * @example topic_1
       */
      display_name?: string;
      /**
       * @description Indicates whether the Tableflow should be suspended. The API allows setting it only to `false` i.e., to resume the Tableflow. Pausing the Tableflow on-demand is not currently supported.
       * @example false
       */
      suspended?: boolean;
      /** @description The config for the Tableflow enabled topic */
      config?: components["schemas"]["tableflow.v1.TableFlowTopicConfigsSpec"];
      /** @description The storage config */
      storage?:
        | components["schemas"]["tableflow.v1.ByobAwsSpec"]
        | components["schemas"]["tableflow.v1.ManagedStorageSpec"];
      /**
       * @description The supported table formats for the Tableflow-enabled topic.
       *
       * @default [
       *       "ICEBERG"
       *     ]
       * @example [
       *       "DELTA"
       *     ]
       */
      table_formats: string[];
      /** @description The environment to which the target Kafka cluster belongs. */
      environment?: components["schemas"]["GlobalObjectReference"];
      /** @description The kafka cluster of the topic for which Tableflow is enabled */
      kafka_cluster?: components["schemas"]["EnvScopedObjectReference"];
    };
    /** @description A Catalog Integration represents configuration related to a catalog integration
     *
     *
     *     ## The Catalog Integrations Model
     *     <SchemaDefinition schemaRef="#/components/schemas/tableflow.v1.CatalogIntegration" /> */
    "tableflow.v1.CatalogIntegrationList": {
      /**
       * @description APIVersion defines the schema version of this representation of a resource.
       * @enum {string}
       */
      readonly api_version: "tableflow/v1";
      /**
       * @description Kind defines the object this REST resource represents.
       * @enum {string}
       */
      readonly kind: "CatalogIntegrationList";
      metadata: components["schemas"]["ListMeta"] & {
        /** @example https://api.confluent.cloud/tableflow/v1/catalog-integrations */
        first?: unknown;
        /** @example https://api.confluent.cloud/tableflow/v1/catalog-integrations?page_token=bcAOehAY8F16YD84Z1wT */
        last?: unknown;
        /** @example https://api.confluent.cloud/tableflow/v1/catalog-integrations?page_token=YIXRY97wWYmwzrax4dld */
        prev?: unknown;
        /** @example https://api.confluent.cloud/tableflow/v1/catalog-integrations?page_token=UvmDWOB1iwfAIBPj6EYb */
        next?: unknown;
      };
      /** @description A data property that contains an array of resource items. Each entry in the array is a separate resource. */
      data: (components["schemas"]["tableflow.v1.CatalogIntegration"] & {
        spec: Record<string, unknown>;
      })[];
    };
    /** @description The desired state of the Catalog Integration */
    "tableflow.v1.CatalogIntegrationSpec": {
      /**
       * @description The name of the catalog integration
       * @example catalog_integration_1
       */
      display_name?: string;
      /**
       * @description Indicates whether the Catalog Integration should be suspended. The API allows setting it only to `false` i.e., to resume the Catalog Integration. Pausing the Catalog Integration on-demand is not currently supported.
       * @example false
       */
      suspended?: boolean;
      /** @description The integration config */
      config?:
        | components["schemas"]["tableflow.v1.CatalogIntegrationAwsGlueSpec"]
        | components["schemas"]["tableflow.v1.CatalogIntegrationSnowflakeSpec"];
      /** @description The environment to which the target Kafka cluster belongs. */
      environment?: components["schemas"]["GlobalObjectReference"];
      /** @description The kafka cluster of the topic for which Tableflow is enabled */
      kafka_cluster?: components["schemas"]["EnvScopedObjectReference"];
    };
    /** @description The desired state of the Api Key */
    "iam.v2.ApiKeySpecUpdate": {
      /**
       * @description A human readable name for the API key
       * @example CI kafka access key
       */
      display_name?: string;
      /**
       * @description A human readable description for the API key
       * @example This API key provides kafka access to cluster x
       */
      description?: string;
    };
    /** @description `ApiKey` objects represent access to different parts of Confluent Cloud. Some types
     *     of API keys represent access to a single cluster/resource such as a Kafka cluster,
     *     Schema Registry cluster or a ksqlDB cluster. Cloud API Keys represent access to resources within an organization
     *     that are not tied to a specific cluster, such as the Org API, IAM API, Metrics API or Connect API.
     *     Tableflow API keys are not tied to a specific cluster.
     *
     *     The API allows you to list, create, update and delete your API Keys.
     *
     *
     *     Related guide: [API Keys in Confluent Cloud](https://docs.confluent.io/cloud/current/client-apps/api-keys.html).
     *
     *     ## The API Keys Model
     *     <SchemaDefinition schemaRef="#/components/schemas/iam.v2.ApiKey" />
     *
     *     ## Quotas and Limits
     *     This resource is subject to the [following quotas](https://docs.confluent.io/cloud/current/quotas/overview.html):
     *
     *     | Quota | Description |
     *     | --- | --- |
     *     | `apikeys_per_org` | API Keys in one Confluent Cloud organization | */
    "iam.v2.ApiKeyUpdate": {
      /**
       * @description APIVersion defines the schema version of this representation of a resource.
       * @enum {string}
       */
      readonly api_version?: "iam/v2";
      /**
       * @description Kind defines the object this REST resource represents.
       * @enum {string}
       */
      readonly kind?: "ApiKey";
      /**
       * @description ID is the "natural identifier" for an object within its scope/namespace; it is normally unique across time but not space. That is, you can assume that the ID will not be reclaimed and reused after an object is deleted ("time"); however, it may collide with IDs for other object `kinds` or objects of the same `kind` within a different scope/namespace ("space").
       * @example dlz-f3a90de
       */
      readonly id?: string;
      metadata?: components["schemas"]["ObjectMeta"] & {
        /** @example https://api.confluent.cloud/iam/v2/api-keys/ak-12345 */
        self?: unknown;
        /** @example crn://confluent.cloud/organization=9bb441c4-edef-46ac-8a41-c49e44a3fd9a/api-key=ak-12345 */
        resource_name?: unknown;
      };
      spec?: components["schemas"]["iam.v2.ApiKeySpecUpdate"];
    };
    /** @description `User` objects represent individuals who may access your Confluent resources.
     *
     *     The API allows you to retrieve, update, and delete individual users, as well as list of all your
     *     users. This API cannot be used to create new user accounts.
     *
     *
     *     Related guide: [Users in Confluent Cloud](https://docs.confluent.io/cloud/current/access-management/user-account.html).
     *
     *     ## The Users Model
     *     <SchemaDefinition schemaRef="#/components/schemas/iam.v2.User" />
     *
     *     ## Quotas and Limits
     *     This resource is subject to the [following quotas](https://docs.confluent.io/cloud/current/quotas/overview.html):
     *
     *     | Quota | Description |
     *     | --- | --- |
     *     | `users_per_org` | Users in one Confluent Cloud organization | */
    "iam.v2.UserUpdate": {
      /**
       * @description APIVersion defines the schema version of this representation of a resource.
       * @enum {string}
       */
      readonly api_version?: "iam/v2";
      /**
       * @description Kind defines the object this REST resource represents.
       * @enum {string}
       */
      readonly kind?: "User";
      /**
       * @description ID is the "natural identifier" for an object within its scope/namespace; it is normally unique across time but not space. That is, you can assume that the ID will not be reclaimed and reused after an object is deleted ("time"); however, it may collide with IDs for other object `kinds` or objects of the same `kind` within a different scope/namespace ("space").
       * @example dlz-f3a90de
       */
      readonly id?: string;
      metadata?: components["schemas"]["ObjectMeta"] & {
        /** @example https://api.confluent.cloud/iam/v2/users/u-12345 */
        self?: unknown;
        /** @example crn://confluent.cloud/user=u-12345 */
        resource_name?: unknown;
      };
      /**
       * @description The user's full name
       * @example Marty McFly
       */
      full_name?: string;
      /**
       * @description The user's authentication method
       * @example AUTH_TYPE_SSO
       */
      readonly auth_type?: string;
    };
    /** @description `Subscription` objects represent the intent of the customers to get notifications of particular types.
     *     A subscription is created for a particular `NotificationType` and the user will get notifications on the
     *     `Integrations` that are provided while creating the subscription.
     *
     *     This API allows you to create, retrieve, and update subscriptions,
     *     as well as to view the list of all your subscriptions. You can also delete subscriptions
     *     with RECOMMENDED or OPTIONAL notification types. Subscriptions with REQUIRED notification types cannot be deleted.
     *
     *
     *     Related guide: [Cloud Notifications](https://docs.confluent.io/cloud/current/monitoring/configure-notifications.html#notifications-for-ccloud).
     *
     *     ## The Subscriptions Model
     *     <SchemaDefinition schemaRef="#/components/schemas/notifications.v1.Subscription" /> */
    "notifications.v1.SubscriptionUpdate": {
      /**
       * @description APIVersion defines the schema version of this representation of a resource.
       * @enum {string}
       */
      readonly api_version?: "notifications/v1";
      /**
       * @description Kind defines the object this REST resource represents.
       * @enum {string}
       */
      readonly kind?: "Subscription";
      /**
       * @description ID is the "natural identifier" for an object within its scope/namespace; it is normally unique across time but not space. That is, you can assume that the ID will not be reclaimed and reused after an object is deleted ("time"); however, it may collide with IDs for other object `kinds` or objects of the same `kind` within a different scope/namespace ("space").
       * @example dlz-f3a90de
       */
      readonly id?: string;
      metadata?: components["schemas"]["ObjectMeta"] & {
        /** @example https://api.confluent.cloud/notifications/v1/subscriptions/s-12345 */
        self?: unknown;
        /** @example crn://confluent.cloud/organization=9bb441c4-edef-46ac-8a41-c49e44a3fd9a/subscription=s-12345 */
        resource_name?: unknown;
      };
      /**
       * @description Denotes the state of the subscription. When the subscription is ENABLED, the user will receive
       *     notification on the configured Integrations. If the subscription is DISABLED, the user will not
       *     recieve any notification for the configured notification type. Note that, you cannot disable
       *     a subscription for `REQUIRED` notification type.
       *
       * @example ENABLED
       */
      current_state?: string;
      /** @description Integrations to which notifications are to be sent. */
      integrations?: components["schemas"]["GlobalObjectReference"][];
    };
    /** @description The desired state of the Cluster */
    "cmk.v2.ClusterSpecUpdate": {
      /**
       * @description The name of the cluster.
       * @example ProdKafkaCluster
       */
      display_name?: string;
      /**
       * @description The availability zone configuration of the cluster
       *
       * @example SINGLE_ZONE
       */
      availability?: string;
      /**
       * @description The configuration of the Kafka cluster.
       *
       *     Note: Clusters can be upgraded from Basic to Standard, but cannot be downgraded from Standard to Basic.
       *
       * @default {
       *       "kind": "Basic"
       *     }
       * @example {
       *       "kind": "Basic"
       *     }
       */
      config:
        | components["schemas"]["cmk.v2.Basic"]
        | components["schemas"]["cmk.v2.Standard"]
        | components["schemas"]["cmk.v2.Dedicated"]
        | components["schemas"]["cmk.v2.Enterprise"]
        | components["schemas"]["cmk.v2.Freight"];
      /** @description The environment to which this belongs. */
      environment?: components["schemas"]["EnvScopedObjectReference"];
    };
    /** @description `Clusters` objects represent Apache Kafka Clusters on Confluent Cloud.
     *
     *     The API allows you to list, create, read, update, and delete your Kafka clusters.
     *
     *
     *     Related guide: [Confluent Cloud Cluster Management for Apache Kafka APIs](https://docs.confluent.io/cloud/current/clusters/cluster-api.html).
     *
     *     ## The Clusters Model
     *     <SchemaDefinition schemaRef="#/components/schemas/cmk.v2.Cluster" />
     *
     *     ## Quotas and Limits
     *     This resource is subject to the [following quotas](https://docs.confluent.io/cloud/current/quotas/overview.html):
     *
     *     | Quota | Description |
     *     | --- | --- |
     *     | `kafka_clusters_per_environment` | Number of clusters in one Confluent Cloud environment | */
    "cmk.v2.ClusterUpdate": {
      /**
       * @description APIVersion defines the schema version of this representation of a resource.
       * @enum {string}
       */
      readonly api_version?: "cmk/v2";
      /**
       * @description Kind defines the object this REST resource represents.
       * @enum {string}
       */
      readonly kind?: "Cluster";
      /**
       * @description ID is the "natural identifier" for an object within its scope/namespace; it is normally unique across time but not space. That is, you can assume that the ID will not be reclaimed and reused after an object is deleted ("time"); however, it may collide with IDs for other object `kinds` or objects of the same `kind` within a different scope/namespace ("space").
       * @example dlz-f3a90de
       */
      readonly id?: string;
      metadata?: components["schemas"]["ObjectMeta"] & {
        /** @example https://api.confluent.cloud/cmk/v2/clusters/lkc-12345 */
        self?: unknown;
        /** @example crn://confluent.cloud/organization=9bb441c4-edef-46ac-8a41-c49e44a3fd9a/environment=env-abc123/cloud-cluster=lkc-12345 */
        resource_name?: unknown;
      };
      spec?: components["schemas"]["cmk.v2.ClusterSpecUpdate"];
      status?: components["schemas"]["cmk.v2.ClusterStatus"];
    };
    /** @description CustomConnectorPlugins objects represent Custom Connector Plugins on Confluent Cloud.
     *     The API allows you to list, create, read, update, and delete your Custom Connector Plugins.
     *     Related guide:
     *     [Custom Connector Plugin API](https://docs.confluent.io/cloud/current/connectors/connect-api-section.html).
     *
     *
     *     ## The Custom Connector Plugins Model
     *     <SchemaDefinition schemaRef="#/components/schemas/connect.v1.CustomConnectorPlugin" /> */
    "connect.v1.CustomConnectorPluginUpdate": {
      /**
       * @description APIVersion defines the schema version of this representation of a resource.
       * @enum {string}
       */
      readonly api_version?: "connect/v1";
      /**
       * @description Kind defines the object this REST resource represents.
       * @enum {string}
       */
      readonly kind?: "CustomConnectorPlugin";
      /**
       * @description ID is the "natural identifier" for an object within its scope/namespace; it is normally unique across time but not space. That is, you can assume that the ID will not be reclaimed and reused after an object is deleted ("time"); however, it may collide with IDs for other object `kinds` or objects of the same `kind` within a different scope/namespace ("space").
       * @example dlz-f3a90de
       */
      readonly id?: string;
      metadata?: components["schemas"]["ObjectMeta"] & {
        /** @example https://api.confluent.cloud/connect/v1/custom-connector-plugins/ccp-12345 */
        self?: unknown;
        /** @example crn://confluent.cloud/organization=9bb441c4-edef-46ac-8a41-c49e44a3fd9a/custom-connector-plugin=ccp-12345 */
        resource_name?: unknown;
      };
      /** @description Display name of Custom Connector Plugin. */
      display_name?: string;
      /**
       * @description Archive format of Custom Connector Plugin.
       * @example ZIP
       */
      readonly content_format?: string;
      /** @description Description of Custom Connector Plugin. */
      description?: string;
      /**
       * @description Document link of Custom Connector Plugin.
       * @example https://github.com/confluentinc/kafka-connect-datagen
       */
      documentation_link?: string;
      /**
       * @description A sensitive property is a connector configuration property that must be hidden after a user enters property value when setting up connector.
       * @example [
       *       "passwords",
       *       "keys",
       *       "tokens"
       *     ]
       */
      sensitive_config_properties?: string[];
      /** @description [immutable] Upload source of Custom Connector Plugin. Only required in `create` request, will be ignored in `read`, `update` or `list`. */
      upload_source?: components["schemas"]["connect.v1.UploadSource.PresignedUrl"];
    };
    /** @description The desired state of the Cluster */
    "srcm.v2.ClusterSpecUpdate": {
      /**
       * @description The billing package.
       *
       *     Note: Clusters can be upgraded from ESSENTIALS to ADVANCED, but cannot be
       *     downgraded from ADVANCED to ESSENTIALS.
       *
       * @example ESSENTIALS
       */
      package?: string;
      /** @description The environment to which this belongs. */
      environment?: components["schemas"]["GlobalObjectReference"];
    };
    /** @description `Clusters` objects represent Schema Registry Clusters on Confluent Cloud.
     *
     *     The API allows you to list, create, read, and delete your Schema Registry clusters.
     *
     *
     *     Related guides:
     *     * [Confluent Cloud Schema Registry Cluster APIs](https://docs.confluent.io/cloud/current/stream-governance/clusters-regions-api.html#schema-registry-cluster-management).
     *     * [srcm/v3 Migration Guide](https://docs.confluent.io/cloud/current/stream-governance/packages.html#deprecation-of-srcm-v2-clusters-and-regions-apis-and-upgrade-guide).
     *
     *
     *     ## The Clusters Model
     *     <SchemaDefinition schemaRef="#/components/schemas/srcm.v2.Cluster" /> */
    "srcm.v2.ClusterUpdate": {
      /**
       * @description APIVersion defines the schema version of this representation of a resource.
       * @enum {string}
       */
      readonly api_version?: "srcm/v2";
      /**
       * @description Kind defines the object this REST resource represents.
       * @enum {string}
       */
      readonly kind?: "Cluster";
      /**
       * @description ID is the "natural identifier" for an object within its scope/namespace; it is normally unique across time but not space. That is, you can assume that the ID will not be reclaimed and reused after an object is deleted ("time"); however, it may collide with IDs for other object `kinds` or objects of the same `kind` within a different scope/namespace ("space").
       * @example dlz-f3a90de
       */
      readonly id?: string;
      metadata?: components["schemas"]["ObjectMeta"] & {
        /** @example https://api.confluent.cloud/srcm/v2/clusters/lsrc-12345 */
        self?: unknown;
        /** @example crn://confluent.cloud/organization=9bb441c4-edef-46ac-8a41-c49e44a3fd9a/environment=env-abc123/cloud-cluster=lsrc-12345 */
        resource_name?: unknown;
      };
      spec?: components["schemas"]["srcm.v2.ClusterSpecUpdate"];
      status?: components["schemas"]["srcm.v2.ClusterStatus"];
    };
    /** @description `ProviderSharedResource` object contains details of the data stream
     *     (topic, schema registry subjects, sharing metadata) that you have shared through Stream Sharing.
     *
     *
     *     ## The Provider Shared Resources Model
     *     <SchemaDefinition schemaRef="#/components/schemas/cdx.v1.ProviderSharedResource" /> */
    "cdx.v1.ProviderSharedResourceUpdate": {
      /**
       * @description APIVersion defines the schema version of this representation of a resource.
       * @enum {string}
       */
      readonly api_version?: "cdx/v1";
      /**
       * @description Kind defines the object this REST resource represents.
       * @enum {string}
       */
      readonly kind?: "ProviderSharedResource";
      /**
       * @description ID is the "natural identifier" for an object within its scope/namespace; it is normally unique across time but not space. That is, you can assume that the ID will not be reclaimed and reused after an object is deleted ("time"); however, it may collide with IDs for other object `kinds` or objects of the same `kind` within a different scope/namespace ("space").
       * @example dlz-f3a90de
       */
      readonly id?: string;
      metadata?: components["schemas"]["ObjectMeta"] & {
        /** @example https://api.confluent.cloud/cdx/v1/provider-shared-resources/psr-12345 */
        self?: unknown;
        /** @example crn://confluent.cloud/organization=9bb441c4-edef-46ac-8a41-c49e44a3fd9a/provider-shared-resource=psr-12345 */
        resource_name?: unknown;
      };
      /** @description List of resource crns that are shared together */
      resources?: string[];
      /**
       * @description Shared resource display name
       * @example Stock Trades
       */
      display_name?: string;
      /**
       * @description Shared resource's organization description
       * @example ABC Corp is the biggest online retailer
       */
      organization_description?: string;
      /**
       * Format: email
       * @description Email of contact person from the organization
       * @example jane.doe@example.com
       */
      organization_contact?: string;
      /**
       * Format: uri
       * @description Resource logo url
       * @example https://confluent.cloud/api/cdx/v1/provider-shared-resources/sr-123/images/logo
       */
      readonly logo_url?: string;
    };
    /** @description The desired state of the Network */
    "networking.v1.NetworkSpecUpdate": {
      /**
       * @description The name of the network
       * @example prod-aws-us-east1
       */
      display_name?: string;
      /** @description The environment to which this belongs. */
      environment?: components["schemas"]["ObjectReference"];
      /** @description The gateway associated with this object. The gateway can be one of networking.v1.Gateway. May be `null` or omitted if not associated with a gateway. */
      readonly gateway?:
        | components["schemas"]["TypedEnvScopedObjectReference"]
        | null;
    };
    /** @description `Network` represents a network (VPC) in Confluent Cloud. All Networks exist within Confluent-managed cloud
     *     provider accounts. Dedicated networks support more networking options but can only contain Dedicated clusters.
     *     Shared networks can contain any cluster type.
     *
     *     The API allows you to list, create, read, update, and delete your networks.
     *
     *
     *     Related guide: [APIs to manage networks in Confluent Cloud](https://docs.confluent.io/cloud/current/networking/overview.html).
     *
     *     ## The Networks Model
     *     <SchemaDefinition schemaRef="#/components/schemas/networking.v1.Network" />
     *
     *     ## Quotas and Limits
     *     This resource is subject to the [following quotas](https://docs.confluent.io/cloud/current/quotas/overview.html):
     *
     *     | Quota | Description |
     *     | --- | --- |
     *     | `dedicated_networks_per_environment` | Number of dedicated networks per Confluent Cloud environment | */
    "networking.v1.NetworkUpdate": {
      /**
       * @description APIVersion defines the schema version of this representation of a resource.
       * @enum {string}
       */
      readonly api_version?: "networking/v1";
      /**
       * @description Kind defines the object this REST resource represents.
       * @enum {string}
       */
      readonly kind?: "Network";
      /**
       * @description ID is the "natural identifier" for an object within its scope/namespace; it is normally unique across time but not space. That is, you can assume that the ID will not be reclaimed and reused after an object is deleted ("time"); however, it may collide with IDs for other object `kinds` or objects of the same `kind` within a different scope/namespace ("space").
       * @example dlz-f3a90de
       */
      readonly id?: string;
      metadata?: components["schemas"]["ObjectMeta"] & {
        /** @example https://api.confluent.cloud/networking/v1/networks/n-12345 */
        self?: unknown;
        /** @example crn://confluent.cloud/organization=9bb441c4-edef-46ac-8a41-c49e44a3fd9a/environment=env-abc123/network=n-12345 */
        resource_name?: unknown;
      };
      spec?: components["schemas"]["networking.v1.NetworkSpecUpdate"];
      status?: components["schemas"]["networking.v1.NetworkStatus"];
    };
    /** @description The desired state of the Peering */
    "networking.v1.PeeringSpecUpdate": {
      /**
       * @description The name of the peering
       * @example prod-peering-use1
       */
      display_name?: string;
      /** @description The environment to which this belongs. */
      environment?: components["schemas"]["ObjectReference"];
    };
    /** @description Add or remove VPC/VNet peering connections between your VPC/VNet and Confluent Cloud.
     *
     *     Related guides:
     *     * [Use VPC peering connections with Confluent Cloud on AWS](https://docs.confluent.io/cloud/current/networking/peering/aws-peering.html).
     *     * [Use VNet peering connections with Confluent Cloud on Azure](https://docs.confluent.io/cloud/current/networking/peering/azure-peering.html).
     *     * [Use VPC peering connections with Confluent Cloud on Google Cloud](https://docs.confluent.io/cloud/current/networking/peering/gcp-peering.html).
     *
     *
     *     ## The Peerings Model
     *     <SchemaDefinition schemaRef="#/components/schemas/networking.v1.Peering" />
     *
     *     ## Quotas and Limits
     *     This resource is subject to the [following quotas](https://docs.confluent.io/cloud/current/quotas/overview.html):
     *
     *     | Quota | Description |
     *     | --- | --- |
     *     | `peerings_per_network` | Number of peerings per network | */
    "networking.v1.PeeringUpdate": {
      /**
       * @description APIVersion defines the schema version of this representation of a resource.
       * @enum {string}
       */
      readonly api_version?: "networking/v1";
      /**
       * @description Kind defines the object this REST resource represents.
       * @enum {string}
       */
      readonly kind?: "Peering";
      /**
       * @description ID is the "natural identifier" for an object within its scope/namespace; it is normally unique across time but not space. That is, you can assume that the ID will not be reclaimed and reused after an object is deleted ("time"); however, it may collide with IDs for other object `kinds` or objects of the same `kind` within a different scope/namespace ("space").
       * @example dlz-f3a90de
       */
      readonly id?: string;
      metadata?: components["schemas"]["ObjectMeta"] & {
        /** @example https://api.confluent.cloud/networking/v1/peerings/p-12345 */
        self?: unknown;
        /** @example crn://confluent.cloud/organization=9bb441c4-edef-46ac-8a41-c49e44a3fd9a/environment=env-abc123/network=n-456xyz/peering=p-12345 */
        resource_name?: unknown;
      };
      spec?: components["schemas"]["networking.v1.PeeringSpecUpdate"];
      status?: components["schemas"]["networking.v1.PeeringStatus"];
    };
    /** @description The desired state of the Transit Gateway Attachment */
    "networking.v1.TransitGatewayAttachmentSpecUpdate": {
      /**
       * @description The name of the TGW attachment
       * @example prod-tgw-use1
       */
      display_name?: string;
      /** @description The environment to which this belongs. */
      environment?: components["schemas"]["ObjectReference"];
    };
    /** @description AWS Transit Gateway Attachments
     *
     *     Related guide: [APIs to manage AWS Transit Gateway Attachments](https://docs.confluent.io/cloud/current/networking/aws-transit-gateway.html).
     *
     *     ## The Transit Gateway Attachments Model
     *     <SchemaDefinition schemaRef="#/components/schemas/networking.v1.TransitGatewayAttachment" />
     *
     *     ## Quotas and Limits
     *     This resource is subject to the [following quotas](https://docs.confluent.io/cloud/current/quotas/overview.html):
     *
     *     | Quota | Description |
     *     | --- | --- |
     *     | `tgw_attachments_per_network` | Number of TGW attachments per network | */
    "networking.v1.TransitGatewayAttachmentUpdate": {
      /**
       * @description APIVersion defines the schema version of this representation of a resource.
       * @enum {string}
       */
      readonly api_version?: "networking/v1";
      /**
       * @description Kind defines the object this REST resource represents.
       * @enum {string}
       */
      readonly kind?: "TransitGatewayAttachment";
      /**
       * @description ID is the "natural identifier" for an object within its scope/namespace; it is normally unique across time but not space. That is, you can assume that the ID will not be reclaimed and reused after an object is deleted ("time"); however, it may collide with IDs for other object `kinds` or objects of the same `kind` within a different scope/namespace ("space").
       * @example dlz-f3a90de
       */
      readonly id?: string;
      metadata?: components["schemas"]["ObjectMeta"] & {
        /** @example https://api.confluent.cloud/networking/v1/transit-gateway-attachments/tga-12345 */
        self?: unknown;
        /** @example crn://confluent.cloud/organization=9bb441c4-edef-46ac-8a41-c49e44a3fd9a/environment=env-abc123/network=n-456xyz/transit-gateway-attachment=tga-12345 */
        resource_name?: unknown;
      };
      spec?: components["schemas"]["networking.v1.TransitGatewayAttachmentSpecUpdate"];
      status?: components["schemas"]["networking.v1.TransitGatewayAttachmentStatus"];
    };
    /** @description The desired state of the Private Link Access */
    "networking.v1.PrivateLinkAccessSpecUpdate": {
      /**
       * @description The name of the PrivateLink access
       * @example prod-pl-use1
       */
      display_name?: string;
      /** @description The environment to which this belongs. */
      environment?: components["schemas"]["ObjectReference"];
    };
    /** @description Add or remove access to PrivateLink endpoints by AWS account, Azure subscription and GCP project ID.
     *
     *     Related guides:
     *     * [Use Google Cloud Private Service Connect with Confluent Cloud](https://docs.confluent.io/cloud/current/networking/private-links/gcp-private-service-connect.html).
     *     * [Use Azure Private Link with Confluent Cloud](https://docs.confluent.io/cloud/current/networking/private-links/azure-privatelink.html).
     *     * [Use AWS PrivateLink with Confluent Cloud](https://docs.confluent.io/cloud/current/networking/private-links/aws-privatelink.html).
     *
     *
     *     ## The Private Link Accesses Model
     *     <SchemaDefinition schemaRef="#/components/schemas/networking.v1.PrivateLinkAccess" />
     *
     *     ## Quotas and Limits
     *     This resource is subject to the [following quotas](https://docs.confluent.io/cloud/current/quotas/overview.html):
     *
     *     | Quota | Description |
     *     | --- | --- |
     *     | `private_link_accounts_per_network` | Number of AWS accounts per network |
     *     | `private_link_subscriptions_per_network` | Number of Azure subscriptions per network |
     *     | `private_service_connect_projects_per_network` | Number of GCP projects per network | */
    "networking.v1.PrivateLinkAccessUpdate": {
      /**
       * @description APIVersion defines the schema version of this representation of a resource.
       * @enum {string}
       */
      readonly api_version?: "networking/v1";
      /**
       * @description Kind defines the object this REST resource represents.
       * @enum {string}
       */
      readonly kind?: "PrivateLinkAccess";
      /**
       * @description ID is the "natural identifier" for an object within its scope/namespace; it is normally unique across time but not space. That is, you can assume that the ID will not be reclaimed and reused after an object is deleted ("time"); however, it may collide with IDs for other object `kinds` or objects of the same `kind` within a different scope/namespace ("space").
       * @example dlz-f3a90de
       */
      readonly id?: string;
      metadata?: components["schemas"]["ObjectMeta"] & {
        /** @example https://api.confluent.cloud/networking/v1/private-link-accesses/pla-12345 */
        self?: unknown;
        /** @example crn://confluent.cloud/organization=9bb441c4-edef-46ac-8a41-c49e44a3fd9a/environment=env-abc123/network=n-456xyz/private-link-access=pla-12345 */
        resource_name?: unknown;
      };
      spec?: components["schemas"]["networking.v1.PrivateLinkAccessSpecUpdate"];
      status?: components["schemas"]["networking.v1.PrivateLinkAccessStatus"];
    };
    /** @description The desired state of the Network Link Service */
    "networking.v1.NetworkLinkServiceSpecUpdate": {
      /**
       * @description The name of the network link service
       * @example prod-net-1-nls
       */
      display_name?: string;
      /**
       * @description The description of the network link service
       * @example Allow connections from analytics hub
       */
      description?: string;
      /** @description Network Link Service Accept policy */
      accept?: components["schemas"]["networking.v1.NetworkLinkServiceAcceptPolicy"];
      /** @description The environment to which this belongs. */
      environment?: components["schemas"]["GlobalObjectReference"];
    };
    /** @description Network Link Service is associated with a Private Link Confluent Cloud Network.
     *     It enables connectivity from other Private Link Confluent Cloud Networks based on
     *     the configured accept policies.
     *
     *
     *     Related guide: [Network Linking Overview](https://docs.confluent.io/cloud/current/networking/network-linking.html).
     *
     *     ## The Network Link Services Model
     *     <SchemaDefinition schemaRef="#/components/schemas/networking.v1.NetworkLinkService" />
     *
     *     ## Quotas and Limits
     *     This resource is subject to the [following quotas](https://docs.confluent.io/cloud/current/quotas/overview.html):
     *
     *     | Quota | Description |
     *     | --- | --- |
     *     | `network_link_service_per_network` | Number of network link services per network | */
    "networking.v1.NetworkLinkServiceUpdate": {
      /**
       * @description APIVersion defines the schema version of this representation of a resource.
       * @enum {string}
       */
      readonly api_version?: "networking/v1";
      /**
       * @description Kind defines the object this REST resource represents.
       * @enum {string}
       */
      readonly kind?: "NetworkLinkService";
      /**
       * @description ID is the "natural identifier" for an object within its scope/namespace; it is normally unique across time but not space. That is, you can assume that the ID will not be reclaimed and reused after an object is deleted ("time"); however, it may collide with IDs for other object `kinds` or objects of the same `kind` within a different scope/namespace ("space").
       * @example dlz-f3a90de
       */
      readonly id?: string;
      metadata?: components["schemas"]["ObjectMeta"] & {
        /** @example https://api.confluent.cloud/networking/v1/network-link-services/nls-12345 */
        self?: unknown;
        /** @example crn://confluent.cloud/organization=9bb441c4-edef-46ac-8a41-c49e44a3fd9a/environment=env-abc123/network=n-456xyz/network-link-service=nls-12345 */
        resource_name?: unknown;
      };
      spec?: components["schemas"]["networking.v1.NetworkLinkServiceSpecUpdate"];
      status?: components["schemas"]["networking.v1.NetworkLinkServiceStatus"];
    };
    /** @description The desired state of the Network Link Endpoint */
    "networking.v1.NetworkLinkEndpointSpecUpdate": {
      /**
       * @description The name of the network link endpoint
       * @example prod-net-1-nle
       */
      display_name?: string;
      /**
       * @description The description of the network link endpoint
       * @example Connect to Network - analytics hub
       */
      description?: string;
      /** @description The environment to which this belongs. */
      environment?: components["schemas"]["GlobalObjectReference"];
    };
    /** @description A Network Link Enpoint is associated with a Private Link Confluent Cloud Network at the origin and a
     *     Network Link Service (associated with another Private Link Confluent Cloud Network) at the target.
     *     It enables connectivity between the origin network and the target network.
     *     It can only be associated with a Private Link network.
     *
     *
     *     Related guide: [Network Linking Overview](https://docs.confluent.io/cloud/current/networking/network-linking.html).
     *
     *     ## The Network Link Endpoints Model
     *     <SchemaDefinition schemaRef="#/components/schemas/networking.v1.NetworkLinkEndpoint" />
     *
     *     ## Quotas and Limits
     *     This resource is subject to the [following quotas](https://docs.confluent.io/cloud/current/quotas/overview.html):
     *
     *     | Quota | Description |
     *     | --- | --- |
     *     | `network_link_endpoints_per_network` | Number of network link endpoints per network | */
    "networking.v1.NetworkLinkEndpointUpdate": {
      /**
       * @description APIVersion defines the schema version of this representation of a resource.
       * @enum {string}
       */
      readonly api_version?: "networking/v1";
      /**
       * @description Kind defines the object this REST resource represents.
       * @enum {string}
       */
      readonly kind?: "NetworkLinkEndpoint";
      /**
       * @description ID is the "natural identifier" for an object within its scope/namespace; it is normally unique across time but not space. That is, you can assume that the ID will not be reclaimed and reused after an object is deleted ("time"); however, it may collide with IDs for other object `kinds` or objects of the same `kind` within a different scope/namespace ("space").
       * @example dlz-f3a90de
       */
      readonly id?: string;
      metadata?: components["schemas"]["ObjectMeta"] & {
        /** @example https://api.confluent.cloud/networking/v1/network-link-endpoints/nle-12345 */
        self?: unknown;
        /** @example crn://confluent.cloud/organization=9bb441c4-edef-46ac-8a41-c49e44a3fd9a/environment=env-abc123/network=n-456xyz/network-link-endpoint=nle-12345 */
        resource_name?: unknown;
      };
      spec?: components["schemas"]["networking.v1.NetworkLinkEndpointSpecUpdate"];
      status?: components["schemas"]["networking.v1.NetworkLinkEndpointStatus"];
    };
    /** @description The desired state of the Private Link Attachment */
    "networking.v1.PrivateLinkAttachmentSpecUpdate": {
      /**
       * @description The name of the PrivateLink attachment.
       * @example prod-aws-us-east1
       */
      display_name?: string;
      /** @description The environment to which this belongs. */
      environment?: components["schemas"]["ObjectReference"];
    };
    /** @description PrivateLink attachment objects represent reservations to establish PrivateLink connections
     *     to a cloud region in order to access resources that belong to a Confluent Cloud Environment.
     *     The API allows you to list, create, read update and delete your PrivateLink attachments.
     *
     *
     *     ## The Private Link Attachments Model
     *     <SchemaDefinition schemaRef="#/components/schemas/networking.v1.PrivateLinkAttachment" />
     *
     *     ## Quotas and Limits
     *     This resource is subject to the [following quotas](https://docs.confluent.io/cloud/current/quotas/overview.html):
     *
     *     | Quota | Description |
     *     | --- | --- |
     *     | `private_link_attachments_per_environment` | Number of PrivateLink Attachments per environment | */
    "networking.v1.PrivateLinkAttachmentUpdate": {
      /**
       * @description APIVersion defines the schema version of this representation of a resource.
       * @enum {string}
       */
      readonly api_version?: "networking/v1";
      /**
       * @description Kind defines the object this REST resource represents.
       * @enum {string}
       */
      readonly kind?: "PrivateLinkAttachment";
      /**
       * @description ID is the "natural identifier" for an object within its scope/namespace; it is normally unique across time but not space. That is, you can assume that the ID will not be reclaimed and reused after an object is deleted ("time"); however, it may collide with IDs for other object `kinds` or objects of the same `kind` within a different scope/namespace ("space").
       * @example dlz-f3a90de
       */
      readonly id?: string;
      metadata?: components["schemas"]["ObjectMeta"] & {
        /** @example https://api.confluent.cloud/networking/v1/private-link-attachments/platt-12345 */
        self?: unknown;
        /** @example crn://confluent.cloud/organization=9bb441c4-edef-46ac-8a41-c49e44a3fd9a/private-link-attachment=platt-12345 */
        resource_name?: unknown;
      };
      spec?: components["schemas"]["networking.v1.PrivateLinkAttachmentSpecUpdate"];
      status?: components["schemas"]["networking.v1.PrivateLinkAttachmentStatus"];
    };
    /** @description The desired state of the Private Link Attachment Connection */
    "networking.v1.PrivateLinkAttachmentConnectionSpecUpdate": {
      /**
       * @description The name of the PrivateLink attachment connection.
       * @example prod-gcp-us-central1-a
       */
      display_name?: string;
      /** @description The environment to which this belongs. */
      environment?: components["schemas"]["ObjectReference"];
    };
    /** @description PrivateLink attachment connection objects represent connections established to a cloud region
     *     in order to access resources that belong to a Confluent Cloud Environment.
     *     The API allows you to list, create, read update and delete your PrivateLink attachment connections.
     *
     *
     *     ## The Private Link Attachment Connections Model
     *     <SchemaDefinition schemaRef="#/components/schemas/networking.v1.PrivateLinkAttachmentConnection" /> */
    "networking.v1.PrivateLinkAttachmentConnectionUpdate": {
      /**
       * @description APIVersion defines the schema version of this representation of a resource.
       * @enum {string}
       */
      readonly api_version?: "networking/v1";
      /**
       * @description Kind defines the object this REST resource represents.
       * @enum {string}
       */
      readonly kind?: "PrivateLinkAttachmentConnection";
      /**
       * @description ID is the "natural identifier" for an object within its scope/namespace; it is normally unique across time but not space. That is, you can assume that the ID will not be reclaimed and reused after an object is deleted ("time"); however, it may collide with IDs for other object `kinds` or objects of the same `kind` within a different scope/namespace ("space").
       * @example dlz-f3a90de
       */
      readonly id?: string;
      metadata?: components["schemas"]["ObjectMeta"] & {
        /** @example https://api.confluent.cloud/networking/v1/private-link-attachment-connections/plattc-12345 */
        self?: unknown;
        /** @example crn://confluent.cloud/organization=9bb441c4-edef-46ac-8a41-c49e44a3fd9a/private-link-attachment-connection=plattc-12345 */
        resource_name?: unknown;
      };
      spec?: components["schemas"]["networking.v1.PrivateLinkAttachmentConnectionSpecUpdate"];
      status?: components["schemas"]["networking.v1.PrivateLinkAttachmentConnectionStatus"];
    };
    /** @description The desired state of the Client Quota */
    "kafka-quotas.v1.ClientQuotaSpecUpdate": {
      /**
       * @description The name of the client quota.
       * @example QuotaForSA1
       */
      display_name?: string;
      /**
       * @description A human readable description for the client quota.
       * @example This quota defines limits on how much the target principals can use cluster lkc-xxxxx
       */
      description?: string;
      /** @description Throughput for the client quota. */
      throughput?: components["schemas"]["kafka-quotas.v1.Throughput"];
      /** @description A list of principals to apply a client quota to.
       *     Use `"<default>"` to apply a client quota to all service accounts
       *     (see [Control application usage with Client Quotas](https://docs.confluent.io/cloud/current/clusters/client-quotas.html#control-application-usage-with-client-quotas) for more details).
       *      */
      principals?: components["schemas"]["GlobalObjectReference"][];
    };
    /** @description `ClientQuota` objects represent Client Quotas you can set at the service account level.
     *
     *     The API allows you to list, create, read, update, and delete your client quotas.
     *
     *
     *     Related guide: [Client Quotas in Confluent Cloud](https://docs.confluent.io/cloud/current/clusters/client-quotas.html).
     *
     *     ## The Client Quotas Model
     *     <SchemaDefinition schemaRef="#/components/schemas/kafka-quotas.v1.ClientQuota" /> */
    "kafka-quotas.v1.ClientQuotaUpdate": {
      /**
       * @description APIVersion defines the schema version of this representation of a resource.
       * @enum {string}
       */
      readonly api_version?: "kafka-quotas/v1";
      /**
       * @description Kind defines the object this REST resource represents.
       * @enum {string}
       */
      readonly kind?: "ClientQuota";
      /**
       * @description ID is the "natural identifier" for an object within its scope/namespace; it is normally unique across time but not space. That is, you can assume that the ID will not be reclaimed and reused after an object is deleted ("time"); however, it may collide with IDs for other object `kinds` or objects of the same `kind` within a different scope/namespace ("space").
       * @example dlz-f3a90de
       */
      readonly id?: string;
      metadata?: components["schemas"]["ObjectMeta"] & {
        /** @example https://api.confluent.cloud/kafka-quotas/v1/client-quotas/cq-12345 */
        self?: unknown;
        /** @example crn://confluent.cloud/organization=9bb441c4-edef-46ac-8a41-c49e44a3fd9a/client-quota=cq-12345 */
        resource_name?: unknown;
      };
      spec?: components["schemas"]["kafka-quotas.v1.ClientQuotaSpecUpdate"];
    };
    /** @description The desired state of the Compute Pool */
    "fcpm.v2.ComputePoolSpecUpdate": {
      /**
       * @description The name of the Flink compute pool.
       * @example flink_compute_pool_0
       */
      display_name?: string;
      /**
       * Format: int32
       * @description Maximum number of Confluent Flink Units (CFUs) that the Flink compute pool should auto-scale to.
       *
       * @example 5
       */
      max_cfu?: number;
      /** @description The environment to which this belongs. */
      environment?: components["schemas"]["GlobalObjectReference"];
    };
    /** @description A Compute Pool represents a set of compute resources that is used to run your Queries.
     *     The resources (CPUs, memory,…) provided by a Compute Pool are shared between all Queries that use it.
     *     Note that the Compute Pool API supports a limited pagination API, only the `next` field will be populated.
     *
     *
     *     ## The Compute Pools Model
     *     <SchemaDefinition schemaRef="#/components/schemas/fcpm.v2.ComputePool" /> */
    "fcpm.v2.ComputePoolUpdate": {
      /**
       * @description APIVersion defines the schema version of this representation of a resource.
       * @enum {string}
       */
      readonly api_version?: "fcpm/v2";
      /**
       * @description Kind defines the object this REST resource represents.
       * @enum {string}
       */
      readonly kind?: "ComputePool";
      /**
       * @description ID is the "natural identifier" for an object within its scope/namespace; it is normally unique across time but not space. That is, you can assume that the ID will not be reclaimed and reused after an object is deleted ("time"); however, it may collide with IDs for other object `kinds` or objects of the same `kind` within a different scope/namespace ("space").
       * @example dlz-f3a90de
       */
      readonly id?: string;
      metadata?: components["schemas"]["ObjectMeta"] & {
        /** @example https://api.confluent.cloud/fcpm/v2/compute-pools/lfcp-12345 */
        self?: unknown;
        /** @example crn://confluent.cloud/organization=9bb441c4-edef-46ac-8a41-c49e44a3fd9a/environment=env-abc123/flink-region=aws.us-east-2/compute-pool=lfcp-12345 */
        resource_name?: unknown;
      };
      spec?: components["schemas"]["fcpm.v2.ComputePoolSpecUpdate"];
      status?: components["schemas"]["fcpm.v2.ComputePoolStatus"];
    };
    /** @description The desired state of the Dns Forwarder */
    "networking.v1.DnsForwarderSpecUpdate": {
      /**
       * @description The name of the DNS forwarder
       * @example prod-dnsf-1
       */
      display_name?: string;
      /**
       * @description List of domains for the DNS forwarder to use
       * @example [
       *       "example.com",
       *       "domainname.com"
       *     ]
       */
      domains?: string[];
      /** @description The specific details of different kinds of configuration for DNS Forwarder. */
      config?: components["schemas"]["networking.v1.ForwardViaIp"];
      /** @description The environment to which this belongs. */
      environment?: components["schemas"]["ObjectReference"];
    };
    /** @description Add, remove, and update DNS forwarder for your gateway.
     *
     *     Related guides:
     *     * [Use VPC peering connections with Confluent Cloud on AWS](https://docs.confluent.io/cloud/current/networking/peering/aws-peering.html).
     *     * [Use VNet peering connections with Confluent Cloud on Azure](https://docs.confluent.io/cloud/current/networking/peering/azure-peering.html).
     *
     *
     *     ## The DNS Forwarders Model
     *     <SchemaDefinition schemaRef="#/components/schemas/networking.v1.DnsForwarder" /> */
    "networking.v1.DnsForwarderUpdate": {
      /**
       * @description APIVersion defines the schema version of this representation of a resource.
       * @enum {string}
       */
      readonly api_version?: "networking/v1";
      /**
       * @description Kind defines the object this REST resource represents.
       * @enum {string}
       */
      readonly kind?: "DnsForwarder";
      /**
       * @description ID is the "natural identifier" for an object within its scope/namespace; it is normally unique across time but not space. That is, you can assume that the ID will not be reclaimed and reused after an object is deleted ("time"); however, it may collide with IDs for other object `kinds` or objects of the same `kind` within a different scope/namespace ("space").
       * @example dlz-f3a90de
       */
      readonly id?: string;
      metadata?: components["schemas"]["ObjectMeta"] & {
        /** @example https://api.confluent.cloud/networking/v1/dns-forwarders/df-12345 */
        self?: unknown;
        /** @example crn://confluent.cloud/organization=9bb441c4-edef-46ac-8a41-c49e44a3fd9a/environment=env-abc123/gateway=gw-456xyz/dns-forwarder=df-12345 */
        resource_name?: unknown;
      };
      spec?: components["schemas"]["networking.v1.DnsForwarderSpecUpdate"];
      status?: components["schemas"]["networking.v1.DnsForwarderStatus"];
    };
    /** @description The desired state of the Access Point */
    "networking.v1.AccessPointSpecUpdate": {
      /**
       * @description The name of the access point.
       * @example prod-ap-egress-usw2
       */
      display_name?: string;
      /** @description The specific details of the different access point configurations. */
      config?:
        | components["schemas"]["networking.v1.AwsEgressPrivateLinkEndpoint"]
        | components["schemas"]["networking.v1.AzureEgressPrivateLinkEndpoint"]
        | components["schemas"]["networking.v1.AwsPrivateNetworkInterface"]
        | components["schemas"]["networking.v1.GcpEgressPrivateServiceConnectEndpoint"];
      /** @description The environment to which this belongs. */
      environment?: components["schemas"]["ObjectReference"];
    };
    /** @description AccessPoint objects represent network connections in and out of Gateways.
     *     This API allows you to list, create, read, update, and delete your access points.
     *
     *
     *     ## The Access Points Model
     *     <SchemaDefinition schemaRef="#/components/schemas/networking.v1.AccessPoint" /> */
    "networking.v1.AccessPointUpdate": {
      /**
       * @description APIVersion defines the schema version of this representation of a resource.
       * @enum {string}
       */
      readonly api_version?: "networking/v1";
      /**
       * @description Kind defines the object this REST resource represents.
       * @enum {string}
       */
      readonly kind?: "AccessPoint";
      /**
       * @description ID is the "natural identifier" for an object within its scope/namespace; it is normally unique across time but not space. That is, you can assume that the ID will not be reclaimed and reused after an object is deleted ("time"); however, it may collide with IDs for other object `kinds` or objects of the same `kind` within a different scope/namespace ("space").
       * @example dlz-f3a90de
       */
      readonly id?: string;
      metadata?: components["schemas"]["ObjectMeta"] & {
        /** @example https://api.confluent.cloud/networking/v1/access-points/ap-12345 */
        self?: unknown;
        /** @example crn://confluent.cloud/organization=9bb441c4-edef-46ac-8a41-c49e44a3fd9a/environment=env-abc123/gateway=gw-456xyz/access-point=ap-12345 */
        resource_name?: unknown;
      };
      spec?: components["schemas"]["networking.v1.AccessPointSpecUpdate"];
      status?: components["schemas"]["networking.v1.AccessPointStatus"];
    };
    /** @description The desired state of the Dns Record */
    "networking.v1.DnsRecordSpecUpdate": {
      /**
       * @description The name of the DNS record.
       * @example prod-dnsrec-1
       */
      display_name?: string;
      /** @description The config of the DNS record. */
      config?: components["schemas"]["networking.v1.PrivateLinkAccessPoint"];
      /** @description The environment to which this belongs. */
      environment?: components["schemas"]["ObjectReference"];
    };
    /** @description DNS record objects are associated with Confluent Cloud networking resources. This API allows you to list, create, read, update, and delete your DNS records.
     *
     *     ## The DNS Records Model
     *     <SchemaDefinition schemaRef="#/components/schemas/networking.v1.DnsRecord" /> */
    "networking.v1.DnsRecordUpdate": {
      /**
       * @description APIVersion defines the schema version of this representation of a resource.
       * @enum {string}
       */
      readonly api_version?: "networking/v1";
      /**
       * @description Kind defines the object this REST resource represents.
       * @enum {string}
       */
      readonly kind?: "DnsRecord";
      /**
       * @description ID is the "natural identifier" for an object within its scope/namespace; it is normally unique across time but not space. That is, you can assume that the ID will not be reclaimed and reused after an object is deleted ("time"); however, it may collide with IDs for other object `kinds` or objects of the same `kind` within a different scope/namespace ("space").
       * @example dlz-f3a90de
       */
      readonly id?: string;
      metadata?: components["schemas"]["ObjectMeta"] & {
        /** @example https://api.confluent.cloud/networking/v1/dns-records/dnsrec-12345 */
        self?: unknown;
        /** @example crn://confluent.cloud/organization=9bb441c4-edef-46ac-8a41-c49e44a3fd9a/environment=env-abc123/gateway=gw-456xyz/dns-record=dnsrec-12345 */
        resource_name?: unknown;
      };
      spec?: components["schemas"]["networking.v1.DnsRecordSpecUpdate"];
      status?: components["schemas"]["networking.v1.DnsRecordStatus"];
    };
    /** @description FlinkArtifact objects represent Flink Artifacts on Confluent Cloud.
     *
     *
     *     ## The Flink Artifacts Model
     *     <SchemaDefinition schemaRef="#/components/schemas/artifact.v1.FlinkArtifact" /> */
    "artifact.v1.FlinkArtifactUpdate": {
      /**
       * @description APIVersion defines the schema version of this representation of a resource.
       * @enum {string}
       */
      readonly api_version?: "artifact/v1";
      /**
       * @description Kind defines the object this REST resource represents.
       * @enum {string}
       */
      readonly kind?: "FlinkArtifact";
      /**
       * @description ID is the "natural identifier" for an object within its scope/namespace; it is normally unique across time but not space. That is, you can assume that the ID will not be reclaimed and reused after an object is deleted ("time"); however, it may collide with IDs for other object `kinds` or objects of the same `kind` within a different scope/namespace ("space").
       * @example dlz-f3a90de
       */
      readonly id?: string;
      metadata?: components["schemas"]["ObjectMeta"] & {
        /** @example https://api.confluent.cloud/artifact/v1/flink-artifacts/fa-12345 */
        self?: unknown;
        /** @example crn://confluent.cloud/organization=9bb441c4-edef-46ac-8a41-c49e44a3fd9a/flink-artifact=fa-12345 */
        resource_name?: unknown;
      };
      /**
       * @description Cloud provider where the Flink Artifact archive is uploaded.
       * @example AWS
       */
      cloud?: string;
      /**
       * @description The Cloud provider region the Flink Artifact archive is uploaded.
       * @example us-east-1
       */
      region?: string;
      /**
       * @description Environment the Flink Artifact belongs to.
       * @example env-00000
       */
      environment?: string;
      /** @description Unique name of the Flink Artifact per cloud, region, environment scope. */
      display_name?: string;
      /**
       * @description Archive format of the Flink Artifact.
       * @example JAR
       */
      content_format?: string;
      /** @description Description of the Flink Artifact. */
      description?: string;
      /** @description Documentation link of the Flink Artifact. */
      documentation_link?: string;
      /**
       * @description Runtime language of the Flink Artifact.
       * @default JAVA
       * @example JAVA
       */
      runtime_language: string;
      /** @description Versions associated with this Flink Artifact. */
      versions?: components["schemas"]["artifact.v1.FlinkArtifactVersion"][];
    };
    /** @description The desired state of the Gateway */
    "networking.v1.GatewaySpecUpdate": {
      /**
       * @description The name of the gateway.
       * @example prod-gateway
       */
      display_name?: string;
      /** @description The environment to which this belongs. */
      environment?: components["schemas"]["ObjectReference"];
    };
    /** @description A Gateway represents a slice of traffic capacity in a region that is reserved for a customer.
     *
     *
     *     ## The Gateways Model
     *     <SchemaDefinition schemaRef="#/components/schemas/networking.v1.Gateway" />
     *
     *     ## Quotas and Limits
     *     This resource is subject to the [following quotas](https://docs.confluent.io/cloud/current/quotas/overview.html):
     *
     *     | Quota | Description |
     *     | --- | --- |
     *     | `gateways_per_region_per_environment` | Number of Gateways per region per environment | */
    "networking.v1.GatewayUpdate": {
      /**
       * @description APIVersion defines the schema version of this representation of a resource.
       * @enum {string}
       */
      readonly api_version?: "networking/v1";
      /**
       * @description Kind defines the object this REST resource represents.
       * @enum {string}
       */
      readonly kind?: "Gateway";
      /**
       * @description ID is the "natural identifier" for an object within its scope/namespace; it is normally unique across time but not space. That is, you can assume that the ID will not be reclaimed and reused after an object is deleted ("time"); however, it may collide with IDs for other object `kinds` or objects of the same `kind` within a different scope/namespace ("space").
       * @example dlz-f3a90de
       */
      readonly id?: string;
      metadata?: components["schemas"]["ObjectMeta"] & {
        /** @example https://api.confluent.cloud/networking/v1/gateways/gw-12345 */
        self?: unknown;
        /** @example crn://confluent.cloud/organization=9bb441c4-edef-46ac-8a41-c49e44a3fd9a/environment=env-abc123/gateway=gw-12345 */
        resource_name?: unknown;
      };
      spec?: components["schemas"]["networking.v1.GatewaySpecUpdate"];
      status?: components["schemas"]["networking.v1.GatewayStatus"];
    };
    /** @description CustomCodeLogging objects represent Custom Code Logging on Confluent Cloud.
     *     The API allows you to list, create, read, update, and delete your Custom Code Logging.
     *
     *
     *     ## The Custom Code Loggings Model
     *     <SchemaDefinition schemaRef="#/components/schemas/ccl.v1.CustomCodeLogging" /> */
    "ccl.v1.CustomCodeLoggingUpdate": {
      /**
       * @description APIVersion defines the schema version of this representation of a resource.
       * @enum {string}
       */
      readonly api_version?: "ccl/v1";
      /**
       * @description Kind defines the object this REST resource represents.
       * @enum {string}
       */
      readonly kind?: "CustomCodeLogging";
      /**
       * @description ID is the "natural identifier" for an object within its scope/namespace; it is normally unique across time but not space. That is, you can assume that the ID will not be reclaimed and reused after an object is deleted ("time"); however, it may collide with IDs for other object `kinds` or objects of the same `kind` within a different scope/namespace ("space").
       * @example dlz-f3a90de
       */
      readonly id?: string;
      metadata?: components["schemas"]["ObjectMeta"] & {
        /** @example https://api.confluent.cloud/ccl/v1/custom-code-loggings/ccl-12345 */
        self?: unknown;
        /** @example crn://confluent.cloud/organization=9bb441c4-edef-46ac-8a41-c49e44a3fd9a/custom-code-logging=ccl-12345 */
        resource_name?: unknown;
      };
      /** @description Destination Settings of the Custom Code Logging. */
      destination_settings?: components["schemas"]["ccl.v1.KafkaDestinationSettings"];
      /** @description The environment to which this belongs. */
      environment?: components["schemas"]["EnvScopedObjectReference"];
    };
    /** @description The desired state of the Tableflow Topic */
    "tableflow.v1.TableflowTopicSpecUpdate": {
      /**
       * @description Indicates whether the Tableflow should be suspended. The API allows setting it only to `false` i.e., to resume the Tableflow. Pausing the Tableflow on-demand is not currently supported.
       * @example false
       */
      suspended?: boolean;
      /** @description The config for the Tableflow enabled topic */
      config?: components["schemas"]["tableflow.v1.TableFlowTopicConfigsSpec"];
      /**
       * @description The supported table formats for the Tableflow-enabled topic.
       *
       * @default [
       *       "ICEBERG"
       *     ]
       * @example [
       *       "DELTA"
       *     ]
       */
      table_formats: string[];
      /** @description The environment to which the target Kafka cluster belongs. */
      environment?: components["schemas"]["GlobalObjectReference"];
      /** @description The kafka cluster of the topic for which Tableflow is enabled */
      kafka_cluster?: components["schemas"]["EnvScopedObjectReference"];
    };
    /** @description A Tableflow Topic represents configuration related to a Tableflow enabled kafka topic
     *
     *
     *     ## The Tableflow Topics Model
     *     <SchemaDefinition schemaRef="#/components/schemas/tableflow.v1.TableflowTopic" /> */
    "tableflow.v1.TableflowTopicUpdate": {
      /**
       * @description APIVersion defines the schema version of this representation of a resource.
       * @enum {string}
       */
      readonly api_version?: "tableflow/v1";
      /**
       * @description Kind defines the object this REST resource represents.
       * @enum {string}
       */
      readonly kind?: "TableflowTopic";
      metadata?: components["schemas"]["ObjectMeta"] & {
        /** @example https://api.confluent.cloud/tableflow/v1/tableflow-topics/tt-12345 */
        self?: unknown;
        /** @example crn://confluent.cloud/organization=9bb441c4-edef-46ac-8a41-c49e44a3fd9a/tableflow-topic=tt-12345 */
        resource_name?: unknown;
      };
      spec?: components["schemas"]["tableflow.v1.TableflowTopicSpecUpdate"];
      status?: components["schemas"]["tableflow.v1.TableflowTopicStatus"];
    };
  };
  responses: {
    /** @description Bad Request */
    BadRequestError: {
      headers: {
        /** @description The unique identifier for the API request. */
        "X-Request-Id"?: string;
        [name: string]: unknown;
      };
      content: {
        /** @example {
         *       "errors": [
         *         {
         *           "id": "ed42afdc-f0d5-4c0d-b428-9fc6ed6e279d",
         *           "status": "400",
         *           "code": "invalid_filter",
         *           "title": "Invalid Filter",
         *           "detail": "The 'delorean' resource can't be filtered by 'num_doors'",
         *           "source": {
         *             "parameter": "num_doors"
         *           }
         *         }
         *       ]
         *     } */
        "application/json": components["schemas"]["Failure"];
      };
    };
    /** @description The request lacks valid authentication credentials for this resource. */
    UnauthenticatedError: {
      headers: {
        /** @description The unique identifier for the API request. */
        "X-Request-Id"?: string;
        /**
         * @description The unique identifier for the API request.
         * @example Basic error="invalid_key", error_description="The API Key is invalid"
         */
        "WWW-Authenticate"?: string;
        [name: string]: unknown;
      };
      content: {
        /** @example {
         *       "errors": [
         *         {
         *           "id": "ed42afdc-f0d5-4c0d-b428-9fc6ed6e279d",
         *           "status": "401",
         *           "code": "user_unauthenticated",
         *           "title": "Authentication Required",
         *           "detail": "Valid authentication credentials must be provided"
         *         }
         *       ]
         *     } */
        "application/json": components["schemas"]["Failure"];
      };
    };
    /** @description The request would exceed one or more quotas. */
    OverQuotaError: {
      headers: {
        /** @description The unique identifier for the API request. */
        "X-Request-Id"?: string;
        [name: string]: unknown;
      };
      content: {
        /** @example {
         *       "errors": [
         *         {
         *           "id": "ed42afdc-f0d5-4c0d-b428-9fc6ed6e279d",
         *           "status": "402",
         *           "code": "quota_exceeded",
         *           "title": "Kafka Clusters Per Org Quota Exceeded",
         *           "detail": "The request would exceed the quota: kafka_clusters_per_environment"
         *         }
         *       ]
         *     } */
        "application/json": components["schemas"]["Failure"];
      };
    };
    /** @description The access credentials were considered insufficient to grant access */
    UnauthorizedError: {
      headers: {
        /** @description The unique identifier for the API request. */
        "X-Request-Id"?: string;
        [name: string]: unknown;
      };
      content: {
        /** @example {
         *       "errors": [
         *         {
         *           "id": "ed42afdc-f0d5-4c0d-b428-9fc6ed6e279d",
         *           "status": "403",
         *           "code": "user_unauthorized",
         *           "title": "User Access Unauthorized",
         *           "detail": "The user 'mcfly' is not allowed to access the 'delorean' resource without the 'plutonium' role."
         *         }
         *       ]
         *     } */
        "application/json": components["schemas"]["Failure"];
      };
    };
    /** @description The request is in conflict with the current server state */
    ConflictError: {
      headers: {
        /** @description The unique identifier for the API request. */
        "X-Request-Id"?: string;
        /** @description Resource URI of conflicting resource */
        Location?: string;
        [name: string]: unknown;
      };
      content: {
        /** @example {
         *       "errors": [
         *         {
         *           "id": "ed42afdc-f0d5-4c0d-b428-9fc6ed6e279d",
         *           "status": "409",
         *           "code": "resource_already_exists",
         *           "title": "Resource Already exists",
         *           "detail": "The entitlement '91e3e86f-fca6-4f14-98f5-a48e64113ce2' already exists."
         *         }
         *       ]
         *     } */
        "application/json": components["schemas"]["Failure"];
      };
    };
    /** @description Not Found */
    NotFoundError: {
      headers: {
        /** @description The unique identifier for the API request. */
        "X-Request-Id"?: string;
        [name: string]: unknown;
      };
      content: {
        /** @example {
         *       "errors": [
         *         {
         *           "id": "ed42afdc-f0d5-4c0d-b428-9fc6ed6e279d",
         *           "status": "404",
         *           "title": "Not Found"
         *         }
         *       ]
         *     } */
        "application/json": components["schemas"]["Failure"];
      };
    };
    /** @description Validation Failed */
    ValidationError: {
      headers: {
        /** @description The unique identifier for the API request. */
        "X-Request-Id"?: string;
        [name: string]: unknown;
      };
      content: {
        /** @example {
         *       "errors": [
         *         {
         *           "status": "422",
         *           "code": "invalid_configuration",
         *           "id": "ed42afdc-f0d5-4c0d-b428-9fc6ed6e279d",
         *           "title": "Validation Failed",
         *           "detail": "The property '/cluster/storage_size' of type string did not match the following type: integer",
         *           "source": {
         *             "pointer": "/cluster/storage_size"
         *           }
         *         },
         *         {
         *           "status": "422",
         *           "code": "invalid_configuration",
         *           "id": "ed42afdc-f0d5-4c0d-b428-9fc6ed6e279d",
         *           "title": "Validation Failed",
         *           "detail": "The property '/cluster/storage_size' of type string did not match the following type: integer",
         *           "source": {
         *             "pointer": "/cluster/storage_size"
         *           }
         *         },
         *         {
         *           "status": "422",
         *           "code": "invalid_configuration",
         *           "id": "ed42afdc-f0d5-4c0d-b428-9fc6ed6e279d",
         *           "title": "Validation Failed",
         *           "detail": "The property '/cluster/storage_size' of type string did not match the following type: integer",
         *           "source": {
         *             "pointer": "/cluster/storage_size"
         *           }
         *         },
         *         {
         *           "status": "422",
         *           "code": "invalid_configuration",
         *           "id": "ed42afdc-f0d5-4c0d-b428-9fc6ed6e279d",
         *           "title": "Validation Failed",
         *           "detail": "The property '/cluster/storage_size' of type string did not match the following type: integer",
         *           "source": {
         *             "pointer": "/cluster/storage_size"
         *           }
         *         },
         *         {
         *           "status": "422",
         *           "code": "invalid_configuration",
         *           "id": "ed42afdc-f0d5-4c0d-b428-9fc6ed6e279d",
         *           "title": "Validation Failed",
         *           "detail": "The property '/cluster/storage_size' of type string did not match the following type: integer",
         *           "source": {
         *             "pointer": "/cluster/storage_size"
         *           }
         *         },
         *         {
         *           "status": "422",
         *           "code": "invalid_configuration",
         *           "id": "ed42afdc-f0d5-4c0d-b428-9fc6ed6e279d",
         *           "title": "Validation Failed",
         *           "detail": "The property '/cluster/storage_size' of type string did not match the following type: integer",
         *           "source": {
         *             "pointer": "/cluster/storage_size"
         *           }
         *         },
         *         {
         *           "status": "422",
         *           "code": "invalid_configuration",
         *           "id": "ed42afdc-f0d5-4c0d-b428-9fc6ed6e279d",
         *           "title": "Validation Failed",
         *           "detail": "The property '/cluster/storage_size' of type string did not match the following type: integer",
         *           "source": {
         *             "pointer": "/cluster/storage_size"
         *           }
         *         },
         *         {
         *           "status": "422",
         *           "code": "invalid_configuration",
         *           "id": "ed42afdc-f0d5-4c0d-b428-9fc6ed6e279d",
         *           "title": "Validation Failed",
         *           "detail": "The property '/cluster/storage_size' of type string did not match the following type: integer",
         *           "source": {
         *             "pointer": "/cluster/storage_size"
         *           }
         *         },
         *         {
         *           "status": "422",
         *           "code": "invalid_configuration",
         *           "id": "ed42afdc-f0d5-4c0d-b428-9fc6ed6e279d",
         *           "title": "Validation Failed",
         *           "detail": "The property '/cluster/storage_size' of type string did not match the following type: integer",
         *           "source": {
         *             "pointer": "/cluster/storage_size"
         *           }
         *         },
         *         {
         *           "status": "422",
         *           "code": "invalid_configuration",
         *           "id": "ed42afdc-f0d5-4c0d-b428-9fc6ed6e279d",
         *           "title": "Validation Failed",
         *           "detail": "The property '/cluster/storage_size' of type string did not match the following type: integer",
         *           "source": {
         *             "pointer": "/cluster/storage_size"
         *           }
         *         },
         *         {
         *           "status": "422",
         *           "code": "invalid_configuration",
         *           "id": "ed42afdc-f0d5-4c0d-b428-9fc6ed6e279d",
         *           "title": "Validation Failed",
         *           "detail": "The property '/cluster/storage_size' of type string did not match the following type: integer",
         *           "source": {
         *             "pointer": "/cluster/storage_size"
         *           }
         *         },
         *         {
         *           "status": "422",
         *           "code": "invalid_configuration",
         *           "id": "ed42afdc-f0d5-4c0d-b428-9fc6ed6e279d",
         *           "title": "Validation Failed",
         *           "detail": "The property '/cluster/storage_size' of type string did not match the following type: integer",
         *           "source": {
         *             "pointer": "/cluster/storage_size"
         *           }
         *         },
         *         {
         *           "status": "422",
         *           "code": "invalid_configuration",
         *           "id": "ed42afdc-f0d5-4c0d-b428-9fc6ed6e279d",
         *           "title": "Validation Failed",
         *           "detail": "The property '/cluster/storage_size' of type string did not match the following type: integer",
         *           "source": {
         *             "pointer": "/cluster/storage_size"
         *           }
         *         },
         *         {
         *           "status": "422",
         *           "code": "invalid_configuration",
         *           "id": "ed42afdc-f0d5-4c0d-b428-9fc6ed6e279d",
         *           "title": "Validation Failed",
         *           "detail": "The property '/cluster/storage_size' of type string did not match the following type: integer",
         *           "source": {
         *             "pointer": "/cluster/storage_size"
         *           }
         *         },
         *         {
         *           "status": "422",
         *           "code": "invalid_configuration",
         *           "id": "ed42afdc-f0d5-4c0d-b428-9fc6ed6e279d",
         *           "title": "Validation Failed",
         *           "detail": "The property '/cluster/storage_size' of type string did not match the following type: integer",
         *           "source": {
         *             "pointer": "/cluster/storage_size"
         *           }
         *         },
         *         {
         *           "status": "422",
         *           "code": "invalid_configuration",
         *           "id": "ed42afdc-f0d5-4c0d-b428-9fc6ed6e279d",
         *           "title": "Validation Failed",
         *           "detail": "The property '/cluster/storage_size' of type string did not match the following type: integer",
         *           "source": {
         *             "pointer": "/cluster/storage_size"
         *           }
         *         },
         *         {
         *           "status": "422",
         *           "code": "invalid_configuration",
         *           "id": "ed42afdc-f0d5-4c0d-b428-9fc6ed6e279d",
         *           "title": "Validation Failed",
         *           "detail": "The property '/cluster/storage_size' of type string did not match the following type: integer",
         *           "source": {
         *             "pointer": "/cluster/storage_size"
         *           }
         *         },
         *         {
         *           "status": "422",
         *           "code": "invalid_configuration",
         *           "id": "ed42afdc-f0d5-4c0d-b428-9fc6ed6e279d",
         *           "title": "Validation Failed",
         *           "detail": "The property '/cluster/storage_size' of type string did not match the following type: integer",
         *           "source": {
         *             "pointer": "/cluster/storage_size"
         *           }
         *         },
         *         {
         *           "status": "422",
         *           "code": "invalid_configuration",
         *           "id": "ed42afdc-f0d5-4c0d-b428-9fc6ed6e279d",
         *           "title": "Validation Failed",
         *           "detail": "The property '/cluster/storage_size' of type string did not match the following type: integer",
         *           "source": {
         *             "pointer": "/cluster/storage_size"
         *           }
         *         },
         *         {
         *           "status": "422",
         *           "code": "invalid_configuration",
         *           "id": "ed42afdc-f0d5-4c0d-b428-9fc6ed6e279d",
         *           "title": "Validation Failed",
         *           "detail": "The property '/cluster/storage_size' of type string did not match the following type: integer",
         *           "source": {
         *             "pointer": "/cluster/storage_size"
         *           }
         *         },
         *         {
         *           "status": "422",
         *           "code": "invalid_configuration",
         *           "id": "ed42afdc-f0d5-4c0d-b428-9fc6ed6e279d",
         *           "title": "Validation Failed",
         *           "detail": "The property '/cluster/storage_size' of type string did not match the following type: integer",
         *           "source": {
         *             "pointer": "/cluster/storage_size"
         *           }
         *         },
         *         {
         *           "status": "422",
         *           "code": "invalid_configuration",
         *           "id": "ed42afdc-f0d5-4c0d-b428-9fc6ed6e279d",
         *           "title": "Validation Failed",
         *           "detail": "The property '/cluster/storage_size' of type string did not match the following type: integer",
         *           "source": {
         *             "pointer": "/cluster/storage_size"
         *           }
         *         },
         *         {
         *           "status": "422",
         *           "code": "invalid_configuration",
         *           "id": "ed42afdc-f0d5-4c0d-b428-9fc6ed6e279d",
         *           "title": "Validation Failed",
         *           "detail": "The property '/cluster/storage_size' of type string did not match the following type: integer",
         *           "source": {
         *             "pointer": "/cluster/storage_size"
         *           }
         *         },
         *         {
         *           "status": "422",
         *           "code": "invalid_configuration",
         *           "id": "ed42afdc-f0d5-4c0d-b428-9fc6ed6e279d",
         *           "title": "Validation Failed",
         *           "detail": "The property '/cluster/storage_size' of type string did not match the following type: integer",
         *           "source": {
         *             "pointer": "/cluster/storage_size"
         *           }
         *         },
         *         {
         *           "status": "422",
         *           "code": "invalid_configuration",
         *           "id": "ed42afdc-f0d5-4c0d-b428-9fc6ed6e279d",
         *           "title": "Validation Failed",
         *           "detail": "The property '/cluster/storage_size' of type string did not match the following type: integer",
         *           "source": {
         *             "pointer": "/cluster/storage_size"
         *           }
         *         },
         *         {
         *           "status": "422",
         *           "code": "invalid_configuration",
         *           "id": "ed42afdc-f0d5-4c0d-b428-9fc6ed6e279d",
         *           "title": "Validation Failed",
         *           "detail": "The property '/cluster/storage_size' of type string did not match the following type: integer",
         *           "source": {
         *             "pointer": "/cluster/storage_size"
         *           }
         *         },
         *         {
         *           "status": "422",
         *           "code": "invalid_configuration",
         *           "id": "ed42afdc-f0d5-4c0d-b428-9fc6ed6e279d",
         *           "title": "Validation Failed",
         *           "detail": "The property '/cluster/storage_size' of type string did not match the following type: integer",
         *           "source": {
         *             "pointer": "/cluster/storage_size"
         *           }
         *         },
         *         {
         *           "status": "422",
         *           "code": "invalid_configuration",
         *           "id": "ed42afdc-f0d5-4c0d-b428-9fc6ed6e279d",
         *           "title": "Validation Failed",
         *           "detail": "The property '/cluster/storage_size' of type string did not match the following type: integer",
         *           "source": {
         *             "pointer": "/cluster/storage_size"
         *           }
         *         },
         *         {
         *           "status": "422",
         *           "code": "invalid_configuration",
         *           "id": "ed42afdc-f0d5-4c0d-b428-9fc6ed6e279d",
         *           "title": "Validation Failed",
         *           "detail": "The property '/cluster/storage_size' of type string did not match the following type: integer",
         *           "source": {
         *             "pointer": "/cluster/storage_size"
         *           }
         *         },
         *         {
         *           "status": "422",
         *           "code": "invalid_configuration",
         *           "id": "ed42afdc-f0d5-4c0d-b428-9fc6ed6e279d",
         *           "title": "Validation Failed",
         *           "detail": "The property '/cluster/storage_size' of type string did not match the following type: integer",
         *           "source": {
         *             "pointer": "/cluster/storage_size"
         *           }
         *         },
         *         {
         *           "status": "422",
         *           "code": "invalid_configuration",
         *           "id": "ed42afdc-f0d5-4c0d-b428-9fc6ed6e279d",
         *           "title": "Validation Failed",
         *           "detail": "The property '/cluster/storage_size' of type string did not match the following type: integer",
         *           "source": {
         *             "pointer": "/cluster/storage_size"
         *           }
         *         },
         *         {
         *           "status": "422",
         *           "code": "invalid_configuration",
         *           "id": "ed42afdc-f0d5-4c0d-b428-9fc6ed6e279d",
         *           "title": "Validation Failed",
         *           "detail": "The property '/cluster/storage_size' of type string did not match the following type: integer",
         *           "source": {
         *             "pointer": "/cluster/storage_size"
         *           }
         *         }
         *       ]
         *     } */
        "application/json": components["schemas"]["Failure"];
      };
    };
    /** @description Rate Limit Exceeded */
    RateLimitError: {
      headers: {
        /** @description The unique identifier for the API request. */
        "X-Request-Id"?: string;
        /** @description The maximum number of requests you're permitted to make per time period. */
        "X-RateLimit-Limit"?: number;
        /** @description The number of requests remaining in the current rate limit window. */
        "X-RateLimit-Remaining"?: number;
        /** @description The relative time in seconds until the current rate-limit window resets.
         *
         *     **Important:** This differs from Github and Twitter's same-named header which uses UTC epoch seconds. We use relative time to avoid client/server time synchronization issues. */
        "X-RateLimit-Reset"?: number;
        /** @description The number of seconds to wait until the rate limit window resets. Only sent when the rate limit is reached. */
        "Retry-After"?: number;
        [name: string]: unknown;
      };
      content?: never;
    };
    /** @description Oops, something went wrong! */
    DefaultSystemError: {
      headers: {
        /** @description The unique identifier for the API request. */
        "X-Request-Id"?: string;
        [name: string]: unknown;
      };
      content: {
        /** @example {
         *       "errors": [
         *         {
         *           "id": "ed42afdc-f0d5-4c0d-b428-9fc6ed6e279d",
         *           "status": "500",
         *           "code": "out_of_gas",
         *           "title": "DeLorean Out Of Gas",
         *           "detail": "The DeLorean has run out of gas, but Doc Brown will fill 'er up for you asap"
         *         }
         *       ]
         *     } */
        "application/json": components["schemas"]["Failure"];
      };
    };
    /** @description Unauthorized */
    "connect.v1.UnauthenticatedError": {
      headers: {
        [name: string]: unknown;
      };
      content: {
        /** @example {
         *       "error": {
         *         "code": 401,
         *         "message": "Unauthorized"
         *       }
         *     } */
        "application/json": components["schemas"]["connect.v1.ConnectorError"];
      };
    };
    /** @description Forbidden */
    "connect.v1.ForbiddenError": {
      headers: {
        [name: string]: unknown;
      };
      content: {
        /** @example {
         *       "error": {
         *         "code": 403,
         *         "message": "Forbidden"
         *       }
         *     } */
        "application/json": components["schemas"]["connect.v1.ConnectorError"];
      };
    };
    /** @description Not Found */
    "connect.v1.AccountNotFoundError": {
      headers: {
        [name: string]: unknown;
      };
      content: {
        /** @example {
         *       "error": {
         *         "code": 404,
         *         "message": "account not found"
         *       }
         *     } */
        "application/json": components["schemas"]["connect.v1.ConnectorError"];
      };
    };
    /** @description Not Found */
    "connect.v1.ResourceNotFoundError": {
      headers: {
        [name: string]: unknown;
      };
      content: {
        /** @example {
         *       "error": {
         *         "code": 404,
         *         "message": "resource not found"
         *       }
         *     } */
        "application/json": components["schemas"]["connect.v1.ConnectorError"];
      };
    };
    /** @description Internal Server Error */
    "connect.v1.DefaultSystemError": {
      headers: {
        [name: string]: unknown;
      };
      content: {
        /** @example {
         *       "error": {
         *         "code": 500,
         *         "message": "Oops, something went wrong"
         *       }
         *     } */
        "application/json": components["schemas"]["connect.v1.ConnectorError"];
      };
    };
    /** @description Bad Request */
    "connect.v1.BadRequestError": {
      headers: {
        [name: string]: unknown;
      };
      content: {
        /** @example {
         *       "error": {
         *         "code": 400,
         *         "message": "Bad Request"
         *       }
         *     } */
        "application/json": components["schemas"]["connect.v1.ConnectorError"];
      };
    };
    /** @description OK */
    "connect.v1.OK": {
      headers: {
        [name: string]: unknown;
      };
      content: {
        /** @example {
         *       "error": null
         *     } */
        "application/json": {
          error?: Record<string, unknown> | null;
        };
      };
    };
    /** @description The created topic. */
    CreateTopicResponse: {
      headers: {
        [name: string]: unknown;
      };
      content: {
        /** @example {
         *       "kind": "KafkaTopic",
         *       "metadata": {
         *         "self": "https://pkc-00000.region.provider.confluent.cloud/kafka/v3/clusters/cluster-1/topics/topic-X",
         *         "resource_name": "crn:///kafka=cluster-1/topic=topic-X"
         *       },
         *       "cluster_id": "cluster-1",
         *       "topic_name": "topic-X",
         *       "is_internal": false,
         *       "replication_factor": 3,
         *       "partitions_count": 1,
         *       "partitions": {
         *         "related": "https://pkc-00000.region.provider.confluent.cloud/kafka/v3/clusters/cluster-1/topics/topic-X/partitions"
         *       },
         *       "configs": {
         *         "related": "https://pkc-00000.region.provider.confluent.cloud/kafka/v3/clusters/cluster-1/topics/topic-X/configs"
         *       },
         *       "partition_reassignments": {
         *         "related": "https://pkc-00000.region.provider.confluent.cloud/kafka/v3/clusters/cluster-1/topics/topic-X/partitions/-/reassignments"
         *       }
         *     } */
        "application/json": components["schemas"]["TopicData"];
      };
    };
    /** @description The list of deleted ACLs. */
    DeleteAclsResponse: {
      headers: {
        [name: string]: unknown;
      };
      content: {
        /** @example {
         *       "data": [
         *         {
         *           "kind": "KafkaAcl",
         *           "metadata": {
         *             "self": "https://pkc-00000.region.provider.confluent.cloud/kafka/v3/clusters/cluster-1/acls?resource_type=TOPIC&resource_name=topic-&pattern_type=PREFIXED&principal=User%3Aalice&host=*&operation=ALL&permission=ALLOW"
         *           },
         *           "cluster_id": "cluster-1",
         *           "resource_type": "TOPIC",
         *           "resource_name": "topic-",
         *           "pattern_type": "PREFIXED",
         *           "principal": "User:alice",
         *           "host": "*",
         *           "operation": "ALL",
         *           "permission": "ALLOW"
         *         },
         *         {
         *           "kind": "KafkaAcl",
         *           "metadata": {
         *             "self": "https://pkc-00000.region.provider.confluent.cloud/kafka/v3/clusters/cluster-1/acls?resource_type=CLUSTER&resource_name=kafka-cluster&pattern_type=LITERAL&principal=User%3Aalice&host=*&operation=DESCRIBE&permission=DENY"
         *           },
         *           "cluster_id": "cluster-1",
         *           "resource_type": "CLUSTER",
         *           "resource_name": "kafka-cluster",
         *           "pattern_type": "LITERAL",
         *           "principal": "User:alice",
         *           "host": "*",
         *           "operation": "DESCRIBE",
         *           "permission": "DENY"
         *         }
         *       ]
         *     } */
        "application/json": {
          data: components["schemas"]["AclData"][];
        };
      };
    };
    /** @description The broker configuration parameter. */
    GetBrokerConfigResponse: {
      headers: {
        [name: string]: unknown;
      };
      content: {
        /** @example {
         *       "kind": "KafkaBrokerConfig",
         *       "metadata": {
         *         "self": "https://pkc-00000.region.provider.confluent.cloud/kafka/v3/clusters/cluster-1/brokers/1/configs/compression.type",
         *         "resource_name": "crn:///kafka=cluster-1/broker=1/config=compression.type"
         *       },
         *       "cluster_id": "cluster-1",
         *       "broker_id": 1,
         *       "name": "compression.type",
         *       "value": "gzip",
         *       "is_default": false,
         *       "is_read_only": false,
         *       "is_sensitive": false,
         *       "source": "DYNAMIC_BROKER_CONFIG",
         *       "synonyms": [
         *         {
         *           "name": "compression.type",
         *           "value": "gzip",
         *           "source": "DYNAMIC_BROKER_CONFIG"
         *         },
         *         {
         *           "name": "compression.type",
         *           "value": "producer",
         *           "source": "DEFAULT_CONFIG"
         *         }
         *       ]
         *     } */
        "application/json": components["schemas"]["BrokerConfigData"];
      };
    };
    /** @description The broker. */
    GetBrokerResponse: {
      headers: {
        [name: string]: unknown;
      };
      content: {
        /** @example {
         *       "kind": "KafkaBroker",
         *       "metadata": {
         *         "self": "https://pkc-00000.region.provider.confluent.cloud/kafka/v3/clusters/cluster-1/brokers/1",
         *         "resource_name": "crn:///kafka=cluster-1/broker=1"
         *       },
         *       "cluster_id": "cluster-1",
         *       "broker_id": 1,
         *       "host": "localhost",
         *       "port": 9291,
         *       "configs": {
         *         "related": "https://pkc-00000.region.provider.confluent.cloud/kafka/v3/clusters/cluster-1/brokers/1/configs"
         *       },
         *       "partition_replicas": {
         *         "related": "https://pkc-00000.region.provider.confluent.cloud/kafka/v3/clusters/cluster-1/brokers/1/partition-replicas"
         *       }
         *     } */
        "application/json": components["schemas"]["BrokerData"];
      };
    };
    /** @description The cluster configuration parameter. */
    GetClusterConfigResponse: {
      headers: {
        [name: string]: unknown;
      };
      content: {
        /** @example {
         *       "kind": "KafkaClusterConfig",
         *       "metadata": {
         *         "self": "https://pkc-00000.region.provider.confluent.cloud/kafka/v3/clusters/cluster-1/broker-configs/compression.type",
         *         "resource_name": "crn:///kafka=cluster-1/broker-config=compression.type"
         *       },
         *       "cluster_id": "cluster-1",
         *       "config_type": "BROKER",
         *       "name": "compression.type",
         *       "value": "gzip",
         *       "is_default": false,
         *       "is_read_only": false,
         *       "is_sensitive": false,
         *       "source": "DYNAMIC_DEFAULT_BROKER_CONFIG",
         *       "synonyms": [
         *         {
         *           "name": "compression.type",
         *           "value": "gzip",
         *           "source": "DYNAMIC_DEFAULT_BROKER_CONFIG"
         *         },
         *         {
         *           "name": "compression.type",
         *           "value": "producer",
         *           "source": "DEFAULT_CONFIG"
         *         }
         *       ]
         *     } */
        "application/json": components["schemas"]["ClusterConfigData"];
      };
    };
    /** @description The Kafka cluster. */
    GetClusterResponse: {
      headers: {
        [name: string]: unknown;
      };
      content: {
        /** @example {
         *       "kind": "KafkaCluster",
         *       "metadata": {
         *         "self": "https://pkc-00000.region.provider.confluent.cloud/kafka/v3/clusters/cluster-1",
         *         "resource_name": "crn:///kafka=cluster-1"
         *       },
         *       "cluster_id": "cluster-1",
         *       "controller": {
         *         "related": "https://pkc-00000.region.provider.confluent.cloud/kafka/v3/clusters/cluster-1/brokers/1"
         *       },
         *       "acls": {
         *         "related": "https://pkc-00000.region.provider.confluent.cloud/kafka/v3/clusters/cluster-1/acls"
         *       },
         *       "brokers": {
         *         "related": "https://pkc-00000.region.provider.confluent.cloud/kafka/v3/clusters/cluster-1/brokers"
         *       },
         *       "broker_configs": {
         *         "related": "https://pkc-00000.region.provider.confluent.cloud/kafka/v3/clusters/cluster-1/broker-configs"
         *       },
         *       "consumer_groups": {
         *         "related": "https://pkc-00000.region.provider.confluent.cloud/kafka/v3/clusters/cluster-1/consumer-groups"
         *       },
         *       "topics": {
         *         "related": "https://pkc-00000.region.provider.confluent.cloud/kafka/v3/clusters/cluster-1/topics"
         *       },
         *       "partition_reassignments": {
         *         "related": "https://pkc-00000.region.provider.confluent.cloud/kafka/v3/clusters/cluster-1/topics/-/partitions/-/reassignment"
         *       }
         *     } */
        "application/json": components["schemas"]["ClusterData"];
      };
    };
    /** @description The consumer group assignment. */
    GetConsumerAssignmentResponse: {
      headers: {
        [name: string]: unknown;
      };
      content: {
        /** @example {
         *       "kind": "KafkaConsumerAssignment",
         *       "metadata": {
         *         "self": "https://pkc-00000.region.provider.confluent.cloud/kafka/v3/clusters/cluster-1/consumer-groups/consumer-group-1/consumers/consumer-1/assignments/topic-1/partitions/1",
         *         "resource_name": "crn:///kafka=cluster-1/consumer-group=consumer-group-1/consumer=consumer-1/assignment=topic=1/partition=1"
         *       },
         *       "cluster_id": "cluster-1",
         *       "consumer_group_id": "consumer-group-1",
         *       "consumer_id": "consumer-1",
         *       "topic_name": "topic-1",
         *       "partition_id": 1,
         *       "partition": {
         *         "related": "https://pkc-00000.region.provider.confluent.cloud/kafka/v3/clusters/cluster-1/topics/topic-1/partitions/1"
         *       },
         *       "lag": {
         *         "related": "https://pkc-00000.region.provider.confluent.cloud/kafka/v3/clusters/cluster-1/consumer-groups/consumer-group-1/lags/topic-1/partitions/1"
         *       }
         *     } */
        "application/json": components["schemas"]["ConsumerAssignmentData"];
      };
    };
    /** @description The consumer group. */
    GetConsumerGroupResponse: {
      headers: {
        [name: string]: unknown;
      };
      content: {
        /** @example {
         *       "kind": "KafkaConsumerGroup",
         *       "metadata": {
         *         "self": "https://pkc-00000.region.provider.confluent.cloud/kafka/v3/clusters/cluster-1/consumer-groups/consumer-group-1",
         *         "resource_name": "crn:///kafka=cluster-1/consumer-group=consumer-group-1"
         *       },
         *       "cluster_id": "cluster-1",
         *       "consumer_group_id": "consumer-group-1",
         *       "is_simple": false,
         *       "partition_assignor": "org.apache.kafka.clients.consumer.RoundRobinAssignor",
         *       "state": "STABLE",
         *       "coordinator": {
         *         "related": "https://pkc-00000.region.provider.confluent.cloud/kafka/v3/clusters/cluster-1/brokers/1"
         *       },
         *       "consumers": {
         *         "related": "https://pkc-00000.region.provider.confluent.cloud/kafka/v3/clusters/cluster-1/consumer-groups/consumer-group-1/consumers"
         *       },
         *       "lag_summary": {
         *         "related": "https://pkc-00000.region.provider.confluent.cloud/kafka/v3/clusters/cluster-1/consumer-groups/consumer-group-1/lag-summary"
         *       }
         *     } */
        "application/json": components["schemas"]["ConsumerGroupData"];
      };
    };
    /** @description The max and total consumer lag in a consumer group. */
    GetConsumerGroupLagSummaryResponse: {
      headers: {
        [name: string]: unknown;
      };
      content: {
        /** @example {
         *       "kind": "KafkaConsumerGroupLagSummary",
         *       "metadata": {
         *         "self": "https://pkc-00000.region.provider.confluent.cloud/kafka/v3/clusters/cluster-1/consumer-groups/consumer-group-1/lag-summary",
         *         "resource_name": "crn:///kafka=cluster-1/consumer-groups=consumer-group-1/lag-summary"
         *       },
         *       "cluster_id": "cluster-1",
         *       "consumer_group_id": "consumer-group-1",
         *       "max_lag_consumer_id": "consumer-1",
         *       "max_lag_instance_id": "consumer-instance-1",
         *       "max_lag_client_id": "client-1",
         *       "max_lag_topic_name": "topic-1",
         *       "max_lag_partition_id": 1,
         *       "max_lag": 100,
         *       "total_lag": 110,
         *       "max_lag_consumer": {
         *         "related": "https://pkc-00000.region.provider.confluent.cloud/kafka/v3/clusters/cluster-1/consumer-groups/consumer-group-1/consumers/consumer-1"
         *       },
         *       "max_lag_partition": {
         *         "related": "https://pkc-00000.region.provider.confluent.cloud/kafka/v3/clusters/cluster-1/topics/topic-1/partitions/1"
         *       }
         *     } */
        "application/json": components["schemas"]["ConsumerGroupLagSummaryData"];
      };
    };
    /** @description The consumer lag. */
    GetConsumerLagResponse: {
      headers: {
        [name: string]: unknown;
      };
      content: {
        /** @example {
         *       "kind": "KafkaConsumerLag",
         *       "metadata": {
         *         "self": "https://pkc-00000.region.provider.confluent.cloud/kafka/v3/clusters/cluster-1/consumer-groups/consumer-group-1/lags/topic-1/partitions/1",
         *         "resource_name": "crn:///kafka=cluster-1/consumer-group=consumer-group-1/lag=topic-1/partition=1"
         *       },
         *       "cluster_id": "cluster-1",
         *       "consumer_group_id": "consumer-group-1",
         *       "topic_name": "topic-1",
         *       "partition_id": 1,
         *       "consumer_id": "consumer-1",
         *       "instance_id": "consumer-instance-1",
         *       "client_id": "client-1",
         *       "current_offset": 1,
         *       "log_end_offset": 101,
         *       "lag": 100
         *     } */
        "application/json": components["schemas"]["ConsumerLagData"];
      };
    };
    /** @description The consumer. */
    GetConsumerResponse: {
      headers: {
        [name: string]: unknown;
      };
      content: {
        /** @example {
         *       "kind": "KafkaConsumer",
         *       "metadata": {
         *         "self": "https://pkc-00000.region.provider.confluent.cloud/kafka/v3/clusters/cluster-1/consumer-groups/consumer-group-1/consumers/consumer-1",
         *         "resource_name": "crn:///kafka=cluster-1/consumer-group=consumer-group-1/consumer=consumer-1"
         *       },
         *       "cluster_id": "cluster-1",
         *       "consumer_group_id": "consumer-group-1",
         *       "consumer_id": "consumer-1",
         *       "instance_id": "consumer-instance-1",
         *       "client_id": "client-1",
         *       "assignments": {
         *         "related": "https://pkc-00000.region.provider.confluent.cloud/kafka/v3/clusters/cluster-1/consumer-groups/consumer-group-1/consumers/consumer-1/assignments"
         *       }
         *     } */
        "application/json": components["schemas"]["ConsumerData"];
      };
    };
    /** @description The partition */
    GetPartitionResponse: {
      headers: {
        [name: string]: unknown;
      };
      content: {
        /** @example {
         *       "kind": "KafkaPartition",
         *       "metadata": {
         *         "self": "https://pkc-00000.region.provider.confluent.cloud/kafka/v3/clusters/cluster-1/topics/topic-1/partitions/1",
         *         "resource_name": "crn:///kafka=cluster-1/topic=topic-1/partition=1"
         *       },
         *       "cluster_id": "cluster-1",
         *       "topic_name": "topic-1",
         *       "partition_id": 1,
         *       "leader": {
         *         "related": "https://pkc-00000.region.provider.confluent.cloud/kafka/v3/clusters/cluster-1/topics/topic-1/partitions/1/replicas/1"
         *       },
         *       "replicas": {
         *         "related": "https://pkc-00000.region.provider.confluent.cloud/kafka/v3/clusters/cluster-1/topics/topic-1/partitions/1/replicas"
         *       },
         *       "reassignment": {
         *         "related": "https://pkc-00000.region.provider.confluent.cloud/kafka/v3/clusters/cluster-1/topics/topic-1/partitions/1/reassignment"
         *       }
         *     } */
        "application/json": components["schemas"]["PartitionData"];
      };
    };
    /** @description The ongoing replicas reassignments. */
    GetReassignmentResponse: {
      headers: {
        [name: string]: unknown;
      };
      content: {
        /** @example {
         *       "kind": "KafkaReassignment",
         *       "metadata": {
         *         "self": "https://pkc-00000.region.provider.confluent.cloud/kafka/v3/clusters/cluster-1/topics/topic-1/partitions/1/reassignment",
         *         "resource_name": "crn:///kafka=cluster-1/topic=topic-1/partition=1/reassignment"
         *       },
         *       "cluster_id": "cluster-1",
         *       "topic_name": "topic-1",
         *       "partition_id": 1,
         *       "adding_replicas": [
         *         1,
         *         2
         *       ],
         *       "removing_replicas": [
         *         3
         *       ],
         *       "replicas": {
         *         "related": "https://pkc-00000.region.provider.confluent.cloud/kafka/v3/clusters/cluster-1/topics/topic-1/partitions/1/replicas"
         *       }
         *     } */
        "application/json": components["schemas"]["ReassignmentData"];
      };
    };
    /** @description The replica. */
    GetReplicaResponse: {
      headers: {
        [name: string]: unknown;
      };
      content: {
        /** @example {
         *       "kind": "KafkaReplica",
         *       "metadata": {
         *         "self": "https://pkc-00000.region.provider.confluent.cloud/kafka/v3/clusters/cluster-1/topics/topic-1/partitions/1/replicas/1",
         *         "resource_name": "crn:///kafka=cluster-1/topic=topic-1/partition=1/replica=1"
         *       },
         *       "cluster_id": "cluster-1",
         *       "topic_name": "topic-1",
         *       "partition_id": 1,
         *       "broker_id": 1,
         *       "is_leader": true,
         *       "is_in_sync": true,
         *       "broker": {
         *         "related": "https://pkc-00000.region.provider.confluent.cloud/kafka/v3/clusters/cluster-1/brokers/1"
         *       }
         *     } */
        "application/json": components["schemas"]["ReplicaData"];
      };
    };
    /** @description The topic configuration parameter. */
    GetTopicConfigResponse: {
      headers: {
        [name: string]: unknown;
      };
      content: {
        /** @example {
         *       "kind": "KafkaTopicConfig",
         *       "metadata": {
         *         "self": "https://pkc-00000.region.provider.confluent.cloud/kafka/v3/clusters/cluster-1/topics/topic-1/compression.type",
         *         "resource_name": "crn:///kafka=cluster-1/topic=topic-1/config=compression.type"
         *       },
         *       "cluster_id": "cluster-1",
         *       "topic_name": "topic-1",
         *       "name": "compression.type",
         *       "value": "gzip",
         *       "is_default": false,
         *       "is_read_only": false,
         *       "is_sensitive": false,
         *       "source": "DYNAMIC_TOPIC_CONFIG",
         *       "synonyms": [
         *         {
         *           "name": "compression.type",
         *           "value": "gzip",
         *           "source": "DYNAMIC_TOPIC_CONFIG"
         *         },
         *         {
         *           "name": "compression.type",
         *           "value": "producer",
         *           "source": "DEFAULT_CONFIG"
         *         }
         *       ]
         *     } */
        "application/json": components["schemas"]["TopicConfigData"];
      };
    };
    /** @description The topic. */
    GetTopicResponse: {
      headers: {
        [name: string]: unknown;
      };
      content: {
        /** @example {
         *       "kind": "KafkaTopic",
         *       "metadata": {
         *         "self": "https://pkc-00000.region.provider.confluent.cloud/kafka/v3/clusters/cluster-1/topics/topic-1",
         *         "resource_name": "crn:///kafka=cluster-1/topic=topic-1"
         *       },
         *       "cluster_id": "cluster-1",
         *       "topic_name": "topic-1",
         *       "is_internal": false,
         *       "replication_factor": 3,
         *       "partitions_count": 1,
         *       "partitions": {
         *         "related": "https://pkc-00000.region.provider.confluent.cloud/kafka/v3/clusters/cluster-1/topics/topic-1/partitions"
         *       },
         *       "configs": {
         *         "related": "https://pkc-00000.region.provider.confluent.cloud/kafka/v3/clusters/cluster-1/topics/topic-1/configs"
         *       },
         *       "partition_reassignments": {
         *         "related": "https://pkc-00000.region.provider.confluent.cloud/kafka/v3/clusters/cluster-1/topics/topic-1/partitions/-/reassignments"
         *       }
         *     } */
        "application/json": components["schemas"]["TopicData"];
      };
    };
    /** @description The ongoing replicas reassignments. */
    ListAllReassignmentsResponse: {
      headers: {
        [name: string]: unknown;
      };
      content: {
        /** @example {
         *       "kind": "KafkaReassignmentList",
         *       "metadata": {
         *         "self": "https://pkc-00000.region.provider.confluent.cloud/kafka/v3/clusters/cluster-1/topics/-/partitions/-/reassignment",
         *         "next": null
         *       },
         *       "data": [
         *         {
         *           "kind": "KafkaReassignment",
         *           "metadata": {
         *             "self": "https://pkc-00000.region.provider.confluent.cloud/kafka/v3/clusters/cluster-1/topics/topic-1/partitions/1/reassignment",
         *             "resource_name": "crn:///kafka=cluster-1/topic=topic-1/partition=1/reassignment"
         *           },
         *           "cluster_id": "cluster-1",
         *           "topic_name": "topic-1",
         *           "partition_id": 1,
         *           "adding_replicas": [
         *             1,
         *             2
         *           ],
         *           "removing_replicas": [
         *             3
         *           ],
         *           "replicas": {
         *             "related": "https://pkc-00000.region.provider.confluent.cloud/kafka/v3/clusters/cluster-1/topics/topic-1/partitions/1/replicas"
         *           }
         *         },
         *         {
         *           "kind": "KafkaReassignment",
         *           "metadata": {
         *             "self": "https://pkc-00000.region.provider.confluent.cloud/kafka/v3/clusters/cluster-1/topics/topic-2/partitions/2/reassignment",
         *             "resource_name": "crn:///kafka=cluster-1/topic=topic-2/partition=2/reassignment"
         *           },
         *           "cluster_id": "cluster-1",
         *           "topic_name": "topic-2",
         *           "partition_id": 2,
         *           "adding_replicas": [
         *             1
         *           ],
         *           "removing_replicas": [
         *             2,
         *             3
         *           ],
         *           "replicas": {
         *             "related": "https://pkc-00000.region.provider.confluent.cloud/kafka/v3/clusters/cluster-1/topics/topic-2/partitions/2/replicas"
         *           }
         *         },
         *         {
         *           "kind": "KafkaReassignment",
         *           "metadata": {
         *             "self": "https://pkc-00000.region.provider.confluent.cloud/kafka/v3/clusters/cluster-1/topics/topic-3/partitions/3/reassignment",
         *             "resource_name": "crn:///kafka=cluster-1/topic=topic-3/partition=3/reassignment"
         *           },
         *           "cluster_id": "cluster-1",
         *           "topic_name": "topic-3",
         *           "partition_id": 3,
         *           "adding_replicas": [
         *             3
         *           ],
         *           "removing_replicas": [
         *             1,
         *             2
         *           ],
         *           "replicas": {
         *             "related": "https://pkc-00000.region.provider.confluent.cloud/kafka/v3/clusters/cluster-1/topics/topic-3/partitions/3/replicas"
         *           }
         *         }
         *       ]
         *     } */
        "application/json": components["schemas"]["ReassignmentDataList"];
      };
    };
    /** @description The list of broker configs. */
    ListBrokerConfigsResponse: {
      headers: {
        [name: string]: unknown;
      };
      content: {
        /** @example {
         *       "kind": "KafkaBrokerConfigList",
         *       "metadata": {
         *         "self": "https://pkc-00000.region.provider.confluent.cloud/kafka/v3/clusters/cluster-1/brokers/1/configs",
         *         "next": null
         *       },
         *       "data": [
         *         {
         *           "kind": "KafkaBrokerConfig",
         *           "metadata": {
         *             "self": "https://pkc-00000.region.provider.confluent.cloud/kafka/v3/clusters/cluster-1/brokers/1/configs/max.connections",
         *             "resource_name": "crn:///kafka=cluster-1/broker=1/config=max.connections"
         *           },
         *           "cluster_id": "cluster-1",
         *           "broker_id": 1,
         *           "name": "max.connections",
         *           "value": "1000",
         *           "is_default": false,
         *           "is_read_only": false,
         *           "is_sensitive": false,
         *           "source": "DYNAMIC_BROKER_CONFIG",
         *           "synonyms": [
         *             {
         *               "name": "max.connections",
         *               "value": "1000",
         *               "source": "DYNAMIC_BROKER_CONFIG"
         *             },
         *             {
         *               "name": "max.connections",
         *               "value": "2147483647",
         *               "source": "DEFAULT_CONFIG"
         *             }
         *           ]
         *         },
         *         {
         *           "kind": "KafkaBrokerConfig",
         *           "metadata": {
         *             "self": "https://pkc-00000.region.provider.confluent.cloud/kafka/v3/clusters/cluster-1/brokers/1/configs/compression.type",
         *             "resource_name": "crn:///kafka=cluster-1/broker=1/config=compression.type"
         *           },
         *           "cluster_id": "cluster-1",
         *           "broker_id": 1,
         *           "name": "compression.type",
         *           "value": "gzip",
         *           "is_default": false,
         *           "is_read_only": false,
         *           "is_sensitive": false,
         *           "source": "DYNAMIC_BROKER_CONFIG",
         *           "synonyms": [
         *             {
         *               "name": "compression.type",
         *               "value": "gzip",
         *               "source": "DYNAMIC_BROKER_CONFIG"
         *             },
         *             {
         *               "name": "compression.type",
         *               "value": "producer",
         *               "source": "DEFAULT_CONFIG"
         *             }
         *           ]
         *         }
         *       ]
         *     } */
        "application/json": components["schemas"]["BrokerConfigDataList"];
      };
    };
    /** @description The list of brokers. */
    ListBrokersResponse: {
      headers: {
        [name: string]: unknown;
      };
      content: {
        /** @example {
         *       "kind": "KafkaBrokerList",
         *       "metadata": {
         *         "self": "https://pkc-00000.region.provider.confluent.cloud/kafka/v3/clusters/cluster-1/brokers",
         *         "next": null
         *       },
         *       "data": [
         *         {
         *           "kind": "KafkaBroker",
         *           "metadata": {
         *             "self": "https://pkc-00000.region.provider.confluent.cloud/kafka/v3/clusters/cluster-1/brokers/1",
         *             "resource_name": "crn:///kafka=cluster-1/broker=1"
         *           },
         *           "cluster_id": "cluster-1",
         *           "broker_id": 1,
         *           "host": "localhost",
         *           "port": 9291,
         *           "configs": {
         *             "related": "https://pkc-00000.region.provider.confluent.cloud/kafka/v3/clusters/cluster-1/brokers/1/configs"
         *           },
         *           "partition_replicas": {
         *             "related": "https://pkc-00000.region.provider.confluent.cloud/kafka/v3/clusters/cluster-1/brokers/1/partition-replicas"
         *           }
         *         },
         *         {
         *           "kind": "KafkaBroker",
         *           "metadata": {
         *             "self": "https://pkc-00000.region.provider.confluent.cloud/kafka/v3/clusters/cluster-1/brokers/2",
         *             "resource_name": "crn:///kafka=cluster-1/broker=2"
         *           },
         *           "cluster_id": "cluster-1",
         *           "broker_id": 2,
         *           "host": "localhost",
         *           "port": 9292,
         *           "configs": {
         *             "related": "https://pkc-00000.region.provider.confluent.cloud/kafka/v3/clusters/cluster-1/brokers/2/configs"
         *           },
         *           "partition_replicas": {
         *             "related": "https://pkc-00000.region.provider.confluent.cloud/kafka/v3/clusters/cluster-1/brokers/2/partition-replicas"
         *           }
         *         },
         *         {
         *           "kind": "KafkaBroker",
         *           "metadata": {
         *             "self": "https://pkc-00000.region.provider.confluent.cloud/kafka/v3/clusters/cluster-1/brokers/3",
         *             "resource_name": "crn:///kafka=cluster-1/broker=3"
         *           },
         *           "cluster_id": "cluster-1",
         *           "broker_id": 3,
         *           "host": "localhost",
         *           "port": 9293,
         *           "configs": {
         *             "related": "https://pkc-00000.region.provider.confluent.cloud/kafka/v3/clusters/cluster-1/brokers/3/configs"
         *           },
         *           "partition_replicas": {
         *             "related": "https://pkc-00000.region.provider.confluent.cloud/kafka/v3/clusters/cluster-1/brokers/3/partition-replicas"
         *           }
         *         }
         *       ]
         *     } */
        "application/json": components["schemas"]["BrokerDataList"];
      };
    };
    /** @description The list of cluster configs. */
    ListClusterConfigsResponse: {
      headers: {
        [name: string]: unknown;
      };
      content: {
        /** @example {
         *       "kind": "KafkaClusterConfigList",
         *       "metadata": {
         *         "self": "https://pkc-00000.region.provider.confluent.cloud/kafka/v3/clusters/cluster-1/broker-configs",
         *         "next": null
         *       },
         *       "data": [
         *         {
         *           "kind": "KafkaClusterConfig",
         *           "metadata": {
         *             "self": "https://pkc-00000.region.provider.confluent.cloud/kafka/v3/clusters/cluster-1/broker-configs/max.connections",
         *             "resource_name": "crn:///kafka=cluster-1/broker-config=max.connections"
         *           },
         *           "cluster_id": "cluster-1",
         *           "config_type": "BROKER",
         *           "name": "max.connections",
         *           "value": "1000",
         *           "is_default": false,
         *           "is_read_only": false,
         *           "is_sensitive": false,
         *           "source": "DYNAMIC_DEFAULT_BROKER_CONFIG",
         *           "synonyms": [
         *             {
         *               "name": "max.connections",
         *               "value": "1000",
         *               "source": "DYNAMIC_DEFAULT_BROKER_CONFIG"
         *             },
         *             {
         *               "name": "max.connections",
         *               "value": "2147483647",
         *               "source": "DEFAULT_CONFIG"
         *             }
         *           ]
         *         },
         *         {
         *           "kind": "KafkaClusterConfig",
         *           "metadata": {
         *             "self": "https://pkc-00000.region.provider.confluent.cloud/kafka/v3/clusters/cluster-1/broker-configs/compression.type",
         *             "resource_name": "crn:///kafka=cluster-1/broker-config=compression.type"
         *           },
         *           "cluster_id": "cluster-1",
         *           "config_type": "BROKER",
         *           "name": "compression.type",
         *           "value": "gzip",
         *           "is_default": false,
         *           "is_read_only": false,
         *           "is_sensitive": false,
         *           "source": "DYNAMIC_DEFAULT_BROKER_CONFIG",
         *           "synonyms": [
         *             {
         *               "name": "compression.type",
         *               "value": "gzip",
         *               "source": "DYNAMIC_DEFAULT_BROKER_CONFIG"
         *             },
         *             {
         *               "name": "compression.type",
         *               "value": "producer",
         *               "source": "DEFAULT_CONFIG"
         *             }
         *           ]
         *         }
         *       ]
         *     } */
        "application/json": components["schemas"]["ClusterConfigDataList"];
      };
    };
    /** @description The list of Kafka clusters. */
    ListClustersResponse: {
      headers: {
        [name: string]: unknown;
      };
      content: {
        /** @example {
         *       "kind": "KafkaClusterList",
         *       "metadata": {
         *         "self": "https://pkc-00000.region.provider.confluent.cloud/kafka/v3/clusters",
         *         "next": null
         *       },
         *       "data": [
         *         {
         *           "kind": "KafkaCluster",
         *           "metadata": {
         *             "self": "https://pkc-00000.region.provider.confluent.cloud/kafka/v3/clusters/cluster-1",
         *             "resource_name": "crn:///kafka=cluster-1"
         *           },
         *           "cluster_id": "cluster-1",
         *           "controller": {
         *             "related": "https://pkc-00000.region.provider.confluent.cloud/kafka/v3/clusters/cluster-1/brokers/1"
         *           },
         *           "acls": {
         *             "related": "https://pkc-00000.region.provider.confluent.cloud/kafka/v3/clusters/cluster-1/acls"
         *           },
         *           "brokers": {
         *             "related": "https://pkc-00000.region.provider.confluent.cloud/kafka/v3/clusters/cluster-1/brokers"
         *           },
         *           "broker_configs": {
         *             "related": "https://pkc-00000.region.provider.confluent.cloud/kafka/v3/clusters/cluster-1/broker-configs"
         *           },
         *           "consumer_groups": {
         *             "related": "https://pkc-00000.region.provider.confluent.cloud/kafka/v3/clusters/cluster-1/consumer-groups"
         *           },
         *           "topics": {
         *             "related": "https://pkc-00000.region.provider.confluent.cloud/kafka/v3/clusters/cluster-1/topics"
         *           },
         *           "partition_reassignments": {
         *             "related": "https://pkc-00000.region.provider.confluent.cloud/kafka/v3/clusters/cluster-1/topics/-/partitions/-/reassignment"
         *           }
         *         }
         *       ]
         *     } */
        "application/json": components["schemas"]["ClusterDataList"];
      };
    };
    /** @description The list of consumer group assignments. */
    ListConsumerAssignmentsResponse: {
      headers: {
        [name: string]: unknown;
      };
      content: {
        /** @example {
         *       "kind": "KafkaConsumerAssignmentList",
         *       "metadata": {
         *         "self": "https://pkc-00000.region.provider.confluent.cloud/kafka/v3/clusters/cluster-1/consumer-groups/consumer-group-1/consumers/consumer-1/assignments",
         *         "next": null
         *       },
         *       "data": [
         *         {
         *           "kind": "KafkaConsumerAssignment",
         *           "metadata": {
         *             "self": "https://pkc-00000.region.provider.confluent.cloud/kafka/v3/clusters/cluster-1/consumer-groups/consumer-group-1/consumers/consumer-1/assignments/topic-1/partitions/1",
         *             "resource_name": "crn:///kafka=cluster-1/consumer-group=consumer-group-1/consumer=consumer-1/assignment=topic=1/partition=1"
         *           },
         *           "cluster_id": "cluster-1",
         *           "consumer_group_id": "consumer-group-1",
         *           "consumer_id": "consumer-1",
         *           "topic_name": "topic-1",
         *           "partition_id": 1,
         *           "partition": {
         *             "related": "https://pkc-00000.region.provider.confluent.cloud/kafka/v3/clusters/cluster-1/topics/topic-1/partitions/1"
         *           },
         *           "lag": {
         *             "related": "https://pkc-00000.region.provider.confluent.cloud/kafka/v3/clusters/cluster-1/consumer-groups/consumer-group-1/lags/topic-1/partitions/1"
         *           }
         *         },
         *         {
         *           "kind": "KafkaConsumerAssignment",
         *           "metadata": {
         *             "self": "https://pkc-00000.region.provider.confluent.cloud/kafka/v3/clusters/cluster-1/consumer-groups/consumer-group-1/consumers/consumer-1/assignments/topic-2/partitions/2",
         *             "resource_name": "crn:///kafka=cluster-1/consumer-group=consumer-group-1/consumer=consumer-1/assignment=topic=2/partition=2"
         *           },
         *           "cluster_id": "cluster-1",
         *           "consumer_group_id": "consumer-group-1",
         *           "consumer_id": "consumer-1",
         *           "topic_name": "topic-2",
         *           "partition_id": 2,
         *           "partition": {
         *             "related": "https://pkc-00000.region.provider.confluent.cloud/kafka/v3/clusters/cluster-1/topics/topic-2/partitions/2"
         *           },
         *           "lag": {
         *             "related": "https://pkc-00000.region.provider.confluent.cloud/kafka/v3/clusters/cluster-1/consumer-groups/consumer-group-1/lags/topic-2/partitions/2"
         *           }
         *         },
         *         {
         *           "kind": "KafkaConsumerAssignment",
         *           "metadata": {
         *             "self": "https://pkc-00000.region.provider.confluent.cloud/kafka/v3/clusters/cluster-1/consumer-groups/consumer-group-1/consumers/consumer-1/assignments/topic-3/partitions/3",
         *             "resource_name": "crn:///kafka=cluster-1/consumer-group=consumer-group-1/consumer=consumer-1/assignment=topic=3/partition=3"
         *           },
         *           "cluster_id": "cluster-1",
         *           "consumer_group_id": "consumer-group-1",
         *           "consumer_id": "consumer-1",
         *           "topic_name": "topic-3",
         *           "partition_id": 3,
         *           "partition": {
         *             "related": "https://pkc-00000.region.provider.confluent.cloud/kafka/v3/clusters/cluster-1/topics/topic-3/partitions/3"
         *           },
         *           "lag": {
         *             "related": "https://pkc-00000.region.provider.confluent.cloud/kafka/v3/clusters/cluster-1/consumer-groups/consumer-group-1/lags/topic-3/partitions/3"
         *           }
         *         }
         *       ]
         *     } */
        "application/json": components["schemas"]["ConsumerAssignmentDataList"];
      };
    };
    /** @description The list of consumer groups. */
    ListConsumerGroupsResponse: {
      headers: {
        [name: string]: unknown;
      };
      content: {
        /** @example {
         *       "kind": "KafkaConsumerGroupList",
         *       "metadata": {
         *         "self": "https://pkc-00000.region.provider.confluent.cloud/kafka/v3/clusters/cluster-1/consumer-groups",
         *         "next": null
         *       },
         *       "data": [
         *         {
         *           "kind": "KafkaConsumerGroup",
         *           "metadata": {
         *             "self": "https://pkc-00000.region.provider.confluent.cloud/kafka/v3/clusters/cluster-1/consumer-groups/consumer-group-1",
         *             "resource_name": "crn:///kafka=cluster-1/consumer-group=consumer-group-1"
         *           },
         *           "cluster_id": "cluster-1",
         *           "consumer_group_id": "consumer-group-1",
         *           "is_simple": false,
         *           "partition_assignor": "org.apache.kafka.clients.consumer.RoundRobinAssignor",
         *           "state": "STABLE",
         *           "coordinator": {
         *             "related": "https://pkc-00000.region.provider.confluent.cloud/kafka/v3/clusters/cluster-1/brokers/1"
         *           },
         *           "consumers": {
         *             "related": "https://pkc-00000.region.provider.confluent.cloud/kafka/v3/clusters/cluster-1/consumer-groups/consumer-group-1/consumers"
         *           },
         *           "lag_summary": {
         *             "related": "https://pkc-00000.region.provider.confluent.cloud/kafka/v3/clusters/cluster-1/consumer-groups/consumer-group-1/lag-summary"
         *           }
         *         },
         *         {
         *           "kind": "KafkaConsumerGroup",
         *           "metadata": {
         *             "self": "https://pkc-00000.region.provider.confluent.cloud/kafka/v3/clusters/cluster-1/consumer-groups/consumer-group-2",
         *             "resource_name": "crn:///kafka=cluster-1/consumer-group=consumer-group-2"
         *           },
         *           "cluster_id": "cluster-1",
         *           "consumer_group_id": "consumer-group-2",
         *           "is_simple": false,
         *           "partition_assignor": "org.apache.kafka.clients.consumer.StickyAssignor",
         *           "state": "PREPARING_REBALANCE",
         *           "coordinator": {
         *             "related": "https://pkc-00000.region.provider.confluent.cloud/kafka/v3/clusters/cluster-1/brokers/2"
         *           },
         *           "consumers": {
         *             "related": "https://pkc-00000.region.provider.confluent.cloud/kafka/v3/clusters/cluster-1/consumer-groups/consumer-group-2/consumers"
         *           },
         *           "lag_summary": {
         *             "related": "https://pkc-00000.region.provider.confluent.cloud/kafka/v3/clusters/cluster-1/consumer-groups/consumer-group-2/lag-summary"
         *           }
         *         },
         *         {
         *           "kind": "KafkaConsumerGroup",
         *           "metadata": {
         *             "self": "https://pkc-00000.region.provider.confluent.cloud/kafka/v3/clusters/cluster-1/consumer-groups/consumer-group-3",
         *             "resource_name": "crn:///kafka=cluster-1/consumer-group=consumer-group-3"
         *           },
         *           "cluster_id": "cluster-1",
         *           "consumer_group_id": "consumer-group-3",
         *           "is_simple": false,
         *           "partition_assignor": "org.apache.kafka.clients.consumer.RangeAssignor",
         *           "state": "DEAD",
         *           "coordinator": {
         *             "related": "https://pkc-00000.region.provider.confluent.cloud/kafka/v3/clusters/cluster-1/brokers/3"
         *           },
         *           "consumers": {
         *             "related": "https://pkc-00000.region.provider.confluent.cloud/kafka/v3/clusters/cluster-1/consumer-groups/consumer-group-3/consumers"
         *           },
         *           "lag_summary": {
         *             "related": "https://pkc-00000.region.provider.confluent.cloud/kafka/v3/clusters/cluster-1/consumer-groups/consumer-group-3/lag-summary"
         *           }
         *         }
         *       ]
         *     } */
        "application/json": components["schemas"]["ConsumerGroupDataList"];
      };
    };
    /** @description The list of consumer lags. */
    ListConsumerLagsResponse: {
      headers: {
        [name: string]: unknown;
      };
      content: {
        /** @example {
         *       "kind": "KafkaConsumerLagList",
         *       "metadata": {
         *         "self": "https://pkc-00000.region.provider.confluent.cloud/kafka/v3/clusters/cluster-1/consumer-groups/consumer-group-1/lags",
         *         "next": null
         *       },
         *       "data": [
         *         {
         *           "kind": "KafkaConsumerLag",
         *           "metadata": {
         *             "self": "https://pkc-00000.region.provider.confluent.cloud/kafka/v3/clusters/cluster-1/consumer-groups/consumer-group-1/lags/topic-1/partitions/1",
         *             "resource_name": "crn:///kafka=cluster-1/consumer-group=consumer-group-1/lag=topic-1/partition=1"
         *           },
         *           "cluster_id": "cluster-1",
         *           "consumer_group_id": "consumer-group-1",
         *           "topic_name": "topic-1",
         *           "partition_id": 1,
         *           "consumer_id": "consumer-1",
         *           "instance_id": "consumer-instance-1",
         *           "client_id": "client-1",
         *           "current_offset": 1,
         *           "log_end_offset": 101,
         *           "lag": 100
         *         },
         *         {
         *           "kind": "KafkaConsumerLag",
         *           "metadata": {
         *             "self": "https://pkc-00000.region.provider.confluent.cloud/kafka/v3/clusters/cluster-1/consumer-groups/consumer-group-1/lags/topic-1/partitions/2",
         *             "resource_name": "crn:///kafka=cluster-1/consumer-group=consumer-group-1/lag=topic-1/partition=2"
         *           },
         *           "cluster_id": "cluster-1",
         *           "consumer_group_id": "consumer-group-1",
         *           "topic_name": "topic-1",
         *           "partition_id": 2,
         *           "consumer_id": "consumer-2",
         *           "instance_id": "consumer-instance-2",
         *           "client_id": "client-2",
         *           "current_offset": 1,
         *           "log_end_offset": 11,
         *           "lag": 10
         *         },
         *         {
         *           "kind": "KafkaConsumerLag",
         *           "metadata": {
         *             "self": "https://pkc-00000.region.provider.confluent.cloud/kafka/v3/clusters/cluster-1/consumer-groups/consumer-group-1/lags/topic-1/partitions/3",
         *             "resource_name": "crn:///kafka=cluster-1/consumer-group=consumer-group-1/lag=topic-1/partition=3"
         *           },
         *           "cluster_id": "cluster-1",
         *           "consumer_group_id": "consumer-group-1",
         *           "topic_name": "topic-1",
         *           "partition_id": 3,
         *           "consumer_id": "consumer-3",
         *           "instance_id": "consumer-instance-3",
         *           "client_id": "client-3",
         *           "current_offset": 1,
         *           "log_end_offset": 1,
         *           "lag": 0
         *         }
         *       ]
         *     } */
        "application/json": components["schemas"]["ConsumerLagDataList"];
      };
    };
    /** @description The list of consumers. */
    ListConsumersResponse: {
      headers: {
        [name: string]: unknown;
      };
      content: {
        /** @example {
         *       "kind": "KafkaConsumerList",
         *       "metadata": {
         *         "self": "https://pkc-00000.region.provider.confluent.cloud/kafka/v3/clusters/cluster-1/consumer-groups/consumer-group-1/consumers",
         *         "next": null
         *       },
         *       "data": [
         *         {
         *           "kind": "KafkaConsumer",
         *           "metadata": {
         *             "self": "https://pkc-00000.region.provider.confluent.cloud/kafka/v3/clusters/cluster-1/consumer-groups/consumer-group-1/consumers/consumer-1",
         *             "resource_name": "crn:///kafka=cluster-1/consumer-group=consumer-group-1/consumer=consumer-1"
         *           },
         *           "cluster_id": "cluster-1",
         *           "consumer_group_id": "consumer-group-1",
         *           "consumer_id": "consumer-1",
         *           "instance_id": "consumer-instance-1",
         *           "client_id": "client-1",
         *           "assignments": {
         *             "related": "https://pkc-00000.region.provider.confluent.cloud/kafka/v3/clusters/cluster-1/consumer-groups/consumer-group-1/consumers/consumer-1/assignments"
         *           }
         *         },
         *         {
         *           "kind": "KafkaConsumer",
         *           "metadata": {
         *             "self": "https://pkc-00000.region.provider.confluent.cloud/kafka/v3/clusters/cluster-1/consumer-groups/consumer-group-1/consumers/consumer-2",
         *             "resource_name": "crn:///kafka=cluster-1/consumer-group=consumer-group-1/consumer=consumer-2"
         *           },
         *           "cluster_id": "cluster-1",
         *           "consumer_group_id": "consumer-group-1",
         *           "consumer_id": "consumer-2",
         *           "instance_id": "consumer-instance-2",
         *           "client_id": "client-2",
         *           "assignments": {
         *             "related": "https://pkc-00000.region.provider.confluent.cloud/kafka/v3/clusters/cluster-1/consumer-groups/consumer-group-1/consumers/consumer-2/assignments"
         *           }
         *         },
         *         {
         *           "kind": "KafkaConsumer",
         *           "metadata": {
         *             "self": "https://pkc-00000.region.provider.confluent.cloud/kafka/v3/clusters/cluster-1/consumer-groups/consumer-group-1/consumers/consumer-2",
         *             "resource_name": "crn:///kafka=cluster-1/consumer-group=consumer-group-1/consumer=consumer-2"
         *           },
         *           "cluster_id": "cluster-1",
         *           "consumer_group_id": "consumer-group-1",
         *           "consumer_id": "consumer-2",
         *           "instance_id": "consumer-instance-2",
         *           "client_id": "client-2",
         *           "assignments": {
         *             "related": "https://pkc-00000.region.provider.confluent.cloud/kafka/v3/clusters/cluster-1/consumer-groups/consumer-group-1/consumers/consumer-2/assignments"
         *           }
         *         }
         *       ]
         *     } */
        "application/json": components["schemas"]["ConsumerDataList"];
      };
    };
    /** @description The list of partitions. */
    ListPartitionsResponse: {
      headers: {
        [name: string]: unknown;
      };
      content: {
        /** @example {
         *       "kind": "KafkaPartitionList",
         *       "metadata": {
         *         "self": "https://pkc-00000.region.provider.confluent.cloud/kafka/v3/clusters/cluster-1/topics/topic-1/partitions",
         *         "next": null
         *       },
         *       "data": [
         *         {
         *           "kind": "KafkaPartition",
         *           "metadata": {
         *             "self": "https://pkc-00000.region.provider.confluent.cloud/kafka/v3/clusters/cluster-1/topics/topic-1/partitions/1",
         *             "resource_name": "crn:///kafka=cluster-1/topic=topic-1/partition=1"
         *           },
         *           "cluster_id": "cluster-1",
         *           "topic_name": "topic-1",
         *           "partition_id": 1,
         *           "leader": {
         *             "related": "https://pkc-00000.region.provider.confluent.cloud/kafka/v3/clusters/cluster-1/topics/topic-1/partitions/1/replicas/1"
         *           },
         *           "replicas": {
         *             "related": "https://pkc-00000.region.provider.confluent.cloud/kafka/v3/clusters/cluster-1/topics/topic-1/partitions/1/replicas"
         *           },
         *           "reassignment": {
         *             "related": "https://pkc-00000.region.provider.confluent.cloud/kafka/v3/clusters/cluster-1/topics/topic-1/partitions/1/reassignment"
         *           }
         *         },
         *         {
         *           "kind": "KafkaPartition",
         *           "metadata": {
         *             "self": "https://pkc-00000.region.provider.confluent.cloud/kafka/v3/clusters/cluster-1/topics/topic-1/partitions/2",
         *             "resource_name": "crn:///kafka=cluster-1/topic=topic-1/partition=2"
         *           },
         *           "cluster_id": "cluster-1",
         *           "topic_name": "topic-1",
         *           "partition_id": 2,
         *           "leader": {
         *             "related": "https://pkc-00000.region.provider.confluent.cloud/kafka/v3/clusters/cluster-1/topics/topic-1/partitions/2/replicas/2"
         *           },
         *           "replicas": {
         *             "related": "https://pkc-00000.region.provider.confluent.cloud/kafka/v3/clusters/cluster-1/topics/topic-1/partitions/2/replicas"
         *           },
         *           "reassignment": {
         *             "related": "https://pkc-00000.region.provider.confluent.cloud/kafka/v3/clusters/cluster-1/topics/topic-1/partitions/2/reassignment"
         *           }
         *         },
         *         {
         *           "kind": "KafkaPartition",
         *           "metadata": {
         *             "self": "https://pkc-00000.region.provider.confluent.cloud/kafka/v3/clusters/cluster-1/topics/topic-1/partitions/3",
         *             "resource_name": "crn:///kafka=cluster-1/topic=topic-1/partition=3"
         *           },
         *           "cluster_id": "cluster-1",
         *           "topic_name": "topic-1",
         *           "partition_id": 3,
         *           "leader": {
         *             "related": "https://pkc-00000.region.provider.confluent.cloud/kafka/v3/clusters/cluster-1/topics/topic-1/partitions/3/replicas/3"
         *           },
         *           "replicas": {
         *             "related": "https://pkc-00000.region.provider.confluent.cloud/kafka/v3/clusters/cluster-1/topics/topic-1/partitions/3/replicas"
         *           },
         *           "reassignment": {
         *             "related": "https://pkc-00000.region.provider.confluent.cloud/kafka/v3/clusters/cluster-1/topics/topic-1/partitions/3/reassignment"
         *           }
         *         }
         *       ]
         *     } */
        "application/json": components["schemas"]["PartitionDataList"];
      };
    };
    /** @description The list of replicas. */
    ListReplicasResponse: {
      headers: {
        [name: string]: unknown;
      };
      content: {
        /** @example {
         *       "kind": "KafkaReplicaList",
         *       "metadata": {
         *         "self": "https://pkc-00000.region.provider.confluent.cloud/kafka/v3/clusters/cluster-1/topics/topic-1/partitions/1/replicas",
         *         "next": null
         *       },
         *       "data": [
         *         {
         *           "kind": "KafkaReplica",
         *           "metadata": {
         *             "self": "https://pkc-00000.region.provider.confluent.cloud/kafka/v3/clusters/cluster-1/topics/topic-1/partitions/1/replicas/1",
         *             "resource_name": "crn:///kafka=cluster-1/topic=topic-1/partition=1/replica=1"
         *           },
         *           "cluster_id": "cluster-1",
         *           "topic_name": "topic-1",
         *           "partition_id": 1,
         *           "broker_id": 1,
         *           "is_leader": true,
         *           "is_in_sync": true,
         *           "broker": {
         *             "related": "https://pkc-00000.region.provider.confluent.cloud/kafka/v3/clusters/cluster-1/brokers/1"
         *           }
         *         },
         *         {
         *           "kind": "KafkaReplica",
         *           "metadata": {
         *             "self": "https://pkc-00000.region.provider.confluent.cloud/kafka/v3/clusters/cluster-1/topics/topic-1/partitions/1/replicas/2",
         *             "resource_name": "crn:///kafka=cluster-1/topic=topic-1/partition=1/replica=2"
         *           },
         *           "cluster_id": "cluster-1",
         *           "topic_name": "topic-1",
         *           "partition_id": 1,
         *           "broker_id": 2,
         *           "is_leader": false,
         *           "is_in_sync": true,
         *           "broker": {
         *             "related": "https://pkc-00000.region.provider.confluent.cloud/kafka/v3/clusters/cluster-1/brokers/2"
         *           }
         *         },
         *         {
         *           "kind": "KafkaReplica",
         *           "metadata": {
         *             "self": "https://pkc-00000.region.provider.confluent.cloud/kafka/v3/clusters/cluster-1/topics/topic-1/partitions/1/replicas/3",
         *             "resource_name": "crn:///kafka=cluster-1/topic=topic-1/partition=1/replica=3"
         *           },
         *           "cluster_id": "cluster-1",
         *           "topic_name": "topic-1",
         *           "partition_id": 1,
         *           "broker_id": 3,
         *           "is_leader": false,
         *           "is_in_sync": false,
         *           "broker": {
         *             "related": "https://pkc-00000.region.provider.confluent.cloud/kafka/v3/clusters/cluster-1/brokers/3"
         *           }
         *         }
         *       ]
         *     } */
        "application/json": components["schemas"]["ReplicaDataList"];
      };
    };
    /** @description The list of cluster configs. */
    ListTopicConfigsResponse: {
      headers: {
        [name: string]: unknown;
      };
      content: {
        /** @example {
         *       "kind": "KafkaTopicConfigList",
         *       "metadata": {
         *         "self": "https://pkc-00000.region.provider.confluent.cloud/kafka/v3/clusters/cluster-1/topics/topic-1/configs",
         *         "next": null
         *       },
         *       "data": [
         *         {
         *           "kind": "KafkaTopicConfig",
         *           "metadata": {
         *             "self": "https://pkc-00000.region.provider.confluent.cloud/kafka/v3/clusters/cluster-1/topics/topic-1/configs/cleanup.policy",
         *             "resource_name": "crn:///kafka=cluster-1/topic=topic-1/config=cleanup.policy"
         *           },
         *           "cluster_id": "cluster-1",
         *           "topic_name": "topic-1",
         *           "name": "cleanup.policy",
         *           "value": "compact",
         *           "is_default": false,
         *           "is_read_only": false,
         *           "is_sensitive": false,
         *           "source": "DYNAMIC_TOPIC_CONFIG",
         *           "synonyms": [
         *             {
         *               "name": "cleanup.policy",
         *               "value": "compact",
         *               "source": "DYNAMIC_TOPIC_CONFIG"
         *             },
         *             {
         *               "name": "cleanup.policy",
         *               "value": "delete",
         *               "source": "DEFAULT_CONFIG"
         *             }
         *           ]
         *         },
         *         {
         *           "kind": "KafkaTopicConfig",
         *           "metadata": {
         *             "self": "https://pkc-00000.region.provider.confluent.cloud/kafka/v3/clusters/cluster-1/topics/topic-1/configs/compression.type",
         *             "resource_name": "crn:///kafka=cluster-1/topic=topic-1/config=compression.type"
         *           },
         *           "cluster_id": "cluster-1",
         *           "topic_name": "topic-1",
         *           "name": "compression.type",
         *           "value": "gzip",
         *           "is_default": false,
         *           "is_read_only": false,
         *           "is_sensitive": false,
         *           "source": "DYNAMIC_TOPIC_CONFIG",
         *           "synonyms": [
         *             {
         *               "name": "compression.type",
         *               "value": "gzip",
         *               "source": "DYNAMIC_TOPIC_CONFIG"
         *             },
         *             {
         *               "name": "compression.type",
         *               "value": "producer",
         *               "source": "DEFAULT_CONFIG"
         *             }
         *           ]
         *         }
         *       ]
         *     } */
        "application/json": components["schemas"]["TopicConfigDataList"];
      };
    };
    /** @description The list of topics. */
    ListTopicsResponse: {
      headers: {
        [name: string]: unknown;
      };
      content: {
        /** @example {
         *       "kind": "KafkaTopicList",
         *       "metadata": {
         *         "self": "https://pkc-00000.region.provider.confluent.cloud/kafka/v3/clusters/cluster-1/topics",
         *         "next": null
         *       },
         *       "data": [
         *         {
         *           "kind": "KafkaTopic",
         *           "metadata": {
         *             "self": "https://pkc-00000.region.provider.confluent.cloud/kafka/v3/clusters/cluster-1/topics/topic-1",
         *             "resource_name": "crn:///kafka=cluster-1/topic=topic-1"
         *           },
         *           "cluster_id": "cluster-1",
         *           "topic_name": "topic-1",
         *           "is_internal": false,
         *           "replication_factor": 3,
         *           "partitions_count": 1,
         *           "partitions": {
         *             "related": "https://pkc-00000.region.provider.confluent.cloud/kafka/v3/clusters/cluster-1/topics/topic-1/partitions"
         *           },
         *           "configs": {
         *             "related": "https://pkc-00000.region.provider.confluent.cloud/kafka/v3/clusters/cluster-1/topics/topic-1/configs"
         *           },
         *           "partition_reassignments": {
         *             "related": "https://pkc-00000.region.provider.confluent.cloud/kafka/v3/clusters/cluster-1/topics/topic-1/partitions/-/reassignments"
         *           }
         *         },
         *         {
         *           "kind": "KafkaTopic",
         *           "metadata": {
         *             "self": "https://pkc-00000.region.provider.confluent.cloud/kafka/v3/clusters/cluster-1/topics/topic-2",
         *             "resource_name": "crn:///kafka=cluster-1/topic=topic-2"
         *           },
         *           "cluster_id": "cluster-1",
         *           "topic_name": "topic-2",
         *           "is_internal": true,
         *           "replication_factor": 4,
         *           "partitions_count": 1,
         *           "partitions": {
         *             "related": "https://pkc-00000.region.provider.confluent.cloud/kafka/v3/clusters/cluster-1/topics/topic-2/partitions"
         *           },
         *           "configs": {
         *             "related": "https://pkc-00000.region.provider.confluent.cloud/kafka/v3/clusters/cluster-1/topics/topic-2/configs"
         *           },
         *           "partition_reassignments": {
         *             "related": "https://pkc-00000.region.provider.confluent.cloud/kafka/v3/clusters/cluster-1/topics/topic-2/partitions/-/reassignments"
         *           }
         *         },
         *         {
         *           "kind": "KafkaTopic",
         *           "metadata": {
         *             "self": "https://pkc-00000.region.provider.confluent.cloud/kafka/v3/clusters/cluster-1/topics/topic-3",
         *             "resource_name": "crn:///kafka=cluster-1/topic=topic-3"
         *           },
         *           "cluster_id": "cluster-1",
         *           "topic_name": "topic-3",
         *           "is_internal": false,
         *           "replication_factor": 5,
         *           "partitions_count": 1,
         *           "partitions": {
         *             "related": "https://pkc-00000.region.provider.confluent.cloud/kafka/v3/clusters/cluster-1/topics/topic-3/partitions"
         *           },
         *           "configs": {
         *             "related": "https://pkc-00000.region.provider.confluent.cloud/kafka/v3/clusters/cluster-1/topics/topic-3/configs"
         *           },
         *           "partition_reassignments": {
         *             "related": "https://pkc-00000.region.provider.confluent.cloud/kafka/v3/clusters/cluster-1/topics/topic-3/partitions/-/reassignments"
         *           }
         *         }
         *       ]
         *     } */
        "application/json": components["schemas"]["TopicDataList"];
      };
    };
    /** @description The response containing a delivery report for a record produced to a topic. In streaming mode,
     *     for each record sent, a separate delivery report will be returned, in the same order,
     *     each with its own error_code. */
    ProduceResponse: {
      headers: {
        [name: string]: unknown;
      };
      content: {
        "application/json": components["schemas"]["ProduceResponse"];
      };
    };
    /** @description The list of ACLs. */
    SearchAclsResponse: {
      headers: {
        [name: string]: unknown;
      };
      content: {
        /** @example {
         *       "kind": "KafkaAclList",
         *       "metadata": {
         *         "self": "https://pkc-00000.region.provider.confluent.cloud/kafka/v3/clusters/cluster-1/acls?principal=User%3Aalice"
         *       },
         *       "data": [
         *         {
         *           "kind": "KafkaAcl",
         *           "metadata": {
         *             "self": "https://pkc-00000.region.provider.confluent.cloud/kafka/v3/clusters/cluster-1/acls?resource_type=TOPIC&resource_name=topic-&pattern_type=PREFIXED&principal=User%3Aalice&host=*&operation=ALL&permission=ALLOW"
         *           },
         *           "cluster_id": "cluster-1",
         *           "resource_type": "TOPIC",
         *           "resource_name": "topic-",
         *           "pattern_type": "PREFIXED",
         *           "principal": "User:alice",
         *           "host": "*",
         *           "operation": "ALL",
         *           "permission": "ALLOW"
         *         },
         *         {
         *           "kind": "KafkaAcl",
         *           "metadata": {
         *             "self": "https://pkc-00000.region.provider.confluent.cloud/kafka/v3/clusters/cluster-1/acls?resource_type=CLUSTER&resource_name=kafka-cluster&pattern_type=LITERAL&principal=User%3Aalice&host=*&operation=DESCRIBE&permission=DENY"
         *           },
         *           "cluster_id": "cluster-1",
         *           "resource_type": "CLUSTER",
         *           "resource_name": "kafka-cluster",
         *           "pattern_type": "LITERAL",
         *           "principal": "User:alice",
         *           "host": "*",
         *           "operation": "DESCRIBE",
         *           "permission": "DENY"
         *         }
         *       ]
         *     } */
        "application/json": components["schemas"]["AclDataList"];
      };
    };
    /** @description The ongoing replicas reassignments. */
    SearchReassignmentsByTopicResponse: {
      headers: {
        [name: string]: unknown;
      };
      content: {
        /** @example {
         *       "kind": "KafkaReassignmentList",
         *       "metadata": {
         *         "self": "https://pkc-00000.region.provider.confluent.cloud/kafka/v3/clusters/cluster-1/topics/-/partitions/-/reassignment",
         *         "next": null
         *       },
         *       "data": [
         *         {
         *           "kind": "KafkaReassignment",
         *           "metadata": {
         *             "self": "https://pkc-00000.region.provider.confluent.cloud/kafka/v3/clusters/cluster-1/topics/topic-1/partitions/1/reassignment",
         *             "resource_name": "crn:///kafka=cluster-1/topic=topic-1/partition=1/reassignment"
         *           },
         *           "cluster_id": "cluster-1",
         *           "topic_name": "topic-1",
         *           "partition_id": 1,
         *           "adding_replicas": [
         *             1,
         *             2
         *           ],
         *           "removing_replicas": [
         *             3
         *           ],
         *           "replicas": {
         *             "related": "https://pkc-00000.region.provider.confluent.cloud/kafka/v3/clusters/cluster-1/topics/topic-1/partitions/1/replicas"
         *           }
         *         },
         *         {
         *           "kind": "KafkaReassignment",
         *           "metadata": {
         *             "self": "https://pkc-00000.region.provider.confluent.cloud/kafka/v3/clusters/cluster-1/topics/topic-1/partitions/2/reassignment",
         *             "resource_name": "crn:///kafka=cluster-1/topic=topic-1/partition=2/reassignment"
         *           },
         *           "cluster_id": "cluster-1",
         *           "topic_name": "topic-1",
         *           "partition_id": 2,
         *           "adding_replicas": [
         *             1
         *           ],
         *           "removing_replicas": [
         *             2,
         *             3
         *           ],
         *           "replicas": {
         *             "related": "https://pkc-00000.region.provider.confluent.cloud/kafka/v3/clusters/cluster-1/topics/topic-1/partitions/2/replicas"
         *           }
         *         },
         *         {
         *           "kind": "KafkaReassignment",
         *           "metadata": {
         *             "self": "https://pkc-00000.region.provider.confluent.cloud/kafka/v3/clusters/cluster-1/topics/topic-1/partitions/3/reassignment",
         *             "resource_name": "crn:///kafka=cluster-1/topic=topic-1/partition=3/reassignment"
         *           },
         *           "cluster_id": "cluster-1",
         *           "topic_name": "topic-1",
         *           "partition_id": 3,
         *           "adding_replicas": [
         *             3
         *           ],
         *           "removing_replicas": [
         *             1,
         *             2
         *           ],
         *           "replicas": {
         *             "related": "https://pkc-00000.region.provider.confluent.cloud/kafka/v3/clusters/cluster-1/topics/topic-1/partitions/3/replicas"
         *           }
         *         }
         *       ]
         *     } */
        "application/json": components["schemas"]["ReassignmentDataList"];
      };
    };
    /** @description The list of replicas. */
    SearchReplicasByBrokerResponse: {
      headers: {
        [name: string]: unknown;
      };
      content: {
        /** @example {
         *       "kind": "KafkaReplicaList",
         *       "metadata": {
         *         "self": "https://pkc-00000.region.provider.confluent.cloud/kafka/v3/clusters/cluster-1/brokers/1/partition-replicas",
         *         "next": null
         *       },
         *       "data": [
         *         {
         *           "kind": "KafkaReplica",
         *           "metadata": {
         *             "self": "https://pkc-00000.region.provider.confluent.cloud/kafka/v3/clusters/cluster-1/topics/topic-1/partitions/2/replicas/1",
         *             "resource_name": "crn:///kafka=cluster-1/topic=topic-1/partition=2/replica=1"
         *           },
         *           "cluster_id": "cluster-1",
         *           "topic_name": "topic-1",
         *           "partition_id": 2,
         *           "broker_id": 1,
         *           "is_leader": true,
         *           "is_in_sync": true,
         *           "broker": {
         *             "related": "https://pkc-00000.region.provider.confluent.cloud/kafka/v3/clusters/cluster-1/brokers/1"
         *           }
         *         },
         *         {
         *           "kind": "KafkaReplica",
         *           "metadata": {
         *             "self": "https://pkc-00000.region.provider.confluent.cloud/kafka/v3/clusters/cluster-1/topics/topic-2/partitions/3/replicas/1",
         *             "resource_name": "crn:///kafka=cluster-1/topic=topic-3/partition=3/replica=1"
         *           },
         *           "cluster_id": "cluster-1",
         *           "topic_name": "topic-2",
         *           "partition_id": 3,
         *           "broker_id": 1,
         *           "is_leader": false,
         *           "is_in_sync": true,
         *           "broker": {
         *             "related": "https://pkc-00000.region.provider.confluent.cloud/kafka/v3/clusters/cluster-1/brokers/1"
         *           }
         *         },
         *         {
         *           "kind": "KafkaReplica",
         *           "metadata": {
         *             "self": "https://pkc-00000.region.provider.confluent.cloud/kafka/v3/clusters/cluster-1/topics/topic-3/partitions/1/replicas/1",
         *             "resource_name": "crn:///kafka=cluster-1/topic=topic-3/partition=1/replica=1"
         *           },
         *           "cluster_id": "cluster-1",
         *           "topic_name": "topic-3",
         *           "partition_id": 1,
         *           "broker_id": 1,
         *           "is_leader": false,
         *           "is_in_sync": false,
         *           "broker": {
         *             "related": "https://pkc-00000.region.provider.confluent.cloud/kafka/v3/clusters/cluster-1/brokers/1"
         *           }
         *         }
         *       ]
         *     } */
        "application/json": components["schemas"]["ReplicaDataList"];
      };
    };
    /** @description Indicates a bad request error. It could be caused by an unexpected request body format or other forms of request validation failure. */
    BadRequestErrorResponse: {
      headers: {
        [name: string]: unknown;
      };
      content: {
        "application/json": components["schemas"]["Error"];
      };
    };
    /** @description Indicates a bad request error. It could be caused by an unexpected request body format or other forms of request validation failure. */
    BadRequestErrorResponse_CreateAcls: {
      headers: {
        [name: string]: unknown;
      };
      content: {
        "application/json": components["schemas"]["Error"];
      };
    };
    /** @description Indicates a bad request error. It could be caused by an unexpected request body format or other forms of request validation failure. */
    BadRequestErrorResponse_CreateTopic: {
      headers: {
        [name: string]: unknown;
      };
      content: {
        "application/json": components["schemas"]["Error"];
      };
    };
    /** @description Indicates a bad request error. It could be caused by an unexpected request body format or other forms of request validation failure. */
    BadRequestErrorResponse_DeleteAcls: {
      headers: {
        [name: string]: unknown;
      };
      content: {
        "application/json": components["schemas"]["Error"];
      };
    };
    /** @description Indicates a bad request error. It could be caused by an unexpected request body format or other forms of request validation failure. */
    BadRequestErrorResponse_ProduceRecords: {
      headers: {
        [name: string]: unknown;
      };
      content: {
        "application/json": components["schemas"]["Error"];
      };
    };
    /** @description Indicates a bad request error. It could be caused by an unexpected request body format or other forms of request validation failure. */
    UnprocessableEntity_ProduceRecord: {
      headers: {
        [name: string]: unknown;
      };
      content: {
        "application/json": components["schemas"]["Error"];
      };
    };
    /** @description Indicates a bad request error. It could be caused by an unexpected request body format or other forms of request validation failure. */
    BadRequestErrorResponse_UpdatePartitionCountTopic: {
      headers: {
        [name: string]: unknown;
      };
      content: {
        "application/json": components["schemas"]["Error"];
      };
    };
    /** @description Indicates a client authentication error. Kafka authentication failures will contain error code 40101 in the response body. */
    UnauthorizedErrorResponse: {
      headers: {
        [name: string]: unknown;
      };
      content: {
        "application/json": components["schemas"]["Error"];
      };
    };
    /** @description Indicates a client authorization error. Kafka authorization failures will contain error code 40301 in the response body. */
    ForbiddenErrorResponse: {
      headers: {
        [name: string]: unknown;
      };
      content: {
        "application/json": components["schemas"]["Error"];
      };
    };
    /** @description Indicates attempted access to an unreachable or non-existing resource like e.g. an unknown topic or partition. GET requests to endpoints not allowed in the accesslists will also result in this response. */
    NotFoundErrorResponse: {
      headers: {
        [name: string]: unknown;
      };
      content: {
        "application/json": components["schemas"]["Error"];
      };
    };
    /** @description Indicates that a rate limit threshold has been reached, and the client should retry again later. */
    TooManyRequestsErrorResponse: {
      headers: {
        [name: string]: unknown;
      };
      content: {
        /** @example {
         *       "description": "A sample response from Jetty's DoSFilter.",
         *       "value": "<html> <head> <meta http-equiv=\"Content-Type\" content=\"text/html;charset=utf-8\"/> <title>Error 429 Too Many Requests</title> </head> <body> <h2>HTTP ERROR 429 Too Many Requests</h2> <table> <tr> <th>URI:</th> <td>/v3/clusters/my-cluster</td> </tr> <tr> <th>STATUS:</th> <td>429</td> </tr> <tr> <th>MESSAGE:</th> <td>Too Many Requests</td> </tr> <tr> <th>SERVLET:</th> <td>default</td> </tr> </table> </body> </html>"
         *     } */
        "text/html": string;
      };
    };
    /** @description This implies the client is sending a request payload that is larger than the maximum message size the server can accept. */
    RequestEntityTooLargeErrorResponse: {
      headers: {
        [name: string]: unknown;
      };
      content: {
        "application/json": components["schemas"]["Error"];
      };
    };
    /** @description This implies the client is sending the request payload format in an unsupported format. */
    UnsupportedMediaTypeErrorResponse: {
      headers: {
        [name: string]: unknown;
      };
      content: {
        "application/json": components["schemas"]["Error"];
      };
    };
    /** @description A server-side problem that might not be addressable from the client side. Retriable Kafka errors will contain error code 50003 in the response body. */
    ServerErrorResponse: {
      headers: {
        [name: string]: unknown;
      };
      content: {
        "application/json": components["schemas"]["Error"];
      };
    };
    /** @description The list of Replica Statuses. */
    ListReplicaStatusResponse: {
      headers: {
        [name: string]: unknown;
      };
      content: {
        /** @example {
         *       "kind": "KafkaReplicaStatusList",
         *       "metadata": {
         *         "self": "https://pkc-00000.region.provider.confluent.cloud/kafka/v3/clusters/1Rh_4htxSuen7RYGvGmgNw/topics/topic_1/partitions/0/replica-status",
         *         "resource_name": null
         *       },
         *       "data": [
         *         {
         *           "kind": "KafkaReplicaStatus",
         *           "metadata": {
         *             "self": "https://pkc-00000.region.provider.confluent.cloud/kafka/v3/clusters/1Rh_4htxSuen7RYGvGmgNw/topics/topic-1/partitions/0/brokers/1/replica-status"
         *           },
         *           "cluster_id": "cluster-1",
         *           "topic_name": "topic-1",
         *           "broker_id": 1,
         *           "partition_id": 0,
         *           "is_leader": true,
         *           "is_observer": false,
         *           "is_isr_eligible": true,
         *           "is_in_isr": true,
         *           "is_caught_up": true,
         *           "log_start_offset": 0,
         *           "log_end_offset": 0,
         *           "last_caught_up_time_ms": 100,
         *           "last_fetch_time_ms": 200,
         *           "link_name": "test-link"
         *         },
         *         {
         *           "kind": "KafkaReplicaStatus",
         *           "metadata": {
         *             "self": "https://pkc-00000.region.provider.confluent.cloud/kafka/v3/clusters/1Rh_4htxSuen7RYGvGmgNw/topics/topic-1/partitions/0/brokers/2/replica-status"
         *           },
         *           "cluster_id": "cluster-1",
         *           "topic_name": "topic-1",
         *           "broker_id": 2,
         *           "partition_id": 0,
         *           "is_leader": false,
         *           "is_observer": false,
         *           "is_isr_eligible": true,
         *           "is_in_isr": true,
         *           "is_caught_up": true,
         *           "log_start_offset": 0,
         *           "log_end_offset": 0,
         *           "last_caught_up_time_ms": 100,
         *           "last_fetch_time_ms": 200,
         *           "link_name": "test-link"
         *         }
         *       ]
         *     } */
        "application/json": components["schemas"]["ReplicaStatusDataList"];
      };
    };
    /** @description The AnyUnevenLoad status */
    GetAnyUnevenLoadResponse: {
      headers: {
        [name: string]: unknown;
      };
      content: {
        /** @example {
         *       "kind": "KafkaAnyUnevenLoad",
         *       "metadata": {
         *         "self": "https://pkc-00000.region.provider.confluent.cloud/kafka/v3/clusters/cluster-1/any-uneven-load",
         *         "resource_name": "crn:///kafka=cluster-1/any-uneven-load"
         *       },
         *       "cluster_id": "cluster-1",
         *       "status": "BALANCING",
         *       "previous_status": "BALANCING_FAILED",
         *       "status_updated_at": "2019-10-12T07:20:50Z",
         *       "previous_status_updated_at": "2019-10-12T07:20:35Z",
         *       "error_code": 10013,
         *       "error_message": "The Confluent Balancer operation was overridden by a higher priority operation.",
         *       "broker_tasks": {
         *         "related": "https://pkc-00000.region.provider.confluent.cloud/kafka/v3/clusters/cluster-1/brokers/-/tasks"
         *       }
         *     } */
        "application/json": components["schemas"]["AnyUnevenLoadData"];
      };
    };
    /** @description The balancer status */
    GetBalancerStatusResponse: {
      headers: {
        [name: string]: unknown;
      };
      content: {
        /** @example {
         *       "kind": "KafkaBalancerStatus",
         *       "metadata": {
         *         "self": "https://pkc-00000.region.provider.confluent.cloud/kafka/v3/clusters/cluster-1/balancer",
         *         "resource_name": "crn:///kafka=cluster-1/balancer"
         *       },
         *       "cluster_id": "cluster-1",
         *       "status": "ERROR",
         *       "error_code": 10014,
         *       "error_message": "The Confluent Balancer failed to start as JBOD is enabled for the cluster.",
         *       "any_uneven_load": {
         *         "related": "https://pkc-00000.region.provider.confluent.cloud/kafka/v3/clusters/cluster-1/even-cluster-load"
         *       },
         *       "broker_tasks": {
         *         "related": "https://pkc-00000.region.provider.confluent.cloud/kafka/v3/clusters/cluster-1/brokers/-/tasks"
         *       }
         *     } */
        "application/json": components["schemas"]["BalancerStatusData"];
      };
    };
    /** @description The single broker removal response */
    GetBrokerRemovalResponse: {
      headers: {
        [name: string]: unknown;
      };
      content: {
        /** @example {
         *       "kind": "KafkaBrokerRemoval",
         *       "metadata": {
         *         "self": "https://pkc-00000.region.provider.confluent.cloud/kafka/v3/clusters/cluster-1/brokers/1",
         *         "resource_name": "crn:///kafka=cluster-1/broker=1/"
         *       },
         *       "cluster_id": "cluster-1",
         *       "broker_id": 1,
         *       "broker_task": {
         *         "related": "https://pkc-00000.region.provider.confluent.cloud/kafka/v3/clusters/cluster-1/brokers/1"
         *       },
         *       "broker": {
         *         "related": "https://pkc-00000.region.provider.confluent.cloud/kafka/v3/clusters/cluster-1/brokers/1"
         *       }
         *     } */
        "application/json": components["schemas"]["BrokerRemovalData"];
      };
    };
    /** @description The multiple broker removal response */
    ListBrokerRemovalResponse: {
      headers: {
        [name: string]: unknown;
      };
      content: {
        /** @example {
         *       "kind": "KafkaBrokerRemovalList",
         *       "metadata": {
         *         "self": "https://pkc-00000.region.provider.confluent.cloud/kafka/v3/clusters/cluster-1/brokers:delete",
         *         "next": null
         *       },
         *       "data": [
         *         {
         *           "kind": "KafkaBrokerRemoval",
         *           "metadata": {
         *             "self": "https://pkc-00000.region.provider.confluent.cloud/kafka/v3/clusters/cluster-1/brokers/1",
         *             "resource_name": "crn:///kafka=cluster-1/broker=1/"
         *           },
         *           "cluster_id": "cluster-1",
         *           "broker_id": 1,
         *           "broker_task": {
         *             "related": "https://pkc-00000.region.provider.confluent.cloud/kafka/v3/clusters/cluster-1/brokers/1"
         *           },
         *           "broker": {
         *             "related": "https://pkc-00000.region.provider.confluent.cloud/kafka/v3/clusters/cluster-1/brokers/1"
         *           }
         *         },
         *         {
         *           "kind": "KafkaBrokerRemoval",
         *           "metadata": {
         *             "self": "https://pkc-00000.region.provider.confluent.cloud/kafka/v3/clusters/cluster-1/brokers/1",
         *             "resource_name": "crn:///kafka=cluster-1/broker=1/"
         *           },
         *           "cluster_id": "cluster-1",
         *           "broker_id": 1,
         *           "broker_task": {
         *             "related": "https://pkc-00000.region.provider.confluent.cloud/kafka/v3/clusters/cluster-1/brokers/1"
         *           },
         *           "broker": {
         *             "related": "https://pkc-00000.region.provider.confluent.cloud/kafka/v3/clusters/cluster-1/brokers/1"
         *           }
         *         }
         *       ]
         *     } */
        "application/json": components["schemas"]["BrokerRemovalDataList"];
      };
    };
    /** @description The broker task */
    GetBrokerTaskResponse: {
      headers: {
        [name: string]: unknown;
      };
      content: {
        /** @example {
         *       "kind": "KafkaBrokerTask",
         *       "metadata": {
         *         "self": "https://pkc-00000.region.provider.confluent.cloud/kafka/v3/clusters/cluster-1/brokers/1/tasks/add-broker",
         *         "resource_name": "crn:///kafka=cluster-1/broker=1/task=1"
         *       },
         *       "cluster_id": "cluster-1",
         *       "broker_id": 1,
         *       "task_type": "add-broker",
         *       "task_status": "FAILED",
         *       "sub_task_statuses": {
         *         "partition_reassignment_status": "ERROR"
         *       },
         *       "created_at": "2019-10-12T07:20:50Z",
         *       "updated_at": "2019-10-12T07:20:55Z",
         *       "error_code": 10013,
         *       "error_message": "The Confluent Balancer operation was overridden by a higher priority operation",
         *       "broker": {
         *         "related": "https://pkc-00000.region.provider.confluent.cloud/kafka/v3/clusters/cluster-1/brokers/1"
         *       }
         *     } */
        "application/json": components["schemas"]["BrokerTaskData"];
      };
    };
    /** @description The list of tasks. */
    ListBrokerTaskResponse: {
      headers: {
        [name: string]: unknown;
      };
      content: {
        /** @example {
         *       "kind": "KafkaBrokerTaskList",
         *       "metadata": {
         *         "self": "https://pkc-00000.region.provider.confluent.cloud/kafka/v3/clusters/cluster-1/brokers/-/tasks",
         *         "next": null
         *       },
         *       "data": [
         *         {
         *           "kind": "KafkaBrokerTask",
         *           "metadata": {
         *             "self": "https://pkc-00000.region.provider.confluent.cloud/kafka/v3/clusters/cluster-1/brokers/1/tasks/add-broker",
         *             "resource_name": "crn:///kafka=cluster-1/broker=1/task=add-broker"
         *           },
         *           "cluster_id": "cluster_id",
         *           "broker_id": 1,
         *           "task_type": "add-broker",
         *           "task_status": "SUCCESS",
         *           "sub_task_statuses": {
         *             "partition_reassignment_status": "COMPLETED"
         *           },
         *           "created_at": "2019-10-12T10:20:40Z",
         *           "updated_at": "2019-10-12T10:20:45Z",
         *           "broker": {
         *             "related": "https://pkc-00000.region.provider.confluent.cloud/kafka/v3/clusters/cluster-1/brokers/1"
         *           }
         *         },
         *         {
         *           "kind": "KafkaBrokerTask",
         *           "metadata": {
         *             "self": "https://pkc-00000.region.provider.confluent.cloud/kafka/v3/clusters/cluster-1/brokers/2/tasks/remove-broker",
         *             "resource_name": "crn:///kafka=cluster-1/broker=2/task=remove-broker"
         *           },
         *           "cluster_id": "cluster_id",
         *           "broker_id": 2,
         *           "task_type": "remove-broker",
         *           "task_status": "FAILED",
         *           "shutdown_scheduled": true,
         *           "sub_task_statuses": {
         *             "broker_replica_exclusion_status": "COMPLETED",
         *             "partition_reassignment_status": "ERROR",
         *             "broker_shutdown_status": "CANCELED"
         *           },
         *           "created_at": "2019-10-12T07:20:50Z",
         *           "updated_at": "2019-10-12T07:20:55Z",
         *           "error_code": 10006,
         *           "error_message": "Error while computing the initial remove broker plan for brokers [2] prior to shutdown.",
         *           "broker": {
         *             "related": "https://pkc-00000.region.provider.confluent.cloud/kafka/v3/clusters/cluster-1/brokers/2"
         *           }
         *         }
         *       ]
         *     } */
        "application/json": components["schemas"]["BrokerTaskDataList"];
      };
    };
    /** @description The list of tasks. */
    ListBrokerTaskByBrokerResponse: {
      headers: {
        [name: string]: unknown;
      };
      content: {
        /** @example {
         *       "kind": "KafkaBrokerTaskList",
         *       "metadata": {
         *         "self": "https://pkc-00000.region.provider.confluent.cloud/kafka/v3/clusters/cluster-1/brokers/-/tasks",
         *         "next": null
         *       },
         *       "data": [
         *         {
         *           "kind": "KafkaBrokerTask",
         *           "metadata": {
         *             "self": "https://pkc-00000.region.provider.confluent.cloud/kafka/v3/clusters/cluster-1/brokers/1/tasks/add-broker",
         *             "resource_name": "crn:///kafka=cluster-1/broker=1/task=add-broker"
         *           },
         *           "cluster_id": "cluster_id",
         *           "broker_id": 1,
         *           "task_type": "add-broker",
         *           "task_status": "IN_PROGRESS",
         *           "sub_task_statuses": {
         *             "partition_reassignment_status": "IN_PROGRESS"
         *           },
         *           "created_at": "2019-10-12T07:20:50Z",
         *           "updated_at": "2019-10-12T07:20:55Z",
         *           "broker": {
         *             "related": "https://pkc-00000.region.provider.confluent.cloud/kafka/v3/clusters/cluster-1/brokers/1"
         *           }
         *         },
         *         {
         *           "kind": "KafkaBrokerTask",
         *           "metadata": {
         *             "self": "https://pkc-00000.region.provider.confluent.cloud/kafka/v3/clusters/cluster-1/brokers/1/tasks/remove-broker",
         *             "resource_name": "crn:///kafka=cluster-1/broker=1/task=remove-broker"
         *           },
         *           "cluster_id": "cluster_id",
         *           "broker_id": 1,
         *           "task_type": "remove-broker",
         *           "task_status": "FAILED",
         *           "shutdown_scheduled": false,
         *           "sub_task_statuses": {
         *             "broker_replica_exclusion_status": "EXCLUDED",
         *             "partition_reassignment_status": "ERROR",
         *             "broker_shutdown_status": "CANCELED"
         *           },
         *           "created_at": "2019-10-12T07:20:50Z",
         *           "updated_at": "2019-10-12T07:20:55Z",
         *           "error_code": 10006,
         *           "error_message": "Error while computing the initial remove broker plan for brokers [1] prior to shutdown.",
         *           "broker": {
         *             "related": "https://pkc-00000.region.provider.confluent.cloud/kafka/v3/clusters/cluster-1/brokers/1"
         *           }
         *         }
         *       ]
         *     } */
        "application/json": components["schemas"]["BrokerTaskDataList"];
      };
    };
    /** @description The list of tasks. */
    ListBrokerTaskByTaskTypeResponse: {
      headers: {
        [name: string]: unknown;
      };
      content: {
        /** @example {
         *       "kind": "KafkaBrokerTaskList",
         *       "metadata": {
         *         "self": "https://pkc-00000.region.provider.confluent.cloud/kafka/v3/clusters/cluster-1/brokers/-/tasks",
         *         "next": null
         *       },
         *       "data": [
         *         {
         *           "kind": "KafkaBrokerTask",
         *           "metadata": {
         *             "self": "https://pkc-00000.region.provider.confluent.cloud/kafka/v3/clusters/cluster-1/brokers/1/tasks/add-broker",
         *             "resource_name": "crn:///kafka=cluster-1/broker=1/task=add-broker"
         *           },
         *           "cluster_id": "cluster_id",
         *           "broker_id": 1,
         *           "task_type": "add-broker",
         *           "task_status": "IN_PROGRESS",
         *           "sub_task_statuses": {
         *             "partition_reassignment_status": "IN_PROGRESS"
         *           },
         *           "created_at": "2019-10-12T07:20:50Z",
         *           "updated_at": "2019-10-12T07:20:55Z",
         *           "broker": {
         *             "related": "https://pkc-00000.region.provider.confluent.cloud/kafka/v3/clusters/cluster-1/brokers/1"
         *           }
         *         },
         *         {
         *           "kind": "KafkaBrokerTask",
         *           "metadata": {
         *             "self": "https://pkc-00000.region.provider.confluent.cloud/kafka/v3/clusters/cluster-1/brokers/2/tasks/add-broker",
         *             "resource_name": "crn:///kafka=cluster-1/broker=2/task=add-broker"
         *           },
         *           "cluster_id": "cluster_id",
         *           "broker_id": 2,
         *           "task_type": "add-broker",
         *           "task_status": "FAILED",
         *           "sub_task_statuses": {
         *             "partition_reassignment_status": "ERROR"
         *           },
         *           "created_at": "2019-10-12T07:20:50Z",
         *           "updated_at": "2019-10-12T07:20:55Z",
         *           "error_code": 10006,
         *           "error_message": "Error while computing the initial add broker plan for brokers [2]",
         *           "broker": {
         *             "related": "https://pkc-00000.region.provider.confluent.cloud/kafka/v3/clusters/cluster-1/brokers/2"
         *           }
         *         }
         *       ]
         *     } */
        "application/json": components["schemas"]["BrokerTaskDataList"];
      };
    };
    /** @description The list of broker replica exclusions. */
    ListBrokerReplicaExclusionResponse: {
      headers: {
        [name: string]: unknown;
      };
      content: {
        /** @example {
         *       "kind": "KafkaBrokerReplicaExclusionList",
         *       "metadata": {
         *         "self": "https://pkc-00000.region.provider.confluent.cloud/kafka/v3/clusters/cluster-1/broker-replica-exclusions",
         *         "next": null
         *       },
         *       "data": [
         *         {
         *           "kind": "KafkaBrokerReplicaExclusion",
         *           "metadata": {
         *             "self": "https://pkc-00000.region.provider.confluent.cloud/kafka/v3/clusters/cluster-1/broker-replica-exclusions/1",
         *             "resource_name": "crn:///kafka=cluster-1/broker-replica-exclusions=1"
         *           },
         *           "cluster_id": "cluster-1",
         *           "broker_id": 1,
         *           "reason": "Broker is to be removed.",
         *           "broker": {
         *             "related": "https://pkc-00000.region.provider.confluent.cloud/kafka/v3/clusters/cluster-1/brokers/1"
         *           }
         *         },
         *         {
         *           "kind": "KafkaBrokerReplicaExclusion",
         *           "metadata": {
         *             "self": "https://pkc-00000.region.provider.confluent.cloud/kafka/v3/clusters/cluster-1/broker-replica-exclusions/2",
         *             "resource_name": "crn:///kafka=cluster-1/broker-replica-exclusions=2"
         *           },
         *           "cluster_id": "cluster-1",
         *           "broker_id": 2,
         *           "reason": "Broker is to be removed.",
         *           "broker": {
         *             "related": "https://pkc-00000.region.provider.confluent.cloud/kafka/v3/clusters/cluster-1/brokers/2"
         *           }
         *         }
         *       ]
         *     } */
        "application/json": components["schemas"]["BrokerReplicaExclusionDataList"];
      };
    };
    /** @description A Broker Replica Exclusion. */
    GetBrokerReplicaExclusionResponse: {
      headers: {
        [name: string]: unknown;
      };
      content: {
        /** @example {
         *       "kind": "KafkaBrokerReplicaExclusion",
         *       "metadata": {
         *         "self": "https://pkc-00000.region.provider.confluent.cloud/kafka/v3/clusters/cluster-1/broker-replica-exclusions/1",
         *         "next": null
         *       },
         *       "cluster_id": "cluster-1",
         *       "broker_id": 1,
         *       "reason": "Broker is to be removed.",
         *       "broker": {
         *         "related": "https://pkc-00000.region.provider.confluent.cloud/kafka/v3/clusters/cluster-1/brokers/1"
         *       }
         *     } */
        "application/json": components["schemas"]["BrokerReplicaExclusionData"];
      };
    };
    /** @description The list of alter broker replica exclusions. */
    ListCreateBrokerReplicaExclusionResponse: {
      headers: {
        [name: string]: unknown;
      };
      content: {
        /** @example {
         *       "kind": "KafkaAlterBrokerReplicaExclusionList",
         *       "metadata": {
         *         "self": "https://pkc-00000.region.provider.confluent.cloud/kafka/v3/clusters/cluster-1/broker-replica-exclusions",
         *         "next": null
         *       },
         *       "data": [
         *         {
         *           "kind": "KafkaAlterBrokerReplicaExclusion",
         *           "metadata": {
         *             "self": "https://pkc-00000.region.provider.confluent.cloud/kafka/v3/clusters/cluster-1/broker-replica-exclusions/1",
         *             "resource_name": "crn:///kafka=cluster-1/broker-replica-exclusions=1"
         *           },
         *           "cluster_id": "cluster-1",
         *           "broker_id": 1,
         *           "exclusion": "SET",
         *           "reason": "Broker is to be removed.",
         *           "error_code": null,
         *           "error_message": null,
         *           "broker": {
         *             "related": "https://pkc-00000.region.provider.confluent.cloud/kafka/v3/clusters/cluster-1/brokers/1"
         *           }
         *         },
         *         {
         *           "kind": "KafkaAlterBrokerReplicaExclusion",
         *           "metadata": {
         *             "self": "https://pkc-00000.region.provider.confluent.cloud/kafka/v3/clusters/cluster-1/broker-replica-exclusions/2",
         *             "resource_name": "crn:///kafka=cluster-1/broker-replica-exclusions=2"
         *           },
         *           "cluster_id": "cluster-1",
         *           "broker_id": 2,
         *           "exclusion": "SET",
         *           "reason": "Broker is to be removed.",
         *           "error_code": null,
         *           "error_message": null,
         *           "broker": {
         *             "related": "https://pkc-00000.region.provider.confluent.cloud/kafka/v3/clusters/cluster-1/brokers/2"
         *           }
         *         }
         *       ]
         *     } */
        "application/json": components["schemas"]["AlterBrokerReplicaExclusionDataList"];
      };
    };
    /** @description The list of alter broker replica exclusions. */
    ListDeleteBrokerReplicaExclusionResponse: {
      headers: {
        [name: string]: unknown;
      };
      content: {
        /** @example {
         *       "kind": "KafkaAlterBrokerReplicaExclusionList",
         *       "metadata": {
         *         "self": "https://pkc-00000.region.provider.confluent.cloud/kafka/v3/clusters/cluster-1/broker-replica-exclusions",
         *         "next": null
         *       },
         *       "data": [
         *         {
         *           "kind": "KafkaAlterBrokerReplicaExclusion",
         *           "metadata": {
         *             "self": "https://pkc-00000.region.provider.confluent.cloud/kafka/v3/clusters/cluster-1/broker-replica-exclusions/1",
         *             "resource_name": "crn:///kafka=cluster-1/broker-replica-exclusions=1"
         *           },
         *           "cluster_id": "cluster-1",
         *           "broker_id": 1,
         *           "exclusion": "DELETE",
         *           "reason": "Broker removal is completed.",
         *           "error_code": null,
         *           "error_message": null,
         *           "broker": {
         *             "related": "https://pkc-00000.region.provider.confluent.cloud/kafka/v3/clusters/cluster-1/brokers/1"
         *           }
         *         },
         *         {
         *           "kind": "KafkaAlterBrokerReplicaExclusion",
         *           "metadata": {
         *             "self": "https://pkc-00000.region.provider.confluent.cloud/kafka/v3/clusters/cluster-1/broker-replica-exclusions/2",
         *             "resource_name": "crn:///kafka=cluster-1/broker-replica-exclusions=2"
         *           },
         *           "cluster_id": "cluster-1",
         *           "broker_id": 2,
         *           "exclusion": "DELETE",
         *           "reason": "Broker removal is completed.",
         *           "error_code": null,
         *           "error_message": null,
         *           "broker": {
         *             "related": "https://pkc-00000.region.provider.confluent.cloud/kafka/v3/clusters/cluster-1/brokers/2"
         *           }
         *         }
         *       ]
         *     } */
        "application/json": components["schemas"]["AlterBrokerReplicaExclusionDataList"];
      };
    };
    /** @description The list of alter broker replica exclusions. */
    ListDeleteBrokerReplicaExclusionErrorResponse: {
      headers: {
        [name: string]: unknown;
      };
      content: {
        /** @example {
         *       "kind": "KafkaAlterBrokerReplicaExclusionList",
         *       "metadata": {
         *         "self": "https://pkc-00000.region.provider.confluent.cloud/kafka/v3/clusters/cluster-1/broker-replica-exclusions",
         *         "next": null
         *       },
         *       "data": [
         *         {
         *           "kind": "KafkaAlterBrokerReplicaExclusion",
         *           "metadata": {
         *             "self": "https://pkc-00000.region.provider.confluent.cloud/kafka/v3/clusters/cluster-1/broker-replica-exclusions/1",
         *             "resource_name": "crn:///kafka=cluster-1/broker-replica-exclusions=1"
         *           },
         *           "cluster_id": "cluster-1",
         *           "broker_id": 1,
         *           "exclusion": "DELETE",
         *           "reason": "Broker removal is completed.",
         *           "error_code": 404,
         *           "error_message": "No replica exclusion for broker 1 was present.",
         *           "broker": {
         *             "related": "https://pkc-00000.region.provider.confluent.cloud/kafka/v3/clusters/cluster-1/brokers/1"
         *           }
         *         },
         *         {
         *           "kind": "KafkaAlterBrokerReplicaExclusion",
         *           "metadata": {
         *             "self": "https://pkc-00000.region.provider.confluent.cloud/kafka/v3/clusters/cluster-1/broker-replica-exclusions/2",
         *             "resource_name": "crn:///kafka=cluster-1/broker-replica-exclusions=2"
         *           },
         *           "cluster_id": "cluster-1",
         *           "broker_id": 2,
         *           "exclusion": "DELETE",
         *           "reason": "Broker removal is completed.",
         *           "error_code": null,
         *           "error_message": null,
         *           "broker": {
         *             "related": "https://pkc-00000.region.provider.confluent.cloud/kafka/v3/clusters/cluster-1/brokers/2"
         *           }
         *         }
         *       ]
         *     } */
        "application/json": components["schemas"]["AlterBrokerReplicaExclusionDataList"];
      };
    };
    /** @description The remove broker task. */
    GetRemoveBrokerTaskResponse: {
      headers: {
        [name: string]: unknown;
      };
      content: {
        /** @example {
         *       "kind": "KafkaRemoveBrokerTask",
         *       "metadata": {
         *         "self": "https://pkc-00000.region.provider.confluent.cloud/kafka/v3/clusters/cluster-1/remove-broker-tasks/1",
         *         "resource_name": "crn:///kafka=cluster-1/remove-broker-task=1"
         *       },
         *       "cluster_id": "cluster-1",
         *       "broker_id": 1,
         *       "shutdown_scheduled": false,
         *       "broker_replica_exclusion_status": "COMPLETED",
         *       "partition_reassignment_status": "FAILED",
         *       "broker_shutdown_status": "CANCELED",
         *       "error_code": 10006,
         *       "error_message": "Error while computing the initial remove broker plan for brokers [1] prior to shutdown.",
         *       "broker": {
         *         "related": "https://pkc-00000.region.provider.confluent.cloud/kafka/v3/clusters/cluster-1/brokers/1"
         *       }
         *     } */
        "application/json": components["schemas"]["RemoveBrokerTaskData"];
      };
    };
    /** @description The list of remove broker tasks. */
    ListRemoveBrokerTaskResponse: {
      headers: {
        [name: string]: unknown;
      };
      content: {
        /** @example {
         *       "kind": "KafkaRemoveBrokerTaskList",
         *       "metadata": {
         *         "self": "https://pkc-00000.region.provider.confluent.cloud/kafka/v3/clusters/cluster-1/remove-broker-tasks",
         *         "next": null
         *       },
         *       "data": [
         *         {
         *           "kind": "KafkaRemoveBrokerTask",
         *           "metadata": {
         *             "self": "https://pkc-00000.region.provider.confluent.cloud/kafka/v3/clusters/cluster-1/remove-broker-tasks/1",
         *             "resource_name": "crn:///kafka=cluster-1/remove-broker-task=1"
         *           },
         *           "cluster_id": "cluster-1",
         *           "broker_id": 1,
         *           "shutdown_scheduled": true,
         *           "broker_replica_exclusion_status": "COMPLETED",
         *           "partition_reassignment_status": "FAILED",
         *           "broker_shutdown_status": "CANCELED",
         *           "error_code": 10006,
         *           "error_message": "Error while computing the initial remove broker plan for brokers [1] prior to shutdown.",
         *           "broker": {
         *             "related": "https://pkc-00000.region.provider.confluent.cloud/kafka/v3/clusters/cluster-1/brokers/1"
         *           }
         *         },
         *         {
         *           "kind": "KafkaRemoveBrokerTask",
         *           "metadata": {
         *             "self": "https://pkc-00000.region.provider.confluent.cloud/kafka/v3/clusters/cluster-1/remove-broker-tasks/2",
         *             "resource_name": "crn:///kafka=cluster-1/remove-broker-task=2"
         *           },
         *           "cluster_id": "cluster-1",
         *           "broker_id": 2,
         *           "shutdown_scheduled": true,
         *           "broker_replica_exclusion_status": "EXCLUDED",
         *           "partition_reassignment_status": "FAILED",
         *           "broker_shutdown_status": "CANCELED",
         *           "error_code": 10006,
         *           "error_message": "Error while computing the initial remove broker plan for brokers [2] prior to shutdown.",
         *           "broker": {
         *             "related": "https://pkc-00000.region.provider.confluent.cloud/kafka/v3/clusters/cluster-1/brokers/2"
         *           }
         *         }
         *       ]
         *     } */
        "application/json": components["schemas"]["RemoveBrokerTaskDataList"];
      };
    };
    /** @description Operation succeeded, no content in the response */
    NoContentResponse: {
      headers: {
        [name: string]: unknown;
      };
      content?: never;
    };
    /** @description A list of link names and properties */
    ListLinksResponse: {
      headers: {
        [name: string]: unknown;
      };
      content: {
        /** @example {
         *       "kind": "KafkaLinkDataList",
         *       "metadata": {
         *         "self": "https://pkc-00000.region.provider.confluent.cloud/kafka/v3/clusters/Fds7TcT9TTqEXsoRLEKMcQ/links",
         *         "next": null
         *       },
         *       "data": [
         *         {
         *           "kind": "KafkaLinkData",
         *           "metadata": {
         *             "self": "https://pkc-00000.region.provider.confluent.cloud/kafka/v3/clusters/CIL-69l7S1CwoVNAhoQLug/links/my-new-link-1",
         *             "resource_name": null
         *           },
         *           "source_cluster_id": "src-cluster-id",
         *           "link_name": "my-new-link-1",
         *           "link_id": "7840644d-f7d8-4844-a577-a10ef3df31df",
         *           "cluster_link_id": "eEBkTffYSESld6EO898x3w",
         *           "topic_names": [
         *             "topic-sb-1",
         *             "topic-sb-2"
         *           ],
         *           "link_state": "ACTIVE"
         *         },
         *         {
         *           "kind": "KafkaLinkData",
         *           "metadata": {
         *             "self": "https://pkc-00000.region.provider.confluent.cloud/kafka/v3/clusters/CIL-69l7S1CwoVNAhoQLug/links/my-new-link-2",
         *             "resource_name": null
         *           },
         *           "remote_cluster_id": "src-cluster-id",
         *           "link_name": "my-new-link-2",
         *           "link_id": "f749116e-f847-4bd2-b1f6-5c4e518a0678",
         *           "cluster_link_id": "90kRbvhHS9Kx9lxOUYoGeA",
         *           "topic_names": [
         *             "topic-db-1",
         *             "topic-db-2"
         *           ],
         *           "link_state": "UNAVAILABLE",
         *           "link_error": "AUTHENTICATION_ERROR",
         *           "link_error_message": "Please check your api key and secret"
         *         },
         *         {
         *           "kind": "KafkaLinkData",
         *           "metadata": {
         *             "self": "https://pkc-00000.region.provider.confluent.cloud/kafka/v3/clusters/CIL-69l7S1CwoVNAhoQLug/links/my-new-link-3",
         *             "resource_name": null
         *           },
         *           "destination_cluster_id": "dest-cluster-id",
         *           "link_name": "my-new-link-3",
         *           "link_id": "9cd1711e-a4ef-4390-a35e-dfd758d97a82",
         *           "cluster_link_id": "nNFxHqTvQ5CjXt_XWNl6gg",
         *           "topic_names": [],
         *           "link_state": "ACTIVE"
         *         }
         *       ]
         *     } */
        "application/json": components["schemas"]["ListLinksResponseDataList"];
      };
    };
    /** @description Single link name and properties */
    GetLinkResponse: {
      headers: {
        [name: string]: unknown;
      };
      content: {
        "application/json": components["schemas"]["ListLinksResponseData"];
      };
    };
    /** @description Config name and value */
    ListLinkConfigsResponse: {
      headers: {
        [name: string]: unknown;
      };
      content: {
        /** @example {
         *       "kind": "KafkaLinkConfigDataList",
         *       "metadata": {
         *         "self": "https://pkc-00000.region.provider.confluent.cloud/kafka/v3/clusters/v-0Ce-CkTyKQol9v46LaCQ/links/link-nb-1/configs",
         *         "next": null
         *       },
         *       "data": [
         *         {
         *           "kind": "KafkaLinkConfigData",
         *           "metadata": {
         *             "self": "https://pkc-00000.region.provider.confluent.cloud/kafka/v3/clusters/1Rh_4htxSuen7RYGvGmgNw/links/my-new-link-1",
         *             "resource_name": null
         *           },
         *           "cluster_id": "1Rh_4htxSuen7RYGvGmgNw",
         *           "name": "consumer.offset.sync.ms",
         *           "value": "3825940",
         *           "default": false,
         *           "read_only": false,
         *           "sensitive": false,
         *           "source": "DYNAMIC_CLUSTER_LINK_CONFIG",
         *           "synonyms": [
         *             "cosm"
         *           ],
         *           "link_name": "link-db-1",
         *           "link_id": "7840644d-f7d8-4844-a577-a10ef3df31df"
         *         },
         *         {
         *           "kind": "KafkaLinkConfigData",
         *           "metadata": {
         *             "self": "https://pkc-00000.region.provider.confluent.cloud/kafka/v3/clusters/1Rh_4htxSuen7RYGvGmgNw/links/my-new-link-1",
         *             "resource_name": null
         *           },
         *           "cluster_id": "1Rh_4htxSuen7RYGvGmgNw",
         *           "name": "acl.sync.ms",
         *           "value": "5000",
         *           "default": false,
         *           "read_only": false,
         *           "sensitive": false,
         *           "source": "DYNAMIC_CLUSTER_LINK_CONFIG",
         *           "synonyms": [
         *             "asm"
         *           ],
         *           "link_name": "link-db-1",
         *           "link_id": "7840644d-f7d8-4844-a577-a10ef3df31df"
         *         }
         *       ]
         *     } */
        "application/json": components["schemas"]["ListLinkConfigsResponseDataList"];
      };
    };
    /** @description Config name and value */
    GetLinkConfigsResponse: {
      headers: {
        [name: string]: unknown;
      };
      content: {
        /** @example {
         *       "kind": "KafkaLinkConfigData",
         *       "metadata": {
         *         "self": "https://pkc-00000.region.provider.confluent.cloud/kafka/v3/clusters/1Rh_4htxSuen7RYGvGmgNw/links/my-new-link-1",
         *         "resource_name": null
         *       },
         *       "cluster_id": "1Rh_4htxSuen7RYGvGmgNw",
         *       "name": "consumer.offset.sync.ms",
         *       "value": "3825940",
         *       "default": false,
         *       "read_only": false,
         *       "sensitive": false,
         *       "source": "DYNAMIC_CLUSTER_LINK_CONFIG",
         *       "synonyms": [
         *         "cosm"
         *       ],
         *       "link_name": "link-db-1",
         *       "link_id": "7840644d-f7d8-4844-a577-a10ef3df31df",
         *       "topics": [
         *         "topic-db-1",
         *         "topic-db-2"
         *       ]
         *     } */
        "application/json": components["schemas"]["ListLinkConfigsResponseData"];
      };
    };
    /** @description Metadata of mirror topics */
    ListMirrorTopicsResponse: {
      headers: {
        [name: string]: unknown;
      };
      content: {
        /** @example {
         *       "kind": "KafkaMirrorDataList",
         *       "metadata": {
         *         "self": "https://pkc-00000.region.provider.confluent.cloud/kafka/v3/clusters/cluster-1/link/link-1/mirrors",
         *         "resource_name": "crn:///kafka=cluster-1",
         *         "next": null
         *       },
         *       "data": [
         *         {
         *           "kind": "KafkaMirrorData",
         *           "metadata": {
         *             "self": "https://pkc-00000.region.provider.confluent.cloud/kafka/v3/clusters/Fds7TcT9TTqEXsoRLEKMcQ/links/link-1/mirrors/topic-1",
         *             "resource_name": "crn:///kafka=cluster-1"
         *           },
         *           "link_name": "link-sb-1",
         *           "resource_name": "crn:///kafka=cluster-1",
         *           "mirror_topic_name": "topic-1",
         *           "source_topic_name": "topic-1",
         *           "num_partitions": 3,
         *           "mirror_lags": [
         *             {
         *               "partition": 0,
         *               "lag": 0,
         *               "last_source_fetch_offset": 0
         *             },
         *             {
         *               "partition": 1,
         *               "lag": 10000,
         *               "last_source_fetch_offset": 1000
         *             },
         *             {
         *               "partition": 2,
         *               "lag": 40000,
         *               "last_source_fetch_offset": 12030
         *             }
         *           ],
         *           "mirror_status": "ACTIVE",
         *           "state_time_ms": 1612550939300
         *         },
         *         {
         *           "kind": "KafkaMirrorData",
         *           "metadata": {
         *             "self": "https://pkc-00000.region.provider.confluent.cloud/kafka/v3/clusters/Fds7TcT9TTqEXsoRLEKMcQ/links/link-1/mirrors/topic-2",
         *             "resource_name": "crn:///kafka=cluster-1"
         *           },
         *           "link_name": "link-sb-2",
         *           "resource_name": "crn:///kafka=cluster-1",
         *           "mirror_topic_name": "topic-2",
         *           "source_topic_name": "topic-2",
         *           "num_partitions": 3,
         *           "mirror_lags": [
         *             {
         *               "partition": 0,
         *               "lag": 0,
         *               "last_source_fetch_offset": 0
         *             },
         *             {
         *               "partition": 1,
         *               "lag": 10000,
         *               "last_source_fetch_offset": 1000
         *             },
         *             {
         *               "partition": 2,
         *               "lag": 40000,
         *               "last_source_fetch_offset": 12030
         *             }
         *           ],
         *           "mirror_status": "STOPPED",
         *           "state_time_ms": 1612551353640
         *         }
         *       ]
         *     } */
        "application/json": components["schemas"]["ListMirrorTopicsResponseDataList"];
      };
    };
    /** @description Metadata of the mirror topic */
    DescribeMirrorTopicResponse: {
      headers: {
        [name: string]: unknown;
      };
      content: {
        /** @example {
         *       "kind": "KafkaMirrorData",
         *       "metadata": {
         *         "self": "https://pkc-00000.region.provider.confluent.cloud/kafka/v3/clusters/cluster-1/link/link-1/mirrors/topic-1",
         *         "resource_name": "crn:///kafka=cluster-1"
         *       },
         *       "link_name": "link-sb-1",
         *       "mirror_topic_name": "topic-1",
         *       "source_topic_name": "topic-1",
         *       "num_partitions": 3,
         *       "mirror_lags": [
         *         {
         *           "partition": 0,
         *           "lag": 0,
         *           "last_source_fetch_offset": 0
         *         },
         *         {
         *           "partition": 1,
         *           "lag": 10000,
         *           "last_source_fetch_offset": 1000
         *         },
         *         {
         *           "partition": 2,
         *           "lag": 40000,
         *           "last_source_fetch_offset": 12030
         *         }
         *       ],
         *       "mirror_status": "ACTIVE",
         *       "state_time_ms": 1612550939300
         *     } */
        "application/json": components["schemas"]["ListMirrorTopicsResponseData"];
      };
    };
    /** @description Mirror status alternation result */
    AlterMirrorStatusResponse: {
      headers: {
        [name: string]: unknown;
      };
      content: {
        /** @example {
         *       "kind": "KafkaPromoteMirror",
         *       "metadata": {
         *         "self": "https://pkc-00000.region.provider.confluent.cloud/kafka/v3/clusters/cluster-1/links/link-1/mirrors",
         *         "resource_name": "crn:///kafka=cluster-1"
         *       },
         *       "data": [
         *         {
         *           "kind": "AlterMirrorsData",
         *           "metadata": {
         *             "self": "https://pkc-00000.region.provider.confluent.cloud/kafka/v3/clusters/cluster-1/links/my-new-link-1/mirrors/topic-1",
         *             "resource": "crn:///kafka=cluster-1"
         *           },
         *           "mirror_topic_name": "topic-sb",
         *           "error_code": null,
         *           "error_message": null,
         *           "mirror_lags": [
         *             {
         *               "partition": 0,
         *               "lag": 0,
         *               "last_source_fetch_offset": 0
         *             },
         *             {
         *               "partition": 1,
         *               "lag": 10000,
         *               "last_source_fetch_offset": 1000
         *             },
         *             {
         *               "partition": 2,
         *               "lag": 40000,
         *               "last_source_fetch_offset": 12030
         *             }
         *           ],
         *           "messages_truncated": null,
         *           "partition_level_truncation_data": [
         *             {
         *               "partition_id": 0,
         *               "offset_truncated_to": 10000,
         *               "messages_truncated": 10000
         *             },
         *             {
         *               "partition_id": 1,
         *               "offset_truncated_to": 40000,
         *               "messages_truncated": 12030
         *             },
         *             {
         *               "partition_id": 2,
         *               "offset_truncated_to": 20000,
         *               "messages_truncated": 20000
         *             }
         *           ]
         *         },
         *         {
         *           "kind": "AlterMirrorsData",
         *           "metadata": {
         *             "self": "https://pkc-00000.region.provider.confluent.cloud/kafka/v3/clusters/cluster-1/links/my-new-link-1/mirrors/topic-2",
         *             "resource": "crn:///kafka=cluster-1"
         *           },
         *           "mirror_topic_name": "topic-2",
         *           "error_code": 400,
         *           "error_message": "Topic 'topic-2' has already stopped its mirror from 'my-new-link-1'",
         *           "mirror_lags": [
         *             {
         *               "partition": 0,
         *               "lag": 0,
         *               "last_source_fetch_offset": 0
         *             },
         *             {
         *               "partition": 1,
         *               "lag": 10000,
         *               "last_source_fetch_offset": 1000
         *             },
         *             {
         *               "partition": 2,
         *               "lag": 40000,
         *               "last_source_fetch_offset": 12030
         *             }
         *           ],
         *           "messages_truncated": null,
         *           "partition_level_truncation_data": [
         *             {
         *               "partition_id": 0,
         *               "offset_truncated_to": 10000,
         *               "messages_truncated": 10000
         *             },
         *             {
         *               "partition_id": 1,
         *               "offset_truncated_to": 40000,
         *               "messages_truncated": 12030
         *             },
         *             {
         *               "partition_id": 2,
         *               "offset_truncated_to": 20000,
         *               "messages_truncated": 20000
         *             }
         *           ]
         *         }
         *       ]
         *     } */
        "application/json": components["schemas"]["AlterMirrorStatusResponseDataList"];
      };
    };
    /** @description Bad broker or balancer request */
    BadBrokerOrBalancerRequestErrorResponse: {
      headers: {
        [name: string]: unknown;
      };
      content: {
        "application/json": components["schemas"]["Error"];
      };
    };
    /** @description Balancer offline */
    BalancerOfflineErrorResponse: {
      headers: {
        [name: string]: unknown;
      };
      content: {
        /** @example {
         *       "error_code": 400,
         *       "message": "The Confluent Balancer component is disabled or not started yet."
         *     } */
        "application/json": components["schemas"]["Error"];
      };
    };
    /** @description Broker not found. */
    BrokerNotFoundErrorResponse: {
      headers: {
        [name: string]: unknown;
      };
      content: {
        /** @example {
         *       "error_code": 404,
         *       "message": "Broker not found. Broker: 1 not found in the cluster: cluster-1"
         *     } */
        "application/json": components["schemas"]["Error"];
      };
    };
    /** @description Unrepresentable broker id. */
    UnrepresentableBrokerErrorResponse: {
      headers: {
        [name: string]: unknown;
      };
      content: {
        /** @example {
         *       "error_code": 400,
         *       "message": "The given broker id -10 is invalid"
         *     } */
        "application/json": components["schemas"]["Error"];
      };
    };
    /** @description Confluent Balancer disabled or not started. */
    BalancerNotEnabledErrorResponse: {
      headers: {
        [name: string]: unknown;
      };
      content: {
        /** @example {
         *       "error_code": 500,
         *       "message": "The Confluent Balancer component is disabled or not started yet."
         *     } */
        "application/json": components["schemas"]["Error"];
      };
    };
    /** @description Operation not authorized. */
    ClusterAuthorizationErrorResponse: {
      headers: {
        [name: string]: unknown;
      };
      content: {
        /** @example {
         *       "error_code": 401,
         *       "message": "Not authorized: the authenticated user didn't have the right access to the resource."
         *     } */
        "application/json": components["schemas"]["Error"];
      };
    };
    /** @description The cluster link doesn't exist. */
    ClusterLinkNotFoundErrorResponse: {
      headers: {
        [name: string]: unknown;
      };
      content: {
        /** @example {
         *       "error_code": 404,
         *       "message": "The cluster link doesn't exist."
         *     } */
        "application/json": components["schemas"]["Error"];
      };
    };
    /** @description The cluster link doesn't exist. */
    InvalidClusterLinkErrorResponse: {
      headers: {
        [name: string]: unknown;
      };
      content: {
        /** @example {
         *       "error_code": 400,
         *       "message": "Invalid Cluster Link Name."
         *     } */
        "application/json": components["schemas"]["Error"];
      };
    };
    /** @description Invalid Config Name. */
    InvalidConfigNameErrorResponse: {
      headers: {
        [name: string]: unknown;
      };
      content: {
        /** @example {
         *       "error_code": 400,
         *       "message": "Invalid Config Name."
         *     } */
        "application/json": components["schemas"]["Error"];
      };
    };
    /** @description A cluster link already exists with the provided link name */
    ClusterLinkExistsErrorResponse: {
      headers: {
        [name: string]: unknown;
      };
      content: {
        /** @example {
         *       "error_code": 404,
         *       "message": "A cluster link already exists with the provided link name"
         *     } */
        "application/json": components["schemas"]["Error"];
      };
    };
    /** @description The server received the request, but the operation timed out */
    TimeoutErrorResponse: {
      headers: {
        [name: string]: unknown;
      };
      content: {
        /** @example {
         *       "error_code": 408,
         *       "message": "The server received the request, but the operation timed out"
         *     } */
        "application/json": components["schemas"]["Error"];
      };
    };
    /** @description Bad Request */
    "schemaregistry.v1.BadRequestError": {
      headers: {
        [name: string]: unknown;
      };
      content: {
        /** @example {
         *       "error_code": 400,
         *       "message": "Bad Request"
         *     } */
        "application/json": components["schemas"]["ErrorMessage"];
      };
    };
    /** @description Unauthorized */
    "schemaregistry.v1.UnauthorizedError": {
      headers: {
        [name: string]: unknown;
      };
      content: {
        /** @example {
         *       "error_code": 401,
         *       "message": "Unauthorized"
         *     } */
        "application/json": components["schemas"]["ErrorMessage"];
      };
    };
    /** @description Forbidden */
    "schemaregistry.v1.ForbiddenError": {
      headers: {
        [name: string]: unknown;
      };
      content: {
        /** @example {
         *       "error_code": 403,
         *       "message": "Forbidden"
         *     } */
        "application/json": components["schemas"]["ErrorMessage"];
      };
    };
    /** @description Not Found */
    "schemaregistry.v1.AccountNotFoundError": {
      headers: {
        [name: string]: unknown;
      };
      content: {
        /** @example {
         *       "error_code": 404,
         *       "message": "account not found"
         *     } */
        "application/json": components["schemas"]["ErrorMessage"];
      };
    };
    /** @description Not Found */
    "schemaregistry.v1.ResourceNotFoundError": {
      headers: {
        [name: string]: unknown;
      };
      content: {
        /** @example {
         *       "error_code": 404,
         *       "message": "resource not found"
         *     } */
        "application/json": components["schemas"]["ErrorMessage"];
      };
    };
    /** @description Internal Server Error */
    "schemaregistry.v1.DefaultSystemError": {
      headers: {
        [name: string]: unknown;
      };
      content: {
        /** @example {
         *       "error_code": 500,
         *       "message": "Oops, something went wrong"
         *     } */
        "application/json": components["schemas"]["ErrorMessage"];
      };
    };
  };
  parameters: {
    /** @description The ACL host. */
    AclHost: string;
    /** @description The ACL operation. */
    AclOperation: components["schemas"]["AclOperation"];
    /** @description The ACL operation. */
    AclOperationRequired: components["schemas"]["AclOperation"];
    /** @description The ACL pattern type. */
    AclPatternType: components["schemas"]["AclPatternType"];
    /** @description The ACL pattern type. */
    AclPatternTypeRequired: components["schemas"]["AclPatternType"];
    /** @description The ACL permission. */
    AclPermission: components["schemas"]["AclPermission"];
    /** @description The ACL permission. */
    AclPermissionRequired: components["schemas"]["AclPermission"];
    /** @description The ACL principal. This is the Service Account name or user name. */
    AclPrincipal: string;
    /** @description The ACL resource name. */
    AclResourceName: string;
    /** @description The ACL resource type. */
    AclResourceType: components["schemas"]["AclResourceType"];
    /** @description The ACL resource type. */
    AclResourceTypeRequired: components["schemas"]["AclResourceType"];
    /**
     * @description The Kafka broker ID.
     * @example 1
     */
    BrokerId: number;
    /**
     * @description The Kafka cluster ID.
     * @example cluster-1
     */
    ClusterId: string;
    /**
     * @description The configuration parameter name.
     * @example compression.type
     */
    ConfigName: string;
    /**
     * @description The consumer group ID.
     * @example consumer-group-1
     */
    ConsumerGroupId: string;
    /**
     * @description The consumer ID.
     * @example consumer-1
     */
    ConsumerId: string;
    /** @description Specify if authorized operations should be included in the response. */
    IncludeAuthorizedOperations: boolean;
    /**
     * @description The partition ID.
     * @example 0
     */
    PartitionId: number;
    /**
     * @description The topic name.
     * @example topic-1
     */
    TopicName: string;
    /**
     * @description The Kafka broker task type.
     * @example remove-broker
     */
    BrokerTaskType: components["schemas"]["BrokerTaskType"];
    /**
     * @description To shutdown the broker or not, Default: true
     * @example true
     */
    ShouldShutdown: boolean;
    /**
     * @description To validate the action can be performed successfully or not. Default: false
     * @example false
     */
    ValidateOnly: boolean;
    /**
     * @description To synchronously validate that the source cluster ID is expected and the dest cluster has the permission to read topics in the source cluster. Default: true
     * @example false
     */
    ValidateLink: boolean;
    /**
     * @description Whether to include cluster linking tasks in the response. Default: false
     * @example false
     */
    IncludeTasks: boolean;
    /**
     * @description Whether to include mirror state transition errors in the response. Default: false
     * @example false
     */
    IncludeStateTransitionErrors: boolean;
    /**
     * @description Force the action. Default: false
     * @example false
     */
    Force: boolean;
    /**
     * @description Whether to include partition level truncation information when truncating and restoring a topic in the response. Default: false
     * @example false
     */
    IncludePartitionLevelTruncationData: boolean;
    /**
     * @description The link name
     * @example link-sb1
     */
    LinkName: string;
    /**
     * @description The link config name
     * @example consumer.offset.sync.enable
     */
    LinkConfigName: string;
    /**
     * @description The status of the mirror topic. If not specified, all mirror topics will be returned.
     * @example ACTIVE
     */
    MirrorTopicStatus: components["schemas"]["MirrorTopicStatus"];
    /**
     * @description Cluster Linking mirror topic name
     * @example topic-1
     */
    MirrorTopicName: string;
    /**
     * @description The link name
     * @example link-sb1
     */
    QueryParamLinkName: string;
  };
  requestBodies: {
    /** @description The alter broker configuration parameter batch request. */
    AlterBrokerConfigBatchRequest: {
      content: {
        /** @example {
         *       "data": [
         *         {
         *           "name": "max.connections",
         *           "operation": "DELETE"
         *         },
         *         {
         *           "name": "compression.type",
         *           "value": "gzip"
         *         }
         *       ]
         *     } */
        "application/json": components["schemas"]["AlterConfigBatchRequestData"];
      };
    };
    /** @description The alter cluster configuration parameter batch request. */
    AlterClusterConfigBatchRequest: {
      content: {
        /** @example {
         *       "data": [
         *         {
         *           "name": "max.connections",
         *           "operation": "DELETE"
         *         },
         *         {
         *           "name": "compression.type",
         *           "value": "gzip"
         *         }
         *       ]
         *     } */
        "application/json": components["schemas"]["AlterConfigBatchRequestData"];
      };
    };
    /** @description The alter topic configuration parameter batch request. */
    AlterTopicConfigBatchRequest: {
      content: {
        "application/json": components["schemas"]["AlterConfigBatchRequestData"];
      };
    };
    /** @description The ACL creation request. */
    CreateAclRequest: {
      content: {
        /** @example {
         *       "resource_type": "CLUSTER",
         *       "resource_name": "kafka-cluster",
         *       "pattern_type": "LITERAL",
         *       "principal": "principalType:principalName",
         *       "host": "*",
         *       "operation": "DESCRIBE",
         *       "permission": "DENY"
         *     } */
        "application/json": components["schemas"]["CreateAclRequestData"];
      };
    };
    /** @description The batch ACL creation request. */
    BatchCreateAclRequest: {
      content: {
        /** @example {
         *       "data": [
         *         {
         *           "resource_type": "CLUSTER",
         *           "resource_name": "kafka-cluster",
         *           "pattern_type": "LITERAL",
         *           "principal": "principalType:principalName",
         *           "host": "*",
         *           "operation": "DESCRIBE",
         *           "permission": "DENY"
         *         },
         *         {
         *           "resource_type": "TOPIC",
         *           "resource_name": "kafka-cluster",
         *           "pattern_type": "LITERAL",
         *           "principal": "principalType:principalName",
         *           "host": "*",
         *           "operation": "READ",
         *           "permission": "ALLOW"
         *         }
         *       ]
         *     } */
        "application/json": components["schemas"]["CreateAclRequestDataList"];
      };
    };
    /** @description The topic creation request. Note that Confluent Cloud allows only specific replication factor values. Because of that the replication factor field should either be omitted or it should use one of the allowed values (see https://docs.confluent.io/cloud/current/client-apps/optimizing/durability.html). */
    CreateTopicRequest: {
      content: {
        "application/json": components["schemas"]["CreateTopicRequestData"];
      };
    };
    /** @description A single record to be produced to Kafka. To produce multiple records in the same request, simply concatenate the records. The delivery reports are concatenated in the same order as the records are sent. */
    ProduceRequest: {
      content: {
        "application/json": components["schemas"]["ProduceRequest"];
      };
    };
    /** @description The broker configuration parameter update request. */
    UpdateBrokerConfigRequest: {
      content: {
        /** @example {
         *       "value": "gzip"
         *     } */
        "application/json": components["schemas"]["UpdateConfigRequestData"];
      };
    };
    /** @description The cluster configuration parameter update request. */
    UpdateClusterConfigRequest: {
      content: {
        /** @example {
         *       "value": "gzip"
         *     } */
        "application/json": components["schemas"]["UpdateConfigRequestData"];
      };
    };
    /** @description The topic configuration parameter update request. */
    UpdateTopicConfigRequest: {
      content: {
        /** @example {
         *       "value": "gzip"
         *     } */
        "application/json": components["schemas"]["UpdateConfigRequestData"];
      };
    };
    /** @description Create a cluster link */
    CreateLinkRequest: {
      content: {
        "application/json": components["schemas"]["CreateLinkRequestData"];
      };
    };
    /** @description Link config value to update */
    UpdateLinkConfigRequest: {
      content: {
        /** @example {
         *       "value": "300000"
         *     } */
        "application/json": components["schemas"]["UpdateLinkConfigRequestData"];
      };
    };
    AlterLinkConfigBatchRequest: {
      content: {
        /** @example {
         *       "data": [
         *         {
         *           "name": "cleanup.policy",
         *           "operation": "DELETE"
         *         },
         *         {
         *           "name": "compression.type",
         *           "value": "gzip"
         *         }
         *       ]
         *     } */
        "application/json": components["schemas"]["AlterConfigBatchRequestData"];
      };
    };
    /** @description Name and configs of the topics mirroring from and mirroring to. Note that Confluent Cloud allows only specific replication factor values. Because of that the replication factor field should either be omitted or it should use one of the allowed values (see https://docs.confluent.io/cloud/current/client-apps/optimizing/durability.html). */
    CreateMirrorTopicRequest: {
      content: {
        "application/json": components["schemas"]["CreateMirrorTopicRequestData"];
      };
    };
    /** @description Mirror topics to be altered. */
    AlterMirrorsRequest: {
      content: {
        "application/json": components["schemas"]["AlterMirrorsRequestData"];
      };
    };
    /** @description Broker ids to remove */
    RemoveBrokersRequest: {
      content: {
        /** @example {
         *       "broker_ids": [
         *         1,
         *         2,
         *         3
         *       ]
         *     } */
        "application/json": components["schemas"]["RemoveBrokersRequestData"];
      };
    };
    /** @description Alter Broker Replica Exclusions. */
    BrokerReplicaExclusionBatchRequest: {
      content: {
        /** @example {
         *       "data": [
         *         {
         *           "broker_id": 1,
         *           "reason": "The broker is to be removed."
         *         },
         *         {
         *           "broker_id": 2,
         *           "reason": "The broker is to be removed."
         *         }
         *       ]
         *     } */
        "application/json": components["schemas"]["BrokerReplicaExclusionBatchRequestData"];
      };
    };
  };
  headers: never;
  pathItems: never;
}
export type $defs = Record<string, never>;
export interface operations {
  listIamV2ApiKeys: {
    parameters: {
      query?: {
        /** @description Filter the results by exact match for spec.owner. */
        "spec.owner"?: components["schemas"]["SearchFilter"];
        /** @description Filter the results by exact match for spec.resource. */
        "spec.resource"?: components["schemas"]["SearchFilter"];
        /** @description A pagination size for collection requests. */
        page_size?: number;
        /** @description An opaque pagination token for collection requests. */
        page_token?: string;
      };
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description API Key. */
      200: {
        headers: {
          /** @description The unique identifier for the API request. */
          "X-Request-Id"?: string;
          /** @description The maximum number of requests you're permitted to make per time period. */
          "X-RateLimit-Limit"?: number;
          /** @description The number of requests remaining in the current rate limit window. */
          "X-RateLimit-Remaining"?: number;
          /** @description The relative time in seconds until the current rate-limit window resets.
           *
           *     **Important:** This differs from Github and Twitter's same-named header which uses UTC epoch seconds. We use relative time to avoid client/server time synchronization issues. */
          "X-RateLimit-Reset"?: number;
          [name: string]: unknown;
        };
        content: {
          "application/json": components["schemas"]["iam.v2.ApiKeyList"] & {
            data?: {
              spec?: {
                /** @example {
                 *       "id": "u-a83k9b",
                 *       "related": "https://api.confluent.cloud/iam/v2/users/u-a83k9b",
                 *       "resource_name": "https://api.confluent.cloud/user=u-a83k9b"
                 *     } */
                owner?: unknown;
                /** @example {
                 *       "id": "lkc-c29js0",
                 *       "related": "https://api.confluent.cloud/cmk/v2/clusters/lkc-c29js0",
                 *       "resource_name": "https://api.confluent.cloud/organization=9bb441c4-edef-46ac-8a41-c49e44a3fd9a/environment=env-abc123/cloud-cluster=lkc-c29js0"
                 *     } */
                resource?: unknown;
              };
            }[];
          };
        };
      };
      400: components["responses"]["BadRequestError"];
      401: components["responses"]["UnauthenticatedError"];
      403: components["responses"]["UnauthorizedError"];
      429: components["responses"]["RateLimitError"];
      500: components["responses"]["DefaultSystemError"];
    };
  };
  createIamV2ApiKey: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody?: {
      content: {
        "application/json": components["schemas"]["iam.v2.ApiKey"] & {
          spec: Record<string, unknown>;
        } & {
          spec?: {
            /** @example {
             *       "id": "u-a83k9b"
             *     } */
            owner?: unknown;
            /** @example {
             *       "id": "lkc-c29js0"
             *     } */
            resource?: unknown;
          };
        };
      };
    };
    responses: {
      /** @description An API Key is being created. */
      202: {
        headers: {
          /** @description The unique identifier for the API request. */
          "X-Request-Id"?: string;
          /** @description The maximum number of requests you're permitted to make per time period. */
          "X-RateLimit-Limit"?: number;
          /** @description The number of requests remaining in the current rate limit window. */
          "X-RateLimit-Remaining"?: number;
          /** @description The relative time in seconds until the current rate-limit window resets.
           *
           *     **Important:** This differs from Github and Twitter's same-named header which uses UTC epoch seconds. We use relative time to avoid client/server time synchronization issues. */
          "X-RateLimit-Reset"?: number;
          /** @description ApiKey resource uri */
          Location?: string;
          [name: string]: unknown;
        };
        content: {
          "application/json": components["schemas"]["iam.v2.ApiKey"] & {
            spec: Record<string, unknown>;
          } & {
            spec?: {
              /** @example {
               *       "id": "u-a83k9b",
               *       "related": "https://api.confluent.cloud/iam/v2/users/u-a83k9b",
               *       "resource_name": "https://api.confluent.cloud/user=u-a83k9b"
               *     } */
              owner?: unknown;
              /** @example {
               *       "id": "lkc-c29js0",
               *       "related": "https://api.confluent.cloud/cmk/v2/clusters/lkc-c29js0",
               *       "resource_name": "https://api.confluent.cloud/organization=9bb441c4-edef-46ac-8a41-c49e44a3fd9a/environment=env-abc123/cloud-cluster=lkc-c29js0"
               *     } */
              resource?: unknown;
            };
          };
        };
      };
      400: components["responses"]["BadRequestError"];
      401: components["responses"]["UnauthenticatedError"];
      402: components["responses"]["OverQuotaError"];
      403: components["responses"]["UnauthorizedError"];
      409: components["responses"]["ConflictError"];
      422: components["responses"]["ValidationError"];
      429: components["responses"]["RateLimitError"];
      500: components["responses"]["DefaultSystemError"];
    };
  };
  getIamV2ApiKey: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description The unique identifier for the API key. */
        id: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description API Key. */
      200: {
        headers: {
          /** @description The unique identifier for the API request. */
          "X-Request-Id"?: string;
          /** @description The maximum number of requests you're permitted to make per time period. */
          "X-RateLimit-Limit"?: number;
          /** @description The number of requests remaining in the current rate limit window. */
          "X-RateLimit-Remaining"?: number;
          /** @description The relative time in seconds until the current rate-limit window resets.
           *
           *     **Important:** This differs from Github and Twitter's same-named header which uses UTC epoch seconds. We use relative time to avoid client/server time synchronization issues. */
          "X-RateLimit-Reset"?: number;
          [name: string]: unknown;
        };
        content: {
          "application/json": components["schemas"]["iam.v2.ApiKey"] & {
            spec: Record<string, unknown>;
          } & {
            spec?: {
              /** @example {
               *       "id": "u-a83k9b",
               *       "related": "https://api.confluent.cloud/iam/v2/users/u-a83k9b",
               *       "resource_name": "https://api.confluent.cloud/user=u-a83k9b"
               *     } */
              owner?: unknown;
              /** @example {
               *       "id": "lkc-c29js0",
               *       "related": "https://api.confluent.cloud/cmk/v2/clusters/lkc-c29js0",
               *       "resource_name": "https://api.confluent.cloud/organization=9bb441c4-edef-46ac-8a41-c49e44a3fd9a/environment=env-abc123/cloud-cluster=lkc-c29js0"
               *     } */
              resource?: unknown;
            };
          };
        };
      };
      400: components["responses"]["BadRequestError"];
      401: components["responses"]["UnauthenticatedError"];
      403: components["responses"]["UnauthorizedError"];
      404: components["responses"]["NotFoundError"];
      429: components["responses"]["RateLimitError"];
      500: components["responses"]["DefaultSystemError"];
    };
  };
  deleteIamV2ApiKey: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description The unique identifier for the API key. */
        id: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description An API Key is being deleted. */
      204: {
        headers: {
          /** @description The unique identifier for the API request. */
          "X-Request-Id"?: string;
          /** @description The maximum number of requests you're permitted to make per time period. */
          "X-RateLimit-Limit"?: number;
          /** @description The number of requests remaining in the current rate limit window. */
          "X-RateLimit-Remaining"?: number;
          /** @description The relative time in seconds until the current rate-limit window resets.
           *
           *     **Important:** This differs from Github and Twitter's same-named header which uses UTC epoch seconds. We use relative time to avoid client/server time synchronization issues. */
          "X-RateLimit-Reset"?: number;
          [name: string]: unknown;
        };
        content?: never;
      };
      400: components["responses"]["BadRequestError"];
      401: components["responses"]["UnauthenticatedError"];
      403: components["responses"]["UnauthorizedError"];
      404: components["responses"]["NotFoundError"];
      429: components["responses"]["RateLimitError"];
      500: components["responses"]["DefaultSystemError"];
    };
  };
  updateIamV2ApiKey: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description The unique identifier for the API key. */
        id: string;
      };
      cookie?: never;
    };
    requestBody?: {
      content: {
        "application/json": components["schemas"]["iam.v2.ApiKeyUpdate"];
      };
    };
    responses: {
      /** @description API Key. */
      200: {
        headers: {
          /** @description The unique identifier for the API request. */
          "X-Request-Id"?: string;
          /** @description The maximum number of requests you're permitted to make per time period. */
          "X-RateLimit-Limit"?: number;
          /** @description The number of requests remaining in the current rate limit window. */
          "X-RateLimit-Remaining"?: number;
          /** @description The relative time in seconds until the current rate-limit window resets.
           *
           *     **Important:** This differs from Github and Twitter's same-named header which uses UTC epoch seconds. We use relative time to avoid client/server time synchronization issues. */
          "X-RateLimit-Reset"?: number;
          [name: string]: unknown;
        };
        content: {
          "application/json": components["schemas"]["iam.v2.ApiKey"] & {
            spec: Record<string, unknown>;
          } & {
            spec?: {
              /** @example {
               *       "id": "u-a83k9b",
               *       "related": "https://api.confluent.cloud/iam/v2/users/u-a83k9b",
               *       "resource_name": "https://api.confluent.cloud/user=u-a83k9b"
               *     } */
              owner?: unknown;
              /** @example {
               *       "id": "lkc-c29js0",
               *       "related": "https://api.confluent.cloud/cmk/v2/clusters/lkc-c29js0",
               *       "resource_name": "https://api.confluent.cloud/organization=9bb441c4-edef-46ac-8a41-c49e44a3fd9a/environment=env-abc123/cloud-cluster=lkc-c29js0"
               *     } */
              resource?: unknown;
            };
          };
        };
      };
      400: components["responses"]["BadRequestError"];
      401: components["responses"]["UnauthenticatedError"];
      402: components["responses"]["OverQuotaError"];
      403: components["responses"]["UnauthorizedError"];
      404: components["responses"]["NotFoundError"];
      409: components["responses"]["ConflictError"];
      422: components["responses"]["ValidationError"];
      429: components["responses"]["RateLimitError"];
      500: components["responses"]["DefaultSystemError"];
    };
  };
  listOrgV2Environments: {
    parameters: {
      query?: {
        /** @description A pagination size for collection requests. */
        page_size?: number;
        /** @description An opaque pagination token for collection requests. */
        page_token?: string;
      };
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description Environment. */
      200: {
        headers: {
          /** @description The unique identifier for the API request. */
          "X-Request-Id"?: string;
          /** @description The maximum number of requests you're permitted to make per time period. */
          "X-RateLimit-Limit"?: number;
          /** @description The number of requests remaining in the current rate limit window. */
          "X-RateLimit-Remaining"?: number;
          /** @description The relative time in seconds until the current rate-limit window resets.
           *
           *     **Important:** This differs from Github and Twitter's same-named header which uses UTC epoch seconds. We use relative time to avoid client/server time synchronization issues. */
          "X-RateLimit-Reset"?: number;
          [name: string]: unknown;
        };
        content: {
          "application/json": components["schemas"]["org.v2.EnvironmentList"];
        };
      };
      400: components["responses"]["BadRequestError"];
      401: components["responses"]["UnauthenticatedError"];
      403: components["responses"]["UnauthorizedError"];
      429: components["responses"]["RateLimitError"];
      500: components["responses"]["DefaultSystemError"];
    };
  };
  createOrgV2Environment: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody?: {
      content: {
        "application/json": components["schemas"]["org.v2.Environment"] &
          Record<string, unknown>;
      };
    };
    responses: {
      /** @description An Environment was created. */
      201: {
        headers: {
          /** @description The unique identifier for the API request. */
          "X-Request-Id"?: string;
          /** @description The maximum number of requests you're permitted to make per time period. */
          "X-RateLimit-Limit"?: number;
          /** @description The number of requests remaining in the current rate limit window. */
          "X-RateLimit-Remaining"?: number;
          /** @description The relative time in seconds until the current rate-limit window resets.
           *
           *     **Important:** This differs from Github and Twitter's same-named header which uses UTC epoch seconds. We use relative time to avoid client/server time synchronization issues. */
          "X-RateLimit-Reset"?: number;
          /** @description Environment resource uri */
          Location?: string;
          [name: string]: unknown;
        };
        content: {
          "application/json": components["schemas"]["org.v2.Environment"] &
            Record<string, unknown>;
        };
      };
      400: components["responses"]["BadRequestError"];
      401: components["responses"]["UnauthenticatedError"];
      402: components["responses"]["OverQuotaError"];
      403: components["responses"]["UnauthorizedError"];
      409: components["responses"]["ConflictError"];
      422: components["responses"]["ValidationError"];
      429: components["responses"]["RateLimitError"];
      500: components["responses"]["DefaultSystemError"];
    };
  };
  getOrgV2Environment: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description The unique identifier for the environment. */
        id: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description Environment. */
      200: {
        headers: {
          /** @description The unique identifier for the API request. */
          "X-Request-Id"?: string;
          /** @description The maximum number of requests you're permitted to make per time period. */
          "X-RateLimit-Limit"?: number;
          /** @description The number of requests remaining in the current rate limit window. */
          "X-RateLimit-Remaining"?: number;
          /** @description The relative time in seconds until the current rate-limit window resets.
           *
           *     **Important:** This differs from Github and Twitter's same-named header which uses UTC epoch seconds. We use relative time to avoid client/server time synchronization issues. */
          "X-RateLimit-Reset"?: number;
          [name: string]: unknown;
        };
        content: {
          "application/json": components["schemas"]["org.v2.Environment"] &
            Record<string, unknown>;
        };
      };
      400: components["responses"]["BadRequestError"];
      401: components["responses"]["UnauthenticatedError"];
      403: components["responses"]["UnauthorizedError"];
      404: components["responses"]["NotFoundError"];
      429: components["responses"]["RateLimitError"];
      500: components["responses"]["DefaultSystemError"];
    };
  };
  deleteOrgV2Environment: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description The unique identifier for the environment. */
        id: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description An Environment is being deleted. */
      204: {
        headers: {
          /** @description The unique identifier for the API request. */
          "X-Request-Id"?: string;
          /** @description The maximum number of requests you're permitted to make per time period. */
          "X-RateLimit-Limit"?: number;
          /** @description The number of requests remaining in the current rate limit window. */
          "X-RateLimit-Remaining"?: number;
          /** @description The relative time in seconds until the current rate-limit window resets.
           *
           *     **Important:** This differs from Github and Twitter's same-named header which uses UTC epoch seconds. We use relative time to avoid client/server time synchronization issues. */
          "X-RateLimit-Reset"?: number;
          [name: string]: unknown;
        };
        content?: never;
      };
      400: components["responses"]["BadRequestError"];
      401: components["responses"]["UnauthenticatedError"];
      403: components["responses"]["UnauthorizedError"];
      404: components["responses"]["NotFoundError"];
      429: components["responses"]["RateLimitError"];
      500: components["responses"]["DefaultSystemError"];
    };
  };
  updateOrgV2Environment: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description The unique identifier for the environment. */
        id: string;
      };
      cookie?: never;
    };
    requestBody?: {
      content: {
        "application/json": components["schemas"]["org.v2.Environment"];
      };
    };
    responses: {
      /** @description Environment. */
      200: {
        headers: {
          /** @description The unique identifier for the API request. */
          "X-Request-Id"?: string;
          /** @description The maximum number of requests you're permitted to make per time period. */
          "X-RateLimit-Limit"?: number;
          /** @description The number of requests remaining in the current rate limit window. */
          "X-RateLimit-Remaining"?: number;
          /** @description The relative time in seconds until the current rate-limit window resets.
           *
           *     **Important:** This differs from Github and Twitter's same-named header which uses UTC epoch seconds. We use relative time to avoid client/server time synchronization issues. */
          "X-RateLimit-Reset"?: number;
          [name: string]: unknown;
        };
        content: {
          "application/json": components["schemas"]["org.v2.Environment"] &
            Record<string, unknown>;
        };
      };
      400: components["responses"]["BadRequestError"];
      401: components["responses"]["UnauthenticatedError"];
      402: components["responses"]["OverQuotaError"];
      403: components["responses"]["UnauthorizedError"];
      404: components["responses"]["NotFoundError"];
      409: components["responses"]["ConflictError"];
      422: components["responses"]["ValidationError"];
      429: components["responses"]["RateLimitError"];
      500: components["responses"]["DefaultSystemError"];
    };
  };
  listOrgV2Organizations: {
    parameters: {
      query?: {
        /** @description A pagination size for collection requests. */
        page_size?: number;
        /** @description An opaque pagination token for collection requests. */
        page_token?: string;
      };
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description Organization. */
      200: {
        headers: {
          /** @description The unique identifier for the API request. */
          "X-Request-Id"?: string;
          /** @description The maximum number of requests you're permitted to make per time period. */
          "X-RateLimit-Limit"?: number;
          /** @description The number of requests remaining in the current rate limit window. */
          "X-RateLimit-Remaining"?: number;
          /** @description The relative time in seconds until the current rate-limit window resets.
           *
           *     **Important:** This differs from Github and Twitter's same-named header which uses UTC epoch seconds. We use relative time to avoid client/server time synchronization issues. */
          "X-RateLimit-Reset"?: number;
          [name: string]: unknown;
        };
        content: {
          "application/json": components["schemas"]["org.v2.OrganizationList"];
        };
      };
      400: components["responses"]["BadRequestError"];
      401: components["responses"]["UnauthenticatedError"];
      403: components["responses"]["UnauthorizedError"];
      429: components["responses"]["RateLimitError"];
      500: components["responses"]["DefaultSystemError"];
    };
  };
  getOrgV2Organization: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description The unique identifier for the organization. */
        id: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description Organization. */
      200: {
        headers: {
          /** @description The unique identifier for the API request. */
          "X-Request-Id"?: string;
          /** @description The maximum number of requests you're permitted to make per time period. */
          "X-RateLimit-Limit"?: number;
          /** @description The number of requests remaining in the current rate limit window. */
          "X-RateLimit-Remaining"?: number;
          /** @description The relative time in seconds until the current rate-limit window resets.
           *
           *     **Important:** This differs from Github and Twitter's same-named header which uses UTC epoch seconds. We use relative time to avoid client/server time synchronization issues. */
          "X-RateLimit-Reset"?: number;
          [name: string]: unknown;
        };
        content: {
          "application/json": components["schemas"]["org.v2.Organization"] &
            Record<string, unknown>;
        };
      };
      400: components["responses"]["BadRequestError"];
      401: components["responses"]["UnauthenticatedError"];
      403: components["responses"]["UnauthorizedError"];
      404: components["responses"]["NotFoundError"];
      429: components["responses"]["RateLimitError"];
      500: components["responses"]["DefaultSystemError"];
    };
  };
  updateOrgV2Organization: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description The unique identifier for the organization. */
        id: string;
      };
      cookie?: never;
    };
    requestBody?: {
      content: {
        "application/json": components["schemas"]["org.v2.Organization"];
      };
    };
    responses: {
      /** @description Organization. */
      200: {
        headers: {
          /** @description The unique identifier for the API request. */
          "X-Request-Id"?: string;
          /** @description The maximum number of requests you're permitted to make per time period. */
          "X-RateLimit-Limit"?: number;
          /** @description The number of requests remaining in the current rate limit window. */
          "X-RateLimit-Remaining"?: number;
          /** @description The relative time in seconds until the current rate-limit window resets.
           *
           *     **Important:** This differs from Github and Twitter's same-named header which uses UTC epoch seconds. We use relative time to avoid client/server time synchronization issues. */
          "X-RateLimit-Reset"?: number;
          [name: string]: unknown;
        };
        content: {
          "application/json": components["schemas"]["org.v2.Organization"] &
            Record<string, unknown>;
        };
      };
      400: components["responses"]["BadRequestError"];
      401: components["responses"]["UnauthenticatedError"];
      402: components["responses"]["OverQuotaError"];
      403: components["responses"]["UnauthorizedError"];
      404: components["responses"]["NotFoundError"];
      409: components["responses"]["ConflictError"];
      422: components["responses"]["ValidationError"];
      429: components["responses"]["RateLimitError"];
      500: components["responses"]["DefaultSystemError"];
    };
  };
  listIamV2Users: {
    parameters: {
      query?: {
        /** @description A pagination size for collection requests. */
        page_size?: number;
        /** @description An opaque pagination token for collection requests. */
        page_token?: string;
      };
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description User. */
      200: {
        headers: {
          /** @description The unique identifier for the API request. */
          "X-Request-Id"?: string;
          /** @description The maximum number of requests you're permitted to make per time period. */
          "X-RateLimit-Limit"?: number;
          /** @description The number of requests remaining in the current rate limit window. */
          "X-RateLimit-Remaining"?: number;
          /** @description The relative time in seconds until the current rate-limit window resets.
           *
           *     **Important:** This differs from Github and Twitter's same-named header which uses UTC epoch seconds. We use relative time to avoid client/server time synchronization issues. */
          "X-RateLimit-Reset"?: number;
          [name: string]: unknown;
        };
        content: {
          "application/json": components["schemas"]["iam.v2.UserList"];
        };
      };
      400: components["responses"]["BadRequestError"];
      401: components["responses"]["UnauthenticatedError"];
      403: components["responses"]["UnauthorizedError"];
      429: components["responses"]["RateLimitError"];
      500: components["responses"]["DefaultSystemError"];
    };
  };
  getIamV2User: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description The unique identifier for the user. */
        id: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description User. */
      200: {
        headers: {
          /** @description The unique identifier for the API request. */
          "X-Request-Id"?: string;
          /** @description The maximum number of requests you're permitted to make per time period. */
          "X-RateLimit-Limit"?: number;
          /** @description The number of requests remaining in the current rate limit window. */
          "X-RateLimit-Remaining"?: number;
          /** @description The relative time in seconds until the current rate-limit window resets.
           *
           *     **Important:** This differs from Github and Twitter's same-named header which uses UTC epoch seconds. We use relative time to avoid client/server time synchronization issues. */
          "X-RateLimit-Reset"?: number;
          [name: string]: unknown;
        };
        content: {
          "application/json": components["schemas"]["iam.v2.User"] &
            Record<string, unknown>;
        };
      };
      400: components["responses"]["BadRequestError"];
      401: components["responses"]["UnauthenticatedError"];
      403: components["responses"]["UnauthorizedError"];
      404: components["responses"]["NotFoundError"];
      429: components["responses"]["RateLimitError"];
      500: components["responses"]["DefaultSystemError"];
    };
  };
  deleteIamV2User: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description The unique identifier for the user. */
        id: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description A User is being deleted. */
      204: {
        headers: {
          /** @description The unique identifier for the API request. */
          "X-Request-Id"?: string;
          /** @description The maximum number of requests you're permitted to make per time period. */
          "X-RateLimit-Limit"?: number;
          /** @description The number of requests remaining in the current rate limit window. */
          "X-RateLimit-Remaining"?: number;
          /** @description The relative time in seconds until the current rate-limit window resets.
           *
           *     **Important:** This differs from Github and Twitter's same-named header which uses UTC epoch seconds. We use relative time to avoid client/server time synchronization issues. */
          "X-RateLimit-Reset"?: number;
          [name: string]: unknown;
        };
        content?: never;
      };
      400: components["responses"]["BadRequestError"];
      401: components["responses"]["UnauthenticatedError"];
      403: components["responses"]["UnauthorizedError"];
      404: components["responses"]["NotFoundError"];
      429: components["responses"]["RateLimitError"];
      500: components["responses"]["DefaultSystemError"];
    };
  };
  updateIamV2User: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description The unique identifier for the user. */
        id: string;
      };
      cookie?: never;
    };
    requestBody?: {
      content: {
        "application/json": components["schemas"]["iam.v2.UserUpdate"];
      };
    };
    responses: {
      /** @description User. */
      200: {
        headers: {
          /** @description The unique identifier for the API request. */
          "X-Request-Id"?: string;
          /** @description The maximum number of requests you're permitted to make per time period. */
          "X-RateLimit-Limit"?: number;
          /** @description The number of requests remaining in the current rate limit window. */
          "X-RateLimit-Remaining"?: number;
          /** @description The relative time in seconds until the current rate-limit window resets.
           *
           *     **Important:** This differs from Github and Twitter's same-named header which uses UTC epoch seconds. We use relative time to avoid client/server time synchronization issues. */
          "X-RateLimit-Reset"?: number;
          [name: string]: unknown;
        };
        content: {
          "application/json": components["schemas"]["iam.v2.User"] &
            Record<string, unknown>;
        };
      };
      400: components["responses"]["BadRequestError"];
      401: components["responses"]["UnauthenticatedError"];
      402: components["responses"]["OverQuotaError"];
      403: components["responses"]["UnauthorizedError"];
      404: components["responses"]["NotFoundError"];
      409: components["responses"]["ConflictError"];
      422: components["responses"]["ValidationError"];
      429: components["responses"]["RateLimitError"];
      500: components["responses"]["DefaultSystemError"];
    };
  };
  update_auth_typeIamV2User: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description The unique identifier for the user. */
        id: string;
      };
      cookie?: never;
    };
    requestBody?: {
      content: {
        "application/json": components["schemas"]["iam.v2.User.ConfigureUserAuthRequest"];
      };
    };
    responses: {
      /** @description No Content */
      204: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
      400: components["responses"]["BadRequestError"];
      401: components["responses"]["UnauthenticatedError"];
      403: components["responses"]["UnauthorizedError"];
      404: components["responses"]["NotFoundError"];
      429: components["responses"]["RateLimitError"];
      500: components["responses"]["DefaultSystemError"];
    };
  };
  listIamV2ServiceAccounts: {
    parameters: {
      query?: {
        /**
         * @description Filter the results by exact match for display_name. Pass multiple times to see results matching any of the values.
         * @example [
         *       "tf_runner_sa",
         *       "mySA"
         *     ]
         */
        display_name?: components["schemas"]["MultipleSearchFilter"];
        /** @description A pagination size for collection requests. */
        page_size?: number;
        /** @description An opaque pagination token for collection requests. */
        page_token?: string;
      };
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description Service Account. */
      200: {
        headers: {
          /** @description The unique identifier for the API request. */
          "X-Request-Id"?: string;
          /** @description The maximum number of requests you're permitted to make per time period. */
          "X-RateLimit-Limit"?: number;
          /** @description The number of requests remaining in the current rate limit window. */
          "X-RateLimit-Remaining"?: number;
          /** @description The relative time in seconds until the current rate-limit window resets.
           *
           *     **Important:** This differs from Github and Twitter's same-named header which uses UTC epoch seconds. We use relative time to avoid client/server time synchronization issues. */
          "X-RateLimit-Reset"?: number;
          [name: string]: unknown;
        };
        content: {
          "application/json": components["schemas"]["iam.v2.ServiceAccountList"];
        };
      };
      400: components["responses"]["BadRequestError"];
      401: components["responses"]["UnauthenticatedError"];
      403: components["responses"]["UnauthorizedError"];
      429: components["responses"]["RateLimitError"];
      500: components["responses"]["DefaultSystemError"];
    };
  };
  createIamV2ServiceAccount: {
    parameters: {
      query?: {
        /**
         * @description The resource_id of the principal who will be assigned resource owner on the created service account. Principal can be group-mapping (group-xxx), user (u-xxx), service-account (sa-xxx) or identity-pool (pool-xxx).
         * @example u-a83k9b
         */
        assigned_resource_owner?: components["schemas"]["SearchFilter"];
      };
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody?: {
      content: {
        "application/json": components["schemas"]["iam.v2.ServiceAccount"] &
          Record<string, unknown>;
      };
    };
    responses: {
      /** @description A Service Account was created. */
      201: {
        headers: {
          /** @description The unique identifier for the API request. */
          "X-Request-Id"?: string;
          /** @description The maximum number of requests you're permitted to make per time period. */
          "X-RateLimit-Limit"?: number;
          /** @description The number of requests remaining in the current rate limit window. */
          "X-RateLimit-Remaining"?: number;
          /** @description The relative time in seconds until the current rate-limit window resets.
           *
           *     **Important:** This differs from Github and Twitter's same-named header which uses UTC epoch seconds. We use relative time to avoid client/server time synchronization issues. */
          "X-RateLimit-Reset"?: number;
          /** @description ServiceAccount resource uri */
          Location?: string;
          [name: string]: unknown;
        };
        content: {
          "application/json": components["schemas"]["iam.v2.ServiceAccount"] &
            Record<string, unknown>;
        };
      };
      400: components["responses"]["BadRequestError"];
      401: components["responses"]["UnauthenticatedError"];
      402: components["responses"]["OverQuotaError"];
      403: components["responses"]["UnauthorizedError"];
      409: components["responses"]["ConflictError"];
      422: components["responses"]["ValidationError"];
      429: components["responses"]["RateLimitError"];
      500: components["responses"]["DefaultSystemError"];
    };
  };
  getIamV2ServiceAccount: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description The unique identifier for the service account. */
        id: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description Service Account. */
      200: {
        headers: {
          /** @description The unique identifier for the API request. */
          "X-Request-Id"?: string;
          /** @description The maximum number of requests you're permitted to make per time period. */
          "X-RateLimit-Limit"?: number;
          /** @description The number of requests remaining in the current rate limit window. */
          "X-RateLimit-Remaining"?: number;
          /** @description The relative time in seconds until the current rate-limit window resets.
           *
           *     **Important:** This differs from Github and Twitter's same-named header which uses UTC epoch seconds. We use relative time to avoid client/server time synchronization issues. */
          "X-RateLimit-Reset"?: number;
          [name: string]: unknown;
        };
        content: {
          "application/json": components["schemas"]["iam.v2.ServiceAccount"] &
            Record<string, unknown>;
        };
      };
      400: components["responses"]["BadRequestError"];
      401: components["responses"]["UnauthenticatedError"];
      403: components["responses"]["UnauthorizedError"];
      404: components["responses"]["NotFoundError"];
      429: components["responses"]["RateLimitError"];
      500: components["responses"]["DefaultSystemError"];
    };
  };
  deleteIamV2ServiceAccount: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description The unique identifier for the service account. */
        id: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description A Service Account is being deleted. */
      204: {
        headers: {
          /** @description The unique identifier for the API request. */
          "X-Request-Id"?: string;
          /** @description The maximum number of requests you're permitted to make per time period. */
          "X-RateLimit-Limit"?: number;
          /** @description The number of requests remaining in the current rate limit window. */
          "X-RateLimit-Remaining"?: number;
          /** @description The relative time in seconds until the current rate-limit window resets.
           *
           *     **Important:** This differs from Github and Twitter's same-named header which uses UTC epoch seconds. We use relative time to avoid client/server time synchronization issues. */
          "X-RateLimit-Reset"?: number;
          [name: string]: unknown;
        };
        content?: never;
      };
      400: components["responses"]["BadRequestError"];
      401: components["responses"]["UnauthenticatedError"];
      403: components["responses"]["UnauthorizedError"];
      404: components["responses"]["NotFoundError"];
      429: components["responses"]["RateLimitError"];
      500: components["responses"]["DefaultSystemError"];
    };
  };
  updateIamV2ServiceAccount: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description The unique identifier for the service account. */
        id: string;
      };
      cookie?: never;
    };
    requestBody?: {
      content: {
        "application/json": components["schemas"]["iam.v2.ServiceAccount"];
      };
    };
    responses: {
      /** @description Service Account. */
      200: {
        headers: {
          /** @description The unique identifier for the API request. */
          "X-Request-Id"?: string;
          /** @description The maximum number of requests you're permitted to make per time period. */
          "X-RateLimit-Limit"?: number;
          /** @description The number of requests remaining in the current rate limit window. */
          "X-RateLimit-Remaining"?: number;
          /** @description The relative time in seconds until the current rate-limit window resets.
           *
           *     **Important:** This differs from Github and Twitter's same-named header which uses UTC epoch seconds. We use relative time to avoid client/server time synchronization issues. */
          "X-RateLimit-Reset"?: number;
          [name: string]: unknown;
        };
        content: {
          "application/json": components["schemas"]["iam.v2.ServiceAccount"] &
            Record<string, unknown>;
        };
      };
      400: components["responses"]["BadRequestError"];
      401: components["responses"]["UnauthenticatedError"];
      402: components["responses"]["OverQuotaError"];
      403: components["responses"]["UnauthorizedError"];
      404: components["responses"]["NotFoundError"];
      409: components["responses"]["ConflictError"];
      422: components["responses"]["ValidationError"];
      429: components["responses"]["RateLimitError"];
      500: components["responses"]["DefaultSystemError"];
    };
  };
  listIamV2Invitations: {
    parameters: {
      query?: {
        /**
         * @description Filter the results by exact match for email.
         * @example johndoe@confluent.io
         */
        email?: components["schemas"]["SearchFilter"];
        /**
         * @description Filter the results by exact match for status.
         * @example INVITE_STATUS_SENT
         */
        status?: components["schemas"]["SearchFilter"];
        /**
         * @description Filter the results by exact match for user.
         * @example u-j93dy8
         */
        user?: components["schemas"]["SearchFilter"];
        /**
         * @description Filter the results by exact match for creator.
         * @example u-m2r9o7
         */
        creator?: components["schemas"]["SearchFilter"];
        /** @description A pagination size for collection requests. */
        page_size?: number;
        /** @description An opaque pagination token for collection requests. */
        page_token?: string;
      };
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description Invitation. */
      200: {
        headers: {
          /** @description The unique identifier for the API request. */
          "X-Request-Id"?: string;
          /** @description The maximum number of requests you're permitted to make per time period. */
          "X-RateLimit-Limit"?: number;
          /** @description The number of requests remaining in the current rate limit window. */
          "X-RateLimit-Remaining"?: number;
          /** @description The relative time in seconds until the current rate-limit window resets.
           *
           *     **Important:** This differs from Github and Twitter's same-named header which uses UTC epoch seconds. We use relative time to avoid client/server time synchronization issues. */
          "X-RateLimit-Reset"?: number;
          [name: string]: unknown;
        };
        content: {
          "application/json": components["schemas"]["iam.v2.InvitationList"];
        };
      };
      400: components["responses"]["BadRequestError"];
      401: components["responses"]["UnauthenticatedError"];
      403: components["responses"]["UnauthorizedError"];
      429: components["responses"]["RateLimitError"];
      500: components["responses"]["DefaultSystemError"];
    };
  };
  createIamV2Invitation: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody?: {
      content: {
        "application/json": components["schemas"]["iam.v2.Invitation"] &
          Record<string, unknown>;
      };
    };
    responses: {
      /** @description An Invitation was created. */
      201: {
        headers: {
          /** @description The unique identifier for the API request. */
          "X-Request-Id"?: string;
          /** @description The maximum number of requests you're permitted to make per time period. */
          "X-RateLimit-Limit"?: number;
          /** @description The number of requests remaining in the current rate limit window. */
          "X-RateLimit-Remaining"?: number;
          /** @description The relative time in seconds until the current rate-limit window resets.
           *
           *     **Important:** This differs from Github and Twitter's same-named header which uses UTC epoch seconds. We use relative time to avoid client/server time synchronization issues. */
          "X-RateLimit-Reset"?: number;
          /** @description Invitation resource uri */
          Location?: string;
          [name: string]: unknown;
        };
        content: {
          "application/json": components["schemas"]["iam.v2.Invitation"] &
            Record<string, unknown>;
        };
      };
      400: components["responses"]["BadRequestError"];
      401: components["responses"]["UnauthenticatedError"];
      402: components["responses"]["OverQuotaError"];
      403: components["responses"]["UnauthorizedError"];
      409: components["responses"]["ConflictError"];
      422: components["responses"]["ValidationError"];
      429: components["responses"]["RateLimitError"];
      500: components["responses"]["DefaultSystemError"];
    };
  };
  getIamV2Invitation: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description The unique identifier for the invitation. */
        id: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description Invitation. */
      200: {
        headers: {
          /** @description The unique identifier for the API request. */
          "X-Request-Id"?: string;
          /** @description The maximum number of requests you're permitted to make per time period. */
          "X-RateLimit-Limit"?: number;
          /** @description The number of requests remaining in the current rate limit window. */
          "X-RateLimit-Remaining"?: number;
          /** @description The relative time in seconds until the current rate-limit window resets.
           *
           *     **Important:** This differs from Github and Twitter's same-named header which uses UTC epoch seconds. We use relative time to avoid client/server time synchronization issues. */
          "X-RateLimit-Reset"?: number;
          [name: string]: unknown;
        };
        content: {
          "application/json": components["schemas"]["iam.v2.Invitation"] &
            Record<string, unknown>;
        };
      };
      400: components["responses"]["BadRequestError"];
      401: components["responses"]["UnauthenticatedError"];
      403: components["responses"]["UnauthorizedError"];
      404: components["responses"]["NotFoundError"];
      429: components["responses"]["RateLimitError"];
      500: components["responses"]["DefaultSystemError"];
    };
  };
  deleteIamV2Invitation: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description The unique identifier for the invitation. */
        id: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description An Invitation is being deleted. */
      204: {
        headers: {
          /** @description The unique identifier for the API request. */
          "X-Request-Id"?: string;
          /** @description The maximum number of requests you're permitted to make per time period. */
          "X-RateLimit-Limit"?: number;
          /** @description The number of requests remaining in the current rate limit window. */
          "X-RateLimit-Remaining"?: number;
          /** @description The relative time in seconds until the current rate-limit window resets.
           *
           *     **Important:** This differs from Github and Twitter's same-named header which uses UTC epoch seconds. We use relative time to avoid client/server time synchronization issues. */
          "X-RateLimit-Reset"?: number;
          [name: string]: unknown;
        };
        content?: never;
      };
      400: components["responses"]["BadRequestError"];
      401: components["responses"]["UnauthenticatedError"];
      403: components["responses"]["UnauthorizedError"];
      404: components["responses"]["NotFoundError"];
      429: components["responses"]["RateLimitError"];
      500: components["responses"]["DefaultSystemError"];
    };
  };
  listIamV2IpGroups: {
    parameters: {
      query?: {
        /** @description A pagination size for collection requests. */
        page_size?: number;
        /** @description An opaque pagination token for collection requests. */
        page_token?: string;
      };
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description IP Group. */
      200: {
        headers: {
          /** @description The unique identifier for the API request. */
          "X-Request-Id"?: string;
          /** @description The maximum number of requests you're permitted to make per time period. */
          "X-RateLimit-Limit"?: number;
          /** @description The number of requests remaining in the current rate limit window. */
          "X-RateLimit-Remaining"?: number;
          /** @description The relative time in seconds until the current rate-limit window resets.
           *
           *     **Important:** This differs from Github and Twitter's same-named header which uses UTC epoch seconds. We use relative time to avoid client/server time synchronization issues. */
          "X-RateLimit-Reset"?: number;
          [name: string]: unknown;
        };
        content: {
          "application/json": components["schemas"]["iam.v2.IpGroupList"];
        };
      };
      400: components["responses"]["BadRequestError"];
      401: components["responses"]["UnauthenticatedError"];
      403: components["responses"]["UnauthorizedError"];
      429: components["responses"]["RateLimitError"];
      500: components["responses"]["DefaultSystemError"];
    };
  };
  createIamV2IpGroup: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody?: {
      content: {
        "application/json": components["schemas"]["iam.v2.IpGroup"] &
          Record<string, unknown>;
      };
    };
    responses: {
      /** @description An IP Group was created. */
      201: {
        headers: {
          /** @description The unique identifier for the API request. */
          "X-Request-Id"?: string;
          /** @description The maximum number of requests you're permitted to make per time period. */
          "X-RateLimit-Limit"?: number;
          /** @description The number of requests remaining in the current rate limit window. */
          "X-RateLimit-Remaining"?: number;
          /** @description The relative time in seconds until the current rate-limit window resets.
           *
           *     **Important:** This differs from Github and Twitter's same-named header which uses UTC epoch seconds. We use relative time to avoid client/server time synchronization issues. */
          "X-RateLimit-Reset"?: number;
          /** @description IpGroup resource uri */
          Location?: string;
          [name: string]: unknown;
        };
        content: {
          "application/json": components["schemas"]["iam.v2.IpGroup"] &
            Record<string, unknown>;
        };
      };
      400: components["responses"]["BadRequestError"];
      401: components["responses"]["UnauthenticatedError"];
      402: components["responses"]["OverQuotaError"];
      403: components["responses"]["UnauthorizedError"];
      409: components["responses"]["ConflictError"];
      422: components["responses"]["ValidationError"];
      429: components["responses"]["RateLimitError"];
      500: components["responses"]["DefaultSystemError"];
    };
  };
  getIamV2IpGroup: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description The unique identifier for the IP group. */
        id: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description IP Group. */
      200: {
        headers: {
          /** @description The unique identifier for the API request. */
          "X-Request-Id"?: string;
          /** @description The maximum number of requests you're permitted to make per time period. */
          "X-RateLimit-Limit"?: number;
          /** @description The number of requests remaining in the current rate limit window. */
          "X-RateLimit-Remaining"?: number;
          /** @description The relative time in seconds until the current rate-limit window resets.
           *
           *     **Important:** This differs from Github and Twitter's same-named header which uses UTC epoch seconds. We use relative time to avoid client/server time synchronization issues. */
          "X-RateLimit-Reset"?: number;
          [name: string]: unknown;
        };
        content: {
          "application/json": components["schemas"]["iam.v2.IpGroup"] &
            Record<string, unknown>;
        };
      };
      400: components["responses"]["BadRequestError"];
      401: components["responses"]["UnauthenticatedError"];
      403: components["responses"]["UnauthorizedError"];
      404: components["responses"]["NotFoundError"];
      429: components["responses"]["RateLimitError"];
      500: components["responses"]["DefaultSystemError"];
    };
  };
  deleteIamV2IpGroup: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description The unique identifier for the IP group. */
        id: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description An IP Group is being deleted. */
      204: {
        headers: {
          /** @description The unique identifier for the API request. */
          "X-Request-Id"?: string;
          /** @description The maximum number of requests you're permitted to make per time period. */
          "X-RateLimit-Limit"?: number;
          /** @description The number of requests remaining in the current rate limit window. */
          "X-RateLimit-Remaining"?: number;
          /** @description The relative time in seconds until the current rate-limit window resets.
           *
           *     **Important:** This differs from Github and Twitter's same-named header which uses UTC epoch seconds. We use relative time to avoid client/server time synchronization issues. */
          "X-RateLimit-Reset"?: number;
          [name: string]: unknown;
        };
        content?: never;
      };
      400: components["responses"]["BadRequestError"];
      401: components["responses"]["UnauthenticatedError"];
      403: components["responses"]["UnauthorizedError"];
      404: components["responses"]["NotFoundError"];
      429: components["responses"]["RateLimitError"];
      500: components["responses"]["DefaultSystemError"];
    };
  };
  updateIamV2IpGroup: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description The unique identifier for the IP group. */
        id: string;
      };
      cookie?: never;
    };
    requestBody?: {
      content: {
        "application/json": components["schemas"]["iam.v2.IpGroup"];
      };
    };
    responses: {
      /** @description IP Group. */
      200: {
        headers: {
          /** @description The unique identifier for the API request. */
          "X-Request-Id"?: string;
          /** @description The maximum number of requests you're permitted to make per time period. */
          "X-RateLimit-Limit"?: number;
          /** @description The number of requests remaining in the current rate limit window. */
          "X-RateLimit-Remaining"?: number;
          /** @description The relative time in seconds until the current rate-limit window resets.
           *
           *     **Important:** This differs from Github and Twitter's same-named header which uses UTC epoch seconds. We use relative time to avoid client/server time synchronization issues. */
          "X-RateLimit-Reset"?: number;
          [name: string]: unknown;
        };
        content: {
          "application/json": components["schemas"]["iam.v2.IpGroup"] &
            Record<string, unknown>;
        };
      };
      400: components["responses"]["BadRequestError"];
      401: components["responses"]["UnauthenticatedError"];
      403: components["responses"]["UnauthorizedError"];
      404: components["responses"]["NotFoundError"];
      409: components["responses"]["ConflictError"];
      422: components["responses"]["ValidationError"];
      429: components["responses"]["RateLimitError"];
      500: components["responses"]["DefaultSystemError"];
    };
  };
  listIamV2IpFilters: {
    parameters: {
      query?: {
        /** @description Lists all filters belonging to the specified resource scope. */
        resource_scope?: string;
        /** @description If set to true, this includes filters defined at the organization level. The resource scope must also be set to use this parameter. */
        include_parent_scopes?: string;
        /** @description A pagination size for collection requests. */
        page_size?: number;
        /** @description An opaque pagination token for collection requests. */
        page_token?: string;
      };
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description IP Filter. */
      200: {
        headers: {
          /** @description The unique identifier for the API request. */
          "X-Request-Id"?: string;
          /** @description The maximum number of requests you're permitted to make per time period. */
          "X-RateLimit-Limit"?: number;
          /** @description The number of requests remaining in the current rate limit window. */
          "X-RateLimit-Remaining"?: number;
          /** @description The relative time in seconds until the current rate-limit window resets.
           *
           *     **Important:** This differs from Github and Twitter's same-named header which uses UTC epoch seconds. We use relative time to avoid client/server time synchronization issues. */
          "X-RateLimit-Reset"?: number;
          [name: string]: unknown;
        };
        content: {
          "application/json": components["schemas"]["iam.v2.IpFilterList"];
        };
      };
      400: components["responses"]["BadRequestError"];
      401: components["responses"]["UnauthenticatedError"];
      403: components["responses"]["UnauthorizedError"];
      429: components["responses"]["RateLimitError"];
      500: components["responses"]["DefaultSystemError"];
    };
  };
  createIamV2IpFilter: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody?: {
      content: {
        "application/json": components["schemas"]["iam.v2.IpFilter"] &
          Record<string, unknown>;
      };
    };
    responses: {
      /** @description An IP Filter was created. */
      201: {
        headers: {
          /** @description The unique identifier for the API request. */
          "X-Request-Id"?: string;
          /** @description The maximum number of requests you're permitted to make per time period. */
          "X-RateLimit-Limit"?: number;
          /** @description The number of requests remaining in the current rate limit window. */
          "X-RateLimit-Remaining"?: number;
          /** @description The relative time in seconds until the current rate-limit window resets.
           *
           *     **Important:** This differs from Github and Twitter's same-named header which uses UTC epoch seconds. We use relative time to avoid client/server time synchronization issues. */
          "X-RateLimit-Reset"?: number;
          /** @description IpFilter resource uri */
          Location?: string;
          [name: string]: unknown;
        };
        content: {
          "application/json": components["schemas"]["iam.v2.IpFilter"] &
            Record<string, unknown>;
        };
      };
      400: components["responses"]["BadRequestError"];
      401: components["responses"]["UnauthenticatedError"];
      402: components["responses"]["OverQuotaError"];
      403: components["responses"]["UnauthorizedError"];
      409: components["responses"]["ConflictError"];
      422: components["responses"]["ValidationError"];
      429: components["responses"]["RateLimitError"];
      500: components["responses"]["DefaultSystemError"];
    };
  };
  getIamV2IpFilter: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description The unique identifier for the IP filter. */
        id: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description IP Filter. */
      200: {
        headers: {
          /** @description The unique identifier for the API request. */
          "X-Request-Id"?: string;
          /** @description The maximum number of requests you're permitted to make per time period. */
          "X-RateLimit-Limit"?: number;
          /** @description The number of requests remaining in the current rate limit window. */
          "X-RateLimit-Remaining"?: number;
          /** @description The relative time in seconds until the current rate-limit window resets.
           *
           *     **Important:** This differs from Github and Twitter's same-named header which uses UTC epoch seconds. We use relative time to avoid client/server time synchronization issues. */
          "X-RateLimit-Reset"?: number;
          [name: string]: unknown;
        };
        content: {
          "application/json": components["schemas"]["iam.v2.IpFilter"] &
            Record<string, unknown>;
        };
      };
      400: components["responses"]["BadRequestError"];
      401: components["responses"]["UnauthenticatedError"];
      403: components["responses"]["UnauthorizedError"];
      404: components["responses"]["NotFoundError"];
      429: components["responses"]["RateLimitError"];
      500: components["responses"]["DefaultSystemError"];
    };
  };
  deleteIamV2IpFilter: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description The unique identifier for the IP filter. */
        id: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description An IP Filter is being deleted. */
      204: {
        headers: {
          /** @description The unique identifier for the API request. */
          "X-Request-Id"?: string;
          /** @description The maximum number of requests you're permitted to make per time period. */
          "X-RateLimit-Limit"?: number;
          /** @description The number of requests remaining in the current rate limit window. */
          "X-RateLimit-Remaining"?: number;
          /** @description The relative time in seconds until the current rate-limit window resets.
           *
           *     **Important:** This differs from Github and Twitter's same-named header which uses UTC epoch seconds. We use relative time to avoid client/server time synchronization issues. */
          "X-RateLimit-Reset"?: number;
          [name: string]: unknown;
        };
        content?: never;
      };
      400: components["responses"]["BadRequestError"];
      401: components["responses"]["UnauthenticatedError"];
      403: components["responses"]["UnauthorizedError"];
      404: components["responses"]["NotFoundError"];
      429: components["responses"]["RateLimitError"];
      500: components["responses"]["DefaultSystemError"];
    };
  };
  updateIamV2IpFilter: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description The unique identifier for the IP filter. */
        id: string;
      };
      cookie?: never;
    };
    requestBody?: {
      content: {
        "application/json": components["schemas"]["iam.v2.IpFilter"];
      };
    };
    responses: {
      /** @description IP Filter. */
      200: {
        headers: {
          /** @description The unique identifier for the API request. */
          "X-Request-Id"?: string;
          /** @description The maximum number of requests you're permitted to make per time period. */
          "X-RateLimit-Limit"?: number;
          /** @description The number of requests remaining in the current rate limit window. */
          "X-RateLimit-Remaining"?: number;
          /** @description The relative time in seconds until the current rate-limit window resets.
           *
           *     **Important:** This differs from Github and Twitter's same-named header which uses UTC epoch seconds. We use relative time to avoid client/server time synchronization issues. */
          "X-RateLimit-Reset"?: number;
          [name: string]: unknown;
        };
        content: {
          "application/json": components["schemas"]["iam.v2.IpFilter"] &
            Record<string, unknown>;
        };
      };
      400: components["responses"]["BadRequestError"];
      401: components["responses"]["UnauthenticatedError"];
      403: components["responses"]["UnauthorizedError"];
      404: components["responses"]["NotFoundError"];
      409: components["responses"]["ConflictError"];
      422: components["responses"]["ValidationError"];
      429: components["responses"]["RateLimitError"];
      500: components["responses"]["DefaultSystemError"];
    };
  };
  getIamV2IpFilterSummary: {
    parameters: {
      query: {
        /**
         * @description Scope the operation to the given scope.
         * @example crn://confluent.cloud/organization=org-123/environment=env-abc
         */
        scope: string;
      };
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description IP Filter Summary. */
      200: {
        headers: {
          /** @description The unique identifier for the API request. */
          "X-Request-Id"?: string;
          /** @description The maximum number of requests you're permitted to make per time period. */
          "X-RateLimit-Limit"?: number;
          /** @description The number of requests remaining in the current rate limit window. */
          "X-RateLimit-Remaining"?: number;
          /** @description The relative time in seconds until the current rate-limit window resets.
           *
           *     **Important:** This differs from Github and Twitter's same-named header which uses UTC epoch seconds. We use relative time to avoid client/server time synchronization issues. */
          "X-RateLimit-Reset"?: number;
          [name: string]: unknown;
        };
        content: {
          "application/json": components["schemas"]["iam.v2.IpFilterSummary"] &
            Record<string, unknown>;
        };
      };
      400: components["responses"]["BadRequestError"];
      401: components["responses"]["UnauthenticatedError"];
      403: components["responses"]["UnauthorizedError"];
      404: components["responses"]["NotFoundError"];
      429: components["responses"]["RateLimitError"];
      500: components["responses"]["DefaultSystemError"];
    };
  };
  listIamV2RoleBindings: {
    parameters: {
      query: {
        /**
         * @description Filter the results by exact match for principal.
         * @example User:u-111aaa
         */
        principal?: components["schemas"]["SearchFilter"];
        /**
         * @description Filter the results by exact match for role_name.
         * @example CloudClusterAdmin
         */
        role_name?: components["schemas"]["SearchFilter"];
        /**
         * @description Filter the results by a partial search of crn_pattern.
         * @example crn://confluent.cloud/organization=1111aaaa-11aa-11aa-11aa-111111aaaaaa/environment=env-aaa1111/cloud-cluster=lkc-1111aaa
         */
        crn_pattern: components["schemas"]["SearchFilter"];
        /** @description A pagination size for collection requests. */
        page_size?: number;
        /** @description An opaque pagination token for collection requests. */
        page_token?: string;
      };
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description Role Binding. */
      200: {
        headers: {
          /** @description The unique identifier for the API request. */
          "X-Request-Id"?: string;
          /** @description The maximum number of requests you're permitted to make per time period. */
          "X-RateLimit-Limit"?: number;
          /** @description The number of requests remaining in the current rate limit window. */
          "X-RateLimit-Remaining"?: number;
          /** @description The relative time in seconds until the current rate-limit window resets.
           *
           *     **Important:** This differs from Github and Twitter's same-named header which uses UTC epoch seconds. We use relative time to avoid client/server time synchronization issues. */
          "X-RateLimit-Reset"?: number;
          [name: string]: unknown;
        };
        content: {
          "application/json": components["schemas"]["iam.v2.RoleBindingList"];
        };
      };
      400: components["responses"]["BadRequestError"];
      401: components["responses"]["UnauthenticatedError"];
      403: components["responses"]["UnauthorizedError"];
      429: components["responses"]["RateLimitError"];
      500: components["responses"]["DefaultSystemError"];
    };
  };
  createIamV2RoleBinding: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody?: {
      content: {
        "application/json": components["schemas"]["iam.v2.RoleBinding"] &
          Record<string, unknown>;
      };
    };
    responses: {
      /** @description A Role Binding was created. */
      201: {
        headers: {
          /** @description The unique identifier for the API request. */
          "X-Request-Id"?: string;
          /** @description The maximum number of requests you're permitted to make per time period. */
          "X-RateLimit-Limit"?: number;
          /** @description The number of requests remaining in the current rate limit window. */
          "X-RateLimit-Remaining"?: number;
          /** @description The relative time in seconds until the current rate-limit window resets.
           *
           *     **Important:** This differs from Github and Twitter's same-named header which uses UTC epoch seconds. We use relative time to avoid client/server time synchronization issues. */
          "X-RateLimit-Reset"?: number;
          /** @description RoleBinding resource uri */
          Location?: string;
          [name: string]: unknown;
        };
        content: {
          "application/json": components["schemas"]["iam.v2.RoleBinding"] &
            Record<string, unknown>;
        };
      };
      400: components["responses"]["BadRequestError"];
      401: components["responses"]["UnauthenticatedError"];
      403: components["responses"]["UnauthorizedError"];
      409: components["responses"]["ConflictError"];
      422: components["responses"]["ValidationError"];
      429: components["responses"]["RateLimitError"];
      500: components["responses"]["DefaultSystemError"];
    };
  };
  getIamV2RoleBinding: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description The unique identifier for the role binding. */
        id: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description Role Binding. */
      200: {
        headers: {
          /** @description The unique identifier for the API request. */
          "X-Request-Id"?: string;
          /** @description The maximum number of requests you're permitted to make per time period. */
          "X-RateLimit-Limit"?: number;
          /** @description The number of requests remaining in the current rate limit window. */
          "X-RateLimit-Remaining"?: number;
          /** @description The relative time in seconds until the current rate-limit window resets.
           *
           *     **Important:** This differs from Github and Twitter's same-named header which uses UTC epoch seconds. We use relative time to avoid client/server time synchronization issues. */
          "X-RateLimit-Reset"?: number;
          [name: string]: unknown;
        };
        content: {
          "application/json": components["schemas"]["iam.v2.RoleBinding"] &
            Record<string, unknown>;
        };
      };
      400: components["responses"]["BadRequestError"];
      401: components["responses"]["UnauthenticatedError"];
      403: components["responses"]["UnauthorizedError"];
      404: components["responses"]["NotFoundError"];
      429: components["responses"]["RateLimitError"];
      500: components["responses"]["DefaultSystemError"];
    };
  };
  deleteIamV2RoleBinding: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description The unique identifier for the role binding. */
        id: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description A Role Binding is being deleted. */
      200: {
        headers: {
          /** @description The unique identifier for the API request. */
          "X-Request-Id"?: string;
          /** @description The maximum number of requests you're permitted to make per time period. */
          "X-RateLimit-Limit"?: number;
          /** @description The number of requests remaining in the current rate limit window. */
          "X-RateLimit-Remaining"?: number;
          /** @description The relative time in seconds until the current rate-limit window resets.
           *
           *     **Important:** This differs from Github and Twitter's same-named header which uses UTC epoch seconds. We use relative time to avoid client/server time synchronization issues. */
          "X-RateLimit-Reset"?: number;
          [name: string]: unknown;
        };
        content: {
          "application/json": components["schemas"]["iam.v2.RoleBinding"] &
            Record<string, unknown>;
        };
      };
      400: components["responses"]["BadRequestError"];
      401: components["responses"]["UnauthenticatedError"];
      403: components["responses"]["UnauthorizedError"];
      404: components["responses"]["NotFoundError"];
      429: components["responses"]["RateLimitError"];
      500: components["responses"]["DefaultSystemError"];
    };
  };
  listNotificationsV1Subscriptions: {
    parameters: {
      query?: {
        /** @description A pagination size for collection requests. */
        page_size?: number;
        /** @description An opaque pagination token for collection requests. */
        page_token?: string;
      };
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description Subscription. */
      200: {
        headers: {
          /** @description The unique identifier for the API request. */
          "X-Request-Id"?: string;
          /** @description The maximum number of requests you're permitted to make per time period. */
          "X-RateLimit-Limit"?: number;
          /** @description The number of requests remaining in the current rate limit window. */
          "X-RateLimit-Remaining"?: number;
          /** @description The relative time in seconds until the current rate-limit window resets.
           *
           *     **Important:** This differs from Github and Twitter's same-named header which uses UTC epoch seconds. We use relative time to avoid client/server time synchronization issues. */
          "X-RateLimit-Reset"?: number;
          [name: string]: unknown;
        };
        content: {
          "application/json": components["schemas"]["notifications.v1.SubscriptionList"];
        };
      };
      400: components["responses"]["BadRequestError"];
      401: components["responses"]["UnauthenticatedError"];
      403: components["responses"]["UnauthorizedError"];
      429: components["responses"]["RateLimitError"];
      500: components["responses"]["DefaultSystemError"];
    };
  };
  createNotificationsV1Subscription: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody?: {
      content: {
        "application/json": components["schemas"]["notifications.v1.Subscription"] &
          Record<string, unknown>;
      };
    };
    responses: {
      /** @description A Subscription was created. */
      201: {
        headers: {
          /** @description The unique identifier for the API request. */
          "X-Request-Id"?: string;
          /** @description The maximum number of requests you're permitted to make per time period. */
          "X-RateLimit-Limit"?: number;
          /** @description The number of requests remaining in the current rate limit window. */
          "X-RateLimit-Remaining"?: number;
          /** @description The relative time in seconds until the current rate-limit window resets.
           *
           *     **Important:** This differs from Github and Twitter's same-named header which uses UTC epoch seconds. We use relative time to avoid client/server time synchronization issues. */
          "X-RateLimit-Reset"?: number;
          /** @description Subscription resource uri */
          Location?: string;
          [name: string]: unknown;
        };
        content: {
          "application/json": components["schemas"]["notifications.v1.Subscription"] &
            Record<string, unknown>;
        };
      };
      400: components["responses"]["BadRequestError"];
      401: components["responses"]["UnauthenticatedError"];
      403: components["responses"]["UnauthorizedError"];
      409: components["responses"]["ConflictError"];
      422: components["responses"]["ValidationError"];
      429: components["responses"]["RateLimitError"];
      500: components["responses"]["DefaultSystemError"];
    };
  };
  getNotificationsV1Subscription: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description The unique identifier for the subscription. */
        id: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description Subscription. */
      200: {
        headers: {
          /** @description The unique identifier for the API request. */
          "X-Request-Id"?: string;
          /** @description The maximum number of requests you're permitted to make per time period. */
          "X-RateLimit-Limit"?: number;
          /** @description The number of requests remaining in the current rate limit window. */
          "X-RateLimit-Remaining"?: number;
          /** @description The relative time in seconds until the current rate-limit window resets.
           *
           *     **Important:** This differs from Github and Twitter's same-named header which uses UTC epoch seconds. We use relative time to avoid client/server time synchronization issues. */
          "X-RateLimit-Reset"?: number;
          [name: string]: unknown;
        };
        content: {
          "application/json": components["schemas"]["notifications.v1.Subscription"] &
            Record<string, unknown>;
        };
      };
      400: components["responses"]["BadRequestError"];
      401: components["responses"]["UnauthenticatedError"];
      403: components["responses"]["UnauthorizedError"];
      404: components["responses"]["NotFoundError"];
      429: components["responses"]["RateLimitError"];
      500: components["responses"]["DefaultSystemError"];
    };
  };
  deleteNotificationsV1Subscription: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description The unique identifier for the subscription. */
        id: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description A Subscription is being deleted. */
      204: {
        headers: {
          /** @description The unique identifier for the API request. */
          "X-Request-Id"?: string;
          /** @description The maximum number of requests you're permitted to make per time period. */
          "X-RateLimit-Limit"?: number;
          /** @description The number of requests remaining in the current rate limit window. */
          "X-RateLimit-Remaining"?: number;
          /** @description The relative time in seconds until the current rate-limit window resets.
           *
           *     **Important:** This differs from Github and Twitter's same-named header which uses UTC epoch seconds. We use relative time to avoid client/server time synchronization issues. */
          "X-RateLimit-Reset"?: number;
          [name: string]: unknown;
        };
        content?: never;
      };
      400: components["responses"]["BadRequestError"];
      401: components["responses"]["UnauthenticatedError"];
      403: components["responses"]["UnauthorizedError"];
      404: components["responses"]["NotFoundError"];
      429: components["responses"]["RateLimitError"];
      500: components["responses"]["DefaultSystemError"];
    };
  };
  updateNotificationsV1Subscription: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description The unique identifier for the subscription. */
        id: string;
      };
      cookie?: never;
    };
    requestBody?: {
      content: {
        "application/json": components["schemas"]["notifications.v1.SubscriptionUpdate"];
      };
    };
    responses: {
      /** @description Subscription. */
      200: {
        headers: {
          /** @description The unique identifier for the API request. */
          "X-Request-Id"?: string;
          /** @description The maximum number of requests you're permitted to make per time period. */
          "X-RateLimit-Limit"?: number;
          /** @description The number of requests remaining in the current rate limit window. */
          "X-RateLimit-Remaining"?: number;
          /** @description The relative time in seconds until the current rate-limit window resets.
           *
           *     **Important:** This differs from Github and Twitter's same-named header which uses UTC epoch seconds. We use relative time to avoid client/server time synchronization issues. */
          "X-RateLimit-Reset"?: number;
          [name: string]: unknown;
        };
        content: {
          "application/json": components["schemas"]["notifications.v1.Subscription"] &
            Record<string, unknown>;
        };
      };
      400: components["responses"]["BadRequestError"];
      401: components["responses"]["UnauthenticatedError"];
      403: components["responses"]["UnauthorizedError"];
      404: components["responses"]["NotFoundError"];
      409: components["responses"]["ConflictError"];
      422: components["responses"]["ValidationError"];
      429: components["responses"]["RateLimitError"];
      500: components["responses"]["DefaultSystemError"];
    };
  };
  listNotificationsV1Integrations: {
    parameters: {
      query?: {
        /** @description A pagination size for collection requests. */
        page_size?: number;
        /** @description An opaque pagination token for collection requests. */
        page_token?: string;
      };
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description Integration. */
      200: {
        headers: {
          /** @description The unique identifier for the API request. */
          "X-Request-Id"?: string;
          /** @description The maximum number of requests you're permitted to make per time period. */
          "X-RateLimit-Limit"?: number;
          /** @description The number of requests remaining in the current rate limit window. */
          "X-RateLimit-Remaining"?: number;
          /** @description The relative time in seconds until the current rate-limit window resets.
           *
           *     **Important:** This differs from Github and Twitter's same-named header which uses UTC epoch seconds. We use relative time to avoid client/server time synchronization issues. */
          "X-RateLimit-Reset"?: number;
          [name: string]: unknown;
        };
        content: {
          "application/json": components["schemas"]["notifications.v1.IntegrationList"];
        };
      };
      400: components["responses"]["BadRequestError"];
      401: components["responses"]["UnauthenticatedError"];
      403: components["responses"]["UnauthorizedError"];
      429: components["responses"]["RateLimitError"];
      500: components["responses"]["DefaultSystemError"];
    };
  };
  createNotificationsV1Integration: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody?: {
      content: {
        "application/json": components["schemas"]["notifications.v1.Integration"] &
          Record<string, unknown>;
      };
    };
    responses: {
      /** @description An Integration was created. */
      201: {
        headers: {
          /** @description The unique identifier for the API request. */
          "X-Request-Id"?: string;
          /** @description The maximum number of requests you're permitted to make per time period. */
          "X-RateLimit-Limit"?: number;
          /** @description The number of requests remaining in the current rate limit window. */
          "X-RateLimit-Remaining"?: number;
          /** @description The relative time in seconds until the current rate-limit window resets.
           *
           *     **Important:** This differs from Github and Twitter's same-named header which uses UTC epoch seconds. We use relative time to avoid client/server time synchronization issues. */
          "X-RateLimit-Reset"?: number;
          /** @description Integration resource uri */
          Location?: string;
          [name: string]: unknown;
        };
        content: {
          "application/json": components["schemas"]["notifications.v1.Integration"] &
            Record<string, unknown>;
        };
      };
      400: components["responses"]["BadRequestError"];
      401: components["responses"]["UnauthenticatedError"];
      402: components["responses"]["OverQuotaError"];
      403: components["responses"]["UnauthorizedError"];
      409: components["responses"]["ConflictError"];
      422: components["responses"]["ValidationError"];
      429: components["responses"]["RateLimitError"];
      500: components["responses"]["DefaultSystemError"];
    };
  };
  getNotificationsV1Integration: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description The unique identifier for the integration. */
        id: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description Integration. */
      200: {
        headers: {
          /** @description The unique identifier for the API request. */
          "X-Request-Id"?: string;
          /** @description The maximum number of requests you're permitted to make per time period. */
          "X-RateLimit-Limit"?: number;
          /** @description The number of requests remaining in the current rate limit window. */
          "X-RateLimit-Remaining"?: number;
          /** @description The relative time in seconds until the current rate-limit window resets.
           *
           *     **Important:** This differs from Github and Twitter's same-named header which uses UTC epoch seconds. We use relative time to avoid client/server time synchronization issues. */
          "X-RateLimit-Reset"?: number;
          [name: string]: unknown;
        };
        content: {
          "application/json": components["schemas"]["notifications.v1.Integration"] &
            Record<string, unknown>;
        };
      };
      400: components["responses"]["BadRequestError"];
      401: components["responses"]["UnauthenticatedError"];
      403: components["responses"]["UnauthorizedError"];
      404: components["responses"]["NotFoundError"];
      429: components["responses"]["RateLimitError"];
      500: components["responses"]["DefaultSystemError"];
    };
  };
  deleteNotificationsV1Integration: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description The unique identifier for the integration. */
        id: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description An Integration is being deleted. */
      204: {
        headers: {
          /** @description The unique identifier for the API request. */
          "X-Request-Id"?: string;
          /** @description The maximum number of requests you're permitted to make per time period. */
          "X-RateLimit-Limit"?: number;
          /** @description The number of requests remaining in the current rate limit window. */
          "X-RateLimit-Remaining"?: number;
          /** @description The relative time in seconds until the current rate-limit window resets.
           *
           *     **Important:** This differs from Github and Twitter's same-named header which uses UTC epoch seconds. We use relative time to avoid client/server time synchronization issues. */
          "X-RateLimit-Reset"?: number;
          [name: string]: unknown;
        };
        content?: never;
      };
      400: components["responses"]["BadRequestError"];
      401: components["responses"]["UnauthenticatedError"];
      403: components["responses"]["UnauthorizedError"];
      404: components["responses"]["NotFoundError"];
      429: components["responses"]["RateLimitError"];
      500: components["responses"]["DefaultSystemError"];
    };
  };
  updateNotificationsV1Integration: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description The unique identifier for the integration. */
        id: string;
      };
      cookie?: never;
    };
    requestBody?: {
      content: {
        "application/json": components["schemas"]["notifications.v1.Integration"];
      };
    };
    responses: {
      /** @description Integration. */
      200: {
        headers: {
          /** @description The unique identifier for the API request. */
          "X-Request-Id"?: string;
          /** @description The maximum number of requests you're permitted to make per time period. */
          "X-RateLimit-Limit"?: number;
          /** @description The number of requests remaining in the current rate limit window. */
          "X-RateLimit-Remaining"?: number;
          /** @description The relative time in seconds until the current rate-limit window resets.
           *
           *     **Important:** This differs from Github and Twitter's same-named header which uses UTC epoch seconds. We use relative time to avoid client/server time synchronization issues. */
          "X-RateLimit-Reset"?: number;
          [name: string]: unknown;
        };
        content: {
          "application/json": components["schemas"]["notifications.v1.Integration"] &
            Record<string, unknown>;
        };
      };
      400: components["responses"]["BadRequestError"];
      401: components["responses"]["UnauthenticatedError"];
      402: components["responses"]["OverQuotaError"];
      403: components["responses"]["UnauthorizedError"];
      404: components["responses"]["NotFoundError"];
      409: components["responses"]["ConflictError"];
      422: components["responses"]["ValidationError"];
      429: components["responses"]["RateLimitError"];
      500: components["responses"]["DefaultSystemError"];
    };
  };
  testNotificationsV1Integration: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody?: {
      content: {
        "application/json": components["schemas"]["notifications.v1.Integration"] &
          Record<string, unknown>;
      };
    };
    responses: {
      /** @description Notification sent to test integration. */
      204: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
      400: components["responses"]["BadRequestError"];
      401: components["responses"]["UnauthenticatedError"];
      403: components["responses"]["UnauthorizedError"];
      404: components["responses"]["NotFoundError"];
      429: components["responses"]["RateLimitError"];
      500: components["responses"]["DefaultSystemError"];
    };
  };
  listNotificationsV1NotificationTypes: {
    parameters: {
      query?: {
        /** @description A pagination size for collection requests. */
        page_size?: number;
        /** @description An opaque pagination token for collection requests. */
        page_token?: string;
      };
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description Notification Type. */
      200: {
        headers: {
          /** @description The unique identifier for the API request. */
          "X-Request-Id"?: string;
          /** @description The maximum number of requests you're permitted to make per time period. */
          "X-RateLimit-Limit"?: number;
          /** @description The number of requests remaining in the current rate limit window. */
          "X-RateLimit-Remaining"?: number;
          /** @description The relative time in seconds until the current rate-limit window resets.
           *
           *     **Important:** This differs from Github and Twitter's same-named header which uses UTC epoch seconds. We use relative time to avoid client/server time synchronization issues. */
          "X-RateLimit-Reset"?: number;
          [name: string]: unknown;
        };
        content: {
          "application/json": components["schemas"]["notifications.v1.NotificationTypeList"];
        };
      };
      400: components["responses"]["BadRequestError"];
      401: components["responses"]["UnauthenticatedError"];
      403: components["responses"]["UnauthorizedError"];
      429: components["responses"]["RateLimitError"];
      500: components["responses"]["DefaultSystemError"];
    };
  };
  getNotificationsV1NotificationType: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description The unique identifier for the notification type. */
        id: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description Notification Type. */
      200: {
        headers: {
          /** @description The unique identifier for the API request. */
          "X-Request-Id"?: string;
          /** @description The maximum number of requests you're permitted to make per time period. */
          "X-RateLimit-Limit"?: number;
          /** @description The number of requests remaining in the current rate limit window. */
          "X-RateLimit-Remaining"?: number;
          /** @description The relative time in seconds until the current rate-limit window resets.
           *
           *     **Important:** This differs from Github and Twitter's same-named header which uses UTC epoch seconds. We use relative time to avoid client/server time synchronization issues. */
          "X-RateLimit-Reset"?: number;
          [name: string]: unknown;
        };
        content: {
          "application/json": components["schemas"]["notifications.v1.NotificationType"] &
            Record<string, unknown>;
        };
      };
      400: components["responses"]["BadRequestError"];
      401: components["responses"]["UnauthenticatedError"];
      403: components["responses"]["UnauthorizedError"];
      404: components["responses"]["NotFoundError"];
      429: components["responses"]["RateLimitError"];
      500: components["responses"]["DefaultSystemError"];
    };
  };
  listCmkV2Clusters: {
    parameters: {
      query: {
        /**
         * @description Filter the results by exact match for environment.
         * @example env-00000
         */
        environment: components["schemas"]["SearchFilter"];
        /**
         * @description Filter the results by exact match for spec.network. Pass multiple times to see results matching any of the values.
         * @example [
         *       "n-00000",
         *       "n-00001"
         *     ]
         */
        "spec.network"?: components["schemas"]["MultipleSearchFilter"];
        /** @description A pagination size for collection requests. */
        page_size?: number;
        /** @description An opaque pagination token for collection requests. */
        page_token?: string;
      };
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description Cluster. */
      200: {
        headers: {
          /** @description The unique identifier for the API request. */
          "X-Request-Id"?: string;
          /** @description The maximum number of requests you're permitted to make per time period. */
          "X-RateLimit-Limit"?: number;
          /** @description The number of requests remaining in the current rate limit window. */
          "X-RateLimit-Remaining"?: number;
          /** @description The relative time in seconds until the current rate-limit window resets.
           *
           *     **Important:** This differs from Github and Twitter's same-named header which uses UTC epoch seconds. We use relative time to avoid client/server time synchronization issues. */
          "X-RateLimit-Reset"?: number;
          [name: string]: unknown;
        };
        content: {
          "application/json": components["schemas"]["cmk.v2.ClusterList"] & {
            data?: {
              spec?: {
                /** @example {
                 *       "id": "env-00000",
                 *       "related": "https://api.confluent.cloud/v2/environments/env-00000",
                 *       "resource_name": "https://api.confluent.cloud/organization=9bb441c4-edef-46ac-8a41-c49e44a3fd9a/environment=env-00000"
                 *     } */
                environment?: unknown;
                /** @example {
                 *       "id": "n-00000",
                 *       "related": "https://api.confluent.cloud/networking/v1/networks/n-00000",
                 *       "resource_name": "https://api.confluent.cloud/organization=9bb441c4-edef-46ac-8a41-c49e44a3fd9a/environment=env-abc123/network=n-00000"
                 *     } */
                network?: unknown;
                /** @example {
                 *       "id": "cck-00000",
                 *       "related": "https://api.confluent.cloud/byok/v1/keys/cck-00000",
                 *       "resource_name": "https://api.confluent.cloud/organization=9bb441c4-edef-46ac-8a41-c49e44a3fd9a/key=cck-00000"
                 *     } */
                byok?: unknown;
              };
            }[];
          };
        };
      };
      400: components["responses"]["BadRequestError"];
      401: components["responses"]["UnauthenticatedError"];
      403: components["responses"]["UnauthorizedError"];
      429: components["responses"]["RateLimitError"];
      500: components["responses"]["DefaultSystemError"];
    };
  };
  createCmkV2Cluster: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody?: {
      content: {
        "application/json": components["schemas"]["cmk.v2.Cluster"] & {
          spec: Record<string, unknown>;
        } & {
          spec?: {
            /** @example {
             *       "id": "env-00000"
             *     } */
            environment?: unknown;
            /** @example {
             *       "id": "n-00000"
             *     } */
            network?: unknown;
            /** @example {
             *       "id": "cck-00000"
             *     } */
            byok?: unknown;
          };
        };
      };
    };
    responses: {
      /** @description A Cluster is being created. */
      202: {
        headers: {
          /** @description The unique identifier for the API request. */
          "X-Request-Id"?: string;
          /** @description The maximum number of requests you're permitted to make per time period. */
          "X-RateLimit-Limit"?: number;
          /** @description The number of requests remaining in the current rate limit window. */
          "X-RateLimit-Remaining"?: number;
          /** @description The relative time in seconds until the current rate-limit window resets.
           *
           *     **Important:** This differs from Github and Twitter's same-named header which uses UTC epoch seconds. We use relative time to avoid client/server time synchronization issues. */
          "X-RateLimit-Reset"?: number;
          /** @description Cluster resource uri */
          Location?: string;
          [name: string]: unknown;
        };
        content: {
          "application/json": components["schemas"]["cmk.v2.Cluster"] & {
            spec: Record<string, unknown>;
          } & {
            spec?: {
              /** @example {
               *       "id": "env-00000",
               *       "related": "https://api.confluent.cloud/v2/environments/env-00000",
               *       "resource_name": "https://api.confluent.cloud/organization=9bb441c4-edef-46ac-8a41-c49e44a3fd9a/environment=env-00000"
               *     } */
              environment?: unknown;
              /** @example {
               *       "id": "n-00000",
               *       "related": "https://api.confluent.cloud/networking/v1/networks/n-00000",
               *       "resource_name": "https://api.confluent.cloud/organization=9bb441c4-edef-46ac-8a41-c49e44a3fd9a/environment=env-abc123/network=n-00000"
               *     } */
              network?: unknown;
              /** @example {
               *       "id": "cck-00000",
               *       "related": "https://api.confluent.cloud/byok/v1/keys/cck-00000",
               *       "resource_name": "https://api.confluent.cloud/organization=9bb441c4-edef-46ac-8a41-c49e44a3fd9a/key=cck-00000"
               *     } */
              byok?: unknown;
            };
          };
        };
      };
      400: components["responses"]["BadRequestError"];
      401: components["responses"]["UnauthenticatedError"];
      402: components["responses"]["OverQuotaError"];
      403: components["responses"]["UnauthorizedError"];
      409: components["responses"]["ConflictError"];
      422: components["responses"]["ValidationError"];
      429: components["responses"]["RateLimitError"];
      500: components["responses"]["DefaultSystemError"];
    };
  };
  getCmkV2Cluster: {
    parameters: {
      query: {
        /**
         * @description Scope the operation to the given environment.
         * @example env-00000
         */
        environment: components["schemas"]["SearchFilter"];
      };
      header?: never;
      path: {
        /** @description The unique identifier for the cluster. */
        id: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description Cluster. */
      200: {
        headers: {
          /** @description The unique identifier for the API request. */
          "X-Request-Id"?: string;
          /** @description The maximum number of requests you're permitted to make per time period. */
          "X-RateLimit-Limit"?: number;
          /** @description The number of requests remaining in the current rate limit window. */
          "X-RateLimit-Remaining"?: number;
          /** @description The relative time in seconds until the current rate-limit window resets.
           *
           *     **Important:** This differs from Github and Twitter's same-named header which uses UTC epoch seconds. We use relative time to avoid client/server time synchronization issues. */
          "X-RateLimit-Reset"?: number;
          [name: string]: unknown;
        };
        content: {
          "application/json": components["schemas"]["cmk.v2.Cluster"] & {
            spec: Record<string, unknown>;
          } & {
            spec?: {
              /** @example {
               *       "id": "env-00000",
               *       "related": "https://api.confluent.cloud/v2/environments/env-00000",
               *       "resource_name": "https://api.confluent.cloud/organization=9bb441c4-edef-46ac-8a41-c49e44a3fd9a/environment=env-00000"
               *     } */
              environment?: unknown;
              /** @example {
               *       "id": "n-00000",
               *       "related": "https://api.confluent.cloud/networking/v1/networks/n-00000",
               *       "resource_name": "https://api.confluent.cloud/organization=9bb441c4-edef-46ac-8a41-c49e44a3fd9a/environment=env-abc123/network=n-00000"
               *     } */
              network?: unknown;
              /** @example {
               *       "id": "cck-00000",
               *       "related": "https://api.confluent.cloud/byok/v1/keys/cck-00000",
               *       "resource_name": "https://api.confluent.cloud/organization=9bb441c4-edef-46ac-8a41-c49e44a3fd9a/key=cck-00000"
               *     } */
              byok?: unknown;
            };
          };
        };
      };
      400: components["responses"]["BadRequestError"];
      401: components["responses"]["UnauthenticatedError"];
      403: components["responses"]["UnauthorizedError"];
      404: components["responses"]["NotFoundError"];
      429: components["responses"]["RateLimitError"];
      500: components["responses"]["DefaultSystemError"];
    };
  };
  deleteCmkV2Cluster: {
    parameters: {
      query: {
        /**
         * @description Scope the operation to the given environment.
         * @example env-00000
         */
        environment: components["schemas"]["SearchFilter"];
      };
      header?: never;
      path: {
        /** @description The unique identifier for the cluster. */
        id: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description A Cluster is being deleted. */
      204: {
        headers: {
          /** @description The unique identifier for the API request. */
          "X-Request-Id"?: string;
          /** @description The maximum number of requests you're permitted to make per time period. */
          "X-RateLimit-Limit"?: number;
          /** @description The number of requests remaining in the current rate limit window. */
          "X-RateLimit-Remaining"?: number;
          /** @description The relative time in seconds until the current rate-limit window resets.
           *
           *     **Important:** This differs from Github and Twitter's same-named header which uses UTC epoch seconds. We use relative time to avoid client/server time synchronization issues. */
          "X-RateLimit-Reset"?: number;
          [name: string]: unknown;
        };
        content?: never;
      };
      400: components["responses"]["BadRequestError"];
      401: components["responses"]["UnauthenticatedError"];
      403: components["responses"]["UnauthorizedError"];
      404: components["responses"]["NotFoundError"];
      429: components["responses"]["RateLimitError"];
      500: components["responses"]["DefaultSystemError"];
    };
  };
  updateCmkV2Cluster: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description The unique identifier for the cluster. */
        id: string;
      };
      cookie?: never;
    };
    requestBody?: {
      content: {
        "application/json": components["schemas"]["cmk.v2.ClusterUpdate"] & {
          spec: {
            /** @example {
             *       "id": "env-00000"
             *     } */
            environment: unknown;
          };
        };
      };
    };
    responses: {
      /** @description Cluster. */
      200: {
        headers: {
          /** @description The unique identifier for the API request. */
          "X-Request-Id"?: string;
          /** @description The maximum number of requests you're permitted to make per time period. */
          "X-RateLimit-Limit"?: number;
          /** @description The number of requests remaining in the current rate limit window. */
          "X-RateLimit-Remaining"?: number;
          /** @description The relative time in seconds until the current rate-limit window resets.
           *
           *     **Important:** This differs from Github and Twitter's same-named header which uses UTC epoch seconds. We use relative time to avoid client/server time synchronization issues. */
          "X-RateLimit-Reset"?: number;
          [name: string]: unknown;
        };
        content: {
          "application/json": components["schemas"]["cmk.v2.Cluster"] & {
            spec: Record<string, unknown>;
          } & {
            spec?: {
              /** @example {
               *       "id": "env-00000",
               *       "related": "https://api.confluent.cloud/v2/environments/env-00000",
               *       "resource_name": "https://api.confluent.cloud/organization=9bb441c4-edef-46ac-8a41-c49e44a3fd9a/environment=env-00000"
               *     } */
              environment?: unknown;
              /** @example {
               *       "id": "n-00000",
               *       "related": "https://api.confluent.cloud/networking/v1/networks/n-00000",
               *       "resource_name": "https://api.confluent.cloud/organization=9bb441c4-edef-46ac-8a41-c49e44a3fd9a/environment=env-abc123/network=n-00000"
               *     } */
              network?: unknown;
              /** @example {
               *       "id": "cck-00000",
               *       "related": "https://api.confluent.cloud/byok/v1/keys/cck-00000",
               *       "resource_name": "https://api.confluent.cloud/organization=9bb441c4-edef-46ac-8a41-c49e44a3fd9a/key=cck-00000"
               *     } */
              byok?: unknown;
            };
          };
        };
      };
      400: components["responses"]["BadRequestError"];
      401: components["responses"]["UnauthenticatedError"];
      402: components["responses"]["OverQuotaError"];
      403: components["responses"]["UnauthorizedError"];
      404: components["responses"]["NotFoundError"];
      409: components["responses"]["ConflictError"];
      422: components["responses"]["ValidationError"];
      429: components["responses"]["RateLimitError"];
      500: components["responses"]["DefaultSystemError"];
    };
  };
  listKsqldbcmV2Clusters: {
    parameters: {
      query: {
        /**
         * @description Filter the results by exact match for environment.
         * @example env-00000
         */
        environment: components["schemas"]["SearchFilter"];
        /** @description A pagination size for collection requests. */
        page_size?: number;
        /** @description An opaque pagination token for collection requests. */
        page_token?: string;
      };
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description Cluster. */
      200: {
        headers: {
          /** @description The unique identifier for the API request. */
          "X-Request-Id"?: string;
          /** @description The maximum number of requests you're permitted to make per time period. */
          "X-RateLimit-Limit"?: number;
          /** @description The number of requests remaining in the current rate limit window. */
          "X-RateLimit-Remaining"?: number;
          /** @description The relative time in seconds until the current rate-limit window resets.
           *
           *     **Important:** This differs from Github and Twitter's same-named header which uses UTC epoch seconds. We use relative time to avoid client/server time synchronization issues. */
          "X-RateLimit-Reset"?: number;
          [name: string]: unknown;
        };
        content: {
          "application/json": components["schemas"]["ksqldbcm.v2.ClusterList"] & {
            data?: {
              spec?: {
                /** @example {
                 *       "id": "lkc-00000",
                 *       "related": "https://api.confluent.cloud/cmk/v2/clusters/lkc-00000",
                 *       "resource_name": "https://api.confluent.cloud/organization=9bb441c4-edef-46ac-8a41-c49e44a3fd9a/environment=env-abc123/cloud-cluster=lkc-00000"
                 *     } */
                kafka_cluster?: unknown;
                /** @example {
                 *       "id": "u-a83k9b",
                 *       "related": "https://api.confluent.cloud/iam/v2/users/u-a83k9b",
                 *       "resource_name": "https://api.confluent.cloud/user=u-a83k9b"
                 *     } */
                credential_identity?: unknown;
                /** @example {
                 *       "id": "env-00000",
                 *       "related": "https://api.confluent.cloud/org/v2/environments/env-00000",
                 *       "resource_name": "https://api.confluent.cloud/organization=9bb441c4-edef-46ac-8a41-c49e44a3fd9a/environment=env-00000"
                 *     } */
                environment?: unknown;
              };
            }[];
          };
        };
      };
      400: components["responses"]["BadRequestError"];
      401: components["responses"]["UnauthenticatedError"];
      403: components["responses"]["UnauthorizedError"];
      429: components["responses"]["RateLimitError"];
      500: components["responses"]["DefaultSystemError"];
    };
  };
  createKsqldbcmV2Cluster: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody?: {
      content: {
        "application/json": components["schemas"]["ksqldbcm.v2.Cluster"] & {
          spec: Record<string, unknown>;
        } & {
          spec?: {
            /** @example {
             *       "id": "lkc-00000"
             *     } */
            kafka_cluster?: unknown;
            /** @example {
             *       "id": "u-a83k9b"
             *     } */
            credential_identity?: unknown;
            /** @example {
             *       "id": "env-00000"
             *     } */
            environment?: unknown;
          };
        };
      };
    };
    responses: {
      /** @description A Cluster is being created. */
      202: {
        headers: {
          /** @description The unique identifier for the API request. */
          "X-Request-Id"?: string;
          /** @description The maximum number of requests you're permitted to make per time period. */
          "X-RateLimit-Limit"?: number;
          /** @description The number of requests remaining in the current rate limit window. */
          "X-RateLimit-Remaining"?: number;
          /** @description The relative time in seconds until the current rate-limit window resets.
           *
           *     **Important:** This differs from Github and Twitter's same-named header which uses UTC epoch seconds. We use relative time to avoid client/server time synchronization issues. */
          "X-RateLimit-Reset"?: number;
          /** @description Cluster resource uri */
          Location?: string;
          [name: string]: unknown;
        };
        content: {
          "application/json": components["schemas"]["ksqldbcm.v2.Cluster"] & {
            spec: Record<string, unknown>;
          } & {
            spec?: {
              /** @example {
               *       "id": "lkc-00000",
               *       "related": "https://api.confluent.cloud/cmk/v2/clusters/lkc-00000",
               *       "resource_name": "https://api.confluent.cloud/organization=9bb441c4-edef-46ac-8a41-c49e44a3fd9a/environment=env-abc123/cloud-cluster=lkc-00000"
               *     } */
              kafka_cluster?: unknown;
              /** @example {
               *       "id": "u-a83k9b",
               *       "related": "https://api.confluent.cloud/iam/v2/users/u-a83k9b",
               *       "resource_name": "https://api.confluent.cloud/user=u-a83k9b"
               *     } */
              credential_identity?: unknown;
              /** @example {
               *       "id": "env-00000",
               *       "related": "https://api.confluent.cloud/org/v2/environments/env-00000",
               *       "resource_name": "https://api.confluent.cloud/organization=9bb441c4-edef-46ac-8a41-c49e44a3fd9a/environment=env-00000"
               *     } */
              environment?: unknown;
            };
          };
        };
      };
      400: components["responses"]["BadRequestError"];
      401: components["responses"]["UnauthenticatedError"];
      402: components["responses"]["OverQuotaError"];
      403: components["responses"]["UnauthorizedError"];
      409: components["responses"]["ConflictError"];
      422: components["responses"]["ValidationError"];
      429: components["responses"]["RateLimitError"];
      500: components["responses"]["DefaultSystemError"];
    };
  };
  getKsqldbcmV2Cluster: {
    parameters: {
      query: {
        /**
         * @description Scope the operation to the given environment.
         * @example env-00000
         */
        environment: components["schemas"]["SearchFilter"];
      };
      header?: never;
      path: {
        /** @description The unique identifier for the cluster. */
        id: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description Cluster. */
      200: {
        headers: {
          /** @description The unique identifier for the API request. */
          "X-Request-Id"?: string;
          /** @description The maximum number of requests you're permitted to make per time period. */
          "X-RateLimit-Limit"?: number;
          /** @description The number of requests remaining in the current rate limit window. */
          "X-RateLimit-Remaining"?: number;
          /** @description The relative time in seconds until the current rate-limit window resets.
           *
           *     **Important:** This differs from Github and Twitter's same-named header which uses UTC epoch seconds. We use relative time to avoid client/server time synchronization issues. */
          "X-RateLimit-Reset"?: number;
          [name: string]: unknown;
        };
        content: {
          "application/json": components["schemas"]["ksqldbcm.v2.Cluster"] & {
            spec: Record<string, unknown>;
          } & {
            spec?: {
              /** @example {
               *       "id": "lkc-00000",
               *       "related": "https://api.confluent.cloud/cmk/v2/clusters/lkc-00000",
               *       "resource_name": "https://api.confluent.cloud/organization=9bb441c4-edef-46ac-8a41-c49e44a3fd9a/environment=env-abc123/cloud-cluster=lkc-00000"
               *     } */
              kafka_cluster?: unknown;
              /** @example {
               *       "id": "u-a83k9b",
               *       "related": "https://api.confluent.cloud/iam/v2/users/u-a83k9b",
               *       "resource_name": "https://api.confluent.cloud/user=u-a83k9b"
               *     } */
              credential_identity?: unknown;
              /** @example {
               *       "id": "env-00000",
               *       "related": "https://api.confluent.cloud/org/v2/environments/env-00000",
               *       "resource_name": "https://api.confluent.cloud/organization=9bb441c4-edef-46ac-8a41-c49e44a3fd9a/environment=env-00000"
               *     } */
              environment?: unknown;
            };
          };
        };
      };
      400: components["responses"]["BadRequestError"];
      401: components["responses"]["UnauthenticatedError"];
      403: components["responses"]["UnauthorizedError"];
      404: components["responses"]["NotFoundError"];
      429: components["responses"]["RateLimitError"];
      500: components["responses"]["DefaultSystemError"];
    };
  };
  deleteKsqldbcmV2Cluster: {
    parameters: {
      query: {
        /**
         * @description Scope the operation to the given environment.
         * @example env-00000
         */
        environment: components["schemas"]["SearchFilter"];
      };
      header?: never;
      path: {
        /** @description The unique identifier for the cluster. */
        id: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description A Cluster is being deleted. */
      204: {
        headers: {
          /** @description The unique identifier for the API request. */
          "X-Request-Id"?: string;
          /** @description The maximum number of requests you're permitted to make per time period. */
          "X-RateLimit-Limit"?: number;
          /** @description The number of requests remaining in the current rate limit window. */
          "X-RateLimit-Remaining"?: number;
          /** @description The relative time in seconds until the current rate-limit window resets.
           *
           *     **Important:** This differs from Github and Twitter's same-named header which uses UTC epoch seconds. We use relative time to avoid client/server time synchronization issues. */
          "X-RateLimit-Reset"?: number;
          [name: string]: unknown;
        };
        content?: never;
      };
      400: components["responses"]["BadRequestError"];
      401: components["responses"]["UnauthenticatedError"];
      403: components["responses"]["UnauthorizedError"];
      404: components["responses"]["NotFoundError"];
      429: components["responses"]["RateLimitError"];
      500: components["responses"]["DefaultSystemError"];
    };
  };
  listConnectv1Connectors: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description The unique identifier of the environment this resource belongs to. */
        environment_id: string;
        /** @description The unique identifier for the Kafka cluster. */
        kafka_cluster_id: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description Connector. */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          /** @example [
           *       "MyGcsLogsBucketConnector",
           *       "MyS3BucketConnector",
           *       "MyDatagenConnector"
           *     ] */
          "application/json": string[];
        };
      };
      401: components["responses"]["connect.v1.UnauthenticatedError"];
      404: components["responses"]["connect.v1.AccountNotFoundError"];
      429: components["responses"]["RateLimitError"];
      500: components["responses"]["connect.v1.DefaultSystemError"];
    };
  };
  createConnectv1Connector: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description The unique identifier of the environment this resource belongs to. */
        environment_id: string;
        /** @description The unique identifier for the Kafka cluster. */
        kafka_cluster_id: string;
      };
      cookie?: never;
    };
    requestBody?: {
      content: {
        "application/json": {
          /** @description Name of the connector to create. */
          name?: string;
          /** @description Configuration parameters for the connector. All values should be strings. */
          config?: {
            /** @description \[Required for Managed Connector, Ignored for Custom Connector\] The connector class name, e.g., BigQuerySink, GcsSink, etc. */
            "connector.class": string;
            /** @description Name or alias of the class (plugin) for this connector. For custom connector, it must be the same as the name of the connector to create. */
            name: string;
            /** @description The kafka cluster api key. */
            "kafka.api.key": string;
            /** @description The kafka cluster api secret key. */
            "kafka.api.secret": string;
            /**
             * @description \[Required for Custom Connector\] The connector type.
             *
             * @default MANAGED
             * @example CUSTOM
             */
            "confluent.connector.type"?: string;
            /**
             * @description \[Required for Custom Connector\] The custom plugin id of custom connector, e.g., `ccp-lq5m06`
             *
             * @example ccp-lq5m06
             */
            "confluent.custom.plugin.id"?: string;
            /** @description \[Optional for Custom Connector\] Egress endpoint(s) for the connector to use when attaching to the sink or source data system.
             *      */
            "confluent.custom.connection.endpoints"?: string;
            /**
             * @description \[Optional for Custom Connector\] Automatically add the required schema registry properties in a custom connector config if schema registry is enabled.
             *
             * @default FALSE
             * @example FALSE
             */
            "confluent.custom.schema.registry.auto"?: string;
          } & {
            [key: string]: string;
          };
          offsets?: components["schemas"]["connect.v1.Offsets"];
        };
      };
    };
    responses: {
      /** @description Created */
      201: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          /** @example {
           *       "name": "MyGcsLogsBucketConnector",
           *       "config": {
           *         "cloud.environment": "prod",
           *         "cloud.provider": "aws",
           *         "connector.class": "GcsSink",
           *         "data.format": "BYTES",
           *         "flush.size": "1000",
           *         "gcs.bucket.name": "APILogsBucket",
           *         "gcs.credentials.config": "****************",
           *         "kafka.api.key": "****************",
           *         "kafka.api.secret": "****************",
           *         "kafka.endpoint": "SASL_SSL://pkc-xxxxx.us-west-2.aws.confluent.cloud:9092",
           *         "kafka.region": "us-west-2",
           *         "name": "MyGcsLogsBucketConnector",
           *         "tasks.max": "1",
           *         "time.interval": "DAILY",
           *         "topics": "APILogsTopic"
           *       },
           *       "tasks": [
           *         {
           *           "connector": "MyGcsLogsBucketConnector",
           *           "task": 0
           *         }
           *       ],
           *       "type": "sink",
           *       "offsets": [
           *         {
           *           "partition": {
           *             "kafka_partition": 0,
           *             "kafka_topic": "APILogsTopic"
           *           },
           *           "offset": {
           *             "kafka_offset": 1000
           *           }
           *         }
           *       ]
           *     } */
          "application/json": components["schemas"]["connect.v1.ConnectorWithOffsets"];
        };
      };
      /** @description Bad Request */
      400: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          /** @example {
           *       "error": {
           *         "code": 400,
           *         "message": "Unauthorized"
           *       }
           *     } */
          "application/json": {
            code?: number;
            message?: string;
          };
        };
      };
      401: components["responses"]["connect.v1.UnauthenticatedError"];
      429: components["responses"]["RateLimitError"];
      /** @description Internal Server Error */
      500: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          /** @example {
           *       "error_code": 500,
           *       "message": "Failed to find any class that implements Connector and which name matches io.confluent.connect.<connector-class>..."
           *     } */
          "application/json": {
            error_code?: number;
            message?: string;
          };
        };
      };
    };
  };
  listConnectv1ConnectorsWithExpansions: {
    parameters: {
      query?: {
        /** @description - id : Returns metadata of each connector such as id and id type.
         *     - info : Returns metadata of each connector such as the configuration, task
         *     information, and type of connector.
         *     - status : Returns additional state information of each connector including their status and tasks. */
        expand?: "id" | "info" | "status";
      };
      header?: never;
      path: {
        /** @description The unique identifier of the environment this resource belongs to. */
        environment_id: string;
        /** @description The unique identifier for the Kafka cluster. */
        kafka_cluster_id: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description Connector. */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          /** @example {
           *       "MyGcsLogsBucketConnector": {
           *         "id": {
           *           "id": "lcc-xxxxx",
           *           "id_type": "ID"
           *         },
           *         "info": {
           *           "name": "MyGcsLogsBucketConnector",
           *           "config": {
           *             "cloud.environment": "prod",
           *             "cloud.provider": "aws",
           *             "connector.class": "GcsSink",
           *             "data.format": "BYTES",
           *             "flush.size": "1000",
           *             "gcs.bucket.name": "APILogsBucket",
           *             "gcs.credentials.config": "****************",
           *             "kafka.api.key": "****************",
           *             "kafka.api.secret": "****************",
           *             "kafka.endpoint": "SASL_SSL://pkc-xxxxx.us-west-2.aws.confluent.cloud:9092",
           *             "kafka.region": "us-west-2",
           *             "name": "MyGcsLogsBucketConnector",
           *             "tasks.max": "1",
           *             "time.interval": "DAILY",
           *             "topics": "APILogsTopic",
           *             "type": "sink"
           *           }
           *         },
           *         "status": {
           *           "name": "MyGcsLogsBucketConnector",
           *           "connector": {
           *             "state": "PROVISIONING",
           *             "worker_id": "MyGcsLogsBucketConnector",
           *             "trace": ""
           *           },
           *           "tasks": [],
           *           "type": "sink"
           *         }
           *       },
           *       "MyS3BucketConnector": {
           *         "id": {
           *           "id": "lcc-xxxxx",
           *           "id_type": "ID"
           *         },
           *         "info": {
           *           "name": "MyS3BucketConnector",
           *           "config": {
           *             "cloud.environment": "prod",
           *             "cloud.provider": "aws",
           *             "connector.class": "S3Sink",
           *             "data.format": "BYTES",
           *             "flush.size": "1000",
           *             "s3.bucket": "APILogsBucket",
           *             "aws.access.key.id": "************",
           *             "aws.secret.access.key": "**********",
           *             "kafka.api.key": "****************",
           *             "kafka.api.secret": "****************",
           *             "kafka.endpoint": "SASL_SSL://pkc-xxxxx.us-west-2.aws.confluent.cloud:9092",
           *             "kafka.region": "us-west-2",
           *             "name": "MyS3BucketConnector",
           *             "tasks.max": "1",
           *             "time.interval": "DAILY",
           *             "topics": "APILogsTopic",
           *             "type": "source"
           *           }
           *         },
           *         "status": {
           *           "name": "MyS3BucketConnector",
           *           "connector": {
           *             "state": "FAILED",
           *             "worker_id": "MyS3BucketConnector",
           *             "trace": "There were some errors with your configuration:\ntopics: Provided Kafka ApiKey is invalid\nkafka.api.secret: Provided Kafka ApiKey is invalid\n"
           *           },
           *           "tasks": [],
           *           "type": "sink"
           *         }
           *       },
           *       "MyDatagenConnector": {
           *         "id": {
           *           "id": "lcc-xxxxx",
           *           "id_type": "ID"
           *         },
           *         "info": {
           *           "name": "MyDatagenConnector",
           *           "config": {
           *             "cloud.environment": "prod",
           *             "cloud.provider": "aws",
           *             "connector.class": "DatagenSource",
           *             "data.format": "BYTES",
           *             "flush.size": "1000",
           *             "quickstart": "ORDERS",
           *             "kafka.api.key": "****************",
           *             "kafka.api.secret": "****************",
           *             "kafka.endpoint": "SASL_SSL://pkc-xxxxx.us-west-2.aws.confluent.cloud:9092",
           *             "kafka.region": "us-west-2",
           *             "name": "MyDatagenConnector",
           *             "tasks.max": "1",
           *             "time.interval": "DAILY",
           *             "topics": "APILogsTopic",
           *             "type": "source"
           *           }
           *         },
           *         "status": {
           *           "name": "MyDatagenConnector",
           *           "connector": {
           *             "state": "RUNNING",
           *             "worker_id": "MyDatagenConnector",
           *             "trace": ""
           *           },
           *           "tasks": [
           *             {
           *               "id": 0,
           *               "msg": "",
           *               "state": "RUNNING",
           *               "worker_id": "MyDatagenConnector"
           *             }
           *           ],
           *           "type": "source"
           *         }
           *       }
           *     } */
          "application/json": components["schemas"]["connect.v1.ConnectorExpansionMap"];
        };
      };
      401: components["responses"]["connect.v1.UnauthenticatedError"];
      404: components["responses"]["connect.v1.AccountNotFoundError"];
      429: components["responses"]["RateLimitError"];
      500: components["responses"]["connect.v1.DefaultSystemError"];
    };
  };
  getConnectv1ConnectorConfig: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description The unique name of the connector. */
        connector_name: string;
        /** @description The unique identifier of the environment this resource belongs to. */
        environment_id: string;
        /** @description The unique identifier for the Kafka cluster. */
        kafka_cluster_id: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description Connector. */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          /** @example {
           *       "cloud.environment": "prod",
           *       "cloud.provider": "aws",
           *       "connector.class": "GcsSink",
           *       "data.format": "BYTES",
           *       "flush.size": "1000",
           *       "gcs.bucket.name": "APILogsBucket",
           *       "gcs.credentials.config": "****************",
           *       "kafka.api.key": "****************",
           *       "kafka.api.secret": "****************",
           *       "kafka.endpoint": "SASL_SSL://pkc-xxxxx.us-west-2.aws.confluent.cloud:9092",
           *       "kafka.region": "us-west-2",
           *       "name": "MyGcsLogsBucketConnector",
           *       "tasks.max": "2",
           *       "time.interval": "DAILY",
           *       "topics": "APILogsTopic"
           *     } */
          "application/json": {
            /** @description The cloud environment type. */
            "cloud.environment": string;
            /** @description The cloud service provider, e.g. aws, azure, etc. */
            "cloud.provider": string;
            /** @description The connector class name. E.g. BigQuerySink, GcsSink, etc. */
            "connector.class": string;
            /** @description Name or alias of the class (plugin) for this connector. For Custom Connector, it must be the same as connector_name. */
            name: string;
            /** @description The kafka cluster endpoint. */
            "kafka.endpoint": string;
            /** @description The kafka cluster region. */
            "kafka.region": string;
            /** @description The kafka cluster api key. */
            "kafka.api.key": string;
            /** @description The kafka cluster api secret key. */
            "kafka.api.secret": string;
          } & {
            [key: string]: string;
          };
        };
      };
      401: components["responses"]["connect.v1.UnauthenticatedError"];
      404: components["responses"]["connect.v1.AccountNotFoundError"];
      429: components["responses"]["RateLimitError"];
      500: components["responses"]["connect.v1.DefaultSystemError"];
    };
  };
  createOrUpdateConnectv1ConnectorConfig: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description The unique name of the connector. */
        connector_name: string;
        /** @description The unique identifier of the environment this resource belongs to. */
        environment_id: string;
        /** @description The unique identifier for the Kafka cluster. */
        kafka_cluster_id: string;
      };
      cookie?: never;
    };
    /** @description Configuration parameters for the connector. All values should be strings. */
    requestBody?: {
      content: {
        /** @example {
         *       "connector.class": "GcsSink",
         *       "data.format": "BYTES",
         *       "flush.size": "1000",
         *       "gcs.bucket.name": "APILogsBucket",
         *       "gcs.credentials.config": "****************",
         *       "kafka.api.key": "****************",
         *       "kafka.api.secret": "****************",
         *       "name": "MyGcsLogsBucketConnector",
         *       "tasks.max": "2",
         *       "time.interval": "DAILY",
         *       "topics": "APILogsTopic"
         *     } */
        "application/json": {
          /** @description \[Required for Managed Connector, Ignored for Custom Connector\] The connector class name. E.g. BigQuerySink, GcsSink, etc. */
          "connector.class": string;
          /** @description Name or alias of the class (plugin) for this connector. */
          name: string;
          /** @description The kafka cluster api key. */
          "kafka.api.key": string;
          /** @description The kafka cluster api secret key. */
          "kafka.api.secret": string;
          /**
           * @description \[Required for Custom Connector\] The connector type.
           *
           * @default MANAGED
           * @example CUSTOM
           */
          "confluent.connector.type"?: string;
          /**
           * @description \[Required for Custom Connector\] The custom plugin id of custom connector, e.g., `ccp-lq5m06`
           *
           * @example ccp-lq5m06
           */
          "confluent.custom.plugin.id"?: string;
          /** @description \[Optional for Custom Connector\] Egress endpoint(s) for the connector to use when attaching to the sink or source data system.
           *      */
          "confluent.custom.connection.endpoints"?: string;
          /**
           * @description \[Optional for Custom Connector\] Automatically add the required schema registry properties in a custom connector config if schema registry is enabled.
           *
           * @default FALSE
           * @example FALSE
           */
          "confluent.custom.schema.registry.auto"?: string;
        } & {
          [key: string]: string;
        };
      };
    };
    responses: {
      /** @description Created */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          /** @example {
           *       "name": "MyGcsLogsBucketConnector",
           *       "config": {
           *         "cloud.environment": "prod",
           *         "cloud.provider": "aws",
           *         "connector.class": "GcsSink",
           *         "data.format": "BYTES",
           *         "flush.size": "1000",
           *         "gcs.bucket.name": "APILogsBucket",
           *         "gcs.credentials.config": "****************",
           *         "kafka.api.key": "****************",
           *         "kafka.api.secret": "****************",
           *         "kafka.endpoint": "SASL_SSL://pkc-xxxxx.us-west-2.aws.confluent.cloud:9092",
           *         "kafka.region": "us-west-2",
           *         "name": "MyGcsLogsBucketConnector",
           *         "tasks.max": "2",
           *         "time.interval": "DAILY",
           *         "topics": "APILogsTopic"
           *       },
           *       "tasks": [
           *         {
           *           "connector": "MyGcsLogsBucketConnector",
           *           "task": 0
           *         },
           *         {
           *           "connector": "MyGcsLogsBucketConnector",
           *           "task": 1
           *         }
           *       ],
           *       "type": "sink"
           *     } */
          "application/json": components["schemas"]["connect.v1.Connector"];
        };
      };
      400: components["responses"]["connect.v1.BadRequestError"];
      401: components["responses"]["connect.v1.UnauthenticatedError"];
      404: components["responses"]["connect.v1.AccountNotFoundError"];
      429: components["responses"]["RateLimitError"];
      /** @description Internal Server Error */
      500: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          /** @example {
           *       "error_code": 500,
           *       "message": "Failed to find any class that implements Connector and which name matches io.confluent.connect.<connector-class>..."
           *     } */
          "application/json": {
            error_code?: number;
            message?: string;
          };
        };
      };
    };
  };
  readConnectv1Connector: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description The unique name of the connector. */
        connector_name: string;
        /** @description The unique identifier of the environment this resource belongs to. */
        environment_id: string;
        /** @description The unique identifier for the Kafka cluster. */
        kafka_cluster_id: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description Connector. */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          /** @example {
           *       "name": "MyGcsLogsBucketConnector",
           *       "config": {
           *         "cloud.environment": "prod",
           *         "cloud.provider": "aws",
           *         "connector.class": "GcsSink",
           *         "data.format": "BYTES",
           *         "flush.size": "1000",
           *         "gcs.bucket.name": "APILogsBucket",
           *         "gcs.credentials.config": "****************",
           *         "kafka.api.key": "****************",
           *         "kafka.api.secret": "****************",
           *         "kafka.endpoint": "SASL_SSL://pkc-xxxxx.us-west-2.aws.confluent.cloud:9092",
           *         "kafka.region": "us-west-2",
           *         "name": "MyGcsLogsBucketConnector",
           *         "tasks.max": "1",
           *         "time.interval": "DAILY",
           *         "topics": "APILogsTopic"
           *       },
           *       "tasks": [
           *         {
           *           "connector": "MyGcsLogsBucketConnector",
           *           "task": 0
           *         }
           *       ],
           *       "type": "sink"
           *     } */
          "application/json": components["schemas"]["connect.v1.Connector"];
        };
      };
      401: components["responses"]["connect.v1.UnauthenticatedError"];
      404: components["responses"]["connect.v1.AccountNotFoundError"];
      429: components["responses"]["RateLimitError"];
      500: components["responses"]["connect.v1.DefaultSystemError"];
    };
  };
  deleteConnectv1Connector: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description The unique name of the connector. */
        connector_name: string;
        /** @description The unique identifier of the environment this resource belongs to. */
        environment_id: string;
        /** @description The unique identifier for the Kafka cluster. */
        kafka_cluster_id: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      200: components["responses"]["connect.v1.OK"];
      401: components["responses"]["connect.v1.UnauthenticatedError"];
      404: components["responses"]["connect.v1.ResourceNotFoundError"];
      429: components["responses"]["RateLimitError"];
      500: components["responses"]["connect.v1.DefaultSystemError"];
    };
  };
  pauseConnectv1Connector: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description The unique name of the connector. */
        connector_name: string;
        /** @description The unique identifier of the environment this resource belongs to. */
        environment_id: string;
        /** @description The unique identifier for the Kafka cluster. */
        kafka_cluster_id: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description Accepted */
      202: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
      401: components["responses"]["connect.v1.UnauthenticatedError"];
      404: components["responses"]["connect.v1.ResourceNotFoundError"];
      429: components["responses"]["RateLimitError"];
      500: components["responses"]["connect.v1.DefaultSystemError"];
    };
  };
  resumeConnectv1Connector: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description The unique name of the connector. */
        connector_name: string;
        /** @description The unique identifier of the environment this resource belongs to. */
        environment_id: string;
        /** @description The unique identifier for the Kafka cluster. */
        kafka_cluster_id: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description Accepted */
      202: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
      401: components["responses"]["connect.v1.UnauthenticatedError"];
      404: components["responses"]["connect.v1.ResourceNotFoundError"];
      429: components["responses"]["RateLimitError"];
      500: components["responses"]["connect.v1.DefaultSystemError"];
    };
  };
  restartConnectv1Connector: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description The unique name of the connector. */
        connector_name: string;
        /** @description The unique identifier of the environment this resource belongs to. */
        environment_id: string;
        /** @description The unique identifier for the Kafka cluster. */
        kafka_cluster_id: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description Accepted */
      202: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
      401: components["responses"]["connect.v1.UnauthenticatedError"];
      403: components["responses"]["connect.v1.ForbiddenError"];
      404: components["responses"]["connect.v1.ResourceNotFoundError"];
      429: components["responses"]["RateLimitError"];
      500: components["responses"]["connect.v1.DefaultSystemError"];
    };
  };
  readConnectv1ConnectorStatus: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description The unique name of the connector. */
        connector_name: string;
        /** @description The unique identifier of the environment this resource belongs to. */
        environment_id: string;
        /** @description The unique identifier for the Kafka cluster. */
        kafka_cluster_id: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description Connector. */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          /** @example {
           *       "name": "MyGcsLogsBucketConnector",
           *       "connector": {
           *         "state": "PROVISIONING",
           *         "worker_id": "MyGcsLogsBucketConnector",
           *         "trace": ""
           *       },
           *       "tasks": [],
           *       "type": "source"
           *     } */
          "application/json": {
            /** @description The name of the connector. */
            name: string;
            /**
             * @description Type of connector, sink or source.
             * @enum {string}
             */
            type: "sink" | "source";
            /** @description The map containing connector status. */
            connector: {
              /**
               * @description The state of the connector.
               * @enum {string}
               */
              state:
                | "NONE"
                | "PROVISIONING"
                | "RUNNING"
                | "DEGRADED"
                | "FAILED"
                | "PAUSED"
                | "DELETED";
              /** @description The worker ID of the connector. */
              worker_id: string;
              /** @description The exception name in case of error. */
              trace?: string;
            };
            /** @description The map containing the task status. */
            tasks?: {
              /** @description The ID of task. */
              id: number;
              /** @description The state of the task. */
              state: string;
              /** @description The worker ID of the task. */
              worker_id: string;
              msg?: string;
            }[];
          };
        };
      };
      401: components["responses"]["connect.v1.UnauthenticatedError"];
      404: components["responses"]["connect.v1.AccountNotFoundError"];
      429: components["responses"]["RateLimitError"];
      500: components["responses"]["connect.v1.DefaultSystemError"];
    };
  };
  listConnectv1ConnectorTasks: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description The unique name of the connector. */
        connector_name: string;
        /** @description The unique identifier of the environment this resource belongs to. */
        environment_id: string;
        /** @description The unique identifier for the Kafka cluster. */
        kafka_cluster_id: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description Connector Task. */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          /** @example [
           *       {
           *         "id": {
           *           "connector": "MyGcsLogsBucketConnector",
           *           "task": 2
           *         },
           *         "config": {
           *           "cloud.environment": "prod",
           *           "cloud.provider": "aws",
           *           "connector.class": "GcsSink",
           *           "data.format": "BYTES",
           *           "flush.size": "1000",
           *           "gcs.bucket.name": "APILogsBucket",
           *           "gcs.credentials.config": "****************",
           *           "kafka.api.key": "****************",
           *           "kafka.api.secret": "****************",
           *           "kafka.endpoint": "SASL_SSL://pkc-xxxxx.us-west-2.aws.confluent.cloud:9092",
           *           "kafka.region": "us-west-2",
           *           "name": "MyGcsLogsBucketConnector",
           *           "tasks.max": "2",
           *           "time.interval": "DAILY",
           *           "topics": "APILogsTopic"
           *         }
           *       }
           *     ] */
          "application/json": components["schemas"]["connect.v1.Connectors"];
        };
      };
      401: components["responses"]["connect.v1.UnauthenticatedError"];
      404: components["responses"]["connect.v1.AccountNotFoundError"];
      429: components["responses"]["RateLimitError"];
      500: components["responses"]["connect.v1.DefaultSystemError"];
    };
  };
  listConnectv1ConnectorPlugins: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description The unique identifier of the environment this resource belongs to. */
        environment_id: string;
        /** @description The unique identifier for the Kafka cluster. */
        kafka_cluster_id: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description Connector Plugin. */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          /** @example [
           *       {
           *         "class": "BigQuerySink",
           *         "type": "sink"
           *       },
           *       {
           *         "class": "KinesisSource",
           *         "type": "source",
           *         "version": "0.1.0"
           *       },
           *       {
           *         "class": "PostgresSource",
           *         "type": "source",
           *         "version": "0.1.0"
           *       },
           *       {
           *         "class": "S3_SINK",
           *         "type": "sink"
           *       },
           *       {
           *         "class": "GcsSink",
           *         "type": "sink",
           *         "version": "0.2.0"
           *       }
           *     ] */
          "application/json": {
            /** @description The connector class name. E.g. BigQuerySink. */
            class: string;
            /**
             * @description Type of connector, sink or source.
             * @enum {string}
             */
            type: "sink" | "source";
            /** @description The version string for the connector available. */
            version?: string;
          }[];
        };
      };
      401: components["responses"]["connect.v1.UnauthenticatedError"];
      404: components["responses"]["connect.v1.ResourceNotFoundError"];
      429: components["responses"]["RateLimitError"];
      500: components["responses"]["connect.v1.DefaultSystemError"];
    };
  };
  validateConnectv1ConnectorPlugin: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description The unique name of the connector plugin. */
        plugin_name: string;
        /** @description The unique identifier of the environment this resource belongs to. */
        environment_id: string;
        /** @description The unique identifier for the Kafka cluster. */
        kafka_cluster_id: string;
      };
      cookie?: never;
    };
    /** @description Configuration parameters for the connector. All values should be strings. */
    requestBody?: {
      content: {
        /** @example {
         *       "cloud.environment": "prod",
         *       "cloud.provider": "aws",
         *       "connector.class": "GcsSink",
         *       "data.format": "BYTES",
         *       "flush.size": "500",
         *       "gcs.bucket.name": "APILogsBucket",
         *       "gcs.credentials.config": "****************",
         *       "kafka.api.key": "****************",
         *       "kafka.api.secret": "****************",
         *       "kafka.endpoint": "SASL_SSL://pkc-xxxxx.us-west-2.aws.confluent.cloud:9092",
         *       "kafka.region": "us-west-2",
         *       "name": "MyGcsLogsBucketConnector",
         *       "tasks.max": "2",
         *       "time.interval": "DAILY",
         *       "topics": "APILogsTopic"
         *     } */
        "application/json": {
          [key: string]: string;
        };
      };
    };
    responses: {
      /** @description Connector Plugin. */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          /** @example {
           *       "name": "io.confluent.connect.gcs.GcsSinkConnector",
           *       "groups": [
           *         "Organize my data by...",
           *         "Which topics do you want to get data from?",
           *         "Messages",
           *         "How should we connect to your data?",
           *         "Google Cloud Storage details",
           *         "Kafka Cluster credentials",
           *         "Number of tasks for this connector"
           *       ],
           *       "error_count": 1,
           *       "configs": [
           *         {
           *           "definition": {
           *             "name": "name",
           *             "type": "STRING",
           *             "required": true,
           *             "default_value": "",
           *             "importance": "HIGH",
           *             "documentation": "Sets a name for your connector.",
           *             "group": "How should we connect to your data?",
           *             "width": "NONE",
           *             "display_name": "Connector name",
           *             "dependents": [],
           *             "order": 2,
           *             "alias": ""
           *           },
           *           "value": {
           *             "name": "name",
           *             "value": "{{.logicalClusterId}}",
           *             "recommended_values": [],
           *             "errors": [],
           *             "visible": true
           *           },
           *           "metadata": {}
           *         },
           *         {
           *           "definition": {
           *             "name": "connector.class",
           *             "type": "STRING",
           *             "required": true,
           *             "default_value": "",
           *             "importance": "HIGH",
           *             "documentation": "",
           *             "group": "How should we connect to your data?",
           *             "width": "NONE",
           *             "display_name": "Connector class",
           *             "dependents": [],
           *             "order": 1,
           *             "alias": ""
           *           },
           *           "value": {
           *             "name": "connector.class",
           *             "value": "io.confluent.connect.gcs.GcsSinkConnector",
           *             "recommended_values": [],
           *             "errors": [],
           *             "visible": true
           *           },
           *           "metadata": {}
           *         },
           *         {
           *           "definition": {
           *             "name": "kafka.api.key",
           *             "type": "PASSWORD",
           *             "required": true,
           *             "default_value": "",
           *             "importance": "HIGH",
           *             "documentation": "",
           *             "group": "Kafka Cluster credentials",
           *             "width": "NONE",
           *             "display_name": "Kafka API Key",
           *             "dependents": [],
           *             "order": 1,
           *             "alias": ""
           *           },
           *           "value": {
           *             "name": "kafka.api.key",
           *             "value": "",
           *             "recommended_values": [],
           *             "errors": [],
           *             "visible": true
           *           },
           *           "metadata": {}
           *         },
           *         {
           *           "definition": {
           *             "name": "kafka.api.secret",
           *             "type": "PASSWORD",
           *             "required": true,
           *             "default_value": "",
           *             "importance": "HIGH",
           *             "documentation": "",
           *             "group": "Kafka Cluster credentials",
           *             "width": "NONE",
           *             "display_name": "Kafka API Secret",
           *             "dependents": [
           *               "kafka.api.key"
           *             ],
           *             "order": 2,
           *             "alias": ""
           *           },
           *           "value": {
           *             "name": "kafka.api.secret",
           *             "value": "",
           *             "recommended_values": [],
           *             "errors": [],
           *             "visible": true
           *           },
           *           "metadata": {}
           *         },
           *         {
           *           "definition": {
           *             "name": "topics",
           *             "type": "LIST",
           *             "required": true,
           *             "default_value": "",
           *             "importance": "HIGH",
           *             "documentation": "Identifies the topic name or a comma-separated list of topic names.",
           *             "group": "Which topics do you want to get data from?",
           *             "width": "NONE",
           *             "display_name": "Topic names",
           *             "dependents": [],
           *             "order": 1,
           *             "alias": ""
           *           },
           *           "value": {
           *             "name": "topics",
           *             "value": "test1",
           *             "recommended_values": [],
           *             "errors": [],
           *             "visible": true
           *           },
           *           "metadata": {}
           *         },
           *         {
           *           "definition": {
           *             "name": "data.format",
           *             "type": "STRING",
           *             "required": true,
           *             "default_value": "",
           *             "importance": "HIGH",
           *             "documentation": "Sets the input/output message format. Valid entries are AVRO, JSON, or BYTES",
           *             "group": "Messages",
           *             "width": "NONE",
           *             "display_name": "Message format",
           *             "dependents": [],
           *             "order": 1,
           *             "alias": ""
           *           },
           *           "value": {
           *             "name": "data.format",
           *             "value": "BYTES",
           *             "recommended_values": [
           *               "BYTES",
           *               "JSON",
           *               "AVRO"
           *             ],
           *             "errors": [],
           *             "visible": true
           *           },
           *           "metadata": {}
           *         },
           *         {
           *           "definition": {
           *             "name": "gcs.credentials.config",
           *             "type": "PASSWORD",
           *             "required": true,
           *             "default_value": "",
           *             "importance": "HIGH",
           *             "documentation": "Contents of the downloaded GCP service account JSON file.",
           *             "group": "Google Cloud Storage details",
           *             "width": "NONE",
           *             "display_name": "Google Cloud Storage credentials.",
           *             "dependents": [],
           *             "order": 1,
           *             "alias": ""
           *           },
           *           "value": {
           *             "name": "gcs.credentials.config",
           *             "value": "",
           *             "recommended_values": [],
           *             "errors": [],
           *             "visible": true
           *           },
           *           "metadata": {}
           *         },
           *         {
           *           "definition": {
           *             "name": "gcs.bucket.name",
           *             "type": "STRING",
           *             "required": true,
           *             "default_value": "",
           *             "importance": "HIGH",
           *             "documentation": "A Google Cloud Storage bucket must be in the same region as your Confluent Cloud cluster.",
           *             "group": "Google Cloud Storage details",
           *             "width": "NONE",
           *             "display_name": "Bucket name.",
           *             "dependents": [],
           *             "order": 2,
           *             "alias": ""
           *           },
           *           "value": {
           *             "name": "gcs.bucket.name",
           *             "value": "gmagare",
           *             "recommended_values": [],
           *             "errors": [],
           *             "visible": true
           *           },
           *           "metadata": {}
           *         },
           *         {
           *           "definition": {
           *             "name": "time.interval",
           *             "type": "STRING",
           *             "required": true,
           *             "default_value": "",
           *             "importance": "HIGH",
           *             "documentation": "Sets how your messages grouped in storage. Valid entries are DAILY or HOURLY.",
           *             "group": "Organize my data by...",
           *             "width": "NONE",
           *             "display_name": "Time interval",
           *             "dependents": [],
           *             "order": 1,
           *             "alias": ""
           *           },
           *           "value": {
           *             "name": "time.interval",
           *             "value": "DAILY",
           *             "recommended_values": [
           *               "DAILY",
           *               "HOURLY"
           *             ],
           *             "errors": [],
           *             "visible": true
           *           },
           *           "metadata": {}
           *         },
           *         {
           *           "definition": {
           *             "name": "tasks.max",
           *             "type": "INT",
           *             "required": true,
           *             "default_value": "",
           *             "importance": "HIGH",
           *             "documentation": "",
           *             "group": "Number of tasks for this connector",
           *             "width": "NONE",
           *             "display_name": "Tasks",
           *             "dependents": [],
           *             "order": 1,
           *             "alias": ""
           *           },
           *           "value": {
           *             "name": "tasks.max",
           *             "value": "1",
           *             "recommended_values": [],
           *             "errors": [],
           *             "visible": true
           *           },
           *           "metadata": {}
           *         },
           *         {
           *           "definition": {
           *             "name": "flush.size",
           *             "type": "INT",
           *             "required": true,
           *             "default_value": "1000",
           *             "importance": "HIGH",
           *             "documentation": "This value defaults to 1000. For example, if you use the default setting of 1000 and your topic has six partitions, files start to be created in the storage bucket after more than 1000 records exist in each partition. Note that the default value of 1000 can be increased if needed.",
           *             "group": "Organize my data by...",
           *             "width": "NONE",
           *             "display_name": "Flush size",
           *             "dependents": [],
           *             "order": 2,
           *             "alias": ""
           *           },
           *           "value": {
           *             "name": "flush.size",
           *             "value": "1",
           *             "recommended_values": [],
           *             "errors": [
           *               "\"flush.size\" should be greater than or equal to 1000"
           *             ],
           *             "visible": true
           *           },
           *           "metadata": {}
           *         }
           *       ]
           *     } */
          "application/json": {
            /** @description The class name of the connector plugin. */
            name?: string;
            /** @description The list of groups used in configuration definitions. */
            groups?: string[];
            /** @description The total number of errors encountered during configuration validation. */
            error_count?: number;
            configs?: {
              /** @description The definition for a config in the connector plugin, which includes the name, type, importance, etc. */
              definition?: {
                /** @description The name of the configuration */
                name?: string;
                /**
                 * @description The config types
                 * @enum {string}
                 */
                type?:
                  | "NONE"
                  | "BOOLEAN"
                  | "INT"
                  | "SHORT"
                  | "LONG"
                  | "DOUBLE"
                  | "STRING"
                  | "LIST"
                  | "ENUM"
                  | "PASSWORD";
                /** @description Whether this configuration is required */
                required?: boolean;
                /** @description Default value for this configuration */
                default_value?: string;
                /**
                 * @description The importance level for a configuration
                 * @enum {string}
                 */
                importance?: "NONE" | "HIGH" | "MEDIUM" | "LOW";
                /** @description The documentation for the configuration */
                documentation?: string;
                /** @description The UI group to which the configuration belongs to */
                group?: string;
                /**
                 * @description The width of a configuration value
                 * @enum {string}
                 */
                width?: "NONE" | "SHORT" | "MEDIUM" | "LONG";
                display_name?: string;
                /** @description Other configurations on which this configuration is dependent */
                dependents?: string[];
                /** @description The order of configuration in specified group */
                order?: number;
                alias?: string;
              };
              /** @description The current value for a config, which includes the name, value, recommended values, etc. */
              value?: {
                /** @description The name of the configuration */
                name?: string;
                /** @description The value for the configuration */
                value?: string;
                /** @description The list of valid values for the configuration */
                recommended_values?: string[];
                /** @description Errors, if any, in the configuration value */
                errors?: string[];
                /** @description The visibility of the configuration. Based on the values of other configuration
                 *     fields, this visibility boolean value points out if the current field should be
                 *     visible or not. */
                visible?: boolean;
              };
              /** @description Map of metadata details about the connector configuration, such as type of
               *     input, etc. */
              metadata?: Record<string, unknown>;
            }[];
          };
        };
      };
      401: components["responses"]["connect.v1.UnauthenticatedError"];
      404: components["responses"]["connect.v1.ResourceNotFoundError"];
      429: components["responses"]["RateLimitError"];
      500: components["responses"]["connect.v1.DefaultSystemError"];
    };
  };
  getConnectv1ConnectorOffsets: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description The unique name of the connector. */
        connector_name: string;
        /** @description The unique identifier of the environment this resource belongs to. */
        environment_id: string;
        /** @description The unique identifier for the Kafka cluster. */
        kafka_cluster_id: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description Connector Offsets. */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "application/json": components["schemas"]["connect.v1.ConnectorOffsets"];
        };
      };
      400: components["responses"]["connect.v1.BadRequestError"];
      401: components["responses"]["connect.v1.UnauthenticatedError"];
      403: components["responses"]["connect.v1.ForbiddenError"];
      404: components["responses"]["connect.v1.ResourceNotFoundError"];
      429: components["responses"]["RateLimitError"];
      500: components["responses"]["connect.v1.DefaultSystemError"];
    };
  };
  alterConnectv1ConnectorOffsetsRequest: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description The unique name of the connector. */
        connector_name: string;
        /** @description The unique identifier of the environment this resource belongs to. */
        environment_id: string;
        /** @description The unique identifier for the Kafka cluster. */
        kafka_cluster_id: string;
      };
      cookie?: never;
    };
    requestBody?: {
      content: {
        "application/json": components["schemas"]["connect.v1.AlterOffsetRequest"];
      };
    };
    responses: {
      /** @description Accepted */
      202: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "application/json": components["schemas"]["connect.v1.AlterOffsetRequestInfo"];
        };
      };
      400: components["responses"]["connect.v1.BadRequestError"];
      401: components["responses"]["connect.v1.UnauthenticatedError"];
      403: components["responses"]["connect.v1.ForbiddenError"];
      404: components["responses"]["connect.v1.ResourceNotFoundError"];
      429: components["responses"]["RateLimitError"];
      500: components["responses"]["connect.v1.DefaultSystemError"];
    };
  };
  getConnectv1ConnectorOffsetsRequestStatus: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description The unique name of the connector. */
        connector_name: string;
        /** @description The unique identifier of the environment this resource belongs to. */
        environment_id: string;
        /** @description The unique identifier for the Kafka cluster. */
        kafka_cluster_id: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description Connector Offsets Request Status. */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "application/json": components["schemas"]["connect.v1.AlterOffsetStatus"];
        };
      };
      400: components["responses"]["connect.v1.BadRequestError"];
      401: components["responses"]["connect.v1.UnauthenticatedError"];
      403: components["responses"]["connect.v1.ForbiddenError"];
      404: components["responses"]["connect.v1.ResourceNotFoundError"];
      429: components["responses"]["RateLimitError"];
      500: components["responses"]["connect.v1.DefaultSystemError"];
    };
  };
  listConnectV1CustomConnectorPlugins: {
    parameters: {
      query?: {
        /**
         * @description Filter the results by exact match for cloud.
         * @example AWS
         */
        cloud?: components["schemas"]["SearchFilter"];
        /** @description A pagination size for collection requests. */
        page_size?: number;
        /** @description An opaque pagination token for collection requests. */
        page_token?: string;
      };
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description Custom Connector Plugin. */
      200: {
        headers: {
          /** @description The unique identifier for the API request. */
          "X-Request-Id"?: string;
          /** @description The maximum number of requests you're permitted to make per time period. */
          "X-RateLimit-Limit"?: number;
          /** @description The number of requests remaining in the current rate limit window. */
          "X-RateLimit-Remaining"?: number;
          /** @description The relative time in seconds until the current rate-limit window resets.
           *
           *     **Important:** This differs from Github and Twitter's same-named header which uses UTC epoch seconds. We use relative time to avoid client/server time synchronization issues. */
          "X-RateLimit-Reset"?: number;
          [name: string]: unknown;
        };
        content: {
          "application/json": components["schemas"]["connect.v1.CustomConnectorPluginList"];
        };
      };
      400: components["responses"]["BadRequestError"];
      401: components["responses"]["UnauthenticatedError"];
      403: components["responses"]["UnauthorizedError"];
      429: components["responses"]["RateLimitError"];
      500: components["responses"]["DefaultSystemError"];
    };
  };
  createConnectV1CustomConnectorPlugin: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody?: {
      content: {
        "application/json": components["schemas"]["connect.v1.CustomConnectorPlugin"] &
          Record<string, unknown>;
      };
    };
    responses: {
      /** @description A Custom Connector Plugin was created. */
      201: {
        headers: {
          /** @description The unique identifier for the API request. */
          "X-Request-Id"?: string;
          /** @description The maximum number of requests you're permitted to make per time period. */
          "X-RateLimit-Limit"?: number;
          /** @description The number of requests remaining in the current rate limit window. */
          "X-RateLimit-Remaining"?: number;
          /** @description The relative time in seconds until the current rate-limit window resets.
           *
           *     **Important:** This differs from Github and Twitter's same-named header which uses UTC epoch seconds. We use relative time to avoid client/server time synchronization issues. */
          "X-RateLimit-Reset"?: number;
          /** @description CustomConnectorPlugin resource uri */
          Location?: string;
          [name: string]: unknown;
        };
        content: {
          "application/json": components["schemas"]["connect.v1.CustomConnectorPlugin"] &
            Record<string, unknown>;
        };
      };
      400: components["responses"]["BadRequestError"];
      401: components["responses"]["UnauthenticatedError"];
      403: components["responses"]["UnauthorizedError"];
      409: components["responses"]["ConflictError"];
      422: components["responses"]["ValidationError"];
      429: components["responses"]["RateLimitError"];
      500: components["responses"]["DefaultSystemError"];
    };
  };
  getConnectV1CustomConnectorPlugin: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description The unique identifier for the custom connector plugin. */
        id: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description Custom Connector Plugin. */
      200: {
        headers: {
          /** @description The unique identifier for the API request. */
          "X-Request-Id"?: string;
          /** @description The maximum number of requests you're permitted to make per time period. */
          "X-RateLimit-Limit"?: number;
          /** @description The number of requests remaining in the current rate limit window. */
          "X-RateLimit-Remaining"?: number;
          /** @description The relative time in seconds until the current rate-limit window resets.
           *
           *     **Important:** This differs from Github and Twitter's same-named header which uses UTC epoch seconds. We use relative time to avoid client/server time synchronization issues. */
          "X-RateLimit-Reset"?: number;
          [name: string]: unknown;
        };
        content: {
          "application/json": components["schemas"]["connect.v1.CustomConnectorPlugin"] &
            Record<string, unknown>;
        };
      };
      400: components["responses"]["BadRequestError"];
      401: components["responses"]["UnauthenticatedError"];
      403: components["responses"]["UnauthorizedError"];
      404: components["responses"]["NotFoundError"];
      429: components["responses"]["RateLimitError"];
      500: components["responses"]["DefaultSystemError"];
    };
  };
  deleteConnectV1CustomConnectorPlugin: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description The unique identifier for the custom connector plugin. */
        id: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description A Custom Connector Plugin is being deleted. */
      204: {
        headers: {
          /** @description The unique identifier for the API request. */
          "X-Request-Id"?: string;
          /** @description The maximum number of requests you're permitted to make per time period. */
          "X-RateLimit-Limit"?: number;
          /** @description The number of requests remaining in the current rate limit window. */
          "X-RateLimit-Remaining"?: number;
          /** @description The relative time in seconds until the current rate-limit window resets.
           *
           *     **Important:** This differs from Github and Twitter's same-named header which uses UTC epoch seconds. We use relative time to avoid client/server time synchronization issues. */
          "X-RateLimit-Reset"?: number;
          [name: string]: unknown;
        };
        content?: never;
      };
      400: components["responses"]["BadRequestError"];
      401: components["responses"]["UnauthenticatedError"];
      403: components["responses"]["UnauthorizedError"];
      404: components["responses"]["NotFoundError"];
      429: components["responses"]["RateLimitError"];
      500: components["responses"]["DefaultSystemError"];
    };
  };
  updateConnectV1CustomConnectorPlugin: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description The unique identifier for the custom connector plugin. */
        id: string;
      };
      cookie?: never;
    };
    requestBody?: {
      content: {
        "application/json": components["schemas"]["connect.v1.CustomConnectorPluginUpdate"];
      };
    };
    responses: {
      /** @description Custom Connector Plugin. */
      200: {
        headers: {
          /** @description The unique identifier for the API request. */
          "X-Request-Id"?: string;
          /** @description The maximum number of requests you're permitted to make per time period. */
          "X-RateLimit-Limit"?: number;
          /** @description The number of requests remaining in the current rate limit window. */
          "X-RateLimit-Remaining"?: number;
          /** @description The relative time in seconds until the current rate-limit window resets.
           *
           *     **Important:** This differs from Github and Twitter's same-named header which uses UTC epoch seconds. We use relative time to avoid client/server time synchronization issues. */
          "X-RateLimit-Reset"?: number;
          [name: string]: unknown;
        };
        content: {
          "application/json": components["schemas"]["connect.v1.CustomConnectorPlugin"] &
            Record<string, unknown>;
        };
      };
      400: components["responses"]["BadRequestError"];
      401: components["responses"]["UnauthenticatedError"];
      403: components["responses"]["UnauthorizedError"];
      404: components["responses"]["NotFoundError"];
      409: components["responses"]["ConflictError"];
      422: components["responses"]["ValidationError"];
      429: components["responses"]["RateLimitError"];
      500: components["responses"]["DefaultSystemError"];
    };
  };
  "presigned-upload-urlConnectV1PresignedUrl": {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody?: {
      content: {
        "application/json": components["schemas"]["connect.v1.PresignedUrlRequest"] &
          Record<string, unknown>;
      };
    };
    responses: {
      /** @description Presigned Url. */
      200: {
        headers: {
          /** @description The unique identifier for the API request. */
          "X-Request-Id"?: string;
          /** @description The maximum number of requests you're permitted to make per time period. */
          "X-RateLimit-Limit"?: number;
          /** @description The number of requests remaining in the current rate limit window. */
          "X-RateLimit-Remaining"?: number;
          /** @description The relative time in seconds until the current rate-limit window resets.
           *
           *     **Important:** This differs from Github and Twitter's same-named header which uses UTC epoch seconds. We use relative time to avoid client/server time synchronization issues. */
          "X-RateLimit-Reset"?: number;
          [name: string]: unknown;
        };
        content: {
          "application/json": components["schemas"]["connect.v1.PresignedUrl"] &
            Record<string, unknown>;
        };
      };
      400: components["responses"]["BadRequestError"];
      401: components["responses"]["UnauthenticatedError"];
      403: components["responses"]["UnauthorizedError"];
      404: components["responses"]["NotFoundError"];
      429: components["responses"]["RateLimitError"];
      500: components["responses"]["DefaultSystemError"];
    };
  };
  getKafkaCluster: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /**
         * @description The Kafka cluster ID.
         * @example cluster-1
         */
        cluster_id: components["parameters"]["ClusterId"];
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      200: components["responses"]["GetClusterResponse"];
      400: components["responses"]["BadRequestErrorResponse"];
      401: components["responses"]["UnauthorizedErrorResponse"];
      403: components["responses"]["ForbiddenErrorResponse"];
      429: components["responses"]["TooManyRequestsErrorResponse"];
      "5XX": components["responses"]["ServerErrorResponse"];
    };
  };
  batchCreateKafkaAcls: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /**
         * @description The Kafka cluster ID.
         * @example cluster-1
         */
        cluster_id: components["parameters"]["ClusterId"];
      };
      cookie?: never;
    };
    requestBody?: components["requestBodies"]["BatchCreateAclRequest"];
    responses: {
      /** @description Created */
      201: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
      400: components["responses"]["BadRequestErrorResponse_CreateAcls"];
      401: components["responses"]["UnauthorizedErrorResponse"];
      403: components["responses"]["ForbiddenErrorResponse"];
      429: components["responses"]["TooManyRequestsErrorResponse"];
      "5XX": components["responses"]["ServerErrorResponse"];
    };
  };
  getKafkaAcls: {
    parameters: {
      query?: {
        /** @description The ACL resource type. */
        resource_type?: components["parameters"]["AclResourceType"];
        /** @description The ACL resource name. */
        resource_name?: components["parameters"]["AclResourceName"];
        /** @description The ACL pattern type. */
        pattern_type?: components["parameters"]["AclPatternType"];
        /** @description The ACL principal. This is the Service Account name or user name. */
        principal?: components["parameters"]["AclPrincipal"];
        /** @description The ACL host. */
        host?: components["parameters"]["AclHost"];
        /** @description The ACL operation. */
        operation?: components["parameters"]["AclOperation"];
        /** @description The ACL permission. */
        permission?: components["parameters"]["AclPermission"];
      };
      header?: never;
      path: {
        /**
         * @description The Kafka cluster ID.
         * @example cluster-1
         */
        cluster_id: components["parameters"]["ClusterId"];
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      200: components["responses"]["SearchAclsResponse"];
      400: components["responses"]["BadRequestErrorResponse"];
      401: components["responses"]["UnauthorizedErrorResponse"];
      403: components["responses"]["ForbiddenErrorResponse"];
      429: components["responses"]["TooManyRequestsErrorResponse"];
      "5XX": components["responses"]["ServerErrorResponse"];
    };
  };
  createKafkaAcls: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /**
         * @description The Kafka cluster ID.
         * @example cluster-1
         */
        cluster_id: components["parameters"]["ClusterId"];
      };
      cookie?: never;
    };
    requestBody?: components["requestBodies"]["CreateAclRequest"];
    responses: {
      /** @description Created */
      201: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
      400: components["responses"]["BadRequestErrorResponse_CreateAcls"];
      401: components["responses"]["UnauthorizedErrorResponse"];
      403: components["responses"]["ForbiddenErrorResponse"];
      429: components["responses"]["TooManyRequestsErrorResponse"];
      "5XX": components["responses"]["ServerErrorResponse"];
    };
  };
  deleteKafkaAcls: {
    parameters: {
      query: {
        /** @description The ACL resource type. */
        resource_type: components["parameters"]["AclResourceTypeRequired"];
        /** @description The ACL resource name. */
        resource_name?: components["parameters"]["AclResourceName"];
        /** @description The ACL pattern type. */
        pattern_type: components["parameters"]["AclPatternTypeRequired"];
        /** @description The ACL principal. This is the Service Account name or user name. */
        principal?: components["parameters"]["AclPrincipal"];
        /** @description The ACL host. */
        host?: components["parameters"]["AclHost"];
        /** @description The ACL operation. */
        operation: components["parameters"]["AclOperationRequired"];
        /** @description The ACL permission. */
        permission: components["parameters"]["AclPermissionRequired"];
      };
      header?: never;
      path: {
        /**
         * @description The Kafka cluster ID.
         * @example cluster-1
         */
        cluster_id: components["parameters"]["ClusterId"];
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      200: components["responses"]["DeleteAclsResponse"];
      400: components["responses"]["BadRequestErrorResponse_DeleteAcls"];
      401: components["responses"]["UnauthorizedErrorResponse"];
      403: components["responses"]["ForbiddenErrorResponse"];
      429: components["responses"]["TooManyRequestsErrorResponse"];
      "5XX": components["responses"]["ServerErrorResponse"];
    };
  };
  listKafkaClusterConfigs: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /**
         * @description The Kafka cluster ID.
         * @example cluster-1
         */
        cluster_id: components["parameters"]["ClusterId"];
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      200: components["responses"]["ListClusterConfigsResponse"];
      400: components["responses"]["BadRequestErrorResponse"];
      401: components["responses"]["UnauthorizedErrorResponse"];
      403: components["responses"]["ForbiddenErrorResponse"];
      429: components["responses"]["TooManyRequestsErrorResponse"];
      "5XX": components["responses"]["ServerErrorResponse"];
    };
  };
  updateKafkaClusterConfigs: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /**
         * @description The Kafka cluster ID.
         * @example cluster-1
         */
        cluster_id: components["parameters"]["ClusterId"];
      };
      cookie?: never;
    };
    requestBody?: components["requestBodies"]["AlterClusterConfigBatchRequest"];
    responses: {
      /** @description No Content */
      204: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
      400: components["responses"]["BadRequestErrorResponse"];
      401: components["responses"]["UnauthorizedErrorResponse"];
      403: components["responses"]["ForbiddenErrorResponse"];
      429: components["responses"]["TooManyRequestsErrorResponse"];
      "5XX": components["responses"]["ServerErrorResponse"];
    };
  };
  getKafkaClusterConfig: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /**
         * @description The Kafka cluster ID.
         * @example cluster-1
         */
        cluster_id: components["parameters"]["ClusterId"];
        /**
         * @description The configuration parameter name.
         * @example compression.type
         */
        name: components["parameters"]["ConfigName"];
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      200: components["responses"]["GetClusterConfigResponse"];
      400: components["responses"]["BadRequestErrorResponse"];
      401: components["responses"]["UnauthorizedErrorResponse"];
      403: components["responses"]["ForbiddenErrorResponse"];
      429: components["responses"]["TooManyRequestsErrorResponse"];
      "5XX": components["responses"]["ServerErrorResponse"];
    };
  };
  updateKafkaClusterConfig: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /**
         * @description The Kafka cluster ID.
         * @example cluster-1
         */
        cluster_id: components["parameters"]["ClusterId"];
        /**
         * @description The configuration parameter name.
         * @example compression.type
         */
        name: components["parameters"]["ConfigName"];
      };
      cookie?: never;
    };
    requestBody?: components["requestBodies"]["UpdateClusterConfigRequest"];
    responses: {
      /** @description No Content */
      204: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
      400: components["responses"]["BadRequestErrorResponse"];
      401: components["responses"]["UnauthorizedErrorResponse"];
      403: components["responses"]["ForbiddenErrorResponse"];
      429: components["responses"]["TooManyRequestsErrorResponse"];
      "5XX": components["responses"]["ServerErrorResponse"];
    };
  };
  deleteKafkaClusterConfig: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /**
         * @description The Kafka cluster ID.
         * @example cluster-1
         */
        cluster_id: components["parameters"]["ClusterId"];
        /**
         * @description The configuration parameter name.
         * @example compression.type
         */
        name: components["parameters"]["ConfigName"];
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description No Content */
      204: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
      400: components["responses"]["BadRequestErrorResponse"];
      401: components["responses"]["UnauthorizedErrorResponse"];
      403: components["responses"]["ForbiddenErrorResponse"];
      429: components["responses"]["TooManyRequestsErrorResponse"];
      "5XX": components["responses"]["ServerErrorResponse"];
    };
  };
  listKafkaConsumerGroups: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /**
         * @description The Kafka cluster ID.
         * @example cluster-1
         */
        cluster_id: components["parameters"]["ClusterId"];
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      200: components["responses"]["ListConsumerGroupsResponse"];
      400: components["responses"]["BadRequestErrorResponse"];
      401: components["responses"]["UnauthorizedErrorResponse"];
      403: components["responses"]["ForbiddenErrorResponse"];
      429: components["responses"]["TooManyRequestsErrorResponse"];
      "5XX": components["responses"]["ServerErrorResponse"];
    };
  };
  getKafkaConsumerGroup: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /**
         * @description The Kafka cluster ID.
         * @example cluster-1
         */
        cluster_id: components["parameters"]["ClusterId"];
        /**
         * @description The consumer group ID.
         * @example consumer-group-1
         */
        consumer_group_id: components["parameters"]["ConsumerGroupId"];
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      200: components["responses"]["GetConsumerGroupResponse"];
      400: components["responses"]["BadRequestErrorResponse"];
      401: components["responses"]["UnauthorizedErrorResponse"];
      403: components["responses"]["ForbiddenErrorResponse"];
      429: components["responses"]["TooManyRequestsErrorResponse"];
      "5XX": components["responses"]["ServerErrorResponse"];
    };
  };
  listKafkaConsumers: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /**
         * @description The Kafka cluster ID.
         * @example cluster-1
         */
        cluster_id: components["parameters"]["ClusterId"];
        /**
         * @description The consumer group ID.
         * @example consumer-group-1
         */
        consumer_group_id: components["parameters"]["ConsumerGroupId"];
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      200: components["responses"]["ListConsumersResponse"];
      400: components["responses"]["BadRequestErrorResponse"];
      401: components["responses"]["UnauthorizedErrorResponse"];
      403: components["responses"]["ForbiddenErrorResponse"];
      429: components["responses"]["TooManyRequestsErrorResponse"];
      "5XX": components["responses"]["ServerErrorResponse"];
    };
  };
  getKafkaConsumerGroupLagSummary: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /**
         * @description The Kafka cluster ID.
         * @example cluster-1
         */
        cluster_id: components["parameters"]["ClusterId"];
        /**
         * @description The consumer group ID.
         * @example consumer-group-1
         */
        consumer_group_id: components["parameters"]["ConsumerGroupId"];
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      200: components["responses"]["GetConsumerGroupLagSummaryResponse"];
      400: components["responses"]["BadRequestErrorResponse"];
      401: components["responses"]["UnauthorizedErrorResponse"];
      403: components["responses"]["ForbiddenErrorResponse"];
      429: components["responses"]["TooManyRequestsErrorResponse"];
      "5XX": components["responses"]["ServerErrorResponse"];
    };
  };
  listKafkaConsumerLags: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /**
         * @description The Kafka cluster ID.
         * @example cluster-1
         */
        cluster_id: components["parameters"]["ClusterId"];
        /**
         * @description The consumer group ID.
         * @example consumer-group-1
         */
        consumer_group_id: components["parameters"]["ConsumerGroupId"];
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      200: components["responses"]["ListConsumerLagsResponse"];
      400: components["responses"]["BadRequestErrorResponse"];
      401: components["responses"]["UnauthorizedErrorResponse"];
      403: components["responses"]["ForbiddenErrorResponse"];
      429: components["responses"]["TooManyRequestsErrorResponse"];
      "5XX": components["responses"]["ServerErrorResponse"];
    };
  };
  getKafkaConsumerLag: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /**
         * @description The Kafka cluster ID.
         * @example cluster-1
         */
        cluster_id: components["parameters"]["ClusterId"];
        /**
         * @description The consumer group ID.
         * @example consumer-group-1
         */
        consumer_group_id: components["parameters"]["ConsumerGroupId"];
        /**
         * @description The topic name.
         * @example topic-1
         */
        topic_name: components["parameters"]["TopicName"];
        /**
         * @description The partition ID.
         * @example 0
         */
        partition_id: components["parameters"]["PartitionId"];
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      200: components["responses"]["GetConsumerLagResponse"];
      400: components["responses"]["BadRequestErrorResponse"];
      401: components["responses"]["UnauthorizedErrorResponse"];
      403: components["responses"]["ForbiddenErrorResponse"];
      429: components["responses"]["TooManyRequestsErrorResponse"];
      "5XX": components["responses"]["ServerErrorResponse"];
    };
  };
  getKafkaConsumer: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /**
         * @description The Kafka cluster ID.
         * @example cluster-1
         */
        cluster_id: components["parameters"]["ClusterId"];
        /**
         * @description The consumer group ID.
         * @example consumer-group-1
         */
        consumer_group_id: components["parameters"]["ConsumerGroupId"];
        /**
         * @description The consumer ID.
         * @example consumer-1
         */
        consumer_id: components["parameters"]["ConsumerId"];
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      200: components["responses"]["GetConsumerResponse"];
      400: components["responses"]["BadRequestErrorResponse"];
      401: components["responses"]["UnauthorizedErrorResponse"];
      403: components["responses"]["ForbiddenErrorResponse"];
      429: components["responses"]["TooManyRequestsErrorResponse"];
      "5XX": components["responses"]["ServerErrorResponse"];
    };
  };
  listKafkaTopics: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /**
         * @description The Kafka cluster ID.
         * @example cluster-1
         */
        cluster_id: components["parameters"]["ClusterId"];
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      200: components["responses"]["ListTopicsResponse"];
      400: components["responses"]["BadRequestErrorResponse"];
      401: components["responses"]["UnauthorizedErrorResponse"];
      403: components["responses"]["ForbiddenErrorResponse"];
      429: components["responses"]["TooManyRequestsErrorResponse"];
      "5XX": components["responses"]["ServerErrorResponse"];
    };
  };
  createKafkaTopic: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /**
         * @description The Kafka cluster ID.
         * @example cluster-1
         */
        cluster_id: components["parameters"]["ClusterId"];
      };
      cookie?: never;
    };
    requestBody?: components["requestBodies"]["CreateTopicRequest"];
    responses: {
      200: components["responses"]["CreateTopicResponse"];
      201: components["responses"]["CreateTopicResponse"];
      400: components["responses"]["BadRequestErrorResponse_CreateTopic"];
      401: components["responses"]["UnauthorizedErrorResponse"];
      403: components["responses"]["ForbiddenErrorResponse"];
      429: components["responses"]["TooManyRequestsErrorResponse"];
      "5XX": components["responses"]["ServerErrorResponse"];
    };
  };
  getKafkaTopic: {
    parameters: {
      query?: {
        /** @description Specify if authorized operations should be included in the response. */
        include_authorized_operations?: components["parameters"]["IncludeAuthorizedOperations"];
      };
      header?: never;
      path: {
        /**
         * @description The Kafka cluster ID.
         * @example cluster-1
         */
        cluster_id: components["parameters"]["ClusterId"];
        /**
         * @description The topic name.
         * @example topic-1
         */
        topic_name: components["parameters"]["TopicName"];
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      200: components["responses"]["GetTopicResponse"];
      400: components["responses"]["BadRequestErrorResponse"];
      401: components["responses"]["UnauthorizedErrorResponse"];
      403: components["responses"]["ForbiddenErrorResponse"];
      404: components["responses"]["NotFoundErrorResponse"];
      429: components["responses"]["TooManyRequestsErrorResponse"];
      "5XX": components["responses"]["ServerErrorResponse"];
    };
  };
  deleteKafkaTopic: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /**
         * @description The Kafka cluster ID.
         * @example cluster-1
         */
        cluster_id: components["parameters"]["ClusterId"];
        /**
         * @description The topic name.
         * @example topic-1
         */
        topic_name: components["parameters"]["TopicName"];
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description No Content */
      204: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
      400: components["responses"]["BadRequestErrorResponse"];
      401: components["responses"]["UnauthorizedErrorResponse"];
      403: components["responses"]["ForbiddenErrorResponse"];
      404: components["responses"]["NotFoundErrorResponse"];
      429: components["responses"]["TooManyRequestsErrorResponse"];
      "5XX": components["responses"]["ServerErrorResponse"];
    };
  };
  updatePartitionCountKafkaTopic: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /**
         * @description The Kafka cluster ID.
         * @example cluster-1
         */
        cluster_id: components["parameters"]["ClusterId"];
        /**
         * @description The topic name.
         * @example topic-1
         */
        topic_name: components["parameters"]["TopicName"];
      };
      cookie?: never;
    };
    requestBody?: {
      content: {
        "application/json": components["schemas"]["UpdatePartitionCountRequestData"];
      };
    };
    responses: {
      200: components["responses"]["GetTopicResponse"];
      400: components["responses"]["BadRequestErrorResponse_UpdatePartitionCountTopic"];
      401: components["responses"]["UnauthorizedErrorResponse"];
      403: components["responses"]["ForbiddenErrorResponse"];
      429: components["responses"]["TooManyRequestsErrorResponse"];
      "5XX": components["responses"]["ServerErrorResponse"];
    };
  };
  listKafkaTopicConfigs: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /**
         * @description The Kafka cluster ID.
         * @example cluster-1
         */
        cluster_id: components["parameters"]["ClusterId"];
        /**
         * @description The topic name.
         * @example topic-1
         */
        topic_name: components["parameters"]["TopicName"];
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      200: components["responses"]["ListTopicConfigsResponse"];
      400: components["responses"]["BadRequestErrorResponse"];
      401: components["responses"]["UnauthorizedErrorResponse"];
      403: components["responses"]["ForbiddenErrorResponse"];
      404: components["responses"]["NotFoundErrorResponse"];
      429: components["responses"]["TooManyRequestsErrorResponse"];
      "5XX": components["responses"]["ServerErrorResponse"];
    };
  };
  updateKafkaTopicConfigBatch: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /**
         * @description The Kafka cluster ID.
         * @example cluster-1
         */
        cluster_id: components["parameters"]["ClusterId"];
        /**
         * @description The topic name.
         * @example topic-1
         */
        topic_name: components["parameters"]["TopicName"];
      };
      cookie?: never;
    };
    requestBody?: components["requestBodies"]["AlterTopicConfigBatchRequest"];
    responses: {
      /** @description No Content */
      204: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
      400: components["responses"]["BadRequestErrorResponse"];
      401: components["responses"]["UnauthorizedErrorResponse"];
      403: components["responses"]["ForbiddenErrorResponse"];
      404: components["responses"]["NotFoundErrorResponse"];
      429: components["responses"]["TooManyRequestsErrorResponse"];
      "5XX": components["responses"]["ServerErrorResponse"];
    };
  };
  getKafkaTopicConfig: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /**
         * @description The Kafka cluster ID.
         * @example cluster-1
         */
        cluster_id: components["parameters"]["ClusterId"];
        /**
         * @description The topic name.
         * @example topic-1
         */
        topic_name: components["parameters"]["TopicName"];
        /**
         * @description The configuration parameter name.
         * @example compression.type
         */
        name: components["parameters"]["ConfigName"];
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      200: components["responses"]["GetTopicConfigResponse"];
      400: components["responses"]["BadRequestErrorResponse"];
      401: components["responses"]["UnauthorizedErrorResponse"];
      403: components["responses"]["ForbiddenErrorResponse"];
      404: components["responses"]["NotFoundErrorResponse"];
      429: components["responses"]["TooManyRequestsErrorResponse"];
      "5XX": components["responses"]["ServerErrorResponse"];
    };
  };
  updateKafkaTopicConfig: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /**
         * @description The Kafka cluster ID.
         * @example cluster-1
         */
        cluster_id: components["parameters"]["ClusterId"];
        /**
         * @description The topic name.
         * @example topic-1
         */
        topic_name: components["parameters"]["TopicName"];
        /**
         * @description The configuration parameter name.
         * @example compression.type
         */
        name: components["parameters"]["ConfigName"];
      };
      cookie?: never;
    };
    requestBody?: components["requestBodies"]["UpdateTopicConfigRequest"];
    responses: {
      /** @description No Content */
      204: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
      400: components["responses"]["BadRequestErrorResponse"];
      401: components["responses"]["UnauthorizedErrorResponse"];
      403: components["responses"]["ForbiddenErrorResponse"];
      404: components["responses"]["NotFoundErrorResponse"];
      429: components["responses"]["TooManyRequestsErrorResponse"];
      "5XX": components["responses"]["ServerErrorResponse"];
    };
  };
  deleteKafkaTopicConfig: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /**
         * @description The Kafka cluster ID.
         * @example cluster-1
         */
        cluster_id: components["parameters"]["ClusterId"];
        /**
         * @description The topic name.
         * @example topic-1
         */
        topic_name: components["parameters"]["TopicName"];
        /**
         * @description The configuration parameter name.
         * @example compression.type
         */
        name: components["parameters"]["ConfigName"];
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description No Content */
      204: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
      400: components["responses"]["BadRequestErrorResponse"];
      401: components["responses"]["UnauthorizedErrorResponse"];
      403: components["responses"]["ForbiddenErrorResponse"];
      404: components["responses"]["NotFoundErrorResponse"];
      429: components["responses"]["TooManyRequestsErrorResponse"];
      "5XX": components["responses"]["ServerErrorResponse"];
    };
  };
  listKafkaPartitions: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /**
         * @description The Kafka cluster ID.
         * @example cluster-1
         */
        cluster_id: components["parameters"]["ClusterId"];
        /**
         * @description The topic name.
         * @example topic-1
         */
        topic_name: components["parameters"]["TopicName"];
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      200: components["responses"]["ListPartitionsResponse"];
      400: components["responses"]["BadRequestErrorResponse"];
      401: components["responses"]["UnauthorizedErrorResponse"];
      403: components["responses"]["ForbiddenErrorResponse"];
      404: components["responses"]["NotFoundErrorResponse"];
      429: components["responses"]["TooManyRequestsErrorResponse"];
      "5XX": components["responses"]["ServerErrorResponse"];
    };
  };
  getKafkaPartition: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /**
         * @description The Kafka cluster ID.
         * @example cluster-1
         */
        cluster_id: components["parameters"]["ClusterId"];
        /**
         * @description The topic name.
         * @example topic-1
         */
        topic_name: components["parameters"]["TopicName"];
        /**
         * @description The partition ID.
         * @example 0
         */
        partition_id: components["parameters"]["PartitionId"];
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      200: components["responses"]["GetPartitionResponse"];
      400: components["responses"]["BadRequestErrorResponse"];
      401: components["responses"]["UnauthorizedErrorResponse"];
      403: components["responses"]["ForbiddenErrorResponse"];
      404: components["responses"]["NotFoundErrorResponse"];
      429: components["responses"]["TooManyRequestsErrorResponse"];
      "5XX": components["responses"]["ServerErrorResponse"];
    };
  };
  listKafkaAllTopicConfigs: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /**
         * @description The Kafka cluster ID.
         * @example cluster-1
         */
        cluster_id: components["parameters"]["ClusterId"];
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      200: components["responses"]["ListTopicConfigsResponse"];
      400: components["responses"]["BadRequestErrorResponse"];
      401: components["responses"]["UnauthorizedErrorResponse"];
      403: components["responses"]["ForbiddenErrorResponse"];
      429: components["responses"]["TooManyRequestsErrorResponse"];
      "5XX": components["responses"]["ServerErrorResponse"];
    };
  };
  produceRecord: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /**
         * @description The Kafka cluster ID.
         * @example cluster-1
         */
        cluster_id: components["parameters"]["ClusterId"];
        /**
         * @description The topic name.
         * @example topic-1
         */
        topic_name: components["parameters"]["TopicName"];
      };
      cookie?: never;
    };
    requestBody?: components["requestBodies"]["ProduceRequest"];
    responses: {
      200: components["responses"]["ProduceResponse"];
      400: components["responses"]["BadRequestErrorResponse_ProduceRecords"];
      401: components["responses"]["UnauthorizedErrorResponse"];
      403: components["responses"]["ForbiddenErrorResponse"];
      404: components["responses"]["NotFoundErrorResponse"];
      413: components["responses"]["RequestEntityTooLargeErrorResponse"];
      415: components["responses"]["UnsupportedMediaTypeErrorResponse"];
      422: components["responses"]["UnprocessableEntity_ProduceRecord"];
      429: components["responses"]["TooManyRequestsErrorResponse"];
      "5XX": components["responses"]["ServerErrorResponse"];
    };
  };
  listKafkaLinks: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /**
         * @description The Kafka cluster ID.
         * @example cluster-1
         */
        cluster_id: components["parameters"]["ClusterId"];
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      200: components["responses"]["ListLinksResponse"];
      400: components["responses"]["BadRequestErrorResponse"];
      401: components["responses"]["UnauthorizedErrorResponse"];
      429: components["responses"]["TooManyRequestsErrorResponse"];
      "5XX": components["responses"]["ServerErrorResponse"];
    };
  };
  createKafkaLink: {
    parameters: {
      query: {
        /**
         * @description The link name
         * @example link-sb1
         */
        link_name: components["parameters"]["QueryParamLinkName"];
        /**
         * @description To validate the action can be performed successfully or not. Default: false
         * @example false
         */
        validate_only?: components["parameters"]["ValidateOnly"];
        /**
         * @description To synchronously validate that the source cluster ID is expected and the dest cluster has the permission to read topics in the source cluster. Default: true
         * @example false
         */
        validate_link?: components["parameters"]["ValidateLink"];
      };
      header?: never;
      path: {
        /**
         * @description The Kafka cluster ID.
         * @example cluster-1
         */
        cluster_id: components["parameters"]["ClusterId"];
      };
      cookie?: never;
    };
    requestBody?: components["requestBodies"]["CreateLinkRequest"];
    responses: {
      204: components["responses"]["NoContentResponse"];
      400: components["responses"]["BadRequestErrorResponse"];
      401: components["responses"]["UnauthorizedErrorResponse"];
      429: components["responses"]["TooManyRequestsErrorResponse"];
      "5XX": components["responses"]["ServerErrorResponse"];
    };
  };
  getKafkaLink: {
    parameters: {
      query?: {
        /**
         * @description Whether to include cluster linking tasks in the response. Default: false
         * @example false
         */
        include_tasks?: components["parameters"]["IncludeTasks"];
      };
      header?: never;
      path: {
        /**
         * @description The Kafka cluster ID.
         * @example cluster-1
         */
        cluster_id: components["parameters"]["ClusterId"];
        /**
         * @description The link name
         * @example link-sb1
         */
        link_name: components["parameters"]["LinkName"];
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      200: components["responses"]["GetLinkResponse"];
      400: components["responses"]["BadRequestErrorResponse"];
      401: components["responses"]["UnauthorizedErrorResponse"];
      429: components["responses"]["TooManyRequestsErrorResponse"];
      "5XX": components["responses"]["ServerErrorResponse"];
    };
  };
  deleteKafkaLink: {
    parameters: {
      query?: {
        /**
         * @description Force the action. Default: false
         * @example false
         */
        force?: components["parameters"]["Force"];
        /**
         * @description To validate the action can be performed successfully or not. Default: false
         * @example false
         */
        validate_only?: components["parameters"]["ValidateOnly"];
      };
      header?: never;
      path: {
        /**
         * @description The Kafka cluster ID.
         * @example cluster-1
         */
        cluster_id: components["parameters"]["ClusterId"];
        /**
         * @description The link name
         * @example link-sb1
         */
        link_name: components["parameters"]["LinkName"];
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      200: components["responses"]["NoContentResponse"];
      400: components["responses"]["BadRequestErrorResponse"];
      401: components["responses"]["UnauthorizedErrorResponse"];
      429: components["responses"]["TooManyRequestsErrorResponse"];
      "5XX": components["responses"]["ServerErrorResponse"];
    };
  };
  listKafkaDefaultTopicConfigs: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /**
         * @description The Kafka cluster ID.
         * @example cluster-1
         */
        cluster_id: components["parameters"]["ClusterId"];
        /**
         * @description The topic name.
         * @example topic-1
         */
        topic_name: components["parameters"]["TopicName"];
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      200: components["responses"]["ListTopicConfigsResponse"];
      400: components["responses"]["BadRequestErrorResponse"];
      401: components["responses"]["UnauthorizedErrorResponse"];
      404: components["responses"]["NotFoundErrorResponse"];
      429: components["responses"]["TooManyRequestsErrorResponse"];
      "5XX": components["responses"]["ServerErrorResponse"];
    };
  };
  listKafkaLinkConfigs: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /**
         * @description The Kafka cluster ID.
         * @example cluster-1
         */
        cluster_id: components["parameters"]["ClusterId"];
        /**
         * @description The link name
         * @example link-sb1
         */
        link_name: components["parameters"]["LinkName"];
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      200: components["responses"]["ListLinkConfigsResponse"];
      400: components["responses"]["BadRequestErrorResponse"];
      401: components["responses"]["UnauthorizedErrorResponse"];
      429: components["responses"]["TooManyRequestsErrorResponse"];
      "5XX": components["responses"]["ServerErrorResponse"];
    };
  };
  getKafkaLinkConfigs: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /**
         * @description The Kafka cluster ID.
         * @example cluster-1
         */
        cluster_id: components["parameters"]["ClusterId"];
        /**
         * @description The link name
         * @example link-sb1
         */
        link_name: components["parameters"]["LinkName"];
        /**
         * @description The link config name
         * @example consumer.offset.sync.enable
         */
        config_name: components["parameters"]["LinkConfigName"];
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      200: components["responses"]["GetLinkConfigsResponse"];
      400: components["responses"]["BadRequestErrorResponse"];
      401: components["responses"]["UnauthorizedErrorResponse"];
      429: components["responses"]["TooManyRequestsErrorResponse"];
      "5XX": components["responses"]["ServerErrorResponse"];
    };
  };
  updateKafkaLinkConfig: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /**
         * @description The Kafka cluster ID.
         * @example cluster-1
         */
        cluster_id: components["parameters"]["ClusterId"];
        /**
         * @description The link name
         * @example link-sb1
         */
        link_name: components["parameters"]["LinkName"];
        /**
         * @description The link config name
         * @example consumer.offset.sync.enable
         */
        config_name: components["parameters"]["LinkConfigName"];
      };
      cookie?: never;
    };
    requestBody?: components["requestBodies"]["UpdateLinkConfigRequest"];
    responses: {
      204: components["responses"]["NoContentResponse"];
      400: components["responses"]["BadRequestErrorResponse"];
      401: components["responses"]["UnauthorizedErrorResponse"];
      429: components["responses"]["TooManyRequestsErrorResponse"];
      "5XX": components["responses"]["ServerErrorResponse"];
    };
  };
  deleteKafkaLinkConfig: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /**
         * @description The Kafka cluster ID.
         * @example cluster-1
         */
        cluster_id: components["parameters"]["ClusterId"];
        /**
         * @description The link name
         * @example link-sb1
         */
        link_name: components["parameters"]["LinkName"];
        /**
         * @description The link config name
         * @example consumer.offset.sync.enable
         */
        config_name: components["parameters"]["LinkConfigName"];
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      204: components["responses"]["NoContentResponse"];
      400: components["responses"]["BadRequestErrorResponse"];
      401: components["responses"]["UnauthorizedErrorResponse"];
      429: components["responses"]["TooManyRequestsErrorResponse"];
      "5XX": components["responses"]["ServerErrorResponse"];
    };
  };
  updateKafkaLinkConfigBatch: {
    parameters: {
      query?: {
        /**
         * @description To validate the action can be performed successfully or not. Default: false
         * @example false
         */
        validate_only?: components["parameters"]["ValidateOnly"];
      };
      header?: never;
      path: {
        /**
         * @description The Kafka cluster ID.
         * @example cluster-1
         */
        cluster_id: components["parameters"]["ClusterId"];
        /**
         * @description The link name
         * @example link-sb1
         */
        link_name: components["parameters"]["LinkName"];
      };
      cookie?: never;
    };
    requestBody?: components["requestBodies"]["AlterLinkConfigBatchRequest"];
    responses: {
      /** @description No Content */
      204: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
      400: components["responses"]["BadRequestErrorResponse"];
      401: components["responses"]["UnauthorizedErrorResponse"];
      429: components["responses"]["TooManyRequestsErrorResponse"];
      "5XX": components["responses"]["ServerErrorResponse"];
    };
  };
  listKafkaMirrorTopicsUnderLink: {
    parameters: {
      query?: {
        /**
         * @description The status of the mirror topic. If not specified, all mirror topics will be returned.
         * @example ACTIVE
         */
        mirror_status?: components["parameters"]["MirrorTopicStatus"];
      };
      header?: never;
      path: {
        /**
         * @description The Kafka cluster ID.
         * @example cluster-1
         */
        cluster_id: components["parameters"]["ClusterId"];
        /**
         * @description The link name
         * @example link-sb1
         */
        link_name: components["parameters"]["LinkName"];
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      200: components["responses"]["ListMirrorTopicsResponse"];
      400: components["responses"]["BadRequestErrorResponse"];
      401: components["responses"]["UnauthorizedErrorResponse"];
      429: components["responses"]["TooManyRequestsErrorResponse"];
      "5XX": components["responses"]["ServerErrorResponse"];
    };
  };
  createKafkaMirrorTopic: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /**
         * @description The Kafka cluster ID.
         * @example cluster-1
         */
        cluster_id: components["parameters"]["ClusterId"];
        /**
         * @description The link name
         * @example link-sb1
         */
        link_name: components["parameters"]["LinkName"];
      };
      cookie?: never;
    };
    requestBody?: components["requestBodies"]["CreateMirrorTopicRequest"];
    responses: {
      204: components["responses"]["NoContentResponse"];
      400: components["responses"]["BadRequestErrorResponse"];
      401: components["responses"]["UnauthorizedErrorResponse"];
      429: components["responses"]["TooManyRequestsErrorResponse"];
      "5XX": components["responses"]["ServerErrorResponse"];
    };
  };
  listKafkaMirrorTopics: {
    parameters: {
      query?: {
        /**
         * @description The status of the mirror topic. If not specified, all mirror topics will be returned.
         * @example ACTIVE
         */
        mirror_status?: components["parameters"]["MirrorTopicStatus"];
      };
      header?: never;
      path: {
        /**
         * @description The Kafka cluster ID.
         * @example cluster-1
         */
        cluster_id: components["parameters"]["ClusterId"];
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      200: components["responses"]["ListMirrorTopicsResponse"];
      400: components["responses"]["BadRequestErrorResponse"];
      401: components["responses"]["UnauthorizedErrorResponse"];
      429: components["responses"]["TooManyRequestsErrorResponse"];
      "5XX": components["responses"]["ServerErrorResponse"];
    };
  };
  readKafkaMirrorTopic: {
    parameters: {
      query?: {
        /**
         * @description Whether to include mirror state transition errors in the response. Default: false
         * @example false
         */
        include_state_transition_errors?: components["parameters"]["IncludeStateTransitionErrors"];
      };
      header?: never;
      path: {
        /**
         * @description The Kafka cluster ID.
         * @example cluster-1
         */
        cluster_id: components["parameters"]["ClusterId"];
        /**
         * @description The link name
         * @example link-sb1
         */
        link_name: components["parameters"]["LinkName"];
        /**
         * @description Cluster Linking mirror topic name
         * @example topic-1
         */
        mirror_topic_name: components["parameters"]["MirrorTopicName"];
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      200: components["responses"]["DescribeMirrorTopicResponse"];
      400: components["responses"]["BadRequestErrorResponse"];
      401: components["responses"]["UnauthorizedErrorResponse"];
      429: components["responses"]["TooManyRequestsErrorResponse"];
      "5XX": components["responses"]["ServerErrorResponse"];
    };
  };
  updateKafkaMirrorTopicsPromote: {
    parameters: {
      query?: {
        /**
         * @description To validate the action can be performed successfully or not. Default: false
         * @example false
         */
        validate_only?: components["parameters"]["ValidateOnly"];
      };
      header?: never;
      path: {
        /**
         * @description The Kafka cluster ID.
         * @example cluster-1
         */
        cluster_id: components["parameters"]["ClusterId"];
        /**
         * @description The link name
         * @example link-sb1
         */
        link_name: components["parameters"]["LinkName"];
      };
      cookie?: never;
    };
    requestBody?: components["requestBodies"]["AlterMirrorsRequest"];
    responses: {
      200: components["responses"]["AlterMirrorStatusResponse"];
      400: components["responses"]["BadRequestErrorResponse"];
      401: components["responses"]["UnauthorizedErrorResponse"];
      429: components["responses"]["TooManyRequestsErrorResponse"];
      "5XX": components["responses"]["ServerErrorResponse"];
    };
  };
  updateKafkaMirrorTopicsFailover: {
    parameters: {
      query?: {
        /**
         * @description To validate the action can be performed successfully or not. Default: false
         * @example false
         */
        validate_only?: components["parameters"]["ValidateOnly"];
      };
      header?: never;
      path: {
        /**
         * @description The Kafka cluster ID.
         * @example cluster-1
         */
        cluster_id: components["parameters"]["ClusterId"];
        /**
         * @description The link name
         * @example link-sb1
         */
        link_name: components["parameters"]["LinkName"];
      };
      cookie?: never;
    };
    requestBody?: components["requestBodies"]["AlterMirrorsRequest"];
    responses: {
      200: components["responses"]["AlterMirrorStatusResponse"];
      400: components["responses"]["BadRequestErrorResponse"];
      401: components["responses"]["UnauthorizedErrorResponse"];
      429: components["responses"]["TooManyRequestsErrorResponse"];
      "5XX": components["responses"]["ServerErrorResponse"];
    };
  };
  updateKafkaMirrorTopicsPause: {
    parameters: {
      query?: {
        /**
         * @description To validate the action can be performed successfully or not. Default: false
         * @example false
         */
        validate_only?: components["parameters"]["ValidateOnly"];
      };
      header?: never;
      path: {
        /**
         * @description The Kafka cluster ID.
         * @example cluster-1
         */
        cluster_id: components["parameters"]["ClusterId"];
        /**
         * @description The link name
         * @example link-sb1
         */
        link_name: components["parameters"]["LinkName"];
      };
      cookie?: never;
    };
    requestBody?: components["requestBodies"]["AlterMirrorsRequest"];
    responses: {
      200: components["responses"]["AlterMirrorStatusResponse"];
      400: components["responses"]["BadRequestErrorResponse"];
      401: components["responses"]["UnauthorizedErrorResponse"];
      429: components["responses"]["TooManyRequestsErrorResponse"];
      "5XX": components["responses"]["ServerErrorResponse"];
    };
  };
  updateKafkaMirrorTopicsResume: {
    parameters: {
      query?: {
        /**
         * @description To validate the action can be performed successfully or not. Default: false
         * @example false
         */
        validate_only?: components["parameters"]["ValidateOnly"];
      };
      header?: never;
      path: {
        /**
         * @description The Kafka cluster ID.
         * @example cluster-1
         */
        cluster_id: components["parameters"]["ClusterId"];
        /**
         * @description The link name
         * @example link-sb1
         */
        link_name: components["parameters"]["LinkName"];
      };
      cookie?: never;
    };
    requestBody?: components["requestBodies"]["AlterMirrorsRequest"];
    responses: {
      200: components["responses"]["AlterMirrorStatusResponse"];
      400: components["responses"]["BadRequestErrorResponse"];
      401: components["responses"]["UnauthorizedErrorResponse"];
      429: components["responses"]["TooManyRequestsErrorResponse"];
      "5XX": components["responses"]["ServerErrorResponse"];
    };
  };
  updateKafkaMirrorTopicsReverseAndStartMirror: {
    parameters: {
      query?: {
        /**
         * @description To validate the action can be performed successfully or not. Default: false
         * @example false
         */
        validate_only?: components["parameters"]["ValidateOnly"];
      };
      header?: never;
      path: {
        /**
         * @description The Kafka cluster ID.
         * @example cluster-1
         */
        cluster_id: components["parameters"]["ClusterId"];
        /**
         * @description The link name
         * @example link-sb1
         */
        link_name: components["parameters"]["LinkName"];
      };
      cookie?: never;
    };
    requestBody?: components["requestBodies"]["AlterMirrorsRequest"];
    responses: {
      200: components["responses"]["AlterMirrorStatusResponse"];
      400: components["responses"]["BadRequestErrorResponse"];
      401: components["responses"]["UnauthorizedErrorResponse"];
      429: components["responses"]["TooManyRequestsErrorResponse"];
      "5XX": components["responses"]["ServerErrorResponse"];
    };
  };
  updateKafkaMirrorTopicsReverseAndPauseMirror: {
    parameters: {
      query?: {
        /**
         * @description To validate the action can be performed successfully or not. Default: false
         * @example false
         */
        validate_only?: components["parameters"]["ValidateOnly"];
      };
      header?: never;
      path: {
        /**
         * @description The Kafka cluster ID.
         * @example cluster-1
         */
        cluster_id: components["parameters"]["ClusterId"];
        /**
         * @description The link name
         * @example link-sb1
         */
        link_name: components["parameters"]["LinkName"];
      };
      cookie?: never;
    };
    requestBody?: components["requestBodies"]["AlterMirrorsRequest"];
    responses: {
      200: components["responses"]["AlterMirrorStatusResponse"];
      400: components["responses"]["BadRequestErrorResponse"];
      401: components["responses"]["UnauthorizedErrorResponse"];
      429: components["responses"]["TooManyRequestsErrorResponse"];
      "5XX": components["responses"]["ServerErrorResponse"];
    };
  };
  updateKafkaMirrorTopicsTruncateAndRestoreMirror: {
    parameters: {
      query?: {
        /**
         * @description Whether to include partition level truncation information when truncating and restoring a topic in the response. Default: false
         * @example false
         */
        include_partition_level_truncation_data?: components["parameters"]["IncludePartitionLevelTruncationData"];
        /**
         * @description To validate the action can be performed successfully or not. Default: false
         * @example false
         */
        validate_only?: components["parameters"]["ValidateOnly"];
      };
      header?: never;
      path: {
        /**
         * @description The Kafka cluster ID.
         * @example cluster-1
         */
        cluster_id: components["parameters"]["ClusterId"];
        /**
         * @description The link name
         * @example link-sb1
         */
        link_name: components["parameters"]["LinkName"];
      };
      cookie?: never;
    };
    requestBody?: components["requestBodies"]["AlterMirrorsRequest"];
    responses: {
      200: components["responses"]["AlterMirrorStatusResponse"];
      400: components["responses"]["BadRequestErrorResponse"];
      401: components["responses"]["UnauthorizedErrorResponse"];
      429: components["responses"]["TooManyRequestsErrorResponse"];
      "5XX": components["responses"]["ServerErrorResponse"];
    };
  };
  listServiceQuotaV1AppliedQuotas: {
    parameters: {
      query: {
        /**
         * @description The applied scope the quota belongs to.
         *
         * @example ORGANIZATION
         */
        scope: components["schemas"]["SearchFilter"];
        /**
         * @description The environment ID the quota is associated with.
         *
         * @example env-00000
         */
        environment?: components["schemas"]["SearchFilter"];
        /**
         * @description The network ID the quota is associated with.
         *
         * @example n-12034
         */
        network?: components["schemas"]["SearchFilter"];
        /**
         * @description The kafka cluster ID the quota is associated with.
         *
         * @example lkc-00000
         */
        kafka_cluster?: components["schemas"]["SearchFilter"];
        /**
         * @description The id (quota code) that this quota belongs to.
         *
         * @example iam.max_environments.per_org
         */
        id?: components["schemas"]["SearchFilter"];
        /** @description A pagination size for collection requests. */
        page_size?: number;
        /** @description An opaque pagination token for collection requests. */
        page_token?: string;
      };
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description Applied Quota. */
      200: {
        headers: {
          /** @description The unique identifier for the API request. */
          "X-Request-Id"?: string;
          /** @description The maximum number of requests you're permitted to make per time period. */
          "X-RateLimit-Limit"?: number;
          /** @description The number of requests remaining in the current rate limit window. */
          "X-RateLimit-Remaining"?: number;
          /** @description The relative time in seconds until the current rate-limit window resets.
           *
           *     **Important:** This differs from Github and Twitter's same-named header which uses UTC epoch seconds. We use relative time to avoid client/server time synchronization issues. */
          "X-RateLimit-Reset"?: number;
          [name: string]: unknown;
        };
        content: {
          "application/json": components["schemas"]["service-quota.v1.AppliedQuotaList"] & {
            data?: {
              /** @example {
               *       "id": "u-4voj5e",
               *       "related": "https://api.confluent.cloud/v2/users/u-4voj5e",
               *       "resource_name": "https://api.confluent.cloud/organization=9bb441c4-edef-46ac-8a41-c49e44a3fd9a/user=u-4voj5e"
               *     } */
              user?: unknown;
              /** @example {
               *       "id": "b3a17773-05cc-4431-9560-433fb4613da8",
               *       "related": "https://api.confluent.cloud/partner/v2/organizations/b3a17773-05cc-4431-9560-433fb4613da8",
               *       "resource_name": "https://api.confluent.cloud/organization=b3a17773-05cc-4431-9560-433fb4613da8"
               *     } */
              organization?: unknown;
              /** @example {
               *       "id": "env-00000",
               *       "related": "https://api.confluent.cloud/org/v2/environments/env-00000",
               *       "resource_name": "https://api.confluent.cloud/organization=9bb441c4-edef-46ac-8a41-c49e44a3fd9a/environment=env-00000"
               *     } */
              environment?: unknown;
              /** @example {
               *       "id": "n-12034",
               *       "related": "https://api.confluent.cloud/networking/v1/networks/n-12034",
               *       "resource_name": "https://api.confluent.cloud/organization=9bb441c4-edef-46ac-8a41-c49e44a3fd9a/environment=env-abc123/network=n-12034"
               *     } */
              network?: unknown;
              /** @example {
               *       "id": "lkc-00000",
               *       "related": "https://api.confluent.cloud/cmk/v2/clusters/lkc-00000",
               *       "resource_name": "https://api.confluent.cloud/organization=9bb441c4-edef-46ac-8a41-c49e44a3fd9a/environment=env-abc123/cloud-cluster=lkc-00000"
               *     } */
              kafka_cluster?: unknown;
            }[];
          };
        };
      };
      400: components["responses"]["BadRequestError"];
      401: components["responses"]["UnauthenticatedError"];
      403: components["responses"]["UnauthorizedError"];
      429: components["responses"]["RateLimitError"];
      500: components["responses"]["DefaultSystemError"];
    };
  };
  getServiceQuotaV1AppliedQuota: {
    parameters: {
      query?: {
        /**
         * @description The environment ID the quota is associated with.
         *     This field is only required when retrieving a single quota and
         *     the scope of quota is "ENVIRONMENT" or "NETWORK" or "KAFKA_CLUSTER".
         *
         * @example env-00000
         */
        environment?: components["schemas"]["SearchFilter"];
        /**
         * @description The network ID the quota is associated with.
         *     This field is only required when retrieving a single quota and
         *     the scope of quota is "NETWORK".
         *
         * @example n-12034
         */
        network?: components["schemas"]["SearchFilter"];
        /**
         * @description The kafka cluster ID the quota is associated with.
         *     This field is required only when the scope of quota is "KAFKA_CLUSTER".
         *
         * @example lkc-00000
         */
        kafka_cluster?: components["schemas"]["SearchFilter"];
      };
      header?: never;
      path: {
        /** @description The unique identifier for the applied quota. */
        id: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description Applied Quota. */
      200: {
        headers: {
          /** @description The unique identifier for the API request. */
          "X-Request-Id"?: string;
          /** @description The maximum number of requests you're permitted to make per time period. */
          "X-RateLimit-Limit"?: number;
          /** @description The number of requests remaining in the current rate limit window. */
          "X-RateLimit-Remaining"?: number;
          /** @description The relative time in seconds until the current rate-limit window resets.
           *
           *     **Important:** This differs from Github and Twitter's same-named header which uses UTC epoch seconds. We use relative time to avoid client/server time synchronization issues. */
          "X-RateLimit-Reset"?: number;
          [name: string]: unknown;
        };
        content: {
          "application/json": components["schemas"]["service-quota.v1.AppliedQuota"] &
            Record<string, unknown> & {
              /** @example {
               *       "id": "u-4voj5e",
               *       "related": "https://api.confluent.cloud/v2/users/u-4voj5e",
               *       "resource_name": "https://api.confluent.cloud/organization=9bb441c4-edef-46ac-8a41-c49e44a3fd9a/user=u-4voj5e"
               *     } */
              user?: unknown;
              /** @example {
               *       "id": "b3a17773-05cc-4431-9560-433fb4613da8",
               *       "related": "https://api.confluent.cloud/partner/v2/organizations/b3a17773-05cc-4431-9560-433fb4613da8",
               *       "resource_name": "https://api.confluent.cloud/organization=b3a17773-05cc-4431-9560-433fb4613da8"
               *     } */
              organization?: unknown;
              /** @example {
               *       "id": "env-00000",
               *       "related": "https://api.confluent.cloud/org/v2/environments/env-00000",
               *       "resource_name": "https://api.confluent.cloud/organization=9bb441c4-edef-46ac-8a41-c49e44a3fd9a/environment=env-00000"
               *     } */
              environment?: unknown;
              /** @example {
               *       "id": "n-12034",
               *       "related": "https://api.confluent.cloud/networking/v1/networks/n-12034",
               *       "resource_name": "https://api.confluent.cloud/organization=9bb441c4-edef-46ac-8a41-c49e44a3fd9a/environment=env-abc123/network=n-12034"
               *     } */
              network?: unknown;
              /** @example {
               *       "id": "lkc-00000",
               *       "related": "https://api.confluent.cloud/cmk/v2/clusters/lkc-00000",
               *       "resource_name": "https://api.confluent.cloud/organization=9bb441c4-edef-46ac-8a41-c49e44a3fd9a/environment=env-abc123/cloud-cluster=lkc-00000"
               *     } */
              kafka_cluster?: unknown;
            };
        };
      };
      400: components["responses"]["BadRequestError"];
      401: components["responses"]["UnauthenticatedError"];
      403: components["responses"]["UnauthorizedError"];
      404: components["responses"]["NotFoundError"];
      429: components["responses"]["RateLimitError"];
      500: components["responses"]["DefaultSystemError"];
    };
  };
  listServiceQuotaV1Scopes: {
    parameters: {
      query?: {
        /** @description A pagination size for collection requests. */
        page_size?: number;
        /** @description An opaque pagination token for collection requests. */
        page_token?: string;
      };
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description Scope. */
      200: {
        headers: {
          /** @description The unique identifier for the API request. */
          "X-Request-Id"?: string;
          /** @description The maximum number of requests you're permitted to make per time period. */
          "X-RateLimit-Limit"?: number;
          /** @description The number of requests remaining in the current rate limit window. */
          "X-RateLimit-Remaining"?: number;
          /** @description The relative time in seconds until the current rate-limit window resets.
           *
           *     **Important:** This differs from Github and Twitter's same-named header which uses UTC epoch seconds. We use relative time to avoid client/server time synchronization issues. */
          "X-RateLimit-Reset"?: number;
          [name: string]: unknown;
        };
        content: {
          "application/json": components["schemas"]["service-quota.v1.ScopeList"];
        };
      };
      400: components["responses"]["BadRequestError"];
      401: components["responses"]["UnauthenticatedError"];
      403: components["responses"]["UnauthorizedError"];
      429: components["responses"]["RateLimitError"];
      500: components["responses"]["DefaultSystemError"];
    };
  };
  getServiceQuotaV1Scope: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description The unique identifier for the scope. */
        id: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description Scope. */
      200: {
        headers: {
          /** @description The unique identifier for the API request. */
          "X-Request-Id"?: string;
          /** @description The maximum number of requests you're permitted to make per time period. */
          "X-RateLimit-Limit"?: number;
          /** @description The number of requests remaining in the current rate limit window. */
          "X-RateLimit-Remaining"?: number;
          /** @description The relative time in seconds until the current rate-limit window resets.
           *
           *     **Important:** This differs from Github and Twitter's same-named header which uses UTC epoch seconds. We use relative time to avoid client/server time synchronization issues. */
          "X-RateLimit-Reset"?: number;
          [name: string]: unknown;
        };
        content: {
          "application/json": components["schemas"]["service-quota.v1.Scope"] &
            Record<string, unknown>;
        };
      };
      400: components["responses"]["BadRequestError"];
      401: components["responses"]["UnauthenticatedError"];
      403: components["responses"]["UnauthorizedError"];
      404: components["responses"]["NotFoundError"];
      429: components["responses"]["RateLimitError"];
      500: components["responses"]["DefaultSystemError"];
    };
  };
  listPartnerV2Entitlements: {
    parameters: {
      query?: {
        /**
         * @description Filter the results by exact match for organization.id.
         * @example b3a17773-05cc-4431-9560-433fb4613da8
         */
        "organization.id"?: components["schemas"]["SearchFilter"];
        /** @description A pagination size for collection requests. */
        page_size?: number;
        /** @description An opaque pagination token for collection requests. */
        page_token?: string;
      };
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description Entitlement. */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "application/json": components["schemas"]["partner.v2.EntitlementList"];
        };
      };
      400: components["responses"]["BadRequestError"];
      401: components["responses"]["UnauthenticatedError"];
      403: components["responses"]["UnauthorizedError"];
      429: components["responses"]["RateLimitError"];
      500: components["responses"]["DefaultSystemError"];
    };
  };
  createPartnerV2Entitlement: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody?: {
      content: {
        "application/json": components["schemas"]["partner.v2.Entitlement"] &
          Record<string, unknown>;
      };
    };
    responses: {
      /** @description An Entitlement is being created. */
      201: {
        headers: {
          /** @description Entitlement resource uri */
          Location?: string;
          [name: string]: unknown;
        };
        content: {
          "application/json": components["schemas"]["partner.v2.Entitlement"] &
            Record<string, unknown>;
        };
      };
      400: components["responses"]["BadRequestError"];
      401: components["responses"]["UnauthenticatedError"];
      403: components["responses"]["UnauthorizedError"];
      409: components["responses"]["ConflictError"];
      429: components["responses"]["RateLimitError"];
      500: components["responses"]["DefaultSystemError"];
    };
  };
  getPartnerV2Entitlement: {
    parameters: {
      query?: {
        /**
         * @description Scope the operation to the given organization.id.
         * @example b3a17773-05cc-4431-9560-433fb4613da8
         */
        "organization.id"?: components["schemas"]["SearchFilter"];
      };
      header?: never;
      path: {
        /** @description The unique identifier for the entitlement. */
        id: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description Entitlement. */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "application/json": components["schemas"]["partner.v2.Entitlement"] &
            Record<string, unknown>;
        };
      };
      400: components["responses"]["BadRequestError"];
      401: components["responses"]["UnauthenticatedError"];
      403: components["responses"]["UnauthorizedError"];
      404: components["responses"]["NotFoundError"];
      429: components["responses"]["RateLimitError"];
      500: components["responses"]["DefaultSystemError"];
    };
  };
  listSrcmV2Regions: {
    parameters: {
      query?: {
        /**
         * @description Filter the results by exact match for spec.cloud.
         * @example AWS
         */
        "spec.cloud"?: components["schemas"]["SearchFilter"];
        /**
         * @description Filter the results by exact match for spec.region_name.
         * @example us-east-2
         */
        "spec.region_name"?: components["schemas"]["SearchFilter"];
        /**
         * @description Filter the results by exact match for spec.packages. Pass multiple times to see results matching any of the values.
         * @example [
         *       "ESSENTIALS",
         *       "ADVANCED"
         *     ]
         */
        "spec.packages"?: components["schemas"]["MultipleSearchFilter"];
        /** @description A pagination size for collection requests. */
        page_size?: number;
        /** @description An opaque pagination token for collection requests. */
        page_token?: string;
      };
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description Region. */
      200: {
        headers: {
          /** @description The unique identifier for the API request. */
          "X-Request-Id"?: string;
          /** @description The maximum number of requests you're permitted to make per time period. */
          "X-RateLimit-Limit"?: number;
          /** @description The number of requests remaining in the current rate limit window. */
          "X-RateLimit-Remaining"?: number;
          /** @description The relative time in seconds until the current rate-limit window resets.
           *
           *     **Important:** This differs from Github and Twitter's same-named header which uses UTC epoch seconds. We use relative time to avoid client/server time synchronization issues. */
          "X-RateLimit-Reset"?: number;
          [name: string]: unknown;
        };
        content: {
          "application/json": components["schemas"]["srcm.v2.RegionList"];
        };
      };
      400: components["responses"]["BadRequestError"];
      401: components["responses"]["UnauthenticatedError"];
      403: components["responses"]["UnauthorizedError"];
      429: components["responses"]["RateLimitError"];
      500: components["responses"]["DefaultSystemError"];
    };
  };
  getSrcmV2Region: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description The unique identifier for the region. */
        id: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description Region. */
      200: {
        headers: {
          /** @description The unique identifier for the API request. */
          "X-Request-Id"?: string;
          /** @description The maximum number of requests you're permitted to make per time period. */
          "X-RateLimit-Limit"?: number;
          /** @description The number of requests remaining in the current rate limit window. */
          "X-RateLimit-Remaining"?: number;
          /** @description The relative time in seconds until the current rate-limit window resets.
           *
           *     **Important:** This differs from Github and Twitter's same-named header which uses UTC epoch seconds. We use relative time to avoid client/server time synchronization issues. */
          "X-RateLimit-Reset"?: number;
          [name: string]: unknown;
        };
        content: {
          "application/json": components["schemas"]["srcm.v2.Region"] & {
            spec: Record<string, unknown>;
          };
        };
      };
      400: components["responses"]["BadRequestError"];
      401: components["responses"]["UnauthenticatedError"];
      403: components["responses"]["UnauthorizedError"];
      404: components["responses"]["NotFoundError"];
      429: components["responses"]["RateLimitError"];
      500: components["responses"]["DefaultSystemError"];
    };
  };
  listSrcmV2Clusters: {
    parameters: {
      query: {
        /**
         * @description Filter the results by exact match for environment.
         * @example env-00000
         */
        environment: components["schemas"]["SearchFilter"];
        /** @description A pagination size for collection requests. */
        page_size?: number;
        /** @description An opaque pagination token for collection requests. */
        page_token?: string;
      };
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description Cluster. */
      200: {
        headers: {
          /** @description The unique identifier for the API request. */
          "X-Request-Id"?: string;
          /** @description The maximum number of requests you're permitted to make per time period. */
          "X-RateLimit-Limit"?: number;
          /** @description The number of requests remaining in the current rate limit window. */
          "X-RateLimit-Remaining"?: number;
          /** @description The relative time in seconds until the current rate-limit window resets.
           *
           *     **Important:** This differs from Github and Twitter's same-named header which uses UTC epoch seconds. We use relative time to avoid client/server time synchronization issues. */
          "X-RateLimit-Reset"?: number;
          [name: string]: unknown;
        };
        content: {
          "application/json": components["schemas"]["srcm.v2.ClusterList"] & {
            data?: {
              spec?: {
                /** @example {
                 *       "id": "env-00000",
                 *       "related": "https://api.confluent.cloud/v2/environments/env-00000",
                 *       "resource_name": "https://api.confluent.cloud/organization=9bb441c4-edef-46ac-8a41-c49e44a3fd9a/environment=env-00000"
                 *     } */
                environment?: unknown;
                /** @example {
                 *       "id": "sgreg-00000",
                 *       "related": "https://api.confluent.cloud/srcm/v2/regions/sgreg-00000",
                 *       "resource_name": "https://api.confluent.cloud/organization=9bb441c4-edef-46ac-8a41-c49e44a3fd9a/region=sgreg-00000"
                 *     } */
                region?: unknown;
              };
            }[];
          };
        };
      };
      400: components["responses"]["BadRequestError"];
      401: components["responses"]["UnauthenticatedError"];
      403: components["responses"]["UnauthorizedError"];
      429: components["responses"]["RateLimitError"];
      500: components["responses"]["DefaultSystemError"];
    };
  };
  createSrcmV2Cluster: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody?: {
      content: {
        "application/json": components["schemas"]["srcm.v2.Cluster"] & {
          spec: Record<string, unknown>;
        } & {
          spec?: {
            /** @example {
             *       "id": "env-00000"
             *     } */
            environment?: unknown;
            /** @example {
             *       "id": "sgreg-00000"
             *     } */
            region?: unknown;
          };
        };
      };
    };
    responses: {
      /** @description A Cluster is being created. */
      202: {
        headers: {
          /** @description The unique identifier for the API request. */
          "X-Request-Id"?: string;
          /** @description The maximum number of requests you're permitted to make per time period. */
          "X-RateLimit-Limit"?: number;
          /** @description The number of requests remaining in the current rate limit window. */
          "X-RateLimit-Remaining"?: number;
          /** @description The relative time in seconds until the current rate-limit window resets.
           *
           *     **Important:** This differs from Github and Twitter's same-named header which uses UTC epoch seconds. We use relative time to avoid client/server time synchronization issues. */
          "X-RateLimit-Reset"?: number;
          /** @description Cluster resource uri */
          Location?: string;
          [name: string]: unknown;
        };
        content: {
          "application/json": components["schemas"]["srcm.v2.Cluster"] & {
            spec: Record<string, unknown>;
          } & {
            spec?: {
              /** @example {
               *       "id": "env-00000",
               *       "related": "https://api.confluent.cloud/v2/environments/env-00000",
               *       "resource_name": "https://api.confluent.cloud/organization=9bb441c4-edef-46ac-8a41-c49e44a3fd9a/environment=env-00000"
               *     } */
              environment?: unknown;
              /** @example {
               *       "id": "sgreg-00000",
               *       "related": "https://api.confluent.cloud/srcm/v2/regions/sgreg-00000",
               *       "resource_name": "https://api.confluent.cloud/organization=9bb441c4-edef-46ac-8a41-c49e44a3fd9a/region=sgreg-00000"
               *     } */
              region?: unknown;
            };
          };
        };
      };
      400: components["responses"]["BadRequestError"];
      401: components["responses"]["UnauthenticatedError"];
      403: components["responses"]["UnauthorizedError"];
      409: components["responses"]["ConflictError"];
      422: components["responses"]["ValidationError"];
      429: components["responses"]["RateLimitError"];
      500: components["responses"]["DefaultSystemError"];
    };
  };
  getSrcmV2Cluster: {
    parameters: {
      query: {
        /**
         * @description Scope the operation to the given environment.
         * @example env-00000
         */
        environment: components["schemas"]["SearchFilter"];
      };
      header?: never;
      path: {
        /** @description The unique identifier for the cluster. */
        id: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description Cluster. */
      200: {
        headers: {
          /** @description The unique identifier for the API request. */
          "X-Request-Id"?: string;
          /** @description The maximum number of requests you're permitted to make per time period. */
          "X-RateLimit-Limit"?: number;
          /** @description The number of requests remaining in the current rate limit window. */
          "X-RateLimit-Remaining"?: number;
          /** @description The relative time in seconds until the current rate-limit window resets.
           *
           *     **Important:** This differs from Github and Twitter's same-named header which uses UTC epoch seconds. We use relative time to avoid client/server time synchronization issues. */
          "X-RateLimit-Reset"?: number;
          [name: string]: unknown;
        };
        content: {
          "application/json": components["schemas"]["srcm.v2.Cluster"] & {
            spec: Record<string, unknown>;
          } & {
            spec?: {
              /** @example {
               *       "id": "env-00000",
               *       "related": "https://api.confluent.cloud/v2/environments/env-00000",
               *       "resource_name": "https://api.confluent.cloud/organization=9bb441c4-edef-46ac-8a41-c49e44a3fd9a/environment=env-00000"
               *     } */
              environment?: unknown;
              /** @example {
               *       "id": "sgreg-00000",
               *       "related": "https://api.confluent.cloud/srcm/v2/regions/sgreg-00000",
               *       "resource_name": "https://api.confluent.cloud/organization=9bb441c4-edef-46ac-8a41-c49e44a3fd9a/region=sgreg-00000"
               *     } */
              region?: unknown;
            };
          };
        };
      };
      400: components["responses"]["BadRequestError"];
      401: components["responses"]["UnauthenticatedError"];
      403: components["responses"]["UnauthorizedError"];
      404: components["responses"]["NotFoundError"];
      429: components["responses"]["RateLimitError"];
      500: components["responses"]["DefaultSystemError"];
    };
  };
  deleteSrcmV2Cluster: {
    parameters: {
      query: {
        /**
         * @description Scope the operation to the given environment.
         * @example env-00000
         */
        environment: components["schemas"]["SearchFilter"];
      };
      header?: never;
      path: {
        /** @description The unique identifier for the cluster. */
        id: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description A Cluster is being deleted. */
      204: {
        headers: {
          /** @description The unique identifier for the API request. */
          "X-Request-Id"?: string;
          /** @description The maximum number of requests you're permitted to make per time period. */
          "X-RateLimit-Limit"?: number;
          /** @description The number of requests remaining in the current rate limit window. */
          "X-RateLimit-Remaining"?: number;
          /** @description The relative time in seconds until the current rate-limit window resets.
           *
           *     **Important:** This differs from Github and Twitter's same-named header which uses UTC epoch seconds. We use relative time to avoid client/server time synchronization issues. */
          "X-RateLimit-Reset"?: number;
          [name: string]: unknown;
        };
        content?: never;
      };
      400: components["responses"]["BadRequestError"];
      401: components["responses"]["UnauthenticatedError"];
      403: components["responses"]["UnauthorizedError"];
      404: components["responses"]["NotFoundError"];
      429: components["responses"]["RateLimitError"];
      500: components["responses"]["DefaultSystemError"];
    };
  };
  updateSrcmV2Cluster: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description The unique identifier for the cluster. */
        id: string;
      };
      cookie?: never;
    };
    requestBody?: {
      content: {
        "application/json": components["schemas"]["srcm.v2.ClusterUpdate"] & {
          spec: {
            /** @example {
             *       "id": "env-00000"
             *     } */
            environment: unknown;
          };
        };
      };
    };
    responses: {
      /** @description Cluster. */
      200: {
        headers: {
          /** @description The unique identifier for the API request. */
          "X-Request-Id"?: string;
          /** @description The maximum number of requests you're permitted to make per time period. */
          "X-RateLimit-Limit"?: number;
          /** @description The number of requests remaining in the current rate limit window. */
          "X-RateLimit-Remaining"?: number;
          /** @description The relative time in seconds until the current rate-limit window resets.
           *
           *     **Important:** This differs from Github and Twitter's same-named header which uses UTC epoch seconds. We use relative time to avoid client/server time synchronization issues. */
          "X-RateLimit-Reset"?: number;
          [name: string]: unknown;
        };
        content: {
          "application/json": components["schemas"]["srcm.v2.Cluster"] & {
            spec: Record<string, unknown>;
          } & {
            spec?: {
              /** @example {
               *       "id": "env-00000",
               *       "related": "https://api.confluent.cloud/v2/environments/env-00000",
               *       "resource_name": "https://api.confluent.cloud/organization=9bb441c4-edef-46ac-8a41-c49e44a3fd9a/environment=env-00000"
               *     } */
              environment?: unknown;
              /** @example {
               *       "id": "sgreg-00000",
               *       "related": "https://api.confluent.cloud/srcm/v2/regions/sgreg-00000",
               *       "resource_name": "https://api.confluent.cloud/organization=9bb441c4-edef-46ac-8a41-c49e44a3fd9a/region=sgreg-00000"
               *     } */
              region?: unknown;
            };
          };
        };
      };
      400: components["responses"]["BadRequestError"];
      401: components["responses"]["UnauthenticatedError"];
      403: components["responses"]["UnauthorizedError"];
      404: components["responses"]["NotFoundError"];
      409: components["responses"]["ConflictError"];
      422: components["responses"]["ValidationError"];
      429: components["responses"]["RateLimitError"];
      500: components["responses"]["DefaultSystemError"];
    };
  };
  listSrcmV3Clusters: {
    parameters: {
      query: {
        /**
         * @description Filter the results by exact match for environment.
         * @example env-00000
         */
        environment: components["schemas"]["SearchFilter"];
        /** @description A pagination size for collection requests. */
        page_size?: number;
        /** @description An opaque pagination token for collection requests. */
        page_token?: string;
      };
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description Cluster. */
      200: {
        headers: {
          /** @description The unique identifier for the API request. */
          "X-Request-Id"?: string;
          /** @description The maximum number of requests you're permitted to make per time period. */
          "X-RateLimit-Limit"?: number;
          /** @description The number of requests remaining in the current rate limit window. */
          "X-RateLimit-Remaining"?: number;
          /** @description The relative time in seconds until the current rate-limit window resets.
           *
           *     **Important:** This differs from Github and Twitter's same-named header which uses UTC epoch seconds. We use relative time to avoid client/server time synchronization issues. */
          "X-RateLimit-Reset"?: number;
          [name: string]: unknown;
        };
        content: {
          "application/json": components["schemas"]["srcm.v3.ClusterList"] & {
            data?: {
              spec?: {
                /** @example {
                 *       "id": "env-00000",
                 *       "related": "https://api.confluent.cloud/v2/environments/env-00000",
                 *       "resource_name": "https://api.confluent.cloud/organization=9bb441c4-edef-46ac-8a41-c49e44a3fd9a/environment=env-00000"
                 *     } */
                environment?: unknown;
              };
            }[];
          };
        };
      };
      400: components["responses"]["BadRequestError"];
      401: components["responses"]["UnauthenticatedError"];
      403: components["responses"]["UnauthorizedError"];
      429: components["responses"]["RateLimitError"];
      500: components["responses"]["DefaultSystemError"];
    };
  };
  getSrcmV3Cluster: {
    parameters: {
      query: {
        /**
         * @description Scope the operation to the given environment.
         * @example env-00000
         */
        environment: components["schemas"]["SearchFilter"];
      };
      header?: never;
      path: {
        /** @description The unique identifier for the cluster. */
        id: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description Cluster. */
      200: {
        headers: {
          /** @description The unique identifier for the API request. */
          "X-Request-Id"?: string;
          /** @description The maximum number of requests you're permitted to make per time period. */
          "X-RateLimit-Limit"?: number;
          /** @description The number of requests remaining in the current rate limit window. */
          "X-RateLimit-Remaining"?: number;
          /** @description The relative time in seconds until the current rate-limit window resets.
           *
           *     **Important:** This differs from Github and Twitter's same-named header which uses UTC epoch seconds. We use relative time to avoid client/server time synchronization issues. */
          "X-RateLimit-Reset"?: number;
          [name: string]: unknown;
        };
        content: {
          "application/json": components["schemas"]["srcm.v3.Cluster"] & {
            spec: Record<string, unknown>;
          } & {
            spec?: {
              /** @example {
               *       "id": "env-00000",
               *       "related": "https://api.confluent.cloud/v2/environments/env-00000",
               *       "resource_name": "https://api.confluent.cloud/organization=9bb441c4-edef-46ac-8a41-c49e44a3fd9a/environment=env-00000"
               *     } */
              environment?: unknown;
            };
          };
        };
      };
      400: components["responses"]["BadRequestError"];
      401: components["responses"]["UnauthenticatedError"];
      403: components["responses"]["UnauthorizedError"];
      404: components["responses"]["NotFoundError"];
      429: components["responses"]["RateLimitError"];
      500: components["responses"]["DefaultSystemError"];
    };
  };
  getClusterConfig: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description The cluster config */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "application/vnd.schemaregistry.v1+json": components["schemas"]["ClusterConfig"];
          "application/vnd.schemaregistry+json; qs=0.9": components["schemas"]["ClusterConfig"];
          "application/json; qs=0.5": components["schemas"]["ClusterConfig"];
        };
      };
      400: components["responses"]["schemaregistry.v1.BadRequestError"];
      401: components["responses"]["schemaregistry.v1.UnauthorizedError"];
      403: components["responses"]["schemaregistry.v1.ForbiddenError"];
      429: components["responses"]["RateLimitError"];
      500: components["responses"]["schemaregistry.v1.DefaultSystemError"];
    };
  };
  testCompatibilityBySubjectName: {
    parameters: {
      query?: {
        /** @description Whether to return detailed error messages */
        verbose?: boolean;
      };
      header?: never;
      path: {
        /** @description Subject of the schema version against which compatibility is to be tested */
        subject: string;
        /** @description Version of the subject's schema against which compatibility is to be tested. Valid values for versionId are between [1,2^31-1] or the string "latest"."latest" checks compatibility of the input schema with the last registered schema under the specified subject */
        version: string;
      };
      cookie?: never;
    };
    /** @description Schema */
    requestBody: {
      content: {
        "application/vnd.schemaregistry.v1+json": components["schemas"]["RegisterSchemaRequest"];
        "application/vnd.schemaregistry+json": components["schemas"]["RegisterSchemaRequest"];
        "application/json": components["schemas"]["RegisterSchemaRequest"];
        "application/octet-stream": components["schemas"]["RegisterSchemaRequest"];
      };
    };
    responses: {
      /** @description Compatibility check result. */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "application/vnd.schemaregistry.v1+json": components["schemas"]["CompatibilityCheckResponse"];
          "application/vnd.schemaregistry+json; qs=0.9": components["schemas"]["CompatibilityCheckResponse"];
          "application/json; qs=0.5": components["schemas"]["CompatibilityCheckResponse"];
        };
      };
      400: components["responses"]["schemaregistry.v1.BadRequestError"];
      401: components["responses"]["schemaregistry.v1.UnauthorizedError"];
      403: components["responses"]["schemaregistry.v1.ForbiddenError"];
      /** @description Not Found. Error code 40401 indicates subject not found. Error code 40402 indicates version not found. */
      404: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "application/vnd.schemaregistry.v1+json": components["schemas"]["ErrorMessage"];
          "application/vnd.schemaregistry+json; qs=0.9": components["schemas"]["ErrorMessage"];
          "application/json; qs=0.5": components["schemas"]["ErrorMessage"];
        };
      };
      /** @description Unprocessable entity. Error code 42201 indicates an invalid schema or schema type. Error code 42202 indicates an invalid version. */
      422: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "application/vnd.schemaregistry.v1+json": components["schemas"]["ErrorMessage"];
          "application/vnd.schemaregistry+json; qs=0.9": components["schemas"]["ErrorMessage"];
          "application/json; qs=0.5": components["schemas"]["ErrorMessage"];
        };
      };
      429: components["responses"]["RateLimitError"];
      /** @description Internal Server Error. Error code 50001 indicates a failure in the backend data store. */
      500: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "application/vnd.schemaregistry.v1+json": components["schemas"]["ErrorMessage"];
          "application/vnd.schemaregistry+json; qs=0.9": components["schemas"]["ErrorMessage"];
          "application/json; qs=0.5": components["schemas"]["ErrorMessage"];
        };
      };
    };
  };
  testCompatibilityForSubject: {
    parameters: {
      query?: {
        /** @description Whether to return detailed error messages */
        verbose?: boolean;
      };
      header?: never;
      path: {
        /** @description Subject of the schema version against which compatibility is to be tested */
        subject: string;
      };
      cookie?: never;
    };
    /** @description Schema */
    requestBody: {
      content: {
        "application/vnd.schemaregistry.v1+json": components["schemas"]["RegisterSchemaRequest"];
        "application/vnd.schemaregistry+json": components["schemas"]["RegisterSchemaRequest"];
        "application/json": components["schemas"]["RegisterSchemaRequest"];
        "application/octet-stream": components["schemas"]["RegisterSchemaRequest"];
      };
    };
    responses: {
      /** @description Compatibility check result. */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "application/vnd.schemaregistry.v1+json": components["schemas"]["CompatibilityCheckResponse"];
          "application/vnd.schemaregistry+json; qs=0.9": components["schemas"]["CompatibilityCheckResponse"];
          "application/json; qs=0.5": components["schemas"]["CompatibilityCheckResponse"];
        };
      };
      400: components["responses"]["schemaregistry.v1.BadRequestError"];
      401: components["responses"]["schemaregistry.v1.UnauthorizedError"];
      403: components["responses"]["schemaregistry.v1.ForbiddenError"];
      429: components["responses"]["RateLimitError"];
      /** @description Internal Server Error. Error code 50001 indicates a failure in the backend data store. */
      500: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "application/vnd.schemaregistry.v1+json": components["schemas"]["ErrorMessage"];
          "application/vnd.schemaregistry+json; qs=0.9": components["schemas"]["ErrorMessage"];
          "application/json; qs=0.5": components["schemas"]["ErrorMessage"];
        };
      };
    };
  };
  getSubjectLevelConfig: {
    parameters: {
      query?: {
        /** @description Whether to return the global compatibility level  if subject compatibility level not found */
        defaultToGlobal?: boolean;
      };
      header?: never;
      path: {
        /** @description Name of the subject */
        subject: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description The subject compatibility level. */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "application/vnd.schemaregistry.v1+json": components["schemas"]["Config"];
          "application/vnd.schemaregistry+json; qs=0.9": components["schemas"]["Config"];
          "application/json; qs=0.5": components["schemas"]["Config"];
        };
      };
      400: components["responses"]["schemaregistry.v1.BadRequestError"];
      401: components["responses"]["schemaregistry.v1.UnauthorizedError"];
      403: components["responses"]["schemaregistry.v1.ForbiddenError"];
      /** @description Not Found. Error code 40401 indicates subject not found. */
      404: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "application/vnd.schemaregistry.v1+json": components["schemas"]["ErrorMessage"];
          "application/vnd.schemaregistry+json; qs=0.9": components["schemas"]["ErrorMessage"];
          "application/json; qs=0.5": components["schemas"]["ErrorMessage"];
        };
      };
      429: components["responses"]["RateLimitError"];
      /** @description Internal Server Error. Error code 50001 indicates a failure in the backend data store. */
      500: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "application/vnd.schemaregistry.v1+json": components["schemas"]["ErrorMessage"];
          "application/vnd.schemaregistry+json; qs=0.9": components["schemas"]["ErrorMessage"];
          "application/json; qs=0.5": components["schemas"]["ErrorMessage"];
        };
      };
    };
  };
  updateSubjectLevelConfig: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Name of the subject */
        subject: string;
      };
      cookie?: never;
    };
    /** @description Config Update Request */
    requestBody: {
      content: {
        "application/vnd.schemaregistry.v1+json": components["schemas"]["ConfigUpdateRequest"];
        "application/vnd.schemaregistry+json": components["schemas"]["ConfigUpdateRequest"];
        "application/json": components["schemas"]["ConfigUpdateRequest"];
        "application/octet-stream": components["schemas"]["ConfigUpdateRequest"];
      };
    };
    responses: {
      /** @description The original request. */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "application/vnd.schemaregistry.v1+json": components["schemas"]["ConfigUpdateRequest"];
          "application/vnd.schemaregistry+json; qs=0.9": components["schemas"]["ConfigUpdateRequest"];
          "application/json; qs=0.5": components["schemas"]["ConfigUpdateRequest"];
        };
      };
      400: components["responses"]["schemaregistry.v1.BadRequestError"];
      401: components["responses"]["schemaregistry.v1.UnauthorizedError"];
      403: components["responses"]["schemaregistry.v1.ForbiddenError"];
      /** @description Unprocessable Entity. Error code 42203 indicates invalid compatibility level. */
      422: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "application/vnd.schemaregistry.v1+json": components["schemas"]["ErrorMessage"];
          "application/vnd.schemaregistry+json; qs=0.9": components["schemas"]["ErrorMessage"];
          "application/json; qs=0.5": components["schemas"]["ErrorMessage"];
        };
      };
      429: components["responses"]["RateLimitError"];
      /** @description Internal Server Error. Error code 50001 indicates a failure in the backend data store. Error code 50003 indicates a failure forwarding the request to the primary. */
      500: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "application/vnd.schemaregistry.v1+json": components["schemas"]["ErrorMessage"];
          "application/vnd.schemaregistry+json; qs=0.9": components["schemas"]["ErrorMessage"];
          "application/json; qs=0.5": components["schemas"]["ErrorMessage"];
        };
      };
    };
  };
  deleteSubjectConfig: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Name of the subject */
        subject: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description Operation succeeded. Returns old compatibility level. */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "application/vnd.schemaregistry.v1+json": string;
          "application/vnd.schemaregistry+json; qs=0.9": string;
          "application/json; qs=0.5": string;
        };
      };
      400: components["responses"]["schemaregistry.v1.BadRequestError"];
      401: components["responses"]["schemaregistry.v1.UnauthorizedError"];
      403: components["responses"]["schemaregistry.v1.ForbiddenError"];
      /** @description Not Found. Error code 40401 indicates subject not found. */
      404: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "application/vnd.schemaregistry.v1+json": components["schemas"]["ErrorMessage"];
          "application/vnd.schemaregistry+json; qs=0.9": components["schemas"]["ErrorMessage"];
          "application/json; qs=0.5": components["schemas"]["ErrorMessage"];
        };
      };
      429: components["responses"]["RateLimitError"];
      /** @description Internal Server Error. Error code 50001 indicates a failure in the backend data store. */
      500: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "application/vnd.schemaregistry.v1+json": components["schemas"]["ErrorMessage"];
          "application/vnd.schemaregistry+json; qs=0.9": components["schemas"]["ErrorMessage"];
          "application/json; qs=0.5": components["schemas"]["ErrorMessage"];
        };
      };
    };
  };
  getTopLevelConfig: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description The global compatibility level. */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "application/vnd.schemaregistry.v1+json": components["schemas"]["Config"];
          "application/vnd.schemaregistry+json; qs=0.9": components["schemas"]["Config"];
          "application/json; qs=0.5": components["schemas"]["Config"];
        };
      };
      400: components["responses"]["schemaregistry.v1.BadRequestError"];
      401: components["responses"]["schemaregistry.v1.UnauthorizedError"];
      403: components["responses"]["schemaregistry.v1.ForbiddenError"];
      429: components["responses"]["RateLimitError"];
      /** @description Internal Server Error. Error code 50001 indicates a failure in the backend data store. */
      500: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "application/vnd.schemaregistry.v1+json": components["schemas"]["ErrorMessage"];
          "application/vnd.schemaregistry+json; qs=0.9": components["schemas"]["ErrorMessage"];
          "application/json; qs=0.5": components["schemas"]["ErrorMessage"];
        };
      };
    };
  };
  updateTopLevelConfig: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /** @description Config Update Request */
    requestBody: {
      content: {
        "application/vnd.schemaregistry.v1+json": components["schemas"]["ConfigUpdateRequest"];
        "application/vnd.schemaregistry+json": components["schemas"]["ConfigUpdateRequest"];
        "application/json": components["schemas"]["ConfigUpdateRequest"];
        "application/octet-stream": components["schemas"]["ConfigUpdateRequest"];
      };
    };
    responses: {
      /** @description The original request. */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "application/vnd.schemaregistry.v1+json": components["schemas"]["ConfigUpdateRequest"];
          "application/vnd.schemaregistry+json; qs=0.9": components["schemas"]["ConfigUpdateRequest"];
          "application/json; qs=0.5": components["schemas"]["ConfigUpdateRequest"];
        };
      };
      400: components["responses"]["schemaregistry.v1.BadRequestError"];
      401: components["responses"]["schemaregistry.v1.UnauthorizedError"];
      403: components["responses"]["schemaregistry.v1.ForbiddenError"];
      /** @description Unprocessable Entity. Error code 42203 indicates invalid compatibility level. */
      422: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "application/vnd.schemaregistry.v1+json": components["schemas"]["ErrorMessage"];
          "application/vnd.schemaregistry+json; qs=0.9": components["schemas"]["ErrorMessage"];
          "application/json; qs=0.5": components["schemas"]["ErrorMessage"];
        };
      };
      429: components["responses"]["RateLimitError"];
      /** @description Internal Server Error. Error code 50001 indicates a failure in the backend data store. Error code 50003 indicates a failure forwarding the request to the primary. */
      500: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "application/vnd.schemaregistry.v1+json": components["schemas"]["ErrorMessage"];
          "application/vnd.schemaregistry+json; qs=0.9": components["schemas"]["ErrorMessage"];
          "application/json; qs=0.5": components["schemas"]["ErrorMessage"];
        };
      };
    };
  };
  deleteTopLevelConfig: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description Operation succeeded. Returns old global compatibility level. */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          /** @example FULL_TRANSITIVE */
          "application/vnd.schemaregistry.v1+json": string;
          /** @example FULL_TRANSITIVE */
          "application/vnd.schemaregistry+json; qs=0.9": string;
          /** @example FULL_TRANSITIVE */
          "application/json; qs=0.5": string;
        };
      };
      400: components["responses"]["schemaregistry.v1.BadRequestError"];
      401: components["responses"]["schemaregistry.v1.UnauthorizedError"];
      403: components["responses"]["schemaregistry.v1.ForbiddenError"];
      429: components["responses"]["RateLimitError"];
      /** @description Internal Server Error. Error code 50001 indicates a failure in the backend data store. */
      500: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "application/vnd.schemaregistry.v1+json": components["schemas"]["ErrorMessage"];
          "application/vnd.schemaregistry+json; qs=0.9": components["schemas"]["ErrorMessage"];
          "application/json; qs=0.5": components["schemas"]["ErrorMessage"];
        };
      };
    };
  };
  listExporters: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description Name of the exporter */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "application/vnd.schemaregistry.v1+json": string[];
        };
      };
      400: components["responses"]["schemaregistry.v1.BadRequestError"];
      401: components["responses"]["schemaregistry.v1.UnauthorizedError"];
      403: components["responses"]["schemaregistry.v1.ForbiddenError"];
      429: components["responses"]["RateLimitError"];
      500: components["responses"]["schemaregistry.v1.DefaultSystemError"];
    };
  };
  registerExporter: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /** @description Schema */
    requestBody: {
      content: {
        "application/vnd.schemaregistry.v1+json": components["schemas"]["ExporterReference"];
        "application/vnd.schemaregistry+json": components["schemas"]["ExporterReference"];
        "application/json": components["schemas"]["ExporterReference"];
      };
    };
    responses: {
      /** @description Schema successfully registered. */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "application/json; qs=0.5": components["schemas"]["ExporterResponse"];
        };
      };
      400: components["responses"]["schemaregistry.v1.BadRequestError"];
      401: components["responses"]["schemaregistry.v1.UnauthorizedError"];
      403: components["responses"]["schemaregistry.v1.ForbiddenError"];
      /** @description Conflict. Error code 40950 – Missing or invalid exporter name \ Error code 40951 – Missing or invalid exporter config \ Error code 40952 – Invalid exporter subjects \ Error code 40960 – Exporter already exists \ Error code 40964 – Too many exporters */
      409: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "application/vnd.schemaregistry.v1+json": components["schemas"]["ErrorMessage"];
          "application/vnd.schemaregistry+json; qs=0.9": components["schemas"]["ErrorMessage"];
          "application/json; qs=0.5": components["schemas"]["ErrorMessage"];
        };
      };
      429: components["responses"]["RateLimitError"];
      500: components["responses"]["schemaregistry.v1.DefaultSystemError"];
    };
  };
  getExporterInfoByName: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Name of the exporter */
        name: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description The original request. */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "application/vnd.schemaregistry.v1+json": components["schemas"]["ExporterReference"];
        };
      };
      400: components["responses"]["schemaregistry.v1.BadRequestError"];
      401: components["responses"]["schemaregistry.v1.UnauthorizedError"];
      403: components["responses"]["schemaregistry.v1.ForbiddenError"];
      /** @description Not Found. Error code 40450 – Exporter not found */
      404: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "application/vnd.schemaregistry.v1+json": components["schemas"]["ErrorMessage"];
        };
      };
      429: components["responses"]["RateLimitError"];
      500: components["responses"]["schemaregistry.v1.DefaultSystemError"];
    };
  };
  updateExporterInfo: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Name of the exporter */
        name: string;
      };
      cookie?: never;
    };
    /** @description Exporter Update Request */
    requestBody: {
      content: {
        "application/vnd.schemaregistry.v1+json": components["schemas"]["ExporterUpdateRequest"];
        "application/vnd.schemaregistry+json": components["schemas"]["ExporterUpdateRequest"];
        "application/json": components["schemas"]["ExporterUpdateRequest"];
      };
    };
    responses: {
      /** @description The original request. */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "application/vnd.schemaregistry.v1+json": components["schemas"]["ExporterResponse"];
        };
      };
      400: components["responses"]["schemaregistry.v1.BadRequestError"];
      401: components["responses"]["schemaregistry.v1.UnauthorizedError"];
      403: components["responses"]["schemaregistry.v1.ForbiddenError"];
      /** @description Not Found. Error code 40401 indicates subject not found. */
      404: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "application/vnd.schemaregistry.v1+json": components["schemas"]["ErrorMessage"];
        };
      };
      /** @description Invalid. Error code 40952 – Invalid exporter subjects. Error code 40963 – Exporter not paused. */
      409: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "application/vnd.schemaregistry.v1+json": components["schemas"]["ErrorMessage"];
        };
      };
      429: components["responses"]["RateLimitError"];
      500: components["responses"]["schemaregistry.v1.DefaultSystemError"];
    };
  };
  deleteExporter: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Name of the exporter */
        name: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description No content. */
      204: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
      400: components["responses"]["schemaregistry.v1.BadRequestError"];
      401: components["responses"]["schemaregistry.v1.UnauthorizedError"];
      403: components["responses"]["schemaregistry.v1.ForbiddenError"];
      404: components["responses"]["schemaregistry.v1.AccountNotFoundError"];
      429: components["responses"]["RateLimitError"];
      500: components["responses"]["schemaregistry.v1.DefaultSystemError"];
    };
  };
  getExporterStatusByName: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Name of the exporter */
        name: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description The original request. */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "application/vnd.schemaregistry.v1+json": components["schemas"]["ExporterStatusResponse"];
        };
      };
      400: components["responses"]["schemaregistry.v1.BadRequestError"];
      401: components["responses"]["schemaregistry.v1.UnauthorizedError"];
      403: components["responses"]["schemaregistry.v1.ForbiddenError"];
      /** @description Not Found. Error code 40450 – Exporter not found */
      404: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "application/vnd.schemaregistry.v1+json": components["schemas"]["ErrorMessage"];
        };
      };
      429: components["responses"]["RateLimitError"];
      500: components["responses"]["schemaregistry.v1.DefaultSystemError"];
    };
  };
  getExporterConfigByName: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Name of the exporter */
        name: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description The original request */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "application/vnd.schemaregistry.v1+json": components["schemas"]["ExporterConfigResponse"];
        };
      };
      400: components["responses"]["schemaregistry.v1.BadRequestError"];
      401: components["responses"]["schemaregistry.v1.UnauthorizedError"];
      403: components["responses"]["schemaregistry.v1.ForbiddenError"];
      /** @description Not Found. Error code 40450 – Exporter not found */
      404: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "application/vnd.schemaregistry.v1+json": components["schemas"]["ErrorMessage"];
        };
      };
      429: components["responses"]["RateLimitError"];
      500: components["responses"]["schemaregistry.v1.DefaultSystemError"];
    };
  };
  updateExporterConfigByName: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Name of the exporter */
        name: string;
      };
      cookie?: never;
    };
    /** @description Exporter Update Request */
    requestBody: {
      content: {
        "application/vnd.schemaregistry.v1+json": components["schemas"]["ExporterConfigResponse"];
        "application/vnd.schemaregistry+json": components["schemas"]["ExporterConfigResponse"];
        "application/json": components["schemas"]["ExporterConfigResponse"];
      };
    };
    responses: {
      /** @description The original request. */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "application/vnd.schemaregistry.v1+json": components["schemas"]["ExporterResponse"];
        };
      };
      400: components["responses"]["schemaregistry.v1.BadRequestError"];
      401: components["responses"]["schemaregistry.v1.UnauthorizedError"];
      403: components["responses"]["schemaregistry.v1.ForbiddenError"];
      /** @description Not Found. Error code 40401 indicates subject not found. */
      404: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "application/vnd.schemaregistry.v1+json": components["schemas"]["ErrorMessage"];
        };
      };
      /** @description Invalid. Error code 40952 – Invalid exporter subjects. Error code 40963 – Exporter not paused. */
      409: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "application/vnd.schemaregistry.v1+json": components["schemas"]["ErrorMessage"];
        };
      };
      429: components["responses"]["RateLimitError"];
      500: components["responses"]["schemaregistry.v1.DefaultSystemError"];
    };
  };
  pauseExporterByName: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Name of the exporter */
        name: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description The original request. */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "application/vnd.schemaregistry.v1+json": components["schemas"]["ExporterResponse"];
        };
      };
      400: components["responses"]["schemaregistry.v1.BadRequestError"];
      401: components["responses"]["schemaregistry.v1.UnauthorizedError"];
      403: components["responses"]["schemaregistry.v1.ForbiddenError"];
      /** @description Not Found. Error code 40401 indicates subject not found. */
      404: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "application/vnd.schemaregistry.v1+json": components["schemas"]["ErrorMessage"];
        };
      };
      /** @description Invalid. Error code 40952 – Invalid exporter subjects. Error code 40963 – Exporter not paused. */
      409: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "application/vnd.schemaregistry.v1+json": components["schemas"]["ErrorMessage"];
        };
      };
      429: components["responses"]["RateLimitError"];
      500: components["responses"]["schemaregistry.v1.DefaultSystemError"];
    };
  };
  resetExporterByName: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Name of the exporter */
        name: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description The original request. */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "application/vnd.schemaregistry.v1+json": components["schemas"]["ExporterResponse"];
        };
      };
      400: components["responses"]["schemaregistry.v1.BadRequestError"];
      401: components["responses"]["schemaregistry.v1.UnauthorizedError"];
      403: components["responses"]["schemaregistry.v1.ForbiddenError"];
      /** @description Not Found. Error code 40450 – Exporter not found */
      404: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "application/vnd.schemaregistry.v1+json": components["schemas"]["ErrorMessage"];
        };
      };
      /** @description Invalid. Error code 40963 – Exporter not paused. */
      409: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "application/vnd.schemaregistry.v1+json": components["schemas"]["ErrorMessage"];
        };
      };
      429: components["responses"]["RateLimitError"];
      500: components["responses"]["schemaregistry.v1.DefaultSystemError"];
    };
  };
  resumeExporterByName: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Name of the exporter */
        name: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description The original request. */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "application/vnd.schemaregistry.v1+json": components["schemas"]["ExporterResponse"];
        };
      };
      400: components["responses"]["schemaregistry.v1.BadRequestError"];
      401: components["responses"]["schemaregistry.v1.UnauthorizedError"];
      403: components["responses"]["schemaregistry.v1.ForbiddenError"];
      /** @description Not Found. Error code 40450 indicates subject not found. */
      404: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "application/vnd.schemaregistry.v1+json": components["schemas"]["ErrorMessage"];
        };
      };
      /** @description Invalid. Error code 40961 – Exporter already running. */
      409: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "application/vnd.schemaregistry.v1+json": components["schemas"]["ErrorMessage"];
        };
      };
      429: components["responses"]["RateLimitError"];
      500: components["responses"]["schemaregistry.v1.DefaultSystemError"];
    };
  };
  listContexts: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description The contexts. */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "application/vnd.schemaregistry.v1+json": string[];
          "application/vnd.schemaregistry+json; qs=0.9": string[];
          "application/json; qs=0.5": string[];
        };
      };
      400: components["responses"]["schemaregistry.v1.BadRequestError"];
      401: components["responses"]["schemaregistry.v1.UnauthorizedError"];
      403: components["responses"]["schemaregistry.v1.ForbiddenError"];
      429: components["responses"]["RateLimitError"];
      /** @description Internal Server Error. Error code 50001 indicates a failure in the backend data store.  */
      500: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "application/vnd.schemaregistry.v1+json": components["schemas"]["ErrorMessage"];
          "application/vnd.schemaregistry+json; qs=0.9": components["schemas"]["ErrorMessage"];
          "application/json; qs=0.5": components["schemas"]["ErrorMessage"];
        };
      };
    };
  };
  getMode: {
    parameters: {
      query?: {
        /** @description Whether to return the global mode if subject mode not found */
        defaultToGlobal?: boolean;
      };
      header?: never;
      path: {
        /** @description Name of the subject */
        subject: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description The subject mode. */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "application/vnd.schemaregistry.v1+json": components["schemas"]["Mode"];
          "application/vnd.schemaregistry+json; qs=0.9": components["schemas"]["Mode"];
          "application/json; qs=0.5": components["schemas"]["Mode"];
        };
      };
      400: components["responses"]["schemaregistry.v1.BadRequestError"];
      401: components["responses"]["schemaregistry.v1.UnauthorizedError"];
      403: components["responses"]["schemaregistry.v1.ForbiddenError"];
      /** @description Not Found. Error code 40401 indicates subject not found. */
      404: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "application/vnd.schemaregistry.v1+json": components["schemas"]["ErrorMessage"];
          "application/vnd.schemaregistry+json; qs=0.9": components["schemas"]["ErrorMessage"];
          "application/json; qs=0.5": components["schemas"]["ErrorMessage"];
        };
      };
      429: components["responses"]["RateLimitError"];
      /** @description Internal Server Error. Error code 50001 indicates a failure in the backend data store. */
      500: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "application/vnd.schemaregistry.v1+json": components["schemas"]["ErrorMessage"];
          "application/vnd.schemaregistry+json; qs=0.9": components["schemas"]["ErrorMessage"];
          "application/json; qs=0.5": components["schemas"]["ErrorMessage"];
        };
      };
    };
  };
  updateMode: {
    parameters: {
      query?: {
        /** @description Whether to force update if setting mode to IMPORT and schemas currently exist */
        force?: boolean;
      };
      header?: never;
      path: {
        /** @description Name of the subject */
        subject: string;
      };
      cookie?: never;
    };
    /** @description Update Request */
    requestBody: {
      content: {
        "application/vnd.schemaregistry.v1+json": components["schemas"]["ModeUpdateRequest"];
        "application/vnd.schemaregistry+json": components["schemas"]["ModeUpdateRequest"];
        "application/json": components["schemas"]["ModeUpdateRequest"];
        "application/octet-stream": components["schemas"]["ModeUpdateRequest"];
      };
    };
    responses: {
      /** @description The original request. */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "application/vnd.schemaregistry.v1+json": components["schemas"]["ModeUpdateRequest"];
          "application/vnd.schemaregistry+json; qs=0.9": components["schemas"]["ModeUpdateRequest"];
          "application/json; qs=0.5": components["schemas"]["ModeUpdateRequest"];
        };
      };
      400: components["responses"]["schemaregistry.v1.BadRequestError"];
      401: components["responses"]["schemaregistry.v1.UnauthorizedError"];
      403: components["responses"]["schemaregistry.v1.ForbiddenError"];
      /** @description Unprocessable Entity. Error code 42204 indicates an invalid mode. Error code 42205 indicates operation not permitted. */
      422: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "application/vnd.schemaregistry.v1+json": components["schemas"]["ErrorMessage"];
          "application/vnd.schemaregistry+json; qs=0.9": components["schemas"]["ErrorMessage"];
          "application/json; qs=0.5": components["schemas"]["ErrorMessage"];
        };
      };
      429: components["responses"]["RateLimitError"];
      /** @description Internal Server Error. Error code 50001 indicates a failure in the backend data store. Error code 50003 indicates a failure forwarding the request to the primary. Error code 50004 indicates unknown leader. */
      500: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "application/vnd.schemaregistry.v1+json": components["schemas"]["ErrorMessage"];
          "application/vnd.schemaregistry+json; qs=0.9": components["schemas"]["ErrorMessage"];
          "application/json; qs=0.5": components["schemas"]["ErrorMessage"];
        };
      };
    };
  };
  deleteSubjectMode: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Name of the subject */
        subject: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description Operation succeeded. Returns old mode. */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "application/vnd.schemaregistry.v1+json": components["schemas"]["Mode"];
          "application/vnd.schemaregistry+json; qs=0.9": components["schemas"]["Mode"];
          "application/json; qs=0.5": components["schemas"]["Mode"];
        };
      };
      400: components["responses"]["schemaregistry.v1.BadRequestError"];
      401: components["responses"]["schemaregistry.v1.UnauthorizedError"];
      403: components["responses"]["schemaregistry.v1.ForbiddenError"];
      /** @description Not Found. Error code 40401 indicates subject not found. */
      404: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "application/vnd.schemaregistry.v1+json": components["schemas"]["ErrorMessage"];
          "application/vnd.schemaregistry+json; qs=0.9": components["schemas"]["ErrorMessage"];
          "application/json; qs=0.5": components["schemas"]["ErrorMessage"];
        };
      };
      429: components["responses"]["RateLimitError"];
      /** @description Internal Server Error. Error code 50001 indicates a failure in the backend data store. */
      500: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "application/vnd.schemaregistry.v1+json": components["schemas"]["ErrorMessage"];
          "application/vnd.schemaregistry+json; qs=0.9": components["schemas"]["ErrorMessage"];
          "application/json; qs=0.5": components["schemas"]["ErrorMessage"];
        };
      };
    };
  };
  getTopLevelMode: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description The global mode */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "application/vnd.schemaregistry.v1+json": components["schemas"]["Mode"];
          "application/vnd.schemaregistry+json; qs=0.9": components["schemas"]["Mode"];
          "application/json; qs=0.5": components["schemas"]["Mode"];
        };
      };
      400: components["responses"]["schemaregistry.v1.BadRequestError"];
      401: components["responses"]["schemaregistry.v1.UnauthorizedError"];
      403: components["responses"]["schemaregistry.v1.ForbiddenError"];
      429: components["responses"]["RateLimitError"];
      /** @description Error code 50001 -- Error in the backend data store */
      500: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  updateTopLevelMode: {
    parameters: {
      query?: {
        /** @description Whether to force update if setting mode to IMPORT and schemas currently exist */
        force?: boolean;
      };
      header?: never;
      path?: never;
      cookie?: never;
    };
    /** @description Update Request */
    requestBody: {
      content: {
        "application/vnd.schemaregistry.v1+json": components["schemas"]["ModeUpdateRequest"];
        "application/vnd.schemaregistry+json": components["schemas"]["ModeUpdateRequest"];
        "application/json": components["schemas"]["ModeUpdateRequest"];
        "application/octet-stream": components["schemas"]["ModeUpdateRequest"];
      };
    };
    responses: {
      /** @description The original request. */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "application/vnd.schemaregistry.v1+json": components["schemas"]["ModeUpdateRequest"];
          "application/vnd.schemaregistry+json; qs=0.9": components["schemas"]["ModeUpdateRequest"];
          "application/json; qs=0.5": components["schemas"]["ModeUpdateRequest"];
        };
      };
      400: components["responses"]["schemaregistry.v1.BadRequestError"];
      401: components["responses"]["schemaregistry.v1.UnauthorizedError"];
      403: components["responses"]["schemaregistry.v1.ForbiddenError"];
      /** @description Unprocessable Entity. Error code 42204 indicates an invalid mode. Error code 42205 indicates operation not permitted. */
      422: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "application/vnd.schemaregistry.v1+json": components["schemas"]["ErrorMessage"];
          "application/vnd.schemaregistry+json; qs=0.9": components["schemas"]["ErrorMessage"];
          "application/json; qs=0.5": components["schemas"]["ErrorMessage"];
        };
      };
      429: components["responses"]["RateLimitError"];
      /** @description Internal Server Error. Error code 50001 indicates a failure in the backend data store. Error code 50003 indicates a failure forwarding the request to the primary. Error code 50004 indicates unknown leader. */
      500: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "application/vnd.schemaregistry.v1+json": components["schemas"]["ErrorMessage"];
          "application/vnd.schemaregistry+json; qs=0.9": components["schemas"]["ErrorMessage"];
          "application/json; qs=0.5": components["schemas"]["ErrorMessage"];
        };
      };
    };
  };
  getSchema: {
    parameters: {
      query?: {
        /** @description Name of the subject */
        subject?: string;
        /** @description Desired output format, dependent on schema type */
        format?: string;
        /** @description Whether to fetch the maximum schema identifier that exists */
        fetchMaxId?: boolean;
      };
      header?: never;
      path: {
        /** @description Globally unique identifier of the schema */
        id: number;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description The schema string. */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "application/vnd.schemaregistry.v1+json": components["schemas"]["SchemaString"];
          "application/vnd.schemaregistry+json; qs=0.9": components["schemas"]["SchemaString"];
          "application/json; qs=0.5": components["schemas"]["SchemaString"];
        };
      };
      400: components["responses"]["schemaregistry.v1.BadRequestError"];
      401: components["responses"]["schemaregistry.v1.UnauthorizedError"];
      403: components["responses"]["schemaregistry.v1.ForbiddenError"];
      /** @description Not Found. Error code 40403 indicates schema not found. */
      404: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "application/vnd.schemaregistry.v1+json": components["schemas"]["ErrorMessage"];
          "application/vnd.schemaregistry+json; qs=0.9": components["schemas"]["ErrorMessage"];
          "application/json; qs=0.5": components["schemas"]["ErrorMessage"];
        };
      };
      429: components["responses"]["RateLimitError"];
      /** @description Internal Server Error. Error code 50001 indicates a failure in the backend data store. */
      500: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "application/vnd.schemaregistry.v1+json": components["schemas"]["ErrorMessage"];
          "application/vnd.schemaregistry+json; qs=0.9": components["schemas"]["ErrorMessage"];
          "application/json; qs=0.5": components["schemas"]["ErrorMessage"];
        };
      };
    };
  };
  getSchemaOnly: {
    parameters: {
      query?: {
        /** @description Name of the subject */
        subject?: string;
        /** @description Desired output format, dependent on schema type */
        format?: string;
      };
      header?: never;
      path: {
        /** @description Globally unique identifier of the schema */
        id: number;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description Raw schema string. */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "application/vnd.schemaregistry.v1+json": string;
          "application/vnd.schemaregistry+json; qs=0.9": string;
          "application/json; qs=0.5": string;
        };
      };
      400: components["responses"]["schemaregistry.v1.BadRequestError"];
      401: components["responses"]["schemaregistry.v1.UnauthorizedError"];
      403: components["responses"]["schemaregistry.v1.ForbiddenError"];
      /** @description Not Found. Error code 40403 indicates schema not found. */
      404: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "application/vnd.schemaregistry.v1+json": components["schemas"]["ErrorMessage"];
          "application/vnd.schemaregistry+json; qs=0.9": components["schemas"]["ErrorMessage"];
          "application/json; qs=0.5": components["schemas"]["ErrorMessage"];
        };
      };
      429: components["responses"]["RateLimitError"];
      /** @description Internal Server Error. Error code 50001 indicates a failure in the backend data store. */
      500: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "application/vnd.schemaregistry.v1+json": components["schemas"]["ErrorMessage"];
          "application/vnd.schemaregistry+json; qs=0.9": components["schemas"]["ErrorMessage"];
          "application/json; qs=0.5": components["schemas"]["ErrorMessage"];
        };
      };
    };
  };
  getSchemaTypes: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description List of supported schema types. */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "application/vnd.schemaregistry.v1+json": string[];
          "application/vnd.schemaregistry+json; qs=0.9": string[];
          "application/json; qs=0.5": string[];
        };
      };
      400: components["responses"]["schemaregistry.v1.BadRequestError"];
      401: components["responses"]["schemaregistry.v1.UnauthorizedError"];
      403: components["responses"]["schemaregistry.v1.ForbiddenError"];
      429: components["responses"]["RateLimitError"];
      /** @description Internal Server Error. Error code 50001 indicates a failure in the backend data store. */
      500: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "application/vnd.schemaregistry.v1+json": components["schemas"]["ErrorMessage"];
          "application/vnd.schemaregistry+json; qs=0.9": components["schemas"]["ErrorMessage"];
          "application/json; qs=0.5": components["schemas"]["ErrorMessage"];
        };
      };
    };
  };
  getSchemas: {
    parameters: {
      query?: {
        /** @description Filters results by the respective subject prefix */
        subjectPrefix?: string;
        /** @description Whether to return soft deleted schemas */
        deleted?: boolean;
        /** @description Whether to return latest schema versions only for each matching subject */
        latestOnly?: boolean;
        /** @description Pagination offset for results */
        offset?: number;
        /** @description Pagination size for results. Ignored if negative */
        limit?: number;
      };
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description List of schemas matching the specified parameters. */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "application/vnd.schemaregistry.v1+json": components["schemas"]["Schema"][];
          "application/vnd.schemaregistry+json; qs=0.9": components["schemas"]["Schema"][];
          "application/json; qs=0.5": components["schemas"]["Schema"][];
        };
      };
      400: components["responses"]["schemaregistry.v1.BadRequestError"];
      401: components["responses"]["schemaregistry.v1.UnauthorizedError"];
      403: components["responses"]["schemaregistry.v1.ForbiddenError"];
      429: components["responses"]["RateLimitError"];
      /** @description Internal Server Error. Error code 50001 indicates a failure in the backend data store. */
      500: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "application/vnd.schemaregistry.v1+json": components["schemas"]["ErrorMessage"];
          "application/vnd.schemaregistry+json; qs=0.9": components["schemas"]["ErrorMessage"];
          "application/json; qs=0.5": components["schemas"]["ErrorMessage"];
        };
      };
    };
  };
  getSubjects: {
    parameters: {
      query?: {
        /** @description Filters results by the respective subject */
        subject?: string;
        /** @description Whether to include subjects where the schema was deleted */
        deleted?: boolean;
      };
      header?: never;
      path: {
        /** @description Globally unique identifier of the schema */
        id: number;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description List of subjects matching the specified parameters. */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "application/vnd.schemaregistry.v1+json": string[];
          "application/vnd.schemaregistry+json; qs=0.9": string[];
          "application/json; qs=0.5": string[];
        };
      };
      400: components["responses"]["schemaregistry.v1.BadRequestError"];
      401: components["responses"]["schemaregistry.v1.UnauthorizedError"];
      403: components["responses"]["schemaregistry.v1.ForbiddenError"];
      /** @description Not Found. Error code 40403 indicates schema not found. */
      404: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "application/vnd.schemaregistry.v1+json": components["schemas"]["ErrorMessage"];
          "application/vnd.schemaregistry+json; qs=0.9": components["schemas"]["ErrorMessage"];
          "application/json; qs=0.5": components["schemas"]["ErrorMessage"];
        };
      };
      429: components["responses"]["RateLimitError"];
      /** @description Internal Server Error. Error code 50001 indicates a failure in the backend data store. */
      500: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "application/vnd.schemaregistry.v1+json": components["schemas"]["ErrorMessage"];
          "application/vnd.schemaregistry+json; qs=0.9": components["schemas"]["ErrorMessage"];
          "application/json; qs=0.5": components["schemas"]["ErrorMessage"];
        };
      };
    };
  };
  getVersions: {
    parameters: {
      query?: {
        /** @description Filters results by the respective subject */
        subject?: string;
        /** @description Whether to include subject versions where the schema was deleted */
        deleted?: boolean;
      };
      header?: never;
      path: {
        /** @description Globally unique identifier of the schema */
        id: number;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description List of subject versions matching the specified parameters. */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "application/vnd.schemaregistry.v1+json": components["schemas"]["SubjectVersion"][];
          "application/vnd.schemaregistry+json; qs=0.9": components["schemas"]["SubjectVersion"][];
          "application/json; qs=0.5": components["schemas"]["SubjectVersion"][];
        };
      };
      400: components["responses"]["schemaregistry.v1.BadRequestError"];
      401: components["responses"]["schemaregistry.v1.UnauthorizedError"];
      403: components["responses"]["schemaregistry.v1.ForbiddenError"];
      /** @description Not Found. Error code 40403 indicates schema not found. */
      404: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "application/vnd.schemaregistry.v1+json": components["schemas"]["ErrorMessage"];
          "application/vnd.schemaregistry+json; qs=0.9": components["schemas"]["ErrorMessage"];
          "application/json; qs=0.5": components["schemas"]["ErrorMessage"];
        };
      };
      429: components["responses"]["RateLimitError"];
      /** @description Internal Server Error. Error code 50001 indicates a failure in the backend data store. */
      500: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "application/vnd.schemaregistry.v1+json": components["schemas"]["ErrorMessage"];
          "application/vnd.schemaregistry+json; qs=0.9": components["schemas"]["ErrorMessage"];
          "application/json; qs=0.5": components["schemas"]["ErrorMessage"];
        };
      };
    };
  };
  getSchemaByVersion: {
    parameters: {
      query?: {
        /** @description Whether to include deleted schema */
        deleted?: boolean;
      };
      header?: never;
      path: {
        /** @description Name of the subject */
        subject: string;
        /** @description Version of the schema to be returned. Valid values for versionId are between [1,2^31-1] or the string "latest". "latest" returns the last registered schema under the specified subject. Note that there may be a new latest schema that gets registered right after this request is served. */
        version: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description The schema. */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "application/vnd.schemaregistry.v1+json": components["schemas"]["Schema"];
          "application/vnd.schemaregistry+json; qs=0.9": components["schemas"]["Schema"];
          "application/json; qs=0.5": components["schemas"]["Schema"];
        };
      };
      400: components["responses"]["schemaregistry.v1.BadRequestError"];
      401: components["responses"]["schemaregistry.v1.UnauthorizedError"];
      403: components["responses"]["schemaregistry.v1.ForbiddenError"];
      /** @description Not Found. Error code 40401 indicates subject not found. Error code 40402 indicates version not found. */
      404: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "application/vnd.schemaregistry.v1+json": components["schemas"]["ErrorMessage"];
          "application/vnd.schemaregistry+json; qs=0.9": components["schemas"]["ErrorMessage"];
          "application/json; qs=0.5": components["schemas"]["ErrorMessage"];
        };
      };
      /** @description Unprocessable Entity. Error code 42202 indicates an invalid version. */
      422: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "application/vnd.schemaregistry.v1+json": components["schemas"]["ErrorMessage"];
          "application/vnd.schemaregistry+json; qs=0.9": components["schemas"]["ErrorMessage"];
          "application/json; qs=0.5": components["schemas"]["ErrorMessage"];
        };
      };
      429: components["responses"]["RateLimitError"];
      /** @description Internal Server Error. Error code 50001 indicates a failure in the backend data store. */
      500: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "application/vnd.schemaregistry.v1+json": components["schemas"]["ErrorMessage"];
          "application/vnd.schemaregistry+json; qs=0.9": components["schemas"]["ErrorMessage"];
          "application/json; qs=0.5": components["schemas"]["ErrorMessage"];
        };
      };
    };
  };
  deleteSchemaVersion: {
    parameters: {
      query?: {
        /** @description Whether to perform a permanent delete */
        permanent?: boolean;
      };
      header?: never;
      path: {
        /** @description Name of the subject */
        subject: string;
        /** @description Version of the schema to be returned. Valid values for versionId are between [1,2^31-1] or the string "latest". "latest" returns the last registered schema under the specified subject. Note that there may be a new latest schema that gets registered right after this request is served. */
        version: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description Operation succeeded. Returns the schema version. */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "application/vnd.schemaregistry.v1+json": number;
          "application/vnd.schemaregistry+json; qs=0.9": number;
          "application/json; qs=0.5": number;
        };
      };
      400: components["responses"]["schemaregistry.v1.BadRequestError"];
      401: components["responses"]["schemaregistry.v1.UnauthorizedError"];
      403: components["responses"]["schemaregistry.v1.ForbiddenError"];
      /** @description Not Found. Error code 40401 indicates subject not found. Error code 40402 indicates version not found. */
      404: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "application/vnd.schemaregistry.v1+json": components["schemas"]["ErrorMessage"];
          "application/vnd.schemaregistry+json; qs=0.9": components["schemas"]["ErrorMessage"];
          "application/json; qs=0.5": components["schemas"]["ErrorMessage"];
        };
      };
      /** @description Unprocessable Entity. Error code 42202 indicates an invalid version. */
      422: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "application/vnd.schemaregistry.v1+json": components["schemas"]["ErrorMessage"];
          "application/vnd.schemaregistry+json; qs=0.9": components["schemas"]["ErrorMessage"];
          "application/json; qs=0.5": components["schemas"]["ErrorMessage"];
        };
      };
      429: components["responses"]["RateLimitError"];
      /** @description Internal Server Error. Error code 50001 indicates a failure in the backend data store. */
      500: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "application/vnd.schemaregistry.v1+json": components["schemas"]["ErrorMessage"];
          "application/vnd.schemaregistry+json; qs=0.9": components["schemas"]["ErrorMessage"];
          "application/json; qs=0.5": components["schemas"]["ErrorMessage"];
        };
      };
    };
  };
  getReferencedBy: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Name of the subject */
        subject: string;
        /** @description Version of the schema to be returned. Valid values for versionId are between [1,2^31-1] or the string "latest". "latest" returns the last registered schema under the specified subject. Note that there may be a new latest schema that gets registered right after this request is served. */
        version: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description List of IDs for schemas that reference the specified schema. */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "application/vnd.schemaregistry.v1+json": number[];
          "application/vnd.schemaregistry+json; qs=0.9": number[];
          "application/json; qs=0.5": number[];
        };
      };
      400: components["responses"]["schemaregistry.v1.BadRequestError"];
      401: components["responses"]["schemaregistry.v1.UnauthorizedError"];
      403: components["responses"]["schemaregistry.v1.ForbiddenError"];
      /** @description Not Found. Error code 40401 indicates subject not found. Error code 40402 indicates version not found. */
      404: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "application/vnd.schemaregistry.v1+json": components["schemas"]["ErrorMessage"];
          "application/vnd.schemaregistry+json; qs=0.9": components["schemas"]["ErrorMessage"];
          "application/json; qs=0.5": components["schemas"]["ErrorMessage"];
        };
      };
      /** @description Unprocessable Entity. Error code 42202 indicates an invalid version. */
      422: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "application/vnd.schemaregistry.v1+json": components["schemas"]["ErrorMessage"];
          "application/vnd.schemaregistry+json; qs=0.9": components["schemas"]["ErrorMessage"];
          "application/json; qs=0.5": components["schemas"]["ErrorMessage"];
        };
      };
      429: components["responses"]["RateLimitError"];
      /** @description Internal Server Error. Error code 50001 indicates a failure in the backend data store. */
      500: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "application/vnd.schemaregistry.v1+json": components["schemas"]["ErrorMessage"];
          "application/vnd.schemaregistry+json; qs=0.9": components["schemas"]["ErrorMessage"];
          "application/json; qs=0.5": components["schemas"]["ErrorMessage"];
        };
      };
    };
  };
  getSchemaOnly_1: {
    parameters: {
      query?: {
        /** @description Whether to include deleted schema */
        deleted?: boolean;
      };
      header?: never;
      path: {
        /** @description Name of the subject */
        subject: string;
        /** @description Version of the schema to be returned. Valid values for versionId are between [1,2^31-1] or the string "latest". "latest" returns the last registered schema under the specified subject. Note that there may be a new latest schema that gets registered right after this request is served. */
        version: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description The schema string. */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "application/vnd.schemaregistry.v1+json": string;
          "application/vnd.schemaregistry+json; qs=0.9": string;
          "application/json; qs=0.5": string;
        };
      };
      400: components["responses"]["schemaregistry.v1.BadRequestError"];
      401: components["responses"]["schemaregistry.v1.UnauthorizedError"];
      403: components["responses"]["schemaregistry.v1.ForbiddenError"];
      /** @description Not Found. Error code 40401 indicates subject not found. Error code 40402 indicates version not found. */
      404: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "application/vnd.schemaregistry.v1+json": components["schemas"]["ErrorMessage"];
          "application/vnd.schemaregistry+json; qs=0.9": components["schemas"]["ErrorMessage"];
          "application/json; qs=0.5": components["schemas"]["ErrorMessage"];
        };
      };
      /** @description Unprocessable Entity. Error code 42202 indicates an invalid version. */
      422: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "application/vnd.schemaregistry.v1+json": components["schemas"]["ErrorMessage"];
          "application/vnd.schemaregistry+json; qs=0.9": components["schemas"]["ErrorMessage"];
          "application/json; qs=0.5": components["schemas"]["ErrorMessage"];
        };
      };
      429: components["responses"]["RateLimitError"];
      /** @description Internal Server Error. Error code 50001 indicates a failure in the backend data store. */
      500: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "application/vnd.schemaregistry.v1+json": components["schemas"]["ErrorMessage"];
          "application/vnd.schemaregistry+json; qs=0.9": components["schemas"]["ErrorMessage"];
          "application/json; qs=0.5": components["schemas"]["ErrorMessage"];
        };
      };
    };
  };
  listVersions: {
    parameters: {
      query?: {
        /** @description Whether to include deleted schemas */
        deleted?: boolean;
      };
      header?: never;
      path: {
        /** @description Name of the subject */
        subject: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description List of version numbers matching the specified parameters. */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "application/vnd.schemaregistry.v1+json": number[];
          "application/vnd.schemaregistry+json; qs=0.9": number[];
          "application/json; qs=0.5": number[];
        };
      };
      400: components["responses"]["schemaregistry.v1.BadRequestError"];
      401: components["responses"]["schemaregistry.v1.UnauthorizedError"];
      403: components["responses"]["schemaregistry.v1.ForbiddenError"];
      /** @description Not Found. Error code 40401 indicates subject not found.  */
      404: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "application/vnd.schemaregistry.v1+json": components["schemas"]["ErrorMessage"];
          "application/vnd.schemaregistry+json; qs=0.9": components["schemas"]["ErrorMessage"];
          "application/json; qs=0.5": components["schemas"]["ErrorMessage"];
        };
      };
      429: components["responses"]["RateLimitError"];
      /** @description Internal Server Error. Error code 50001 indicates a failure in the backend data store. */
      500: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "application/vnd.schemaregistry.v1+json": components["schemas"]["ErrorMessage"];
          "application/vnd.schemaregistry+json; qs=0.9": components["schemas"]["ErrorMessage"];
          "application/json; qs=0.5": components["schemas"]["ErrorMessage"];
        };
      };
    };
  };
  register: {
    parameters: {
      query?: {
        /** @description Whether to register the normalized schema */
        normalize?: boolean;
      };
      header?: never;
      path: {
        /** @description Name of the subject */
        subject: string;
      };
      cookie?: never;
    };
    /** @description Schema */
    requestBody: {
      content: {
        "application/vnd.schemaregistry.v1+json": components["schemas"]["RegisterSchemaRequest"];
        "application/vnd.schemaregistry+json": components["schemas"]["RegisterSchemaRequest"];
        "application/json": components["schemas"]["RegisterSchemaRequest"];
        "application/octet-stream": components["schemas"]["RegisterSchemaRequest"];
      };
    };
    responses: {
      /** @description Schema successfully registered. */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "application/vnd.schemaregistry.v1+json": components["schemas"]["RegisterSchemaResponse"];
          "application/vnd.schemaregistry+json; qs=0.9": components["schemas"]["RegisterSchemaResponse"];
          "application/json; qs=0.5": components["schemas"]["RegisterSchemaResponse"];
        };
      };
      400: components["responses"]["schemaregistry.v1.BadRequestError"];
      401: components["responses"]["schemaregistry.v1.UnauthorizedError"];
      403: components["responses"]["schemaregistry.v1.ForbiddenError"];
      /** @description Conflict. Incompatible schema. */
      409: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "application/vnd.schemaregistry.v1+json": components["schemas"]["ErrorMessage"];
          "application/vnd.schemaregistry+json; qs=0.9": components["schemas"]["ErrorMessage"];
          "application/json; qs=0.5": components["schemas"]["ErrorMessage"];
        };
      };
      /** @description Unprocessable entity. Error code 42201 indicates an invalid schema or schema type.  */
      422: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "application/vnd.schemaregistry.v1+json": components["schemas"]["ErrorMessage"];
          "application/vnd.schemaregistry+json; qs=0.9": components["schemas"]["ErrorMessage"];
          "application/json; qs=0.5": components["schemas"]["ErrorMessage"];
        };
      };
      429: components["responses"]["RateLimitError"];
      /** @description Internal Server Error. Error code 50001 indicates a failure in the backend data store.Error code 50002 indicates operation timed out. Error code 50003 indicates a failure forwarding the request to the primary. */
      500: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "application/vnd.schemaregistry.v1+json": components["schemas"]["ErrorMessage"];
          "application/vnd.schemaregistry+json; qs=0.9": components["schemas"]["ErrorMessage"];
          "application/json; qs=0.5": components["schemas"]["ErrorMessage"];
        };
      };
    };
  };
  lookUpSchemaUnderSubject: {
    parameters: {
      query?: {
        /** @description Whether to lookup the normalized schema */
        normalize?: boolean;
        /** @description Whether to lookup deleted schemas */
        deleted?: boolean;
      };
      header?: never;
      path: {
        /** @description Subject under which the schema will be registered */
        subject: string;
      };
      cookie?: never;
    };
    /** @description Schema */
    requestBody: {
      content: {
        "application/vnd.schemaregistry.v1+json": components["schemas"]["RegisterSchemaRequest"];
        "application/vnd.schemaregistry+json": components["schemas"]["RegisterSchemaRequest"];
        "application/json": components["schemas"]["RegisterSchemaRequest"];
        "application/octet-stream": components["schemas"]["RegisterSchemaRequest"];
      };
    };
    responses: {
      /** @description The schema. */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "application/vnd.schemaregistry.v1+json": components["schemas"]["Schema"];
          "application/vnd.schemaregistry+json; qs=0.9": components["schemas"]["Schema"];
          "application/json; qs=0.5": components["schemas"]["Schema"];
        };
      };
      400: components["responses"]["schemaregistry.v1.BadRequestError"];
      401: components["responses"]["schemaregistry.v1.UnauthorizedError"];
      403: components["responses"]["schemaregistry.v1.ForbiddenError"];
      /** @description Not Found. Error code 40401 indicates subject not found. Error code 40403 indicates schema not found. */
      404: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "application/vnd.schemaregistry.v1+json": components["schemas"]["ErrorMessage"];
          "application/vnd.schemaregistry+json; qs=0.9": components["schemas"]["ErrorMessage"];
          "application/json; qs=0.5": components["schemas"]["ErrorMessage"];
        };
      };
      429: components["responses"]["RateLimitError"];
      /** @description Internal Server Error. */
      500: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "application/vnd.schemaregistry.v1+json": components["schemas"]["ErrorMessage"];
          "application/vnd.schemaregistry+json; qs=0.9": components["schemas"]["ErrorMessage"];
          "application/json; qs=0.5": components["schemas"]["ErrorMessage"];
        };
      };
    };
  };
  deleteSubject: {
    parameters: {
      query?: {
        /** @description Whether to perform a permanent delete */
        permanent?: boolean;
      };
      header?: never;
      path: {
        /** @description Name of the subject */
        subject: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description Operation succeeded. Returns list of schema versions deleted */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "application/vnd.schemaregistry.v1+json": number[];
          "application/vnd.schemaregistry+json; qs=0.9": number[];
          "application/json; qs=0.5": number[];
        };
      };
      400: components["responses"]["schemaregistry.v1.BadRequestError"];
      401: components["responses"]["schemaregistry.v1.UnauthorizedError"];
      403: components["responses"]["schemaregistry.v1.ForbiddenError"];
      /** @description Not Found. Error code 40401 indicates subject not found. */
      404: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "application/vnd.schemaregistry.v1+json": components["schemas"]["ErrorMessage"];
          "application/vnd.schemaregistry+json; qs=0.9": components["schemas"]["ErrorMessage"];
          "application/json; qs=0.5": components["schemas"]["ErrorMessage"];
        };
      };
      429: components["responses"]["RateLimitError"];
      /** @description Internal Server Error. Error code 50001 indicates a failure in the backend data store. */
      500: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "application/vnd.schemaregistry.v1+json": components["schemas"]["ErrorMessage"];
          "application/vnd.schemaregistry+json; qs=0.9": components["schemas"]["ErrorMessage"];
          "application/json; qs=0.5": components["schemas"]["ErrorMessage"];
        };
      };
    };
  };
  list: {
    parameters: {
      query?: {
        /** @description Subject name prefix */
        subjectPrefix?: string;
        /** @description Whether to look up deleted subjects */
        deleted?: boolean;
      };
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description List of subjects matching the specified parameters. */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "application/vnd.schemaregistry.v1+json": string[];
          "application/vnd.schemaregistry+json; qs=0.9": string[];
          "application/json; qs=0.5": string[];
        };
      };
      400: components["responses"]["schemaregistry.v1.BadRequestError"];
      401: components["responses"]["schemaregistry.v1.UnauthorizedError"];
      403: components["responses"]["schemaregistry.v1.ForbiddenError"];
      429: components["responses"]["RateLimitError"];
      /** @description Internal Server Error. Error code 50001 indicates a failure in the backend data store. */
      500: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "application/vnd.schemaregistry.v1+json": components["schemas"]["ErrorMessage"];
          "application/vnd.schemaregistry+json; qs=0.9": components["schemas"]["ErrorMessage"];
          "application/json; qs=0.5": components["schemas"]["ErrorMessage"];
        };
      };
    };
  };
  getKekNames: {
    parameters: {
      query?: {
        /** @description Whether to include deleted keys */
        deleted?: boolean;
      };
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description List of kek names */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "application/vnd.schemaregistry.v1+json": string[];
          "application/vnd.schemaregistry+json; qs=0.9": string[];
          "application/json; qs=0.5": string[];
        };
      };
    };
  };
  createKek: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /** @description The create request */
    requestBody: {
      content: {
        "application/vnd.schemaregistry.v1+json": components["schemas"]["CreateKekRequest"];
        "application/vnd.schemaregistry+json": components["schemas"]["CreateKekRequest"];
        "application/json": components["schemas"]["CreateKekRequest"];
        "application/octet-stream": components["schemas"]["CreateKekRequest"];
      };
    };
    responses: {
      /** @description The create response */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "application/vnd.schemaregistry.v1+json": components["schemas"]["Kek"];
          "application/vnd.schemaregistry+json; qs=0.9": components["schemas"]["Kek"];
          "application/json; qs=0.5": components["schemas"]["Kek"];
        };
      };
      /** @description Conflict. Error code 40971 -- Key already exists. Error code 40972 -- Too many keys. */
      409: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
      /** @description Error code 42271 -- Invalid key */
      422: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  getKek: {
    parameters: {
      query?: {
        /** @description Whether to include deleted keys */
        deleted?: boolean;
      };
      header?: never;
      path: {
        /** @description Name of the kek */
        name: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description The kek info */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "application/vnd.schemaregistry.v1+json": components["schemas"]["Kek"];
          "application/vnd.schemaregistry+json; qs=0.9": components["schemas"]["Kek"];
          "application/json; qs=0.5": components["schemas"]["Kek"];
        };
      };
      /** @description Error code 40470 -- Key not found */
      404: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
      /** @description Error code 42271 -- Invalid key */
      422: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  putKek: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Name of the kek */
        name: string;
      };
      cookie?: never;
    };
    /** @description The update request */
    requestBody: {
      content: {
        "application/vnd.schemaregistry.v1+json": components["schemas"]["UpdateKekRequest"];
        "application/vnd.schemaregistry+json": components["schemas"]["UpdateKekRequest"];
        "application/json": components["schemas"]["UpdateKekRequest"];
        "application/octet-stream": components["schemas"]["UpdateKekRequest"];
      };
    };
    responses: {
      /** @description The update response */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "application/vnd.schemaregistry.v1+json": components["schemas"]["Kek"];
          "application/vnd.schemaregistry+json; qs=0.9": components["schemas"]["Kek"];
          "application/json; qs=0.5": components["schemas"]["Kek"];
        };
      };
      /** @description Error code 40470 -- Key not found */
      404: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
      /** @description Error code 40971 -- Key already exists */
      409: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
      /** @description Error code 42271 -- Invalid key */
      422: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  deleteKek: {
    parameters: {
      query?: {
        /** @description Whether to perform a permanent delete */
        permanent?: boolean;
      };
      header?: never;
      path: {
        /** @description Name of the kek */
        name: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description No Content */
      204: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
      /** @description Not found. Error code 40470 -- Key not found. Error code 40471 -- Key not soft-deleted. */
      404: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
      /** @description Unprocessable entity. Error code 42271 -- Invalid key. Error code 42272 -- References to key exist. */
      422: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  undeleteKek: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Name of the kek */
        name: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description No Content */
      204: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
      /** @description Error code 40470 -- Key not found */
      404: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
      /** @description Unprocessable entity. Error code 42271 -- Invalid key. Error code 42272 -- References to key exist. */
      422: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  getDekSubjects: {
    parameters: {
      query?: {
        /** @description Whether to include deleted keys */
        deleted?: boolean;
      };
      header?: never;
      path: {
        /** @description Name of the kek */
        name: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description List of dek subjects */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "application/vnd.schemaregistry.v1+json": string[];
          "application/vnd.schemaregistry+json; qs=0.9": string[];
          "application/json; qs=0.5": string[];
        };
      };
      /** @description Error code 40470 -- Key not found */
      404: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
      /** @description Error code 42271 -- Invalid key */
      422: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  createDek: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Name of the kek */
        name: string;
      };
      cookie?: never;
    };
    /** @description The create request */
    requestBody: {
      content: {
        "application/vnd.schemaregistry.v1+json": components["schemas"]["CreateDekRequest"];
        "application/vnd.schemaregistry+json": components["schemas"]["CreateDekRequest"];
        "application/json": components["schemas"]["CreateDekRequest"];
        "application/octet-stream": components["schemas"]["CreateDekRequest"];
      };
    };
    responses: {
      /** @description The create response */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "application/vnd.schemaregistry.v1+json": components["schemas"]["Dek"];
          "application/vnd.schemaregistry+json; qs=0.9": components["schemas"]["Dek"];
          "application/json; qs=0.5": components["schemas"]["Dek"];
        };
      };
      /** @description Conflict. Error code 40971 -- Key already exists. Error code 40972 -- Too many keys. */
      409: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
      /** @description Error code 42271 -- Invalid key */
      422: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
      /** @description Error code 50070 -- Dek generation error */
      500: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  getDek: {
    parameters: {
      query?: {
        /** @description Algorithm of the dek */
        algorithm?: "AES128_GCM" | "AES256_GCM" | "AES256_SIV";
        /** @description Whether to include deleted keys */
        deleted?: boolean;
      };
      header?: never;
      path: {
        /** @description Name of the kek */
        name: string;
        /** @description Subject of the dek */
        subject: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description The dek info */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "application/vnd.schemaregistry.v1+json": components["schemas"]["Dek"];
          "application/vnd.schemaregistry+json; qs=0.9": components["schemas"]["Dek"];
          "application/json; qs=0.5": components["schemas"]["Dek"];
        };
      };
      /** @description Error code 40470 -- Key not found */
      404: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
      /** @description Error code 42271 -- Invalid key */
      422: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
      /** @description Error code 50070 -- Dek generation error */
      500: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  deleteDekVersions: {
    parameters: {
      query?: {
        /** @description Algorithm of the dek */
        algorithm?: "AES128_GCM" | "AES256_GCM" | "AES256_SIV";
        /** @description Whether to perform a permanent delete */
        permanent?: boolean;
      };
      header?: never;
      path: {
        /** @description Name of the kek */
        name: string;
        /** @description Subject of the dek */
        subject: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description No Content */
      204: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
      /** @description Not found. Error code 40470 -- Key not found. Error code 40471 -- Key not soft-deleted. */
      404: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
      /** @description Error code 42271 -- Invalid key */
      422: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  getDekByVersion: {
    parameters: {
      query?: {
        /** @description Algorithm of the dek */
        algorithm?: "AES128_GCM" | "AES256_GCM" | "AES256_SIV";
        /** @description Whether to include deleted keys */
        deleted?: boolean;
      };
      header?: never;
      path: {
        /** @description Name of the kek */
        name: string;
        /** @description Subject of the dek */
        subject: string;
        /** @description Version of the dek */
        version: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description The dek info */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "application/vnd.schemaregistry.v1+json": components["schemas"]["Dek"];
          "application/vnd.schemaregistry+json; qs=0.9": components["schemas"]["Dek"];
          "application/json; qs=0.5": components["schemas"]["Dek"];
        };
      };
      /** @description Error code 40470 -- Key not found */
      404: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
      /** @description Unprocessable entity. Error code 42202 -- Invalid version. Error code 42271 -- Invalid key. */
      422: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
      /** @description Error code 50070 -- Dek generation error */
      500: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  deleteDekVersion: {
    parameters: {
      query?: {
        /** @description Algorithm of the dek */
        algorithm?: "AES128_GCM" | "AES256_GCM" | "AES256_SIV";
        /** @description Whether to perform a permanent delete */
        permanent?: boolean;
      };
      header?: never;
      path: {
        /** @description Name of the kek */
        name: string;
        /** @description Subject of the dek */
        subject: string;
        /** @description Version of the dek */
        version: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description No Content */
      204: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
      /** @description Not found. Error code 40470 -- Key not found. Error code 40471 -- Key not soft-deleted. */
      404: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
      /** @description Unprocessable entity. Error code 42202 -- Invalid version. Error code 42271 -- Invalid key. */
      422: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  getDekVersions: {
    parameters: {
      query?: {
        /** @description Algorithm of the dek */
        algorithm?: "AES128_GCM" | "AES256_GCM" | "AES256_SIV";
        /** @description Whether to include deleted keys */
        deleted?: boolean;
      };
      header?: never;
      path: {
        /** @description Name of the kek */
        name: string;
        /** @description Subject of the dek */
        subject: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description List of version numbers for dek */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "application/vnd.schemaregistry.v1+json": number[];
          "application/vnd.schemaregistry+json; qs=0.9": number[];
          "application/json; qs=0.5": number[];
        };
      };
      /** @description Error code 40470 -- Key not found */
      404: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
      /** @description Error code 42271 -- Invalid key */
      422: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  undeleteDekVersion: {
    parameters: {
      query?: {
        /** @description Algorithm of the dek */
        algorithm?: "AES128_GCM" | "AES256_GCM" | "AES256_SIV";
      };
      header?: never;
      path: {
        /** @description Name of the kek */
        name: string;
        /** @description Subject of the dek */
        subject: string;
        /** @description Version of the dek */
        version: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description No Content */
      204: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
      /** @description Not found. Error code 40470 -- Key not found. Error code 40472 -- Key must be undeleted. */
      404: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
      /** @description Unprocessable entity. Error code 42202 -- Invalid version. Error code 42271 -- Invalid key. */
      422: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  undeleteDekVersions: {
    parameters: {
      query?: {
        /** @description Algorithm of the dek */
        algorithm?: "AES128_GCM" | "AES256_GCM" | "AES256_SIV";
      };
      header?: never;
      path: {
        /** @description Name of the kek */
        name: string;
        /** @description Subject of the dek */
        subject: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description No Content */
      204: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
      /** @description Not found. Error code 40470 -- Key not found. Error code 40472 -- Key must be undeleted. */
      404: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
      /** @description Error code 42271 -- Invalid key */
      422: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  getAllBusinessMetadataDefs: {
    parameters: {
      query?: {
        /** @description The prefix of a business metadata definition name */
        prefix?: string;
      };
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description The business metadata definitions */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "application/json": components["schemas"]["BusinessMetadataDefResponse"][];
        };
      };
      /** @description Bad Request */
      400: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
      /** @description Rate Limit Error */
      429: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
      /** @description Internal Server Error */
      500: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  updateBusinessMetadataDefs: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /** @description The business metadata definitions to update */
    requestBody?: {
      content: {
        "application/json": components["schemas"]["BusinessMetadataDef"][];
      };
    };
    responses: {
      /** @description The business metadata definitions. Errored business metadata definitions will have an additional error property. */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "application/json": components["schemas"]["BusinessMetadataDefResponse"][];
        };
      };
      /** @description Bad Request */
      400: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
      /** @description Rate Limit Error */
      429: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
      /** @description Internal Server Error */
      500: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  createBusinessMetadataDefs: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /** @description The business metadata definitions to create */
    requestBody?: {
      content: {
        "application/json": components["schemas"]["BusinessMetadataDef"][];
      };
    };
    responses: {
      /** @description The business metadata definitions. Errored business metadata definitions will have an additional error property. */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "application/json": components["schemas"]["BusinessMetadataDefResponse"][];
        };
      };
      /** @description Bad Request */
      400: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
      /** @description Rate Limit Error */
      429: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
      /** @description Internal Server Error */
      500: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  getBusinessMetadataDefByName: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description The name of the business metadata definition */
        bmName: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description The business metadata definition */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "application/json": components["schemas"]["BusinessMetadataDef"];
        };
      };
      /** @description Bad Request */
      400: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
      /** @description Business metadata definition not found */
      404: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
      /** @description Rate Limit Error */
      429: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
      /** @description Internal Server Error */
      500: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  deleteBusinessMetadataDef: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description The name of the business metadata definition */
        bmName: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description No Content */
      204: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
      /** @description Bad Request */
      400: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
      /** @description Rate Limit Error */
      429: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
      /** @description Internal Server Error */
      500: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  updateBusinessMetadata: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /** @description The business metadata */
    requestBody?: {
      content: {
        "application/json": components["schemas"]["BusinessMetadata"][];
      };
    };
    responses: {
      /** @description The business metadata. Errored business metadata will have an additional error property. */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "application/json": components["schemas"]["BusinessMetadataResponse"][];
        };
      };
      /** @description Bad Request */
      400: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
      /** @description Rate Limit Error */
      429: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
      /** @description Internal Server Error */
      500: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  createBusinessMetadata: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /** @description The business metadata */
    requestBody?: {
      content: {
        "application/json": components["schemas"]["BusinessMetadata"][];
      };
    };
    responses: {
      /** @description The business metadata. Errored business metadata will have an additional error property. */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "application/json": components["schemas"]["BusinessMetadataResponse"][];
        };
      };
      /** @description Bad Request */
      400: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
      /** @description Rate Limit Error */
      429: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
      /** @description Internal Server Error */
      500: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  getBusinessMetadata: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description The type of the entity */
        typeName: string;
        /** @description The qualified name of the entity */
        qualifiedName: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description The business metadata */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "application/json": components["schemas"]["BusinessMetadataResponse"][];
        };
      };
      /** @description Bad Request */
      400: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
      /** @description Entity not found */
      404: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
      /** @description Rate Limit Error */
      429: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
      /** @description Internal Server Error */
      500: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  deleteBusinessMetadata: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description The type of the entity */
        typeName: string;
        /** @description The qualified name of the entity */
        qualifiedName: string;
        /** @description The name of the business metadata */
        bmName: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description No Content */
      204: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
      /** @description Bad Request */
      400: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
      /** @description Rate Limit Error */
      429: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
      /** @description Internal Server Error */
      500: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  updateTags: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /** @description The tags */
    requestBody?: {
      content: {
        "application/json": components["schemas"]["Tag"][];
      };
    };
    responses: {
      /** @description The tags. Errored tags will have an additional error property. */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "application/json": components["schemas"]["TagResponse"][];
        };
      };
      /** @description Bad Request */
      400: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
      /** @description Rate Limit Error */
      429: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
      /** @description Internal Server Error */
      500: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  createTags: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /** @description The tags */
    requestBody?: {
      content: {
        "application/json": components["schemas"]["Tag"][];
      };
    };
    responses: {
      /** @description The tags. Errored tags will have an additional error property. */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "application/json": components["schemas"]["TagResponse"][];
        };
      };
      /** @description Bad Request */
      400: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
      /** @description Rate Limit Error */
      429: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
      /** @description Internal Server Error */
      500: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  getByUniqueAttributes: {
    parameters: {
      query?: {
        /** @description Whether to populate on header and schema attributes */
        minExtInfo?: boolean;
        /** @description Whether to ignore relationships */
        ignoreRelationships?: boolean;
      };
      header?: never;
      path: {
        /** @description The type of the entity */
        typeName: string;
        /** @description The qualified name of the entity */
        qualifiedName: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description The entity */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "application/json": components["schemas"]["EntityWithExtInfo"];
        };
      };
      /** @description Bad Request */
      400: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
      /** @description Entity not found */
      404: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
      /** @description Rate Limit Error */
      429: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
      /** @description Internal Server Error */
      500: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  getTags: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description The type of the entity */
        typeName: string;
        /** @description The qualified name of the entity */
        qualifiedName: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description The tags */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "application/json": components["schemas"]["TagResponse"][];
        };
      };
      /** @description Bad Request */
      400: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
      /** @description Entity not found */
      404: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
      /** @description Rate Limit Error */
      429: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
      /** @description Internal Server Error */
      500: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  partialEntityUpdate: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /** @description The entity to update */
    requestBody?: {
      content: {
        "application/json": components["schemas"]["EntityWithExtInfo"];
      };
    };
    responses: {
      /** @description The updated entity */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "application/json": components["schemas"]["EntityPartialUpdateResponse"];
        };
      };
      /** @description Bad Request */
      400: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
      /** @description Entity not found */
      404: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
      /** @description Rate Limit Error */
      429: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
      /** @description Internal Server Error */
      500: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  deleteTag: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description The type of the entity */
        typeName: string;
        /** @description The qualified name of the entity */
        qualifiedName: string;
        /** @description The name of the tag */
        tagName: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description No Content */
      204: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
      /** @description Bad Request */
      400: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
      /** @description Rate Limit Error */
      429: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
      /** @description Internal Server Error */
      500: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  searchUsingAttribute: {
    parameters: {
      query?: {
        /** @description Limit the result to only entities of specified types */
        type?: string[];
        /** @description One of more additional attributes to return in the response */
        attr?: string[];
        /** @description The attribute to search */
        attrName?: string[];
        /** @description The prefix for the attribute value to search */
        attrValuePrefix?: string[];
        /** @description Limit the result to only entities tagged with the given tag */
        tag?: string;
        /** @description An attribute to sort by */
        sortBy?: string;
        /** @description Sort order, either ASCENDING (default) or DESCENDING */
        sortOrder?: "ASCENDING" | "DESCENDING";
        /** @description Whether to include deleted entities */
        deleted?: boolean;
        /** @description Limit the result set to only include the specified number of entries */
        limit?: number;
        /** @description Start offset of the result set (useful for pagination) */
        offset?: number;
      };
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description On successful search query with some results, might return an empty list if execution succeeded without any results */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "application/json": components["schemas"]["SearchResult"];
        };
      };
      /** @description Invalid wildcard or query parameters */
      400: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
      /** @description Rate Limit Error */
      429: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
      /** @description Internal Server Error */
      500: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  searchUsingBasic: {
    parameters: {
      query?: {
        /** @description The full-text query */
        query?: string;
        /** @description Limit the result to only entities of specified types */
        type?: string[];
        /** @description One of more additional attributes to return in the response */
        attr?: string[];
        /** @description Limit the result to only entities tagged with the given tag */
        tag?: string;
        /** @description An attribute to sort by */
        sortBy?: string;
        /** @description Sort order, either ASCENDING (default) or DESCENDING */
        sortOrder?: "ASCENDING" | "DESCENDING";
        /** @description Whether to include deleted entities */
        deleted?: boolean;
        /** @description Limit the result set to only include the specified number of entries */
        limit?: number;
        /** @description Start offset of the result set (useful for pagination) */
        offset?: number;
      };
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description On successful fulltext query with some results, might return an empty list if execution succeeded without any results */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "application/json": components["schemas"]["SearchResult"];
        };
      };
      /** @description Invalid fulltext or query parameters */
      400: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
      /** @description Rate Limit Error */
      429: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
      /** @description Internal Server Error */
      500: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  getAllTagDefs: {
    parameters: {
      query?: {
        /** @description The prefix of a tag definition name */
        prefix?: string;
      };
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description The tag definitions */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "application/json": components["schemas"]["TagDefResponse"][];
        };
      };
      /** @description Bad Request */
      400: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
      /** @description Rate Limit Error */
      429: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
      /** @description Internal Server Error */
      500: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  updateTagDefs: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /** @description The tag definitions to update */
    requestBody?: {
      content: {
        "application/json": components["schemas"]["TagDef"][];
      };
    };
    responses: {
      /** @description The tag definitions. Errored tag definitions will have an additional error property. */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "application/json": components["schemas"]["TagDefResponse"][];
        };
      };
      /** @description Bad Request */
      400: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
      /** @description Rate Limit Error */
      429: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
      /** @description Internal Server Error */
      500: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  createTagDefs: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /** @description The tag definitions to create */
    requestBody?: {
      content: {
        "application/json": components["schemas"]["TagDef"][];
      };
    };
    responses: {
      /** @description The tag definitions. Errored tag definitions will have an additional error property. */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "application/json": components["schemas"]["TagDefResponse"][];
        };
      };
      /** @description Bad Request */
      400: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
      /** @description Rate Limit Error */
      429: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
      /** @description Internal Server Error */
      500: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  getTagDefByName: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description The name of the tag definiton */
        tagName: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description The tag definition */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "application/json": components["schemas"]["TagDef"];
        };
      };
      /** @description Bad Request */
      400: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
      /** @description Tag definition not found */
      404: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
      /** @description Rate Limit Error */
      429: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
      /** @description Internal Server Error */
      500: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  deleteTagDef: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description The name of the tag definition */
        tagName: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description No Content */
      204: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
      /** @description Bad Request */
      400: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
      /** @description Rate Limit Error */
      429: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
      /** @description Internal Server Error */
      500: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  listCdxV1ProviderSharedResources: {
    parameters: {
      query?: {
        /**
         * @description Filter the results by exact match for stream_share.
         * @example ss-1234
         */
        stream_share?: components["schemas"]["SearchFilter"];
        /**
         * @description Filter the results by exact match for crn.
         * @example crn://confluent.cloud/cloud-cluster=lkc-111aaa/kafka=lkc-111aaa/topic=my.topic
         */
        crn?: components["schemas"]["SearchFilter"];
        /** @description Include deactivated shared resources */
        include_deleted?: components["schemas"]["BooleanFilter"];
        /** @description A pagination size for collection requests. */
        page_size?: number;
        /** @description An opaque pagination token for collection requests. */
        page_token?: string;
      };
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description Provider Shared Resource. */
      200: {
        headers: {
          /** @description The unique identifier for the API request. */
          "X-Request-Id"?: string;
          /** @description The maximum number of requests you're permitted to make per time period. */
          "X-RateLimit-Limit"?: number;
          /** @description The number of requests remaining in the current rate limit window. */
          "X-RateLimit-Remaining"?: number;
          /** @description The relative time in seconds until the current rate-limit window resets.
           *
           *     **Important:** This differs from Github and Twitter's same-named header which uses UTC epoch seconds. We use relative time to avoid client/server time synchronization issues. */
          "X-RateLimit-Reset"?: number;
          [name: string]: unknown;
        };
        content: {
          "application/json": components["schemas"]["cdx.v1.ProviderSharedResourceList"] & {
            data?: {
              /** @example {
               *       "id": "lkc-00000",
               *       "related": "https://api.confluent.cloud/cmk/v2/clusters/lkc-00000",
               *       "resource_name": "https://api.confluent.cloud/organization=9bb441c4-edef-46ac-8a41-c49e44a3fd9a/environment=env-abc123/cloud-cluster=lkc-00000"
               *     } */
              cloud_cluster?: unknown;
            }[];
          };
        };
      };
      400: components["responses"]["BadRequestError"];
      401: components["responses"]["UnauthenticatedError"];
      403: components["responses"]["UnauthorizedError"];
      429: components["responses"]["RateLimitError"];
      500: components["responses"]["DefaultSystemError"];
    };
  };
  getCdxV1ProviderSharedResource: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description The unique identifier for the provider shared resource. */
        id: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description Provider Shared Resource. */
      200: {
        headers: {
          /** @description The unique identifier for the API request. */
          "X-Request-Id"?: string;
          /** @description The maximum number of requests you're permitted to make per time period. */
          "X-RateLimit-Limit"?: number;
          /** @description The number of requests remaining in the current rate limit window. */
          "X-RateLimit-Remaining"?: number;
          /** @description The relative time in seconds until the current rate-limit window resets.
           *
           *     **Important:** This differs from Github and Twitter's same-named header which uses UTC epoch seconds. We use relative time to avoid client/server time synchronization issues. */
          "X-RateLimit-Reset"?: number;
          [name: string]: unknown;
        };
        content: {
          "application/json": components["schemas"]["cdx.v1.ProviderSharedResource"] &
            Record<string, unknown> & {
              /** @example {
               *       "id": "lkc-00000",
               *       "related": "https://api.confluent.cloud/cmk/v2/clusters/lkc-00000",
               *       "resource_name": "https://api.confluent.cloud/organization=9bb441c4-edef-46ac-8a41-c49e44a3fd9a/environment=env-abc123/cloud-cluster=lkc-00000"
               *     } */
              cloud_cluster?: unknown;
            };
        };
      };
      400: components["responses"]["BadRequestError"];
      401: components["responses"]["UnauthenticatedError"];
      403: components["responses"]["UnauthorizedError"];
      404: components["responses"]["NotFoundError"];
      429: components["responses"]["RateLimitError"];
      500: components["responses"]["DefaultSystemError"];
    };
  };
  updateCdxV1ProviderSharedResource: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description The unique identifier for the provider shared resource. */
        id: string;
      };
      cookie?: never;
    };
    requestBody?: {
      content: {
        "application/json": components["schemas"]["cdx.v1.ProviderSharedResourceUpdate"];
      };
    };
    responses: {
      /** @description Provider Shared Resource. */
      200: {
        headers: {
          /** @description The unique identifier for the API request. */
          "X-Request-Id"?: string;
          /** @description The maximum number of requests you're permitted to make per time period. */
          "X-RateLimit-Limit"?: number;
          /** @description The number of requests remaining in the current rate limit window. */
          "X-RateLimit-Remaining"?: number;
          /** @description The relative time in seconds until the current rate-limit window resets.
           *
           *     **Important:** This differs from Github and Twitter's same-named header which uses UTC epoch seconds. We use relative time to avoid client/server time synchronization issues. */
          "X-RateLimit-Reset"?: number;
          [name: string]: unknown;
        };
        content: {
          "application/json": components["schemas"]["cdx.v1.ProviderSharedResource"] &
            Record<string, unknown> & {
              /** @example {
               *       "id": "lkc-00000",
               *       "related": "https://api.confluent.cloud/cmk/v2/clusters/lkc-00000",
               *       "resource_name": "https://api.confluent.cloud/organization=9bb441c4-edef-46ac-8a41-c49e44a3fd9a/environment=env-abc123/cloud-cluster=lkc-00000"
               *     } */
              cloud_cluster?: unknown;
            };
        };
      };
      400: components["responses"]["BadRequestError"];
      401: components["responses"]["UnauthenticatedError"];
      403: components["responses"]["UnauthorizedError"];
      404: components["responses"]["NotFoundError"];
      409: components["responses"]["ConflictError"];
      422: components["responses"]["ValidationError"];
      429: components["responses"]["RateLimitError"];
      500: components["responses"]["DefaultSystemError"];
    };
  };
  view_imageCdxV1ProviderSharedResource: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description The unique identifier for the provider shared resource. */
        id: string;
        /** @description The File Name */
        file_name: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description returns the image file */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "image/*": string;
        };
      };
      400: components["responses"]["BadRequestError"];
      401: components["responses"]["UnauthenticatedError"];
      403: components["responses"]["UnauthorizedError"];
      404: components["responses"]["NotFoundError"];
      429: components["responses"]["RateLimitError"];
      500: components["responses"]["DefaultSystemError"];
    };
  };
  upload_imageCdxV1ProviderSharedResource: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description The unique identifier for the provider shared resource. */
        id: string;
        /** @description The File Name */
        file_name: string;
      };
      cookie?: never;
    };
    requestBody?: {
      content: {
        "image/*": string;
      };
    };
    responses: {
      /** @description image uploaded */
      201: {
        headers: {
          /** @description A URL that allows access to the image file */
          Location?: string;
          /** @description The unique identifier for the API request. */
          "X-Request-Id"?: string;
          [name: string]: unknown;
        };
        content?: never;
      };
      400: components["responses"]["BadRequestError"];
      401: components["responses"]["UnauthenticatedError"];
      403: components["responses"]["UnauthorizedError"];
      404: components["responses"]["NotFoundError"];
      429: components["responses"]["RateLimitError"];
      500: components["responses"]["DefaultSystemError"];
    };
  };
  delete_imageCdxV1ProviderSharedResource: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description The unique identifier for the provider shared resource. */
        id: string;
        /** @description The File Name */
        file_name: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description No Content */
      204: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
      400: components["responses"]["BadRequestError"];
      401: components["responses"]["UnauthenticatedError"];
      403: components["responses"]["UnauthorizedError"];
      404: components["responses"]["NotFoundError"];
      429: components["responses"]["RateLimitError"];
      500: components["responses"]["DefaultSystemError"];
    };
  };
  listCdxV1ProviderShares: {
    parameters: {
      query?: {
        /**
         * @description Filter the results by exact match for shared_resource.
         * @example sr-1234
         */
        shared_resource?: components["schemas"]["SearchFilter"];
        /**
         * @description Filter the results by exact match for crn.
         * @example crn://confluent.cloud/cloud-cluster=lkc-111aaa/kafka=lkc-111aaa/topic=my.topic
         */
        crn?: components["schemas"]["SearchFilter"];
        /** @description Include deactivated shares */
        include_deleted?: components["schemas"]["BooleanFilter"];
        /** @description A pagination size for collection requests. */
        page_size?: number;
        /** @description An opaque pagination token for collection requests. */
        page_token?: string;
      };
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description Provider Share. */
      200: {
        headers: {
          /** @description The unique identifier for the API request. */
          "X-Request-Id"?: string;
          /** @description The maximum number of requests you're permitted to make per time period. */
          "X-RateLimit-Limit"?: number;
          /** @description The number of requests remaining in the current rate limit window. */
          "X-RateLimit-Remaining"?: number;
          /** @description The relative time in seconds until the current rate-limit window resets.
           *
           *     **Important:** This differs from Github and Twitter's same-named header which uses UTC epoch seconds. We use relative time to avoid client/server time synchronization issues. */
          "X-RateLimit-Reset"?: number;
          [name: string]: unknown;
        };
        content: {
          "application/json": components["schemas"]["cdx.v1.ProviderShareList"] & {
            data?: {
              /** @example {
               *       "id": "sa-4voj5e",
               *       "related": "https://api.confluent.cloud/iam/v2/service-accounts/sa-4voj5e",
               *       "resource_name": "https://api.confluent.cloud/service-account=sa-4voj5e"
               *     } */
              service_account?: unknown;
              /** @example {
               *       "id": "lkc-00000",
               *       "related": "https://api.confluent.cloud/cmk/v2/clusters/lkc-00000",
               *       "resource_name": "https://api.confluent.cloud/organization=9bb441c4-edef-46ac-8a41-c49e44a3fd9a/environment=env-abc123/cloud-cluster=lkc-00000"
               *     } */
              cloud_cluster?: unknown;
            }[];
          };
        };
      };
      400: components["responses"]["BadRequestError"];
      401: components["responses"]["UnauthenticatedError"];
      403: components["responses"]["UnauthorizedError"];
      429: components["responses"]["RateLimitError"];
      500: components["responses"]["DefaultSystemError"];
    };
  };
  createCdxV1ProviderShare: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody?: {
      content: {
        "application/json": components["schemas"]["cdx.v1.CreateProviderShareRequest"] &
          Record<string, unknown>;
      };
    };
    responses: {
      /** @description Response is the provider share
       *      */
      201: {
        headers: {
          /** @description A URL that allows access to the resourced named by the crn */
          Location?: string;
          /** @description The unique identifier for the API request. */
          "X-Request-Id"?: string;
          [name: string]: unknown;
        };
        content: {
          "application/json": components["schemas"]["cdx.v1.ProviderShare"];
        };
      };
      400: components["responses"]["BadRequestError"];
      401: components["responses"]["UnauthenticatedError"];
      403: components["responses"]["UnauthorizedError"];
      409: components["responses"]["ConflictError"];
      422: components["responses"]["ValidationError"];
      429: components["responses"]["RateLimitError"];
      500: components["responses"]["DefaultSystemError"];
    };
  };
  getCdxV1ProviderShare: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description The unique identifier for the provider share. */
        id: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description Provider Share. */
      200: {
        headers: {
          /** @description The unique identifier for the API request. */
          "X-Request-Id"?: string;
          /** @description The maximum number of requests you're permitted to make per time period. */
          "X-RateLimit-Limit"?: number;
          /** @description The number of requests remaining in the current rate limit window. */
          "X-RateLimit-Remaining"?: number;
          /** @description The relative time in seconds until the current rate-limit window resets.
           *
           *     **Important:** This differs from Github and Twitter's same-named header which uses UTC epoch seconds. We use relative time to avoid client/server time synchronization issues. */
          "X-RateLimit-Reset"?: number;
          [name: string]: unknown;
        };
        content: {
          "application/json": components["schemas"]["cdx.v1.ProviderShare"] &
            Record<string, unknown> & {
              /** @example {
               *       "id": "sa-4voj5e",
               *       "related": "https://api.confluent.cloud/iam/v2/service-accounts/sa-4voj5e",
               *       "resource_name": "https://api.confluent.cloud/service-account=sa-4voj5e"
               *     } */
              service_account?: unknown;
              /** @example {
               *       "id": "lkc-00000",
               *       "related": "https://api.confluent.cloud/cmk/v2/clusters/lkc-00000",
               *       "resource_name": "https://api.confluent.cloud/organization=9bb441c4-edef-46ac-8a41-c49e44a3fd9a/environment=env-abc123/cloud-cluster=lkc-00000"
               *     } */
              cloud_cluster?: unknown;
            };
        };
      };
      400: components["responses"]["BadRequestError"];
      401: components["responses"]["UnauthenticatedError"];
      403: components["responses"]["UnauthorizedError"];
      404: components["responses"]["NotFoundError"];
      429: components["responses"]["RateLimitError"];
      500: components["responses"]["DefaultSystemError"];
    };
  };
  deleteCdxV1ProviderShare: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description The unique identifier for the provider share. */
        id: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description A Provider Share is being deleted. */
      204: {
        headers: {
          /** @description The unique identifier for the API request. */
          "X-Request-Id"?: string;
          /** @description The maximum number of requests you're permitted to make per time period. */
          "X-RateLimit-Limit"?: number;
          /** @description The number of requests remaining in the current rate limit window. */
          "X-RateLimit-Remaining"?: number;
          /** @description The relative time in seconds until the current rate-limit window resets.
           *
           *     **Important:** This differs from Github and Twitter's same-named header which uses UTC epoch seconds. We use relative time to avoid client/server time synchronization issues. */
          "X-RateLimit-Reset"?: number;
          [name: string]: unknown;
        };
        content?: never;
      };
      400: components["responses"]["BadRequestError"];
      401: components["responses"]["UnauthenticatedError"];
      403: components["responses"]["UnauthorizedError"];
      404: components["responses"]["NotFoundError"];
      429: components["responses"]["RateLimitError"];
      500: components["responses"]["DefaultSystemError"];
    };
  };
  resendCdxV1ProviderShare: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description The unique identifier for the provider share. */
        id: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description No Content */
      204: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
      400: components["responses"]["BadRequestError"];
      401: components["responses"]["UnauthenticatedError"];
      403: components["responses"]["UnauthorizedError"];
      404: components["responses"]["NotFoundError"];
      429: components["responses"]["RateLimitError"];
      500: components["responses"]["DefaultSystemError"];
    };
  };
  listCdxV1ConsumerSharedResources: {
    parameters: {
      query?: {
        /**
         * @description Filter the results by exact match for stream_share.
         * @example ss-1234
         */
        stream_share?: components["schemas"]["SearchFilter"];
        /** @description Include deactivated shared resources */
        include_deleted?: components["schemas"]["BooleanFilter"];
        /** @description A pagination size for collection requests. */
        page_size?: number;
        /** @description An opaque pagination token for collection requests. */
        page_token?: string;
      };
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description Consumer Shared Resource. */
      200: {
        headers: {
          /** @description The unique identifier for the API request. */
          "X-Request-Id"?: string;
          /** @description The maximum number of requests you're permitted to make per time period. */
          "X-RateLimit-Limit"?: number;
          /** @description The number of requests remaining in the current rate limit window. */
          "X-RateLimit-Remaining"?: number;
          /** @description The relative time in seconds until the current rate-limit window resets.
           *
           *     **Important:** This differs from Github and Twitter's same-named header which uses UTC epoch seconds. We use relative time to avoid client/server time synchronization issues. */
          "X-RateLimit-Reset"?: number;
          [name: string]: unknown;
        };
        content: {
          "application/json": components["schemas"]["cdx.v1.ConsumerSharedResourceList"];
        };
      };
      400: components["responses"]["BadRequestError"];
      401: components["responses"]["UnauthenticatedError"];
      403: components["responses"]["UnauthorizedError"];
      429: components["responses"]["RateLimitError"];
      500: components["responses"]["DefaultSystemError"];
    };
  };
  getCdxV1ConsumerSharedResource: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description The unique identifier for the consumer shared resource. */
        id: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description Consumer Shared Resource. */
      200: {
        headers: {
          /** @description The unique identifier for the API request. */
          "X-Request-Id"?: string;
          /** @description The maximum number of requests you're permitted to make per time period. */
          "X-RateLimit-Limit"?: number;
          /** @description The number of requests remaining in the current rate limit window. */
          "X-RateLimit-Remaining"?: number;
          /** @description The relative time in seconds until the current rate-limit window resets.
           *
           *     **Important:** This differs from Github and Twitter's same-named header which uses UTC epoch seconds. We use relative time to avoid client/server time synchronization issues. */
          "X-RateLimit-Reset"?: number;
          [name: string]: unknown;
        };
        content: {
          "application/json": components["schemas"]["cdx.v1.ConsumerSharedResource"] &
            Record<string, unknown>;
        };
      };
      400: components["responses"]["BadRequestError"];
      401: components["responses"]["UnauthenticatedError"];
      403: components["responses"]["UnauthorizedError"];
      404: components["responses"]["NotFoundError"];
      429: components["responses"]["RateLimitError"];
      500: components["responses"]["DefaultSystemError"];
    };
  };
  imageCdxV1ConsumerSharedResource: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description The unique identifier for the consumer shared resource. */
        id: string;
        /** @description The File Name */
        file_name: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description Returns the image file's binary content */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "image/*": string;
        };
      };
      400: components["responses"]["BadRequestError"];
      401: components["responses"]["UnauthenticatedError"];
      403: components["responses"]["UnauthorizedError"];
      404: components["responses"]["NotFoundError"];
      429: components["responses"]["RateLimitError"];
      500: components["responses"]["DefaultSystemError"];
    };
  };
  networkCdxV1ConsumerSharedResource: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description The unique identifier for the consumer shared resource. */
        id: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description The network information of the shared resource */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "application/json": components["schemas"]["cdx.v1.Network"];
        };
      };
      400: components["responses"]["BadRequestError"];
      401: components["responses"]["UnauthenticatedError"];
      403: components["responses"]["UnauthorizedError"];
      404: components["responses"]["NotFoundError"];
      429: components["responses"]["RateLimitError"];
      500: components["responses"]["DefaultSystemError"];
    };
  };
  listCdxV1ConsumerShares: {
    parameters: {
      query?: {
        /**
         * @description Filter the results by exact match for shared_resource.
         * @example sr-1234
         */
        shared_resource?: components["schemas"]["SearchFilter"];
        /** @description Include deactivated shares */
        include_deleted?: components["schemas"]["BooleanFilter"];
        /** @description A pagination size for collection requests. */
        page_size?: number;
        /** @description An opaque pagination token for collection requests. */
        page_token?: string;
      };
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description Consumer Share. */
      200: {
        headers: {
          /** @description The unique identifier for the API request. */
          "X-Request-Id"?: string;
          /** @description The maximum number of requests you're permitted to make per time period. */
          "X-RateLimit-Limit"?: number;
          /** @description The number of requests remaining in the current rate limit window. */
          "X-RateLimit-Remaining"?: number;
          /** @description The relative time in seconds until the current rate-limit window resets.
           *
           *     **Important:** This differs from Github and Twitter's same-named header which uses UTC epoch seconds. We use relative time to avoid client/server time synchronization issues. */
          "X-RateLimit-Reset"?: number;
          [name: string]: unknown;
        };
        content: {
          "application/json": components["schemas"]["cdx.v1.ConsumerShareList"];
        };
      };
      400: components["responses"]["BadRequestError"];
      401: components["responses"]["UnauthenticatedError"];
      403: components["responses"]["UnauthorizedError"];
      429: components["responses"]["RateLimitError"];
      500: components["responses"]["DefaultSystemError"];
    };
  };
  getCdxV1ConsumerShare: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description The unique identifier for the consumer share. */
        id: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description Consumer Share. */
      200: {
        headers: {
          /** @description The unique identifier for the API request. */
          "X-Request-Id"?: string;
          /** @description The maximum number of requests you're permitted to make per time period. */
          "X-RateLimit-Limit"?: number;
          /** @description The number of requests remaining in the current rate limit window. */
          "X-RateLimit-Remaining"?: number;
          /** @description The relative time in seconds until the current rate-limit window resets.
           *
           *     **Important:** This differs from Github and Twitter's same-named header which uses UTC epoch seconds. We use relative time to avoid client/server time synchronization issues. */
          "X-RateLimit-Reset"?: number;
          [name: string]: unknown;
        };
        content: {
          "application/json": components["schemas"]["cdx.v1.ConsumerShare"] &
            Record<string, unknown>;
        };
      };
      400: components["responses"]["BadRequestError"];
      401: components["responses"]["UnauthenticatedError"];
      403: components["responses"]["UnauthorizedError"];
      404: components["responses"]["NotFoundError"];
      429: components["responses"]["RateLimitError"];
      500: components["responses"]["DefaultSystemError"];
    };
  };
  deleteCdxV1ConsumerShare: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description The unique identifier for the consumer share. */
        id: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description A Consumer Share is being deleted. */
      204: {
        headers: {
          /** @description The unique identifier for the API request. */
          "X-Request-Id"?: string;
          /** @description The maximum number of requests you're permitted to make per time period. */
          "X-RateLimit-Limit"?: number;
          /** @description The number of requests remaining in the current rate limit window. */
          "X-RateLimit-Remaining"?: number;
          /** @description The relative time in seconds until the current rate-limit window resets.
           *
           *     **Important:** This differs from Github and Twitter's same-named header which uses UTC epoch seconds. We use relative time to avoid client/server time synchronization issues. */
          "X-RateLimit-Reset"?: number;
          [name: string]: unknown;
        };
        content?: never;
      };
      400: components["responses"]["BadRequestError"];
      401: components["responses"]["UnauthenticatedError"];
      403: components["responses"]["UnauthorizedError"];
      404: components["responses"]["NotFoundError"];
      429: components["responses"]["RateLimitError"];
      500: components["responses"]["DefaultSystemError"];
    };
  };
  resourcesCdxV1SharedToken: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody?: {
      content: {
        "application/json": components["schemas"]["cdx.v1.SharedToken"] &
          Record<string, unknown>;
      };
    };
    responses: {
      /** @description Consumer validates share token and view consumer resources before redeeming in the workflow
       *      */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "application/json": {
            consumer_shared_resources?: components["schemas"]["cdx.v1.ConsumerSharedResource"][];
          };
        };
      };
      400: components["responses"]["BadRequestError"];
      401: components["responses"]["UnauthenticatedError"];
      403: components["responses"]["UnauthorizedError"];
      404: components["responses"]["NotFoundError"];
      409: components["responses"]["ConflictError"];
      429: components["responses"]["RateLimitError"];
      500: components["responses"]["DefaultSystemError"];
    };
  };
  redeemCdxV1SharedToken: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody?: {
      content: {
        "application/json": components["schemas"]["cdx.v1.RedeemTokenRequest"] &
          Record<string, unknown>;
      };
    };
    responses: {
      /** @description Consumer redeems shared token
       *      */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "application/json": components["schemas"]["cdx.v1.RedeemTokenResponse"];
        };
      };
      400: components["responses"]["BadRequestError"];
      401: components["responses"]["UnauthenticatedError"];
      403: components["responses"]["UnauthorizedError"];
      404: components["responses"]["NotFoundError"];
      409: components["responses"]["ConflictError"];
      429: components["responses"]["RateLimitError"];
      500: components["responses"]["DefaultSystemError"];
    };
  };
  getCdxV1OptIn: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description Opt In. */
      200: {
        headers: {
          /** @description The unique identifier for the API request. */
          "X-Request-Id"?: string;
          /** @description The maximum number of requests you're permitted to make per time period. */
          "X-RateLimit-Limit"?: number;
          /** @description The number of requests remaining in the current rate limit window. */
          "X-RateLimit-Remaining"?: number;
          /** @description The relative time in seconds until the current rate-limit window resets.
           *
           *     **Important:** This differs from Github and Twitter's same-named header which uses UTC epoch seconds. We use relative time to avoid client/server time synchronization issues. */
          "X-RateLimit-Reset"?: number;
          [name: string]: unknown;
        };
        content: {
          "application/json": components["schemas"]["cdx.v1.OptIn"] &
            Record<string, unknown>;
        };
      };
      400: components["responses"]["BadRequestError"];
      401: components["responses"]["UnauthenticatedError"];
      403: components["responses"]["UnauthorizedError"];
      404: components["responses"]["NotFoundError"];
      429: components["responses"]["RateLimitError"];
      500: components["responses"]["DefaultSystemError"];
    };
  };
  updateCdxV1OptIn: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody?: {
      content: {
        "application/json": components["schemas"]["cdx.v1.OptIn"];
      };
    };
    responses: {
      /** @description Opt In. */
      200: {
        headers: {
          /** @description The unique identifier for the API request. */
          "X-Request-Id"?: string;
          /** @description The maximum number of requests you're permitted to make per time period. */
          "X-RateLimit-Limit"?: number;
          /** @description The number of requests remaining in the current rate limit window. */
          "X-RateLimit-Remaining"?: number;
          /** @description The relative time in seconds until the current rate-limit window resets.
           *
           *     **Important:** This differs from Github and Twitter's same-named header which uses UTC epoch seconds. We use relative time to avoid client/server time synchronization issues. */
          "X-RateLimit-Reset"?: number;
          [name: string]: unknown;
        };
        content: {
          "application/json": components["schemas"]["cdx.v1.OptIn"] &
            Record<string, unknown>;
        };
      };
      400: components["responses"]["BadRequestError"];
      401: components["responses"]["UnauthenticatedError"];
      403: components["responses"]["UnauthorizedError"];
      404: components["responses"]["NotFoundError"];
      409: components["responses"]["ConflictError"];
      422: components["responses"]["ValidationError"];
      429: components["responses"]["RateLimitError"];
      500: components["responses"]["DefaultSystemError"];
    };
  };
  getPartnerV2Organization: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description The unique identifier for the organization. */
        id: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description Organization. */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "application/json": components["schemas"]["partner.v2.Organization"] &
            Record<string, unknown>;
        };
      };
      400: components["responses"]["BadRequestError"];
      401: components["responses"]["UnauthenticatedError"];
      403: components["responses"]["UnauthorizedError"];
      404: components["responses"]["NotFoundError"];
      429: components["responses"]["RateLimitError"];
      500: components["responses"]["DefaultSystemError"];
    };
  };
  listPartnerV2Organizations: {
    parameters: {
      query?: {
        /** @description A pagination size for collection requests. */
        page_size?: number;
        /** @description An opaque pagination token for collection requests. */
        page_token?: string;
      };
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description Organization. */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "application/json": components["schemas"]["partner.v2.OrganizationList"];
        };
      };
      400: components["responses"]["BadRequestError"];
      401: components["responses"]["UnauthenticatedError"];
      403: components["responses"]["UnauthorizedError"];
      429: components["responses"]["RateLimitError"];
      500: components["responses"]["DefaultSystemError"];
    };
  };
  signup: {
    parameters: {
      query?: {
        /** @description If true, only perform validation of signup */
        dry_run?: boolean;
      };
      header?: never;
      path?: never;
      cookie?: never;
    };
    /** @description A JSON object containing signup information */
    requestBody?: {
      content: {
        "application/json": components["schemas"]["PartnerSignupRequest"];
      };
    };
    responses: {
      /** @description Successful signup. */
      201: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "application/json": components["schemas"]["PartnerSignupResponse"];
        };
      };
      400: components["responses"]["BadRequestError"];
      401: components["responses"]["UnauthenticatedError"];
      403: components["responses"]["UnauthorizedError"];
      409: components["responses"]["ConflictError"];
      429: components["responses"]["RateLimitError"];
      500: components["responses"]["DefaultSystemError"];
    };
  };
  activateSignup: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /** @description A JSON object containing signup information */
    requestBody?: {
      content: {
        "application/json": components["schemas"]["ActivatePartnerSignupRequest"];
      };
    };
    responses: {
      /** @description Successful signup activation. User is being created. */
      201: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "application/json": components["schemas"]["PartnerSignupResponse"];
        };
      };
      400: components["responses"]["BadRequestError"];
      401: components["responses"]["UnauthenticatedError"];
      403: components["responses"]["UnauthorizedError"];
      409: components["responses"]["ConflictError"];
      429: components["responses"]["RateLimitError"];
      500: components["responses"]["DefaultSystemError"];
    };
  };
  signupPartnerV2Link: {
    parameters: {
      query?: {
        /** @description If true, only perform validation of signup */
        dry_run?: boolean;
      };
      header?: never;
      path?: never;
      cookie?: never;
    };
    /** @description A JSON object containing signup information */
    requestBody?: {
      content: {
        "application/json": components["schemas"]["PartnerLinkRequest"];
      };
    };
    responses: {
      /** @description Successful signup. */
      201: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "application/json": components["schemas"]["PartnerSignupResponse"];
        };
      };
      400: components["responses"]["BadRequestError"];
      401: components["responses"]["UnauthenticatedError"];
      403: components["responses"]["UnauthorizedError"];
      409: components["responses"]["ConflictError"];
      429: components["responses"]["RateLimitError"];
      500: components["responses"]["DefaultSystemError"];
    };
  };
  listNetworkingV1Networks: {
    parameters: {
      query: {
        /**
         * @description Filter the results by exact match for spec.display_name. Pass multiple times to see results matching any of the values.
         * @example [
         *       "prod-gcp-us-central1",
         *       "prod-aws-us-east1"
         *     ]
         */
        "spec.display_name"?: components["schemas"]["MultipleSearchFilter"];
        /**
         * @description Filter the results by exact match for spec.cloud. Pass multiple times to see results matching any of the values.
         * @example [
         *       "GCP",
         *       "AWS"
         *     ]
         */
        "spec.cloud"?: components["schemas"]["MultipleSearchFilter"];
        /**
         * @description Filter the results by exact match for spec.region. Pass multiple times to see results matching any of the values.
         * @example [
         *       "us-central1",
         *       "us-east-1"
         *     ]
         */
        "spec.region"?: components["schemas"]["MultipleSearchFilter"];
        /**
         * @description Filter the results by exact match for spec.connection_types. Pass multiple times to see results matching any of the values.
         * @example [
         *       "peering",
         *       "privatelink"
         *     ]
         */
        "spec.connection_types"?: components["schemas"]["MultipleSearchFilter"];
        /**
         * @description Filter the results by exact match for spec.cidr. Pass multiple times to see results matching any of the values.
         * @example [
         *       "10.200.0.0/16"
         *     ]
         */
        "spec.cidr"?: components["schemas"]["MultipleSearchFilter"];
        /**
         * @description Filter the results by exact match for status.phase. Pass multiple times to see results matching any of the values.
         * @example [
         *       "PROVISIONING",
         *       "READY"
         *     ]
         */
        "status.phase"?: components["schemas"]["MultipleSearchFilter"];
        /**
         * @description Filter the results by exact match for environment.
         * @example env-00000
         */
        environment: components["schemas"]["SearchFilter"];
        /** @description A pagination size for collection requests. */
        page_size?: number;
        /** @description An opaque pagination token for collection requests. */
        page_token?: string;
      };
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description Network. */
      200: {
        headers: {
          /** @description The unique identifier for the API request. */
          "X-Request-Id"?: string;
          /** @description The maximum number of requests you're permitted to make per time period. */
          "X-RateLimit-Limit"?: number;
          /** @description The number of requests remaining in the current rate limit window. */
          "X-RateLimit-Remaining"?: number;
          /** @description The relative time in seconds until the current rate-limit window resets.
           *
           *     **Important:** This differs from Github and Twitter's same-named header which uses UTC epoch seconds. We use relative time to avoid client/server time synchronization issues. */
          "X-RateLimit-Reset"?: number;
          [name: string]: unknown;
        };
        content: {
          "application/json": components["schemas"]["networking.v1.NetworkList"] & {
            data?: {
              spec?: {
                /** @example {
                 *       "id": "env-00000",
                 *       "related": "https://api.confluent.cloud/v2/environments/env-00000",
                 *       "resource_name": "https://api.confluent.cloud/organization=9bb441c4-edef-46ac-8a41-c49e44a3fd9a/environment=env-00000"
                 *     } */
                environment?: unknown;
              };
            }[];
          };
        };
      };
      400: components["responses"]["BadRequestError"];
      401: components["responses"]["UnauthenticatedError"];
      403: components["responses"]["UnauthorizedError"];
      429: components["responses"]["RateLimitError"];
      500: components["responses"]["DefaultSystemError"];
    };
  };
  createNetworkingV1Network: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody?: {
      content: {
        "application/json": components["schemas"]["networking.v1.Network"] & {
          spec: Record<string, unknown>;
        } & {
          spec?: {
            /** @example {
             *       "id": "env-00000"
             *     } */
            environment?: unknown;
          };
        };
      };
    };
    responses: {
      /** @description A Network is being created. */
      202: {
        headers: {
          /** @description The unique identifier for the API request. */
          "X-Request-Id"?: string;
          /** @description The maximum number of requests you're permitted to make per time period. */
          "X-RateLimit-Limit"?: number;
          /** @description The number of requests remaining in the current rate limit window. */
          "X-RateLimit-Remaining"?: number;
          /** @description The relative time in seconds until the current rate-limit window resets.
           *
           *     **Important:** This differs from Github and Twitter's same-named header which uses UTC epoch seconds. We use relative time to avoid client/server time synchronization issues. */
          "X-RateLimit-Reset"?: number;
          /** @description Network resource uri */
          Location?: string;
          [name: string]: unknown;
        };
        content: {
          "application/json": components["schemas"]["networking.v1.Network"] & {
            spec: Record<string, unknown>;
          } & {
            spec?: {
              /** @example {
               *       "id": "env-00000",
               *       "related": "https://api.confluent.cloud/v2/environments/env-00000",
               *       "resource_name": "https://api.confluent.cloud/organization=9bb441c4-edef-46ac-8a41-c49e44a3fd9a/environment=env-00000"
               *     } */
              environment?: unknown;
            };
          };
        };
      };
      400: components["responses"]["BadRequestError"];
      401: components["responses"]["UnauthenticatedError"];
      402: components["responses"]["OverQuotaError"];
      403: components["responses"]["UnauthorizedError"];
      409: components["responses"]["ConflictError"];
      422: components["responses"]["ValidationError"];
      429: components["responses"]["RateLimitError"];
      500: components["responses"]["DefaultSystemError"];
    };
  };
  getNetworkingV1Network: {
    parameters: {
      query: {
        /**
         * @description Scope the operation to the given environment.
         * @example env-00000
         */
        environment: components["schemas"]["SearchFilter"];
      };
      header?: never;
      path: {
        /** @description The unique identifier for the network. */
        id: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description Network. */
      200: {
        headers: {
          /** @description The unique identifier for the API request. */
          "X-Request-Id"?: string;
          /** @description The maximum number of requests you're permitted to make per time period. */
          "X-RateLimit-Limit"?: number;
          /** @description The number of requests remaining in the current rate limit window. */
          "X-RateLimit-Remaining"?: number;
          /** @description The relative time in seconds until the current rate-limit window resets.
           *
           *     **Important:** This differs from Github and Twitter's same-named header which uses UTC epoch seconds. We use relative time to avoid client/server time synchronization issues. */
          "X-RateLimit-Reset"?: number;
          [name: string]: unknown;
        };
        content: {
          "application/json": components["schemas"]["networking.v1.Network"] & {
            spec: Record<string, unknown>;
          } & {
            spec?: {
              /** @example {
               *       "id": "env-00000",
               *       "related": "https://api.confluent.cloud/v2/environments/env-00000",
               *       "resource_name": "https://api.confluent.cloud/organization=9bb441c4-edef-46ac-8a41-c49e44a3fd9a/environment=env-00000"
               *     } */
              environment?: unknown;
            };
          };
        };
      };
      400: components["responses"]["BadRequestError"];
      401: components["responses"]["UnauthenticatedError"];
      403: components["responses"]["UnauthorizedError"];
      404: components["responses"]["NotFoundError"];
      429: components["responses"]["RateLimitError"];
      500: components["responses"]["DefaultSystemError"];
    };
  };
  deleteNetworkingV1Network: {
    parameters: {
      query: {
        /**
         * @description Scope the operation to the given environment.
         * @example env-00000
         */
        environment: components["schemas"]["SearchFilter"];
      };
      header?: never;
      path: {
        /** @description The unique identifier for the network. */
        id: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description A Network is being deleted. */
      204: {
        headers: {
          /** @description The unique identifier for the API request. */
          "X-Request-Id"?: string;
          /** @description The maximum number of requests you're permitted to make per time period. */
          "X-RateLimit-Limit"?: number;
          /** @description The number of requests remaining in the current rate limit window. */
          "X-RateLimit-Remaining"?: number;
          /** @description The relative time in seconds until the current rate-limit window resets.
           *
           *     **Important:** This differs from Github and Twitter's same-named header which uses UTC epoch seconds. We use relative time to avoid client/server time synchronization issues. */
          "X-RateLimit-Reset"?: number;
          [name: string]: unknown;
        };
        content?: never;
      };
      400: components["responses"]["BadRequestError"];
      401: components["responses"]["UnauthenticatedError"];
      403: components["responses"]["UnauthorizedError"];
      404: components["responses"]["NotFoundError"];
      429: components["responses"]["RateLimitError"];
      500: components["responses"]["DefaultSystemError"];
    };
  };
  updateNetworkingV1Network: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description The unique identifier for the network. */
        id: string;
      };
      cookie?: never;
    };
    requestBody?: {
      content: {
        "application/json": components["schemas"]["networking.v1.NetworkUpdate"] & {
          spec: {
            /** @example {
             *       "id": "env-00000"
             *     } */
            environment: unknown;
          };
        };
      };
    };
    responses: {
      /** @description Network. */
      200: {
        headers: {
          /** @description The unique identifier for the API request. */
          "X-Request-Id"?: string;
          /** @description The maximum number of requests you're permitted to make per time period. */
          "X-RateLimit-Limit"?: number;
          /** @description The number of requests remaining in the current rate limit window. */
          "X-RateLimit-Remaining"?: number;
          /** @description The relative time in seconds until the current rate-limit window resets.
           *
           *     **Important:** This differs from Github and Twitter's same-named header which uses UTC epoch seconds. We use relative time to avoid client/server time synchronization issues. */
          "X-RateLimit-Reset"?: number;
          [name: string]: unknown;
        };
        content: {
          "application/json": components["schemas"]["networking.v1.Network"] & {
            spec: Record<string, unknown>;
          } & {
            spec?: {
              /** @example {
               *       "id": "env-00000",
               *       "related": "https://api.confluent.cloud/v2/environments/env-00000",
               *       "resource_name": "https://api.confluent.cloud/organization=9bb441c4-edef-46ac-8a41-c49e44a3fd9a/environment=env-00000"
               *     } */
              environment?: unknown;
            };
          };
        };
      };
      400: components["responses"]["BadRequestError"];
      401: components["responses"]["UnauthenticatedError"];
      402: components["responses"]["OverQuotaError"];
      403: components["responses"]["UnauthorizedError"];
      404: components["responses"]["NotFoundError"];
      409: components["responses"]["ConflictError"];
      422: components["responses"]["ValidationError"];
      429: components["responses"]["RateLimitError"];
      500: components["responses"]["DefaultSystemError"];
    };
  };
  listNetworkingV1Peerings: {
    parameters: {
      query: {
        /**
         * @description Filter the results by exact match for spec.display_name. Pass multiple times to see results matching any of the values.
         * @example [
         *       "prod-peering-uscentral1",
         *       "prod-peering-use1"
         *     ]
         */
        "spec.display_name"?: components["schemas"]["MultipleSearchFilter"];
        /**
         * @description Filter the results by exact match for status.phase. Pass multiple times to see results matching any of the values.
         * @example [
         *       "PROVISIONING",
         *       "READY"
         *     ]
         */
        "status.phase"?: components["schemas"]["MultipleSearchFilter"];
        /**
         * @description Filter the results by exact match for environment.
         * @example env-00000
         */
        environment: components["schemas"]["SearchFilter"];
        /**
         * @description Filter the results by exact match for spec.network. Pass multiple times to see results matching any of the values.
         * @example [
         *       "n-00000",
         *       "n-00001"
         *     ]
         */
        "spec.network"?: components["schemas"]["MultipleSearchFilter"];
        /** @description A pagination size for collection requests. */
        page_size?: number;
        /** @description An opaque pagination token for collection requests. */
        page_token?: string;
      };
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description Peering. */
      200: {
        headers: {
          /** @description The unique identifier for the API request. */
          "X-Request-Id"?: string;
          /** @description The maximum number of requests you're permitted to make per time period. */
          "X-RateLimit-Limit"?: number;
          /** @description The number of requests remaining in the current rate limit window. */
          "X-RateLimit-Remaining"?: number;
          /** @description The relative time in seconds until the current rate-limit window resets.
           *
           *     **Important:** This differs from Github and Twitter's same-named header which uses UTC epoch seconds. We use relative time to avoid client/server time synchronization issues. */
          "X-RateLimit-Reset"?: number;
          [name: string]: unknown;
        };
        content: {
          "application/json": components["schemas"]["networking.v1.PeeringList"] & {
            data?: {
              spec?: {
                /** @example {
                 *       "id": "env-00000",
                 *       "related": "https://api.confluent.cloud/v2/environments/env-00000",
                 *       "resource_name": "https://api.confluent.cloud/organization=9bb441c4-edef-46ac-8a41-c49e44a3fd9a/environment=env-00000"
                 *     } */
                environment?: unknown;
                /** @example {
                 *       "id": "n-00000",
                 *       "related": "https://api.confluent.cloud/networking/v1/networks/n-00000",
                 *       "resource_name": "https://api.confluent.cloud/organization=9bb441c4-edef-46ac-8a41-c49e44a3fd9a/environment=env-abc123/network=n-00000"
                 *     } */
                network?: unknown;
              };
            }[];
          };
        };
      };
      400: components["responses"]["BadRequestError"];
      401: components["responses"]["UnauthenticatedError"];
      403: components["responses"]["UnauthorizedError"];
      429: components["responses"]["RateLimitError"];
      500: components["responses"]["DefaultSystemError"];
    };
  };
  createNetworkingV1Peering: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody?: {
      content: {
        "application/json": components["schemas"]["networking.v1.Peering"] & {
          spec: Record<string, unknown>;
        } & {
          spec?: {
            /** @example {
             *       "id": "env-00000"
             *     } */
            environment?: unknown;
            /** @example {
             *       "id": "n-00000"
             *     } */
            network?: unknown;
          };
        };
      };
    };
    responses: {
      /** @description A Peering is being created. */
      202: {
        headers: {
          /** @description The unique identifier for the API request. */
          "X-Request-Id"?: string;
          /** @description The maximum number of requests you're permitted to make per time period. */
          "X-RateLimit-Limit"?: number;
          /** @description The number of requests remaining in the current rate limit window. */
          "X-RateLimit-Remaining"?: number;
          /** @description The relative time in seconds until the current rate-limit window resets.
           *
           *     **Important:** This differs from Github and Twitter's same-named header which uses UTC epoch seconds. We use relative time to avoid client/server time synchronization issues. */
          "X-RateLimit-Reset"?: number;
          /** @description Peering resource uri */
          Location?: string;
          [name: string]: unknown;
        };
        content: {
          "application/json": components["schemas"]["networking.v1.Peering"] & {
            spec: Record<string, unknown>;
          } & {
            spec?: {
              /** @example {
               *       "id": "env-00000",
               *       "related": "https://api.confluent.cloud/v2/environments/env-00000",
               *       "resource_name": "https://api.confluent.cloud/organization=9bb441c4-edef-46ac-8a41-c49e44a3fd9a/environment=env-00000"
               *     } */
              environment?: unknown;
              /** @example {
               *       "id": "n-00000",
               *       "related": "https://api.confluent.cloud/networking/v1/networks/n-00000",
               *       "resource_name": "https://api.confluent.cloud/organization=9bb441c4-edef-46ac-8a41-c49e44a3fd9a/environment=env-abc123/network=n-00000"
               *     } */
              network?: unknown;
            };
          };
        };
      };
      400: components["responses"]["BadRequestError"];
      401: components["responses"]["UnauthenticatedError"];
      402: components["responses"]["OverQuotaError"];
      403: components["responses"]["UnauthorizedError"];
      409: components["responses"]["ConflictError"];
      422: components["responses"]["ValidationError"];
      429: components["responses"]["RateLimitError"];
      500: components["responses"]["DefaultSystemError"];
    };
  };
  getNetworkingV1Peering: {
    parameters: {
      query: {
        /**
         * @description Scope the operation to the given environment.
         * @example env-00000
         */
        environment: components["schemas"]["SearchFilter"];
      };
      header?: never;
      path: {
        /** @description The unique identifier for the peering. */
        id: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description Peering. */
      200: {
        headers: {
          /** @description The unique identifier for the API request. */
          "X-Request-Id"?: string;
          /** @description The maximum number of requests you're permitted to make per time period. */
          "X-RateLimit-Limit"?: number;
          /** @description The number of requests remaining in the current rate limit window. */
          "X-RateLimit-Remaining"?: number;
          /** @description The relative time in seconds until the current rate-limit window resets.
           *
           *     **Important:** This differs from Github and Twitter's same-named header which uses UTC epoch seconds. We use relative time to avoid client/server time synchronization issues. */
          "X-RateLimit-Reset"?: number;
          [name: string]: unknown;
        };
        content: {
          "application/json": components["schemas"]["networking.v1.Peering"] & {
            spec: Record<string, unknown>;
          } & {
            spec?: {
              /** @example {
               *       "id": "env-00000",
               *       "related": "https://api.confluent.cloud/v2/environments/env-00000",
               *       "resource_name": "https://api.confluent.cloud/organization=9bb441c4-edef-46ac-8a41-c49e44a3fd9a/environment=env-00000"
               *     } */
              environment?: unknown;
              /** @example {
               *       "id": "n-00000",
               *       "related": "https://api.confluent.cloud/networking/v1/networks/n-00000",
               *       "resource_name": "https://api.confluent.cloud/organization=9bb441c4-edef-46ac-8a41-c49e44a3fd9a/environment=env-abc123/network=n-00000"
               *     } */
              network?: unknown;
            };
          };
        };
      };
      400: components["responses"]["BadRequestError"];
      401: components["responses"]["UnauthenticatedError"];
      403: components["responses"]["UnauthorizedError"];
      404: components["responses"]["NotFoundError"];
      429: components["responses"]["RateLimitError"];
      500: components["responses"]["DefaultSystemError"];
    };
  };
  deleteNetworkingV1Peering: {
    parameters: {
      query: {
        /**
         * @description Scope the operation to the given environment.
         * @example env-00000
         */
        environment: components["schemas"]["SearchFilter"];
      };
      header?: never;
      path: {
        /** @description The unique identifier for the peering. */
        id: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description A Peering is being deleted. */
      204: {
        headers: {
          /** @description The unique identifier for the API request. */
          "X-Request-Id"?: string;
          /** @description The maximum number of requests you're permitted to make per time period. */
          "X-RateLimit-Limit"?: number;
          /** @description The number of requests remaining in the current rate limit window. */
          "X-RateLimit-Remaining"?: number;
          /** @description The relative time in seconds until the current rate-limit window resets.
           *
           *     **Important:** This differs from Github and Twitter's same-named header which uses UTC epoch seconds. We use relative time to avoid client/server time synchronization issues. */
          "X-RateLimit-Reset"?: number;
          [name: string]: unknown;
        };
        content?: never;
      };
      400: components["responses"]["BadRequestError"];
      401: components["responses"]["UnauthenticatedError"];
      403: components["responses"]["UnauthorizedError"];
      404: components["responses"]["NotFoundError"];
      429: components["responses"]["RateLimitError"];
      500: components["responses"]["DefaultSystemError"];
    };
  };
  updateNetworkingV1Peering: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description The unique identifier for the peering. */
        id: string;
      };
      cookie?: never;
    };
    requestBody?: {
      content: {
        "application/json": components["schemas"]["networking.v1.PeeringUpdate"] & {
          spec: {
            /** @example {
             *       "id": "env-00000"
             *     } */
            environment: unknown;
          };
        };
      };
    };
    responses: {
      /** @description Peering. */
      200: {
        headers: {
          /** @description The unique identifier for the API request. */
          "X-Request-Id"?: string;
          /** @description The maximum number of requests you're permitted to make per time period. */
          "X-RateLimit-Limit"?: number;
          /** @description The number of requests remaining in the current rate limit window. */
          "X-RateLimit-Remaining"?: number;
          /** @description The relative time in seconds until the current rate-limit window resets.
           *
           *     **Important:** This differs from Github and Twitter's same-named header which uses UTC epoch seconds. We use relative time to avoid client/server time synchronization issues. */
          "X-RateLimit-Reset"?: number;
          [name: string]: unknown;
        };
        content: {
          "application/json": components["schemas"]["networking.v1.Peering"] & {
            spec: Record<string, unknown>;
          } & {
            spec?: {
              /** @example {
               *       "id": "env-00000",
               *       "related": "https://api.confluent.cloud/v2/environments/env-00000",
               *       "resource_name": "https://api.confluent.cloud/organization=9bb441c4-edef-46ac-8a41-c49e44a3fd9a/environment=env-00000"
               *     } */
              environment?: unknown;
              /** @example {
               *       "id": "n-00000",
               *       "related": "https://api.confluent.cloud/networking/v1/networks/n-00000",
               *       "resource_name": "https://api.confluent.cloud/organization=9bb441c4-edef-46ac-8a41-c49e44a3fd9a/environment=env-abc123/network=n-00000"
               *     } */
              network?: unknown;
            };
          };
        };
      };
      400: components["responses"]["BadRequestError"];
      401: components["responses"]["UnauthenticatedError"];
      402: components["responses"]["OverQuotaError"];
      403: components["responses"]["UnauthorizedError"];
      404: components["responses"]["NotFoundError"];
      409: components["responses"]["ConflictError"];
      422: components["responses"]["ValidationError"];
      429: components["responses"]["RateLimitError"];
      500: components["responses"]["DefaultSystemError"];
    };
  };
  listNetworkingV1TransitGatewayAttachments: {
    parameters: {
      query: {
        /**
         * @description Filter the results by exact match for spec.display_name. Pass multiple times to see results matching any of the values.
         * @example [
         *       "prod-tgw-use1",
         *       "prod-tgw-usw2"
         *     ]
         */
        "spec.display_name"?: components["schemas"]["MultipleSearchFilter"];
        /**
         * @description Filter the results by exact match for status.phase. Pass multiple times to see results matching any of the values.
         * @example [
         *       "PROVISIONING",
         *       "READY"
         *     ]
         */
        "status.phase"?: components["schemas"]["MultipleSearchFilter"];
        /**
         * @description Filter the results by exact match for environment.
         * @example env-00000
         */
        environment: components["schemas"]["SearchFilter"];
        /**
         * @description Filter the results by exact match for spec.network. Pass multiple times to see results matching any of the values.
         * @example [
         *       "n-00000",
         *       "n-00001"
         *     ]
         */
        "spec.network"?: components["schemas"]["MultipleSearchFilter"];
        /** @description A pagination size for collection requests. */
        page_size?: number;
        /** @description An opaque pagination token for collection requests. */
        page_token?: string;
      };
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description Transit Gateway Attachment. */
      200: {
        headers: {
          /** @description The unique identifier for the API request. */
          "X-Request-Id"?: string;
          /** @description The maximum number of requests you're permitted to make per time period. */
          "X-RateLimit-Limit"?: number;
          /** @description The number of requests remaining in the current rate limit window. */
          "X-RateLimit-Remaining"?: number;
          /** @description The relative time in seconds until the current rate-limit window resets.
           *
           *     **Important:** This differs from Github and Twitter's same-named header which uses UTC epoch seconds. We use relative time to avoid client/server time synchronization issues. */
          "X-RateLimit-Reset"?: number;
          [name: string]: unknown;
        };
        content: {
          "application/json": components["schemas"]["networking.v1.TransitGatewayAttachmentList"] & {
            data?: {
              spec?: {
                /** @example {
                 *       "id": "env-00000",
                 *       "related": "https://api.confluent.cloud/v2/environments/env-00000",
                 *       "resource_name": "https://api.confluent.cloud/organization=9bb441c4-edef-46ac-8a41-c49e44a3fd9a/environment=env-00000"
                 *     } */
                environment?: unknown;
                /** @example {
                 *       "id": "n-00000",
                 *       "related": "https://api.confluent.cloud/networking/v1/networks/n-00000",
                 *       "resource_name": "https://api.confluent.cloud/organization=9bb441c4-edef-46ac-8a41-c49e44a3fd9a/environment=env-abc123/network=n-00000"
                 *     } */
                network?: unknown;
              };
            }[];
          };
        };
      };
      400: components["responses"]["BadRequestError"];
      401: components["responses"]["UnauthenticatedError"];
      403: components["responses"]["UnauthorizedError"];
      429: components["responses"]["RateLimitError"];
      500: components["responses"]["DefaultSystemError"];
    };
  };
  createNetworkingV1TransitGatewayAttachment: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody?: {
      content: {
        "application/json": components["schemas"]["networking.v1.TransitGatewayAttachment"] & {
          spec: Record<string, unknown>;
        } & {
          spec?: {
            /** @example {
             *       "id": "env-00000"
             *     } */
            environment?: unknown;
            /** @example {
             *       "id": "n-00000"
             *     } */
            network?: unknown;
          };
        };
      };
    };
    responses: {
      /** @description A Transit Gateway Attachment is being created. */
      202: {
        headers: {
          /** @description The unique identifier for the API request. */
          "X-Request-Id"?: string;
          /** @description The maximum number of requests you're permitted to make per time period. */
          "X-RateLimit-Limit"?: number;
          /** @description The number of requests remaining in the current rate limit window. */
          "X-RateLimit-Remaining"?: number;
          /** @description The relative time in seconds until the current rate-limit window resets.
           *
           *     **Important:** This differs from Github and Twitter's same-named header which uses UTC epoch seconds. We use relative time to avoid client/server time synchronization issues. */
          "X-RateLimit-Reset"?: number;
          /** @description TransitGatewayAttachment resource uri */
          Location?: string;
          [name: string]: unknown;
        };
        content: {
          "application/json": components["schemas"]["networking.v1.TransitGatewayAttachment"] & {
            spec: Record<string, unknown>;
          } & {
            spec?: {
              /** @example {
               *       "id": "env-00000",
               *       "related": "https://api.confluent.cloud/v2/environments/env-00000",
               *       "resource_name": "https://api.confluent.cloud/organization=9bb441c4-edef-46ac-8a41-c49e44a3fd9a/environment=env-00000"
               *     } */
              environment?: unknown;
              /** @example {
               *       "id": "n-00000",
               *       "related": "https://api.confluent.cloud/networking/v1/networks/n-00000",
               *       "resource_name": "https://api.confluent.cloud/organization=9bb441c4-edef-46ac-8a41-c49e44a3fd9a/environment=env-abc123/network=n-00000"
               *     } */
              network?: unknown;
            };
          };
        };
      };
      400: components["responses"]["BadRequestError"];
      401: components["responses"]["UnauthenticatedError"];
      402: components["responses"]["OverQuotaError"];
      403: components["responses"]["UnauthorizedError"];
      409: components["responses"]["ConflictError"];
      422: components["responses"]["ValidationError"];
      429: components["responses"]["RateLimitError"];
      500: components["responses"]["DefaultSystemError"];
    };
  };
  getNetworkingV1TransitGatewayAttachment: {
    parameters: {
      query: {
        /**
         * @description Scope the operation to the given environment.
         * @example env-00000
         */
        environment: components["schemas"]["SearchFilter"];
      };
      header?: never;
      path: {
        /** @description The unique identifier for the transit gateway attachment. */
        id: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description Transit Gateway Attachment. */
      200: {
        headers: {
          /** @description The unique identifier for the API request. */
          "X-Request-Id"?: string;
          /** @description The maximum number of requests you're permitted to make per time period. */
          "X-RateLimit-Limit"?: number;
          /** @description The number of requests remaining in the current rate limit window. */
          "X-RateLimit-Remaining"?: number;
          /** @description The relative time in seconds until the current rate-limit window resets.
           *
           *     **Important:** This differs from Github and Twitter's same-named header which uses UTC epoch seconds. We use relative time to avoid client/server time synchronization issues. */
          "X-RateLimit-Reset"?: number;
          [name: string]: unknown;
        };
        content: {
          "application/json": components["schemas"]["networking.v1.TransitGatewayAttachment"] & {
            spec: Record<string, unknown>;
          } & {
            spec?: {
              /** @example {
               *       "id": "env-00000",
               *       "related": "https://api.confluent.cloud/v2/environments/env-00000",
               *       "resource_name": "https://api.confluent.cloud/organization=9bb441c4-edef-46ac-8a41-c49e44a3fd9a/environment=env-00000"
               *     } */
              environment?: unknown;
              /** @example {
               *       "id": "n-00000",
               *       "related": "https://api.confluent.cloud/networking/v1/networks/n-00000",
               *       "resource_name": "https://api.confluent.cloud/organization=9bb441c4-edef-46ac-8a41-c49e44a3fd9a/environment=env-abc123/network=n-00000"
               *     } */
              network?: unknown;
            };
          };
        };
      };
      400: components["responses"]["BadRequestError"];
      401: components["responses"]["UnauthenticatedError"];
      403: components["responses"]["UnauthorizedError"];
      404: components["responses"]["NotFoundError"];
      429: components["responses"]["RateLimitError"];
      500: components["responses"]["DefaultSystemError"];
    };
  };
  deleteNetworkingV1TransitGatewayAttachment: {
    parameters: {
      query: {
        /**
         * @description Scope the operation to the given environment.
         * @example env-00000
         */
        environment: components["schemas"]["SearchFilter"];
      };
      header?: never;
      path: {
        /** @description The unique identifier for the transit gateway attachment. */
        id: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description A Transit Gateway Attachment is being deleted. */
      204: {
        headers: {
          /** @description The unique identifier for the API request. */
          "X-Request-Id"?: string;
          /** @description The maximum number of requests you're permitted to make per time period. */
          "X-RateLimit-Limit"?: number;
          /** @description The number of requests remaining in the current rate limit window. */
          "X-RateLimit-Remaining"?: number;
          /** @description The relative time in seconds until the current rate-limit window resets.
           *
           *     **Important:** This differs from Github and Twitter's same-named header which uses UTC epoch seconds. We use relative time to avoid client/server time synchronization issues. */
          "X-RateLimit-Reset"?: number;
          [name: string]: unknown;
        };
        content?: never;
      };
      400: components["responses"]["BadRequestError"];
      401: components["responses"]["UnauthenticatedError"];
      403: components["responses"]["UnauthorizedError"];
      404: components["responses"]["NotFoundError"];
      429: components["responses"]["RateLimitError"];
      500: components["responses"]["DefaultSystemError"];
    };
  };
  updateNetworkingV1TransitGatewayAttachment: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description The unique identifier for the transit gateway attachment. */
        id: string;
      };
      cookie?: never;
    };
    requestBody?: {
      content: {
        "application/json": components["schemas"]["networking.v1.TransitGatewayAttachmentUpdate"] & {
          spec: {
            /** @example {
             *       "id": "env-00000"
             *     } */
            environment: unknown;
          };
        };
      };
    };
    responses: {
      /** @description Transit Gateway Attachment. */
      200: {
        headers: {
          /** @description The unique identifier for the API request. */
          "X-Request-Id"?: string;
          /** @description The maximum number of requests you're permitted to make per time period. */
          "X-RateLimit-Limit"?: number;
          /** @description The number of requests remaining in the current rate limit window. */
          "X-RateLimit-Remaining"?: number;
          /** @description The relative time in seconds until the current rate-limit window resets.
           *
           *     **Important:** This differs from Github and Twitter's same-named header which uses UTC epoch seconds. We use relative time to avoid client/server time synchronization issues. */
          "X-RateLimit-Reset"?: number;
          [name: string]: unknown;
        };
        content: {
          "application/json": components["schemas"]["networking.v1.TransitGatewayAttachment"] & {
            spec: Record<string, unknown>;
          } & {
            spec?: {
              /** @example {
               *       "id": "env-00000",
               *       "related": "https://api.confluent.cloud/v2/environments/env-00000",
               *       "resource_name": "https://api.confluent.cloud/organization=9bb441c4-edef-46ac-8a41-c49e44a3fd9a/environment=env-00000"
               *     } */
              environment?: unknown;
              /** @example {
               *       "id": "n-00000",
               *       "related": "https://api.confluent.cloud/networking/v1/networks/n-00000",
               *       "resource_name": "https://api.confluent.cloud/organization=9bb441c4-edef-46ac-8a41-c49e44a3fd9a/environment=env-abc123/network=n-00000"
               *     } */
              network?: unknown;
            };
          };
        };
      };
      400: components["responses"]["BadRequestError"];
      401: components["responses"]["UnauthenticatedError"];
      402: components["responses"]["OverQuotaError"];
      403: components["responses"]["UnauthorizedError"];
      404: components["responses"]["NotFoundError"];
      409: components["responses"]["ConflictError"];
      422: components["responses"]["ValidationError"];
      429: components["responses"]["RateLimitError"];
      500: components["responses"]["DefaultSystemError"];
    };
  };
  listNetworkingV1PrivateLinkAccesses: {
    parameters: {
      query: {
        /**
         * @description Filter the results by exact match for spec.display_name. Pass multiple times to see results matching any of the values.
         * @example [
         *       "prod-pl-use1",
         *       "prod-pl-usw2"
         *     ]
         */
        "spec.display_name"?: components["schemas"]["MultipleSearchFilter"];
        /**
         * @description Filter the results by exact match for status.phase. Pass multiple times to see results matching any of the values.
         * @example [
         *       "PROVISIONING",
         *       "READY"
         *     ]
         */
        "status.phase"?: components["schemas"]["MultipleSearchFilter"];
        /**
         * @description Filter the results by exact match for environment.
         * @example env-00000
         */
        environment: components["schemas"]["SearchFilter"];
        /**
         * @description Filter the results by exact match for spec.network. Pass multiple times to see results matching any of the values.
         * @example [
         *       "n-00000",
         *       "n-00001"
         *     ]
         */
        "spec.network"?: components["schemas"]["MultipleSearchFilter"];
        /** @description A pagination size for collection requests. */
        page_size?: number;
        /** @description An opaque pagination token for collection requests. */
        page_token?: string;
      };
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description Private Link Access. */
      200: {
        headers: {
          /** @description The unique identifier for the API request. */
          "X-Request-Id"?: string;
          /** @description The maximum number of requests you're permitted to make per time period. */
          "X-RateLimit-Limit"?: number;
          /** @description The number of requests remaining in the current rate limit window. */
          "X-RateLimit-Remaining"?: number;
          /** @description The relative time in seconds until the current rate-limit window resets.
           *
           *     **Important:** This differs from Github and Twitter's same-named header which uses UTC epoch seconds. We use relative time to avoid client/server time synchronization issues. */
          "X-RateLimit-Reset"?: number;
          [name: string]: unknown;
        };
        content: {
          "application/json": components["schemas"]["networking.v1.PrivateLinkAccessList"] & {
            data?: {
              spec?: {
                /** @example {
                 *       "id": "env-00000",
                 *       "related": "https://api.confluent.cloud/v2/environments/env-00000",
                 *       "resource_name": "https://api.confluent.cloud/organization=9bb441c4-edef-46ac-8a41-c49e44a3fd9a/environment=env-00000"
                 *     } */
                environment?: unknown;
                /** @example {
                 *       "id": "n-00000",
                 *       "related": "https://api.confluent.cloud/networking/v1/networks/n-00000",
                 *       "resource_name": "https://api.confluent.cloud/organization=9bb441c4-edef-46ac-8a41-c49e44a3fd9a/environment=env-abc123/network=n-00000"
                 *     } */
                network?: unknown;
              };
            }[];
          };
        };
      };
      400: components["responses"]["BadRequestError"];
      401: components["responses"]["UnauthenticatedError"];
      403: components["responses"]["UnauthorizedError"];
      429: components["responses"]["RateLimitError"];
      500: components["responses"]["DefaultSystemError"];
    };
  };
  createNetworkingV1PrivateLinkAccess: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody?: {
      content: {
        "application/json": components["schemas"]["networking.v1.PrivateLinkAccess"] & {
          spec: Record<string, unknown>;
        } & {
          spec?: {
            /** @example {
             *       "id": "env-00000"
             *     } */
            environment?: unknown;
            /** @example {
             *       "id": "n-00000"
             *     } */
            network?: unknown;
          };
        };
      };
    };
    responses: {
      /** @description A Private Link Access is being created. */
      202: {
        headers: {
          /** @description The unique identifier for the API request. */
          "X-Request-Id"?: string;
          /** @description The maximum number of requests you're permitted to make per time period. */
          "X-RateLimit-Limit"?: number;
          /** @description The number of requests remaining in the current rate limit window. */
          "X-RateLimit-Remaining"?: number;
          /** @description The relative time in seconds until the current rate-limit window resets.
           *
           *     **Important:** This differs from Github and Twitter's same-named header which uses UTC epoch seconds. We use relative time to avoid client/server time synchronization issues. */
          "X-RateLimit-Reset"?: number;
          /** @description PrivateLinkAccess resource uri */
          Location?: string;
          [name: string]: unknown;
        };
        content: {
          "application/json": components["schemas"]["networking.v1.PrivateLinkAccess"] & {
            spec: Record<string, unknown>;
          } & {
            spec?: {
              /** @example {
               *       "id": "env-00000",
               *       "related": "https://api.confluent.cloud/v2/environments/env-00000",
               *       "resource_name": "https://api.confluent.cloud/organization=9bb441c4-edef-46ac-8a41-c49e44a3fd9a/environment=env-00000"
               *     } */
              environment?: unknown;
              /** @example {
               *       "id": "n-00000",
               *       "related": "https://api.confluent.cloud/networking/v1/networks/n-00000",
               *       "resource_name": "https://api.confluent.cloud/organization=9bb441c4-edef-46ac-8a41-c49e44a3fd9a/environment=env-abc123/network=n-00000"
               *     } */
              network?: unknown;
            };
          };
        };
      };
      400: components["responses"]["BadRequestError"];
      401: components["responses"]["UnauthenticatedError"];
      402: components["responses"]["OverQuotaError"];
      403: components["responses"]["UnauthorizedError"];
      409: components["responses"]["ConflictError"];
      422: components["responses"]["ValidationError"];
      429: components["responses"]["RateLimitError"];
      500: components["responses"]["DefaultSystemError"];
    };
  };
  getNetworkingV1PrivateLinkAccess: {
    parameters: {
      query: {
        /**
         * @description Scope the operation to the given environment.
         * @example env-00000
         */
        environment: components["schemas"]["SearchFilter"];
      };
      header?: never;
      path: {
        /** @description The unique identifier for the private link access. */
        id: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description Private Link Access. */
      200: {
        headers: {
          /** @description The unique identifier for the API request. */
          "X-Request-Id"?: string;
          /** @description The maximum number of requests you're permitted to make per time period. */
          "X-RateLimit-Limit"?: number;
          /** @description The number of requests remaining in the current rate limit window. */
          "X-RateLimit-Remaining"?: number;
          /** @description The relative time in seconds until the current rate-limit window resets.
           *
           *     **Important:** This differs from Github and Twitter's same-named header which uses UTC epoch seconds. We use relative time to avoid client/server time synchronization issues. */
          "X-RateLimit-Reset"?: number;
          [name: string]: unknown;
        };
        content: {
          "application/json": components["schemas"]["networking.v1.PrivateLinkAccess"] & {
            spec: Record<string, unknown>;
          } & {
            spec?: {
              /** @example {
               *       "id": "env-00000",
               *       "related": "https://api.confluent.cloud/v2/environments/env-00000",
               *       "resource_name": "https://api.confluent.cloud/organization=9bb441c4-edef-46ac-8a41-c49e44a3fd9a/environment=env-00000"
               *     } */
              environment?: unknown;
              /** @example {
               *       "id": "n-00000",
               *       "related": "https://api.confluent.cloud/networking/v1/networks/n-00000",
               *       "resource_name": "https://api.confluent.cloud/organization=9bb441c4-edef-46ac-8a41-c49e44a3fd9a/environment=env-abc123/network=n-00000"
               *     } */
              network?: unknown;
            };
          };
        };
      };
      400: components["responses"]["BadRequestError"];
      401: components["responses"]["UnauthenticatedError"];
      403: components["responses"]["UnauthorizedError"];
      404: components["responses"]["NotFoundError"];
      429: components["responses"]["RateLimitError"];
      500: components["responses"]["DefaultSystemError"];
    };
  };
  deleteNetworkingV1PrivateLinkAccess: {
    parameters: {
      query: {
        /**
         * @description Scope the operation to the given environment.
         * @example env-00000
         */
        environment: components["schemas"]["SearchFilter"];
      };
      header?: never;
      path: {
        /** @description The unique identifier for the private link access. */
        id: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description A Private Link Access is being deleted. */
      204: {
        headers: {
          /** @description The unique identifier for the API request. */
          "X-Request-Id"?: string;
          /** @description The maximum number of requests you're permitted to make per time period. */
          "X-RateLimit-Limit"?: number;
          /** @description The number of requests remaining in the current rate limit window. */
          "X-RateLimit-Remaining"?: number;
          /** @description The relative time in seconds until the current rate-limit window resets.
           *
           *     **Important:** This differs from Github and Twitter's same-named header which uses UTC epoch seconds. We use relative time to avoid client/server time synchronization issues. */
          "X-RateLimit-Reset"?: number;
          [name: string]: unknown;
        };
        content?: never;
      };
      400: components["responses"]["BadRequestError"];
      401: components["responses"]["UnauthenticatedError"];
      403: components["responses"]["UnauthorizedError"];
      404: components["responses"]["NotFoundError"];
      429: components["responses"]["RateLimitError"];
      500: components["responses"]["DefaultSystemError"];
    };
  };
  updateNetworkingV1PrivateLinkAccess: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description The unique identifier for the private link access. */
        id: string;
      };
      cookie?: never;
    };
    requestBody?: {
      content: {
        "application/json": components["schemas"]["networking.v1.PrivateLinkAccessUpdate"] & {
          spec: {
            /** @example {
             *       "id": "env-00000"
             *     } */
            environment: unknown;
          };
        };
      };
    };
    responses: {
      /** @description Private Link Access. */
      200: {
        headers: {
          /** @description The unique identifier for the API request. */
          "X-Request-Id"?: string;
          /** @description The maximum number of requests you're permitted to make per time period. */
          "X-RateLimit-Limit"?: number;
          /** @description The number of requests remaining in the current rate limit window. */
          "X-RateLimit-Remaining"?: number;
          /** @description The relative time in seconds until the current rate-limit window resets.
           *
           *     **Important:** This differs from Github and Twitter's same-named header which uses UTC epoch seconds. We use relative time to avoid client/server time synchronization issues. */
          "X-RateLimit-Reset"?: number;
          [name: string]: unknown;
        };
        content: {
          "application/json": components["schemas"]["networking.v1.PrivateLinkAccess"] & {
            spec: Record<string, unknown>;
          } & {
            spec?: {
              /** @example {
               *       "id": "env-00000",
               *       "related": "https://api.confluent.cloud/v2/environments/env-00000",
               *       "resource_name": "https://api.confluent.cloud/organization=9bb441c4-edef-46ac-8a41-c49e44a3fd9a/environment=env-00000"
               *     } */
              environment?: unknown;
              /** @example {
               *       "id": "n-00000",
               *       "related": "https://api.confluent.cloud/networking/v1/networks/n-00000",
               *       "resource_name": "https://api.confluent.cloud/organization=9bb441c4-edef-46ac-8a41-c49e44a3fd9a/environment=env-abc123/network=n-00000"
               *     } */
              network?: unknown;
            };
          };
        };
      };
      400: components["responses"]["BadRequestError"];
      401: components["responses"]["UnauthenticatedError"];
      402: components["responses"]["OverQuotaError"];
      403: components["responses"]["UnauthorizedError"];
      404: components["responses"]["NotFoundError"];
      409: components["responses"]["ConflictError"];
      422: components["responses"]["ValidationError"];
      429: components["responses"]["RateLimitError"];
      500: components["responses"]["DefaultSystemError"];
    };
  };
  listNetworkingV1NetworkLinkServices: {
    parameters: {
      query: {
        /**
         * @description Filter the results by exact match for spec.display_name. Pass multiple times to see results matching any of the values.
         * @example [
         *       "prod-net-1-nls",
         *       "dev-net-1-nls"
         *     ]
         */
        "spec.display_name"?: components["schemas"]["MultipleSearchFilter"];
        /**
         * @description Filter the results by exact match for status.phase. Pass multiple times to see results matching any of the values.
         * @example [
         *       "READY"
         *     ]
         */
        "status.phase"?: components["schemas"]["MultipleSearchFilter"];
        /**
         * @description Filter the results by exact match for environment.
         * @example env-00000
         */
        environment: components["schemas"]["SearchFilter"];
        /**
         * @description Filter the results by exact match for spec.network. Pass multiple times to see results matching any of the values.
         * @example [
         *       "n-00000",
         *       "n-00001"
         *     ]
         */
        "spec.network"?: components["schemas"]["MultipleSearchFilter"];
        /** @description A pagination size for collection requests. */
        page_size?: number;
        /** @description An opaque pagination token for collection requests. */
        page_token?: string;
      };
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description Network Link Service. */
      200: {
        headers: {
          /** @description The unique identifier for the API request. */
          "X-Request-Id"?: string;
          /** @description The maximum number of requests you're permitted to make per time period. */
          "X-RateLimit-Limit"?: number;
          /** @description The number of requests remaining in the current rate limit window. */
          "X-RateLimit-Remaining"?: number;
          /** @description The relative time in seconds until the current rate-limit window resets.
           *
           *     **Important:** This differs from Github and Twitter's same-named header which uses UTC epoch seconds. We use relative time to avoid client/server time synchronization issues. */
          "X-RateLimit-Reset"?: number;
          [name: string]: unknown;
        };
        content: {
          "application/json": components["schemas"]["networking.v1.NetworkLinkServiceList"] & {
            data?: {
              spec?: {
                /** @example {
                 *       "id": "env-00000",
                 *       "related": "https://api.confluent.cloud/v2/environments/env-00000",
                 *       "resource_name": "https://api.confluent.cloud/organization=9bb441c4-edef-46ac-8a41-c49e44a3fd9a/environment=env-00000"
                 *     } */
                environment?: unknown;
                /** @example {
                 *       "id": "n-00000",
                 *       "related": "https://api.confluent.cloud/networking/v1/networks/n-00000",
                 *       "resource_name": "https://api.confluent.cloud/organization=9bb441c4-edef-46ac-8a41-c49e44a3fd9a/environment=env-abc123/network=n-00000"
                 *     } */
                network?: unknown;
              };
            }[];
          };
        };
      };
      400: components["responses"]["BadRequestError"];
      401: components["responses"]["UnauthenticatedError"];
      403: components["responses"]["UnauthorizedError"];
      429: components["responses"]["RateLimitError"];
      500: components["responses"]["DefaultSystemError"];
    };
  };
  createNetworkingV1NetworkLinkService: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody?: {
      content: {
        "application/json": components["schemas"]["networking.v1.NetworkLinkService"] & {
          spec: Record<string, unknown>;
        } & {
          spec?: {
            /** @example {
             *       "id": "env-00000"
             *     } */
            environment?: unknown;
            /** @example {
             *       "id": "n-00000"
             *     } */
            network?: unknown;
          };
        };
      };
    };
    responses: {
      /** @description A Network Link Service is being created. */
      202: {
        headers: {
          /** @description The unique identifier for the API request. */
          "X-Request-Id"?: string;
          /** @description The maximum number of requests you're permitted to make per time period. */
          "X-RateLimit-Limit"?: number;
          /** @description The number of requests remaining in the current rate limit window. */
          "X-RateLimit-Remaining"?: number;
          /** @description The relative time in seconds until the current rate-limit window resets.
           *
           *     **Important:** This differs from Github and Twitter's same-named header which uses UTC epoch seconds. We use relative time to avoid client/server time synchronization issues. */
          "X-RateLimit-Reset"?: number;
          /** @description NetworkLinkService resource uri */
          Location?: string;
          [name: string]: unknown;
        };
        content: {
          "application/json": components["schemas"]["networking.v1.NetworkLinkService"] & {
            spec: Record<string, unknown>;
          } & {
            spec?: {
              /** @example {
               *       "id": "env-00000",
               *       "related": "https://api.confluent.cloud/v2/environments/env-00000",
               *       "resource_name": "https://api.confluent.cloud/organization=9bb441c4-edef-46ac-8a41-c49e44a3fd9a/environment=env-00000"
               *     } */
              environment?: unknown;
              /** @example {
               *       "id": "n-00000",
               *       "related": "https://api.confluent.cloud/networking/v1/networks/n-00000",
               *       "resource_name": "https://api.confluent.cloud/organization=9bb441c4-edef-46ac-8a41-c49e44a3fd9a/environment=env-abc123/network=n-00000"
               *     } */
              network?: unknown;
            };
          };
        };
      };
      400: components["responses"]["BadRequestError"];
      401: components["responses"]["UnauthenticatedError"];
      402: components["responses"]["OverQuotaError"];
      403: components["responses"]["UnauthorizedError"];
      409: components["responses"]["ConflictError"];
      422: components["responses"]["ValidationError"];
      429: components["responses"]["RateLimitError"];
      500: components["responses"]["DefaultSystemError"];
    };
  };
  getNetworkingV1NetworkLinkService: {
    parameters: {
      query: {
        /**
         * @description Scope the operation to the given environment.
         * @example env-00000
         */
        environment: components["schemas"]["SearchFilter"];
      };
      header?: never;
      path: {
        /** @description The unique identifier for the network link service. */
        id: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description Network Link Service. */
      200: {
        headers: {
          /** @description The unique identifier for the API request. */
          "X-Request-Id"?: string;
          /** @description The maximum number of requests you're permitted to make per time period. */
          "X-RateLimit-Limit"?: number;
          /** @description The number of requests remaining in the current rate limit window. */
          "X-RateLimit-Remaining"?: number;
          /** @description The relative time in seconds until the current rate-limit window resets.
           *
           *     **Important:** This differs from Github and Twitter's same-named header which uses UTC epoch seconds. We use relative time to avoid client/server time synchronization issues. */
          "X-RateLimit-Reset"?: number;
          [name: string]: unknown;
        };
        content: {
          "application/json": components["schemas"]["networking.v1.NetworkLinkService"] & {
            spec: Record<string, unknown>;
          } & {
            spec?: {
              /** @example {
               *       "id": "env-00000",
               *       "related": "https://api.confluent.cloud/v2/environments/env-00000",
               *       "resource_name": "https://api.confluent.cloud/organization=9bb441c4-edef-46ac-8a41-c49e44a3fd9a/environment=env-00000"
               *     } */
              environment?: unknown;
              /** @example {
               *       "id": "n-00000",
               *       "related": "https://api.confluent.cloud/networking/v1/networks/n-00000",
               *       "resource_name": "https://api.confluent.cloud/organization=9bb441c4-edef-46ac-8a41-c49e44a3fd9a/environment=env-abc123/network=n-00000"
               *     } */
              network?: unknown;
            };
          };
        };
      };
      400: components["responses"]["BadRequestError"];
      401: components["responses"]["UnauthenticatedError"];
      403: components["responses"]["UnauthorizedError"];
      404: components["responses"]["NotFoundError"];
      429: components["responses"]["RateLimitError"];
      500: components["responses"]["DefaultSystemError"];
    };
  };
  deleteNetworkingV1NetworkLinkService: {
    parameters: {
      query: {
        /**
         * @description Scope the operation to the given environment.
         * @example env-00000
         */
        environment: components["schemas"]["SearchFilter"];
      };
      header?: never;
      path: {
        /** @description The unique identifier for the network link service. */
        id: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description A Network Link Service is being deleted. */
      204: {
        headers: {
          /** @description The unique identifier for the API request. */
          "X-Request-Id"?: string;
          /** @description The maximum number of requests you're permitted to make per time period. */
          "X-RateLimit-Limit"?: number;
          /** @description The number of requests remaining in the current rate limit window. */
          "X-RateLimit-Remaining"?: number;
          /** @description The relative time in seconds until the current rate-limit window resets.
           *
           *     **Important:** This differs from Github and Twitter's same-named header which uses UTC epoch seconds. We use relative time to avoid client/server time synchronization issues. */
          "X-RateLimit-Reset"?: number;
          [name: string]: unknown;
        };
        content?: never;
      };
      400: components["responses"]["BadRequestError"];
      401: components["responses"]["UnauthenticatedError"];
      403: components["responses"]["UnauthorizedError"];
      404: components["responses"]["NotFoundError"];
      429: components["responses"]["RateLimitError"];
      500: components["responses"]["DefaultSystemError"];
    };
  };
  updateNetworkingV1NetworkLinkService: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description The unique identifier for the network link service. */
        id: string;
      };
      cookie?: never;
    };
    requestBody?: {
      content: {
        "application/json": components["schemas"]["networking.v1.NetworkLinkServiceUpdate"] & {
          spec: {
            /** @example {
             *       "id": "env-00000"
             *     } */
            environment: unknown;
          };
        };
      };
    };
    responses: {
      /** @description Network Link Service. */
      200: {
        headers: {
          /** @description The unique identifier for the API request. */
          "X-Request-Id"?: string;
          /** @description The maximum number of requests you're permitted to make per time period. */
          "X-RateLimit-Limit"?: number;
          /** @description The number of requests remaining in the current rate limit window. */
          "X-RateLimit-Remaining"?: number;
          /** @description The relative time in seconds until the current rate-limit window resets.
           *
           *     **Important:** This differs from Github and Twitter's same-named header which uses UTC epoch seconds. We use relative time to avoid client/server time synchronization issues. */
          "X-RateLimit-Reset"?: number;
          [name: string]: unknown;
        };
        content: {
          "application/json": components["schemas"]["networking.v1.NetworkLinkService"] & {
            spec: Record<string, unknown>;
          } & {
            spec?: {
              /** @example {
               *       "id": "env-00000",
               *       "related": "https://api.confluent.cloud/v2/environments/env-00000",
               *       "resource_name": "https://api.confluent.cloud/organization=9bb441c4-edef-46ac-8a41-c49e44a3fd9a/environment=env-00000"
               *     } */
              environment?: unknown;
              /** @example {
               *       "id": "n-00000",
               *       "related": "https://api.confluent.cloud/networking/v1/networks/n-00000",
               *       "resource_name": "https://api.confluent.cloud/organization=9bb441c4-edef-46ac-8a41-c49e44a3fd9a/environment=env-abc123/network=n-00000"
               *     } */
              network?: unknown;
            };
          };
        };
      };
      400: components["responses"]["BadRequestError"];
      401: components["responses"]["UnauthenticatedError"];
      402: components["responses"]["OverQuotaError"];
      403: components["responses"]["UnauthorizedError"];
      404: components["responses"]["NotFoundError"];
      409: components["responses"]["ConflictError"];
      422: components["responses"]["ValidationError"];
      429: components["responses"]["RateLimitError"];
      500: components["responses"]["DefaultSystemError"];
    };
  };
  listNetworkingV1NetworkLinkEndpoints: {
    parameters: {
      query: {
        /**
         * @description Filter the results by exact match for spec.display_name. Pass multiple times to see results matching any of the values.
         * @example [
         *       "prod-net-1-nle",
         *       "dev-net-1-nle"
         *     ]
         */
        "spec.display_name"?: components["schemas"]["MultipleSearchFilter"];
        /**
         * @description Filter the results by exact match for status.phase. Pass multiple times to see results matching any of the values.
         * @example [
         *       "READY",
         *       "PENDING_ACCEPT"
         *     ]
         */
        "status.phase"?: components["schemas"]["MultipleSearchFilter"];
        /**
         * @description Filter the results by exact match for environment.
         * @example env-00000
         */
        environment: components["schemas"]["SearchFilter"];
        /**
         * @description Filter the results by exact match for spec.network. Pass multiple times to see results matching any of the values.
         * @example [
         *       "n-00000",
         *       "n-00001"
         *     ]
         */
        "spec.network"?: components["schemas"]["MultipleSearchFilter"];
        /**
         * @description Filter the results by exact match for spec.network_link_service. Pass multiple times to see results matching any of the values.
         * @example [
         *       "nls-abcde",
         *       "nls-00000"
         *     ]
         */
        "spec.network_link_service"?: components["schemas"]["MultipleSearchFilter"];
        /** @description A pagination size for collection requests. */
        page_size?: number;
        /** @description An opaque pagination token for collection requests. */
        page_token?: string;
      };
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description Network Link Endpoint. */
      200: {
        headers: {
          /** @description The unique identifier for the API request. */
          "X-Request-Id"?: string;
          /** @description The maximum number of requests you're permitted to make per time period. */
          "X-RateLimit-Limit"?: number;
          /** @description The number of requests remaining in the current rate limit window. */
          "X-RateLimit-Remaining"?: number;
          /** @description The relative time in seconds until the current rate-limit window resets.
           *
           *     **Important:** This differs from Github and Twitter's same-named header which uses UTC epoch seconds. We use relative time to avoid client/server time synchronization issues. */
          "X-RateLimit-Reset"?: number;
          [name: string]: unknown;
        };
        content: {
          "application/json": components["schemas"]["networking.v1.NetworkLinkEndpointList"] & {
            data?: {
              spec?: {
                /** @example {
                 *       "id": "env-00000",
                 *       "related": "https://api.confluent.cloud/v2/environments/env-00000",
                 *       "resource_name": "https://api.confluent.cloud/organization=9bb441c4-edef-46ac-8a41-c49e44a3fd9a/environment=env-00000"
                 *     } */
                environment?: unknown;
                /** @example {
                 *       "id": "n-00000",
                 *       "related": "https://api.confluent.cloud/networking/v1/networks/n-00000",
                 *       "resource_name": "https://api.confluent.cloud/organization=9bb441c4-edef-46ac-8a41-c49e44a3fd9a/environment=env-abc123/network=n-00000"
                 *     } */
                network?: unknown;
                /** @example {
                 *       "id": "nls-abcde",
                 *       "related": "https://api.confluent.cloud/networking/v1/network-link-services/nls-abcde",
                 *       "resource_name": "https://api.confluent.cloud/organization=9bb441c4-edef-46ac-8a41-c49e44a3fd9a/environment=env-abc123/network=n-456xyz/network-link-service=nls-abcde"
                 *     } */
                network_link_service?: unknown;
              };
            }[];
          };
        };
      };
      400: components["responses"]["BadRequestError"];
      401: components["responses"]["UnauthenticatedError"];
      403: components["responses"]["UnauthorizedError"];
      429: components["responses"]["RateLimitError"];
      500: components["responses"]["DefaultSystemError"];
    };
  };
  createNetworkingV1NetworkLinkEndpoint: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody?: {
      content: {
        "application/json": components["schemas"]["networking.v1.NetworkLinkEndpoint"] & {
          spec: Record<string, unknown>;
        } & {
          spec?: {
            /** @example {
             *       "id": "env-00000"
             *     } */
            environment?: unknown;
            /** @example {
             *       "id": "n-00000"
             *     } */
            network?: unknown;
            /** @example {
             *       "id": "nls-abcde"
             *     } */
            network_link_service?: unknown;
          };
        };
      };
    };
    responses: {
      /** @description A Network Link Endpoint is being created. */
      202: {
        headers: {
          /** @description The unique identifier for the API request. */
          "X-Request-Id"?: string;
          /** @description The maximum number of requests you're permitted to make per time period. */
          "X-RateLimit-Limit"?: number;
          /** @description The number of requests remaining in the current rate limit window. */
          "X-RateLimit-Remaining"?: number;
          /** @description The relative time in seconds until the current rate-limit window resets.
           *
           *     **Important:** This differs from Github and Twitter's same-named header which uses UTC epoch seconds. We use relative time to avoid client/server time synchronization issues. */
          "X-RateLimit-Reset"?: number;
          /** @description NetworkLinkEndpoint resource uri */
          Location?: string;
          [name: string]: unknown;
        };
        content: {
          "application/json": components["schemas"]["networking.v1.NetworkLinkEndpoint"] & {
            spec: Record<string, unknown>;
          } & {
            spec?: {
              /** @example {
               *       "id": "env-00000",
               *       "related": "https://api.confluent.cloud/v2/environments/env-00000",
               *       "resource_name": "https://api.confluent.cloud/organization=9bb441c4-edef-46ac-8a41-c49e44a3fd9a/environment=env-00000"
               *     } */
              environment?: unknown;
              /** @example {
               *       "id": "n-00000",
               *       "related": "https://api.confluent.cloud/networking/v1/networks/n-00000",
               *       "resource_name": "https://api.confluent.cloud/organization=9bb441c4-edef-46ac-8a41-c49e44a3fd9a/environment=env-abc123/network=n-00000"
               *     } */
              network?: unknown;
              /** @example {
               *       "id": "nls-abcde",
               *       "related": "https://api.confluent.cloud/networking/v1/network-link-services/nls-abcde",
               *       "resource_name": "https://api.confluent.cloud/organization=9bb441c4-edef-46ac-8a41-c49e44a3fd9a/environment=env-abc123/network=n-456xyz/network-link-service=nls-abcde"
               *     } */
              network_link_service?: unknown;
            };
          };
        };
      };
      400: components["responses"]["BadRequestError"];
      401: components["responses"]["UnauthenticatedError"];
      402: components["responses"]["OverQuotaError"];
      403: components["responses"]["UnauthorizedError"];
      409: components["responses"]["ConflictError"];
      422: components["responses"]["ValidationError"];
      429: components["responses"]["RateLimitError"];
      500: components["responses"]["DefaultSystemError"];
    };
  };
  getNetworkingV1NetworkLinkEndpoint: {
    parameters: {
      query: {
        /**
         * @description Scope the operation to the given environment.
         * @example env-00000
         */
        environment: components["schemas"]["SearchFilter"];
      };
      header?: never;
      path: {
        /** @description The unique identifier for the network link endpoint. */
        id: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description Network Link Endpoint. */
      200: {
        headers: {
          /** @description The unique identifier for the API request. */
          "X-Request-Id"?: string;
          /** @description The maximum number of requests you're permitted to make per time period. */
          "X-RateLimit-Limit"?: number;
          /** @description The number of requests remaining in the current rate limit window. */
          "X-RateLimit-Remaining"?: number;
          /** @description The relative time in seconds until the current rate-limit window resets.
           *
           *     **Important:** This differs from Github and Twitter's same-named header which uses UTC epoch seconds. We use relative time to avoid client/server time synchronization issues. */
          "X-RateLimit-Reset"?: number;
          [name: string]: unknown;
        };
        content: {
          "application/json": components["schemas"]["networking.v1.NetworkLinkEndpoint"] & {
            spec: Record<string, unknown>;
          } & {
            spec?: {
              /** @example {
               *       "id": "env-00000",
               *       "related": "https://api.confluent.cloud/v2/environments/env-00000",
               *       "resource_name": "https://api.confluent.cloud/organization=9bb441c4-edef-46ac-8a41-c49e44a3fd9a/environment=env-00000"
               *     } */
              environment?: unknown;
              /** @example {
               *       "id": "n-00000",
               *       "related": "https://api.confluent.cloud/networking/v1/networks/n-00000",
               *       "resource_name": "https://api.confluent.cloud/organization=9bb441c4-edef-46ac-8a41-c49e44a3fd9a/environment=env-abc123/network=n-00000"
               *     } */
              network?: unknown;
              /** @example {
               *       "id": "nls-abcde",
               *       "related": "https://api.confluent.cloud/networking/v1/network-link-services/nls-abcde",
               *       "resource_name": "https://api.confluent.cloud/organization=9bb441c4-edef-46ac-8a41-c49e44a3fd9a/environment=env-abc123/network=n-456xyz/network-link-service=nls-abcde"
               *     } */
              network_link_service?: unknown;
            };
          };
        };
      };
      400: components["responses"]["BadRequestError"];
      401: components["responses"]["UnauthenticatedError"];
      403: components["responses"]["UnauthorizedError"];
      404: components["responses"]["NotFoundError"];
      429: components["responses"]["RateLimitError"];
      500: components["responses"]["DefaultSystemError"];
    };
  };
  deleteNetworkingV1NetworkLinkEndpoint: {
    parameters: {
      query: {
        /**
         * @description Scope the operation to the given environment.
         * @example env-00000
         */
        environment: components["schemas"]["SearchFilter"];
      };
      header?: never;
      path: {
        /** @description The unique identifier for the network link endpoint. */
        id: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description A Network Link Endpoint is being deleted. */
      204: {
        headers: {
          /** @description The unique identifier for the API request. */
          "X-Request-Id"?: string;
          /** @description The maximum number of requests you're permitted to make per time period. */
          "X-RateLimit-Limit"?: number;
          /** @description The number of requests remaining in the current rate limit window. */
          "X-RateLimit-Remaining"?: number;
          /** @description The relative time in seconds until the current rate-limit window resets.
           *
           *     **Important:** This differs from Github and Twitter's same-named header which uses UTC epoch seconds. We use relative time to avoid client/server time synchronization issues. */
          "X-RateLimit-Reset"?: number;
          [name: string]: unknown;
        };
        content?: never;
      };
      400: components["responses"]["BadRequestError"];
      401: components["responses"]["UnauthenticatedError"];
      403: components["responses"]["UnauthorizedError"];
      404: components["responses"]["NotFoundError"];
      429: components["responses"]["RateLimitError"];
      500: components["responses"]["DefaultSystemError"];
    };
  };
  updateNetworkingV1NetworkLinkEndpoint: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description The unique identifier for the network link endpoint. */
        id: string;
      };
      cookie?: never;
    };
    requestBody?: {
      content: {
        "application/json": components["schemas"]["networking.v1.NetworkLinkEndpointUpdate"] & {
          spec: {
            /** @example {
             *       "id": "env-00000"
             *     } */
            environment: unknown;
          };
        };
      };
    };
    responses: {
      /** @description Network Link Endpoint. */
      200: {
        headers: {
          /** @description The unique identifier for the API request. */
          "X-Request-Id"?: string;
          /** @description The maximum number of requests you're permitted to make per time period. */
          "X-RateLimit-Limit"?: number;
          /** @description The number of requests remaining in the current rate limit window. */
          "X-RateLimit-Remaining"?: number;
          /** @description The relative time in seconds until the current rate-limit window resets.
           *
           *     **Important:** This differs from Github and Twitter's same-named header which uses UTC epoch seconds. We use relative time to avoid client/server time synchronization issues. */
          "X-RateLimit-Reset"?: number;
          [name: string]: unknown;
        };
        content: {
          "application/json": components["schemas"]["networking.v1.NetworkLinkEndpoint"] & {
            spec: Record<string, unknown>;
          } & {
            spec?: {
              /** @example {
               *       "id": "env-00000",
               *       "related": "https://api.confluent.cloud/v2/environments/env-00000",
               *       "resource_name": "https://api.confluent.cloud/organization=9bb441c4-edef-46ac-8a41-c49e44a3fd9a/environment=env-00000"
               *     } */
              environment?: unknown;
              /** @example {
               *       "id": "n-00000",
               *       "related": "https://api.confluent.cloud/networking/v1/networks/n-00000",
               *       "resource_name": "https://api.confluent.cloud/organization=9bb441c4-edef-46ac-8a41-c49e44a3fd9a/environment=env-abc123/network=n-00000"
               *     } */
              network?: unknown;
              /** @example {
               *       "id": "nls-abcde",
               *       "related": "https://api.confluent.cloud/networking/v1/network-link-services/nls-abcde",
               *       "resource_name": "https://api.confluent.cloud/organization=9bb441c4-edef-46ac-8a41-c49e44a3fd9a/environment=env-abc123/network=n-456xyz/network-link-service=nls-abcde"
               *     } */
              network_link_service?: unknown;
            };
          };
        };
      };
      400: components["responses"]["BadRequestError"];
      401: components["responses"]["UnauthenticatedError"];
      402: components["responses"]["OverQuotaError"];
      403: components["responses"]["UnauthorizedError"];
      404: components["responses"]["NotFoundError"];
      409: components["responses"]["ConflictError"];
      422: components["responses"]["ValidationError"];
      429: components["responses"]["RateLimitError"];
      500: components["responses"]["DefaultSystemError"];
    };
  };
  listNetworkingV1NetworkLinkServiceAssociations: {
    parameters: {
      query: {
        /**
         * @description Filter the results by exact match for status.phase. Pass multiple times to see results matching any of the values.
         * @example [
         *       "READY",
         *       "PENDING_ACCEPT"
         *     ]
         */
        "status.phase"?: components["schemas"]["MultipleSearchFilter"];
        /**
         * @description Filter the results by exact match for spec.network_link_service.
         * @example nls-abcde
         */
        "spec.network_link_service": components["schemas"]["SearchFilter"];
        /**
         * @description Filter the results by exact match for environment.
         * @example env-00000
         */
        environment: components["schemas"]["SearchFilter"];
        /** @description A pagination size for collection requests. */
        page_size?: number;
        /** @description An opaque pagination token for collection requests. */
        page_token?: string;
      };
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description Network Link Service Association. */
      200: {
        headers: {
          /** @description The unique identifier for the API request. */
          "X-Request-Id"?: string;
          /** @description The maximum number of requests you're permitted to make per time period. */
          "X-RateLimit-Limit"?: number;
          /** @description The number of requests remaining in the current rate limit window. */
          "X-RateLimit-Remaining"?: number;
          /** @description The relative time in seconds until the current rate-limit window resets.
           *
           *     **Important:** This differs from Github and Twitter's same-named header which uses UTC epoch seconds. We use relative time to avoid client/server time synchronization issues. */
          "X-RateLimit-Reset"?: number;
          [name: string]: unknown;
        };
        content: {
          "application/json": components["schemas"]["networking.v1.NetworkLinkServiceAssociationList"] & {
            data?: {
              spec?: {
                /** @example {
                 *       "id": "nls-abcde",
                 *       "related": "https://api.confluent.cloud/networking/v1/network-link-services/nls-abcde",
                 *       "resource_name": "https://api.confluent.cloud/organization=9bb441c4-edef-46ac-8a41-c49e44a3fd9a/environment=env-abc123/network=n-456xyz/network-link-service=nls-abcde"
                 *     } */
                network_link_service?: unknown;
                /** @example {
                 *       "id": "env-00000",
                 *       "related": "https://api.confluent.cloud/v2/environments/env-00000",
                 *       "resource_name": "https://api.confluent.cloud/organization=9bb441c4-edef-46ac-8a41-c49e44a3fd9a/environment=env-00000"
                 *     } */
                environment?: unknown;
              };
            }[];
          };
        };
      };
      400: components["responses"]["BadRequestError"];
      401: components["responses"]["UnauthenticatedError"];
      403: components["responses"]["UnauthorizedError"];
      429: components["responses"]["RateLimitError"];
      500: components["responses"]["DefaultSystemError"];
    };
  };
  getNetworkingV1NetworkLinkServiceAssociation: {
    parameters: {
      query: {
        /**
         * @description Scope the operation to the given spec.network_link_service.
         * @example nls-abcde
         */
        "spec.network_link_service": components["schemas"]["SearchFilter"];
        /**
         * @description Scope the operation to the given environment.
         * @example env-00000
         */
        environment: components["schemas"]["SearchFilter"];
      };
      header?: never;
      path: {
        /** @description The unique identifier for the network link service association. */
        id: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description Network Link Service Association. */
      200: {
        headers: {
          /** @description The unique identifier for the API request. */
          "X-Request-Id"?: string;
          /** @description The maximum number of requests you're permitted to make per time period. */
          "X-RateLimit-Limit"?: number;
          /** @description The number of requests remaining in the current rate limit window. */
          "X-RateLimit-Remaining"?: number;
          /** @description The relative time in seconds until the current rate-limit window resets.
           *
           *     **Important:** This differs from Github and Twitter's same-named header which uses UTC epoch seconds. We use relative time to avoid client/server time synchronization issues. */
          "X-RateLimit-Reset"?: number;
          [name: string]: unknown;
        };
        content: {
          "application/json": components["schemas"]["networking.v1.NetworkLinkServiceAssociation"] & {
            spec: Record<string, unknown>;
          } & {
            spec?: {
              /** @example {
               *       "id": "nls-abcde",
               *       "related": "https://api.confluent.cloud/networking/v1/network-link-services/nls-abcde",
               *       "resource_name": "https://api.confluent.cloud/organization=9bb441c4-edef-46ac-8a41-c49e44a3fd9a/environment=env-abc123/network=n-456xyz/network-link-service=nls-abcde"
               *     } */
              network_link_service?: unknown;
              /** @example {
               *       "id": "env-00000",
               *       "related": "https://api.confluent.cloud/v2/environments/env-00000",
               *       "resource_name": "https://api.confluent.cloud/organization=9bb441c4-edef-46ac-8a41-c49e44a3fd9a/environment=env-00000"
               *     } */
              environment?: unknown;
            };
          };
        };
      };
      400: components["responses"]["BadRequestError"];
      401: components["responses"]["UnauthenticatedError"];
      403: components["responses"]["UnauthorizedError"];
      404: components["responses"]["NotFoundError"];
      429: components["responses"]["RateLimitError"];
      500: components["responses"]["DefaultSystemError"];
    };
  };
  listNetworkingV1IpAddresses: {
    parameters: {
      query?: {
        /**
         * @description Filter the results by exact match for cloud. Pass multiple times to see results matching any of the values.
         * @example [
         *       "GCP",
         *       "AWS"
         *     ]
         */
        cloud?: components["schemas"]["MultipleSearchFilter"];
        /**
         * @description Filter the results by exact match for region. Pass multiple times to see results matching any of the values.
         * @example [
         *       "us-central1",
         *       "us-east-1"
         *     ]
         */
        region?: components["schemas"]["MultipleSearchFilter"];
        /**
         * @description Filter the results by exact match for services. Pass multiple times to see results matching any of the values.
         * @example [
         *       "KAFKA",
         *       "CONNECT"
         *     ]
         */
        services?: components["schemas"]["MultipleSearchFilter"];
        /**
         * @description Filter the results by exact match for address_type. Pass multiple times to see results matching any of the values.
         * @example [
         *       "INGRESS",
         *       "EGRESS"
         *     ]
         */
        address_type?: components["schemas"]["MultipleSearchFilter"];
        /** @description A pagination size for collection requests. */
        page_size?: number;
        /** @description An opaque pagination token for collection requests. */
        page_token?: string;
      };
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description IP Address. */
      200: {
        headers: {
          /** @description The unique identifier for the API request. */
          "X-Request-Id"?: string;
          [name: string]: unknown;
        };
        content: {
          "application/json": components["schemas"]["networking.v1.IpAddressList"];
        };
      };
      400: components["responses"]["BadRequestError"];
      401: components["responses"]["UnauthenticatedError"];
      403: components["responses"]["UnauthorizedError"];
      429: components["responses"]["RateLimitError"];
      500: components["responses"]["DefaultSystemError"];
    };
  };
  listNetworkingV1PrivateLinkAttachments: {
    parameters: {
      query: {
        /**
         * @description Filter the results by exact match for spec.display_name. Pass multiple times to see results matching any of the values.
         * @example [
         *       "prod-gcp-us-central1",
         *       "prod-aws-useast1"
         *     ]
         */
        "spec.display_name"?: components["schemas"]["MultipleSearchFilter"];
        /**
         * @description Filter the results by exact match for spec.cloud. Pass multiple times to see results matching any of the values.
         * @example [
         *       "GCP",
         *       "AWS"
         *     ]
         */
        "spec.cloud"?: components["schemas"]["MultipleSearchFilter"];
        /**
         * @description Filter the results by exact match for spec.region. Pass multiple times to see results matching any of the values.
         * @example [
         *       "us-central1",
         *       "us-east-1"
         *     ]
         */
        "spec.region"?: components["schemas"]["MultipleSearchFilter"];
        /**
         * @description Filter the results by exact match for status.phase. Pass multiple times to see results matching any of the values.
         * @example [
         *       "PROVISIONING",
         *       "READY"
         *     ]
         */
        "status.phase"?: components["schemas"]["MultipleSearchFilter"];
        /**
         * @description Filter the results by exact match for environment.
         * @example env-00000
         */
        environment: components["schemas"]["SearchFilter"];
        /** @description A pagination size for collection requests. */
        page_size?: number;
        /** @description An opaque pagination token for collection requests. */
        page_token?: string;
      };
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description Private Link Attachment. */
      200: {
        headers: {
          /** @description The unique identifier for the API request. */
          "X-Request-Id"?: string;
          /** @description The maximum number of requests you're permitted to make per time period. */
          "X-RateLimit-Limit"?: number;
          /** @description The number of requests remaining in the current rate limit window. */
          "X-RateLimit-Remaining"?: number;
          /** @description The relative time in seconds until the current rate-limit window resets.
           *
           *     **Important:** This differs from Github and Twitter's same-named header which uses UTC epoch seconds. We use relative time to avoid client/server time synchronization issues. */
          "X-RateLimit-Reset"?: number;
          [name: string]: unknown;
        };
        content: {
          "application/json": components["schemas"]["networking.v1.PrivateLinkAttachmentList"] & {
            data?: {
              spec?: {
                /** @example {
                 *       "id": "env-00000",
                 *       "related": "https://api.confluent.cloud/v2/environments/env-00000",
                 *       "resource_name": "https://api.confluent.cloud/organization=9bb441c4-edef-46ac-8a41-c49e44a3fd9a/environment=env-00000"
                 *     } */
                environment?: unknown;
              };
            }[];
          };
        };
      };
      400: components["responses"]["BadRequestError"];
      401: components["responses"]["UnauthenticatedError"];
      403: components["responses"]["UnauthorizedError"];
      429: components["responses"]["RateLimitError"];
      500: components["responses"]["DefaultSystemError"];
    };
  };
  createNetworkingV1PrivateLinkAttachment: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody?: {
      content: {
        "application/json": components["schemas"]["networking.v1.PrivateLinkAttachment"] & {
          spec: Record<string, unknown>;
        } & {
          spec?: {
            /** @example {
             *       "id": "env-00000"
             *     } */
            environment?: unknown;
          };
        };
      };
    };
    responses: {
      /** @description A Private Link Attachment is being created. */
      202: {
        headers: {
          /** @description The unique identifier for the API request. */
          "X-Request-Id"?: string;
          /** @description The maximum number of requests you're permitted to make per time period. */
          "X-RateLimit-Limit"?: number;
          /** @description The number of requests remaining in the current rate limit window. */
          "X-RateLimit-Remaining"?: number;
          /** @description The relative time in seconds until the current rate-limit window resets.
           *
           *     **Important:** This differs from Github and Twitter's same-named header which uses UTC epoch seconds. We use relative time to avoid client/server time synchronization issues. */
          "X-RateLimit-Reset"?: number;
          /** @description PrivateLinkAttachment resource uri */
          Location?: string;
          [name: string]: unknown;
        };
        content: {
          "application/json": components["schemas"]["networking.v1.PrivateLinkAttachment"] & {
            spec: Record<string, unknown>;
          } & {
            spec?: {
              /** @example {
               *       "id": "env-00000",
               *       "related": "https://api.confluent.cloud/v2/environments/env-00000",
               *       "resource_name": "https://api.confluent.cloud/organization=9bb441c4-edef-46ac-8a41-c49e44a3fd9a/environment=env-00000"
               *     } */
              environment?: unknown;
            };
          };
        };
      };
      400: components["responses"]["BadRequestError"];
      401: components["responses"]["UnauthenticatedError"];
      402: components["responses"]["OverQuotaError"];
      403: components["responses"]["UnauthorizedError"];
      409: components["responses"]["ConflictError"];
      422: components["responses"]["ValidationError"];
      429: components["responses"]["RateLimitError"];
      500: components["responses"]["DefaultSystemError"];
    };
  };
  getNetworkingV1PrivateLinkAttachment: {
    parameters: {
      query: {
        /**
         * @description Scope the operation to the given environment.
         * @example env-00000
         */
        environment: components["schemas"]["SearchFilter"];
      };
      header?: never;
      path: {
        /** @description The unique identifier for the private link attachment. */
        id: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description Private Link Attachment. */
      200: {
        headers: {
          /** @description The unique identifier for the API request. */
          "X-Request-Id"?: string;
          /** @description The maximum number of requests you're permitted to make per time period. */
          "X-RateLimit-Limit"?: number;
          /** @description The number of requests remaining in the current rate limit window. */
          "X-RateLimit-Remaining"?: number;
          /** @description The relative time in seconds until the current rate-limit window resets.
           *
           *     **Important:** This differs from Github and Twitter's same-named header which uses UTC epoch seconds. We use relative time to avoid client/server time synchronization issues. */
          "X-RateLimit-Reset"?: number;
          [name: string]: unknown;
        };
        content: {
          "application/json": components["schemas"]["networking.v1.PrivateLinkAttachment"] & {
            spec: Record<string, unknown>;
          } & {
            spec?: {
              /** @example {
               *       "id": "env-00000",
               *       "related": "https://api.confluent.cloud/v2/environments/env-00000",
               *       "resource_name": "https://api.confluent.cloud/organization=9bb441c4-edef-46ac-8a41-c49e44a3fd9a/environment=env-00000"
               *     } */
              environment?: unknown;
            };
          };
        };
      };
      400: components["responses"]["BadRequestError"];
      401: components["responses"]["UnauthenticatedError"];
      403: components["responses"]["UnauthorizedError"];
      404: components["responses"]["NotFoundError"];
      429: components["responses"]["RateLimitError"];
      500: components["responses"]["DefaultSystemError"];
    };
  };
  deleteNetworkingV1PrivateLinkAttachment: {
    parameters: {
      query: {
        /**
         * @description Scope the operation to the given environment.
         * @example env-00000
         */
        environment: components["schemas"]["SearchFilter"];
      };
      header?: never;
      path: {
        /** @description The unique identifier for the private link attachment. */
        id: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description A Private Link Attachment is being deleted. */
      204: {
        headers: {
          /** @description The unique identifier for the API request. */
          "X-Request-Id"?: string;
          /** @description The maximum number of requests you're permitted to make per time period. */
          "X-RateLimit-Limit"?: number;
          /** @description The number of requests remaining in the current rate limit window. */
          "X-RateLimit-Remaining"?: number;
          /** @description The relative time in seconds until the current rate-limit window resets.
           *
           *     **Important:** This differs from Github and Twitter's same-named header which uses UTC epoch seconds. We use relative time to avoid client/server time synchronization issues. */
          "X-RateLimit-Reset"?: number;
          [name: string]: unknown;
        };
        content?: never;
      };
      400: components["responses"]["BadRequestError"];
      401: components["responses"]["UnauthenticatedError"];
      403: components["responses"]["UnauthorizedError"];
      404: components["responses"]["NotFoundError"];
      429: components["responses"]["RateLimitError"];
      500: components["responses"]["DefaultSystemError"];
    };
  };
  updateNetworkingV1PrivateLinkAttachment: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description The unique identifier for the private link attachment. */
        id: string;
      };
      cookie?: never;
    };
    requestBody?: {
      content: {
        "application/json": components["schemas"]["networking.v1.PrivateLinkAttachmentUpdate"] & {
          spec: {
            /** @example {
             *       "id": "env-00000"
             *     } */
            environment: unknown;
          };
        };
      };
    };
    responses: {
      /** @description Private Link Attachment. */
      200: {
        headers: {
          /** @description The unique identifier for the API request. */
          "X-Request-Id"?: string;
          /** @description The maximum number of requests you're permitted to make per time period. */
          "X-RateLimit-Limit"?: number;
          /** @description The number of requests remaining in the current rate limit window. */
          "X-RateLimit-Remaining"?: number;
          /** @description The relative time in seconds until the current rate-limit window resets.
           *
           *     **Important:** This differs from Github and Twitter's same-named header which uses UTC epoch seconds. We use relative time to avoid client/server time synchronization issues. */
          "X-RateLimit-Reset"?: number;
          [name: string]: unknown;
        };
        content: {
          "application/json": components["schemas"]["networking.v1.PrivateLinkAttachment"] & {
            spec: Record<string, unknown>;
          } & {
            spec?: {
              /** @example {
               *       "id": "env-00000",
               *       "related": "https://api.confluent.cloud/v2/environments/env-00000",
               *       "resource_name": "https://api.confluent.cloud/organization=9bb441c4-edef-46ac-8a41-c49e44a3fd9a/environment=env-00000"
               *     } */
              environment?: unknown;
            };
          };
        };
      };
      400: components["responses"]["BadRequestError"];
      401: components["responses"]["UnauthenticatedError"];
      402: components["responses"]["OverQuotaError"];
      403: components["responses"]["UnauthorizedError"];
      404: components["responses"]["NotFoundError"];
      409: components["responses"]["ConflictError"];
      422: components["responses"]["ValidationError"];
      429: components["responses"]["RateLimitError"];
      500: components["responses"]["DefaultSystemError"];
    };
  };
  listNetworkingV1PrivateLinkAttachmentConnections: {
    parameters: {
      query: {
        /**
         * @description Filter the results by exact match for environment.
         * @example env-00000
         */
        environment: components["schemas"]["SearchFilter"];
        /**
         * @description Filter the results by exact match for spec.private_link_attachment.
         * @example platt-00000
         */
        "spec.private_link_attachment"?: components["schemas"]["SearchFilter"];
        /** @description A pagination size for collection requests. */
        page_size?: number;
        /** @description An opaque pagination token for collection requests. */
        page_token?: string;
      };
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description Private Link Attachment Connection. */
      200: {
        headers: {
          /** @description The unique identifier for the API request. */
          "X-Request-Id"?: string;
          /** @description The maximum number of requests you're permitted to make per time period. */
          "X-RateLimit-Limit"?: number;
          /** @description The number of requests remaining in the current rate limit window. */
          "X-RateLimit-Remaining"?: number;
          /** @description The relative time in seconds until the current rate-limit window resets.
           *
           *     **Important:** This differs from Github and Twitter's same-named header which uses UTC epoch seconds. We use relative time to avoid client/server time synchronization issues. */
          "X-RateLimit-Reset"?: number;
          [name: string]: unknown;
        };
        content: {
          "application/json": components["schemas"]["networking.v1.PrivateLinkAttachmentConnectionList"] & {
            data?: {
              spec?: {
                /** @example {
                 *       "id": "env-00000",
                 *       "related": "https://api.confluent.cloud/v2/environments/env-00000",
                 *       "resource_name": "https://api.confluent.cloud/organization=9bb441c4-edef-46ac-8a41-c49e44a3fd9a/environment=env-00000"
                 *     } */
                environment?: unknown;
                /** @example {
                 *       "id": "platt-00000",
                 *       "related": "https://api.confluent.cloud/networking/v1/private-link-attachments/platt-00000",
                 *       "resource_name": "https://api.confluent.cloud/organization=9bb441c4-edef-46ac-8a41-c49e44a3fd9a/private-link-attachment=platt-00000"
                 *     } */
                private_link_attachment?: unknown;
              };
            }[];
          };
        };
      };
      400: components["responses"]["BadRequestError"];
      401: components["responses"]["UnauthenticatedError"];
      403: components["responses"]["UnauthorizedError"];
      429: components["responses"]["RateLimitError"];
      500: components["responses"]["DefaultSystemError"];
    };
  };
  createNetworkingV1PrivateLinkAttachmentConnection: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody?: {
      content: {
        "application/json": components["schemas"]["networking.v1.PrivateLinkAttachmentConnection"] & {
          spec: Record<string, unknown>;
        } & {
          spec?: {
            /** @example {
             *       "id": "env-00000"
             *     } */
            environment?: unknown;
            /** @example {
             *       "id": "platt-00000"
             *     } */
            private_link_attachment?: unknown;
          };
        };
      };
    };
    responses: {
      /** @description A Private Link Attachment Connection is being created. */
      202: {
        headers: {
          /** @description The unique identifier for the API request. */
          "X-Request-Id"?: string;
          /** @description The maximum number of requests you're permitted to make per time period. */
          "X-RateLimit-Limit"?: number;
          /** @description The number of requests remaining in the current rate limit window. */
          "X-RateLimit-Remaining"?: number;
          /** @description The relative time in seconds until the current rate-limit window resets.
           *
           *     **Important:** This differs from Github and Twitter's same-named header which uses UTC epoch seconds. We use relative time to avoid client/server time synchronization issues. */
          "X-RateLimit-Reset"?: number;
          /** @description PrivateLinkAttachmentConnection resource uri */
          Location?: string;
          [name: string]: unknown;
        };
        content: {
          "application/json": components["schemas"]["networking.v1.PrivateLinkAttachmentConnection"] & {
            spec: Record<string, unknown>;
          } & {
            spec?: {
              /** @example {
               *       "id": "env-00000",
               *       "related": "https://api.confluent.cloud/v2/environments/env-00000",
               *       "resource_name": "https://api.confluent.cloud/organization=9bb441c4-edef-46ac-8a41-c49e44a3fd9a/environment=env-00000"
               *     } */
              environment?: unknown;
              /** @example {
               *       "id": "platt-00000",
               *       "related": "https://api.confluent.cloud/networking/v1/private-link-attachments/platt-00000",
               *       "resource_name": "https://api.confluent.cloud/organization=9bb441c4-edef-46ac-8a41-c49e44a3fd9a/private-link-attachment=platt-00000"
               *     } */
              private_link_attachment?: unknown;
            };
          };
        };
      };
      400: components["responses"]["BadRequestError"];
      401: components["responses"]["UnauthenticatedError"];
      403: components["responses"]["UnauthorizedError"];
      409: components["responses"]["ConflictError"];
      422: components["responses"]["ValidationError"];
      429: components["responses"]["RateLimitError"];
      500: components["responses"]["DefaultSystemError"];
    };
  };
  getNetworkingV1PrivateLinkAttachmentConnection: {
    parameters: {
      query: {
        /**
         * @description Scope the operation to the given environment.
         * @example env-00000
         */
        environment: components["schemas"]["SearchFilter"];
      };
      header?: never;
      path: {
        /** @description The unique identifier for the private link attachment connection. */
        id: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description Private Link Attachment Connection. */
      200: {
        headers: {
          /** @description The unique identifier for the API request. */
          "X-Request-Id"?: string;
          /** @description The maximum number of requests you're permitted to make per time period. */
          "X-RateLimit-Limit"?: number;
          /** @description The number of requests remaining in the current rate limit window. */
          "X-RateLimit-Remaining"?: number;
          /** @description The relative time in seconds until the current rate-limit window resets.
           *
           *     **Important:** This differs from Github and Twitter's same-named header which uses UTC epoch seconds. We use relative time to avoid client/server time synchronization issues. */
          "X-RateLimit-Reset"?: number;
          [name: string]: unknown;
        };
        content: {
          "application/json": components["schemas"]["networking.v1.PrivateLinkAttachmentConnection"] & {
            spec: Record<string, unknown>;
          } & {
            spec?: {
              /** @example {
               *       "id": "env-00000",
               *       "related": "https://api.confluent.cloud/v2/environments/env-00000",
               *       "resource_name": "https://api.confluent.cloud/organization=9bb441c4-edef-46ac-8a41-c49e44a3fd9a/environment=env-00000"
               *     } */
              environment?: unknown;
              /** @example {
               *       "id": "platt-00000",
               *       "related": "https://api.confluent.cloud/networking/v1/private-link-attachments/platt-00000",
               *       "resource_name": "https://api.confluent.cloud/organization=9bb441c4-edef-46ac-8a41-c49e44a3fd9a/private-link-attachment=platt-00000"
               *     } */
              private_link_attachment?: unknown;
            };
          };
        };
      };
      400: components["responses"]["BadRequestError"];
      401: components["responses"]["UnauthenticatedError"];
      403: components["responses"]["UnauthorizedError"];
      404: components["responses"]["NotFoundError"];
      429: components["responses"]["RateLimitError"];
      500: components["responses"]["DefaultSystemError"];
    };
  };
  deleteNetworkingV1PrivateLinkAttachmentConnection: {
    parameters: {
      query: {
        /**
         * @description Scope the operation to the given environment.
         * @example env-00000
         */
        environment: components["schemas"]["SearchFilter"];
      };
      header?: never;
      path: {
        /** @description The unique identifier for the private link attachment connection. */
        id: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description A Private Link Attachment Connection is being deleted. */
      204: {
        headers: {
          /** @description The unique identifier for the API request. */
          "X-Request-Id"?: string;
          /** @description The maximum number of requests you're permitted to make per time period. */
          "X-RateLimit-Limit"?: number;
          /** @description The number of requests remaining in the current rate limit window. */
          "X-RateLimit-Remaining"?: number;
          /** @description The relative time in seconds until the current rate-limit window resets.
           *
           *     **Important:** This differs from Github and Twitter's same-named header which uses UTC epoch seconds. We use relative time to avoid client/server time synchronization issues. */
          "X-RateLimit-Reset"?: number;
          [name: string]: unknown;
        };
        content?: never;
      };
      400: components["responses"]["BadRequestError"];
      401: components["responses"]["UnauthenticatedError"];
      403: components["responses"]["UnauthorizedError"];
      404: components["responses"]["NotFoundError"];
      429: components["responses"]["RateLimitError"];
      500: components["responses"]["DefaultSystemError"];
    };
  };
  updateNetworkingV1PrivateLinkAttachmentConnection: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description The unique identifier for the private link attachment connection. */
        id: string;
      };
      cookie?: never;
    };
    requestBody?: {
      content: {
        "application/json": components["schemas"]["networking.v1.PrivateLinkAttachmentConnectionUpdate"] & {
          spec: {
            /** @example {
             *       "id": "env-00000"
             *     } */
            environment: unknown;
          };
        };
      };
    };
    responses: {
      /** @description Private Link Attachment Connection. */
      200: {
        headers: {
          /** @description The unique identifier for the API request. */
          "X-Request-Id"?: string;
          /** @description The maximum number of requests you're permitted to make per time period. */
          "X-RateLimit-Limit"?: number;
          /** @description The number of requests remaining in the current rate limit window. */
          "X-RateLimit-Remaining"?: number;
          /** @description The relative time in seconds until the current rate-limit window resets.
           *
           *     **Important:** This differs from Github and Twitter's same-named header which uses UTC epoch seconds. We use relative time to avoid client/server time synchronization issues. */
          "X-RateLimit-Reset"?: number;
          [name: string]: unknown;
        };
        content: {
          "application/json": components["schemas"]["networking.v1.PrivateLinkAttachmentConnection"] & {
            spec: Record<string, unknown>;
          } & {
            spec?: {
              /** @example {
               *       "id": "env-00000",
               *       "related": "https://api.confluent.cloud/v2/environments/env-00000",
               *       "resource_name": "https://api.confluent.cloud/organization=9bb441c4-edef-46ac-8a41-c49e44a3fd9a/environment=env-00000"
               *     } */
              environment?: unknown;
              /** @example {
               *       "id": "platt-00000",
               *       "related": "https://api.confluent.cloud/networking/v1/private-link-attachments/platt-00000",
               *       "resource_name": "https://api.confluent.cloud/organization=9bb441c4-edef-46ac-8a41-c49e44a3fd9a/private-link-attachment=platt-00000"
               *     } */
              private_link_attachment?: unknown;
            };
          };
        };
      };
      400: components["responses"]["BadRequestError"];
      401: components["responses"]["UnauthenticatedError"];
      403: components["responses"]["UnauthorizedError"];
      404: components["responses"]["NotFoundError"];
      409: components["responses"]["ConflictError"];
      422: components["responses"]["ValidationError"];
      429: components["responses"]["RateLimitError"];
      500: components["responses"]["DefaultSystemError"];
    };
  };
  listIamV2IdentityProviders: {
    parameters: {
      query?: {
        /** @description A pagination size for collection requests. */
        page_size?: number;
        /** @description An opaque pagination token for collection requests. */
        page_token?: string;
      };
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description Identity Provider. */
      200: {
        headers: {
          /** @description The unique identifier for the API request. */
          "X-Request-Id"?: string;
          /** @description The maximum number of requests you're permitted to make per time period. */
          "X-RateLimit-Limit"?: number;
          /** @description The number of requests remaining in the current rate limit window. */
          "X-RateLimit-Remaining"?: number;
          /** @description The relative time in seconds until the current rate-limit window resets.
           *
           *     **Important:** This differs from Github and Twitter's same-named header which uses UTC epoch seconds. We use relative time to avoid client/server time synchronization issues. */
          "X-RateLimit-Reset"?: number;
          [name: string]: unknown;
        };
        content: {
          "application/json": components["schemas"]["iam.v2.IdentityProviderList"];
        };
      };
      400: components["responses"]["BadRequestError"];
      401: components["responses"]["UnauthenticatedError"];
      403: components["responses"]["UnauthorizedError"];
      429: components["responses"]["RateLimitError"];
      500: components["responses"]["DefaultSystemError"];
    };
  };
  createIamV2IdentityProvider: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody?: {
      content: {
        "application/json": components["schemas"]["iam.v2.IdentityProvider"] &
          Record<string, unknown>;
      };
    };
    responses: {
      /** @description An Identity Provider was created. */
      201: {
        headers: {
          /** @description The unique identifier for the API request. */
          "X-Request-Id"?: string;
          /** @description The maximum number of requests you're permitted to make per time period. */
          "X-RateLimit-Limit"?: number;
          /** @description The number of requests remaining in the current rate limit window. */
          "X-RateLimit-Remaining"?: number;
          /** @description The relative time in seconds until the current rate-limit window resets.
           *
           *     **Important:** This differs from Github and Twitter's same-named header which uses UTC epoch seconds. We use relative time to avoid client/server time synchronization issues. */
          "X-RateLimit-Reset"?: number;
          /** @description IdentityProvider resource uri */
          Location?: string;
          [name: string]: unknown;
        };
        content: {
          "application/json": components["schemas"]["iam.v2.IdentityProvider"] &
            Record<string, unknown>;
        };
      };
      400: components["responses"]["BadRequestError"];
      401: components["responses"]["UnauthenticatedError"];
      402: components["responses"]["OverQuotaError"];
      403: components["responses"]["UnauthorizedError"];
      409: components["responses"]["ConflictError"];
      422: components["responses"]["ValidationError"];
      429: components["responses"]["RateLimitError"];
      500: components["responses"]["DefaultSystemError"];
    };
  };
  getIamV2IdentityProvider: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description The unique identifier for the identity provider. */
        id: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description Identity Provider. */
      200: {
        headers: {
          /** @description The unique identifier for the API request. */
          "X-Request-Id"?: string;
          /** @description The maximum number of requests you're permitted to make per time period. */
          "X-RateLimit-Limit"?: number;
          /** @description The number of requests remaining in the current rate limit window. */
          "X-RateLimit-Remaining"?: number;
          /** @description The relative time in seconds until the current rate-limit window resets.
           *
           *     **Important:** This differs from Github and Twitter's same-named header which uses UTC epoch seconds. We use relative time to avoid client/server time synchronization issues. */
          "X-RateLimit-Reset"?: number;
          [name: string]: unknown;
        };
        content: {
          "application/json": components["schemas"]["iam.v2.IdentityProvider"] &
            Record<string, unknown>;
        };
      };
      400: components["responses"]["BadRequestError"];
      401: components["responses"]["UnauthenticatedError"];
      403: components["responses"]["UnauthorizedError"];
      404: components["responses"]["NotFoundError"];
      429: components["responses"]["RateLimitError"];
      500: components["responses"]["DefaultSystemError"];
    };
  };
  deleteIamV2IdentityProvider: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description The unique identifier for the identity provider. */
        id: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description An Identity Provider is being deleted. */
      204: {
        headers: {
          /** @description The unique identifier for the API request. */
          "X-Request-Id"?: string;
          /** @description The maximum number of requests you're permitted to make per time period. */
          "X-RateLimit-Limit"?: number;
          /** @description The number of requests remaining in the current rate limit window. */
          "X-RateLimit-Remaining"?: number;
          /** @description The relative time in seconds until the current rate-limit window resets.
           *
           *     **Important:** This differs from Github and Twitter's same-named header which uses UTC epoch seconds. We use relative time to avoid client/server time synchronization issues. */
          "X-RateLimit-Reset"?: number;
          [name: string]: unknown;
        };
        content?: never;
      };
      400: components["responses"]["BadRequestError"];
      401: components["responses"]["UnauthenticatedError"];
      403: components["responses"]["UnauthorizedError"];
      404: components["responses"]["NotFoundError"];
      429: components["responses"]["RateLimitError"];
      500: components["responses"]["DefaultSystemError"];
    };
  };
  updateIamV2IdentityProvider: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description The unique identifier for the identity provider. */
        id: string;
      };
      cookie?: never;
    };
    requestBody?: {
      content: {
        "application/json": components["schemas"]["iam.v2.IdentityProvider"];
      };
    };
    responses: {
      /** @description Identity Provider. */
      200: {
        headers: {
          /** @description The unique identifier for the API request. */
          "X-Request-Id"?: string;
          /** @description The maximum number of requests you're permitted to make per time period. */
          "X-RateLimit-Limit"?: number;
          /** @description The number of requests remaining in the current rate limit window. */
          "X-RateLimit-Remaining"?: number;
          /** @description The relative time in seconds until the current rate-limit window resets.
           *
           *     **Important:** This differs from Github and Twitter's same-named header which uses UTC epoch seconds. We use relative time to avoid client/server time synchronization issues. */
          "X-RateLimit-Reset"?: number;
          [name: string]: unknown;
        };
        content: {
          "application/json": components["schemas"]["iam.v2.IdentityProvider"] &
            Record<string, unknown>;
        };
      };
      400: components["responses"]["BadRequestError"];
      401: components["responses"]["UnauthenticatedError"];
      402: components["responses"]["OverQuotaError"];
      403: components["responses"]["UnauthorizedError"];
      404: components["responses"]["NotFoundError"];
      409: components["responses"]["ConflictError"];
      422: components["responses"]["ValidationError"];
      429: components["responses"]["RateLimitError"];
      500: components["responses"]["DefaultSystemError"];
    };
  };
  refreshIamV2JsonWebKeySet: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description The Provider */
        provider_id: string;
      };
      cookie?: never;
    };
    requestBody?: {
      content: {
        "application/json": components["schemas"]["iam.v2.Jwks"];
      };
    };
    responses: {
      /** @description Jwks. */
      200: {
        headers: {
          /** @description The unique identifier for the API request. */
          "X-Request-Id"?: string;
          /** @description The maximum number of requests you're permitted to make per time period. */
          "X-RateLimit-Limit"?: number;
          /** @description The number of requests remaining in the current rate limit window. */
          "X-RateLimit-Remaining"?: number;
          /** @description The relative time in seconds until the current rate-limit window resets.
           *
           *     **Important:** This differs from Github and Twitter's same-named header which uses UTC epoch seconds. We use relative time to avoid client/server time synchronization issues. */
          "X-RateLimit-Reset"?: number;
          [name: string]: unknown;
        };
        content: {
          "application/json": components["schemas"]["iam.v2.Jwks"] & {
            spec: Record<string, unknown>;
          };
        };
      };
      400: components["responses"]["BadRequestError"];
      401: components["responses"]["UnauthenticatedError"];
      403: components["responses"]["UnauthorizedError"];
      404: components["responses"]["NotFoundError"];
      409: components["responses"]["ConflictError"];
      422: components["responses"]["ValidationError"];
      429: components["responses"]["RateLimitError"];
      500: components["responses"]["DefaultSystemError"];
    };
  };
  listIamV2IdentityPools: {
    parameters: {
      query?: {
        /** @description A pagination size for collection requests. */
        page_size?: number;
        /** @description An opaque pagination token for collection requests. */
        page_token?: string;
      };
      header?: never;
      path: {
        /** @description The Provider */
        provider_id: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description Identity Pool. */
      200: {
        headers: {
          /** @description The unique identifier for the API request. */
          "X-Request-Id"?: string;
          /** @description The maximum number of requests you're permitted to make per time period. */
          "X-RateLimit-Limit"?: number;
          /** @description The number of requests remaining in the current rate limit window. */
          "X-RateLimit-Remaining"?: number;
          /** @description The relative time in seconds until the current rate-limit window resets.
           *
           *     **Important:** This differs from Github and Twitter's same-named header which uses UTC epoch seconds. We use relative time to avoid client/server time synchronization issues. */
          "X-RateLimit-Reset"?: number;
          [name: string]: unknown;
        };
        content: {
          "application/json": components["schemas"]["iam.v2.IdentityPoolList"];
        };
      };
      400: components["responses"]["BadRequestError"];
      401: components["responses"]["UnauthenticatedError"];
      403: components["responses"]["UnauthorizedError"];
      429: components["responses"]["RateLimitError"];
      500: components["responses"]["DefaultSystemError"];
    };
  };
  createIamV2IdentityPool: {
    parameters: {
      query?: {
        /**
         * @description The resource_id of the principal who will be assigned resource owner on the created identity pool. Principal can be group-mapping (group-xxx), user (u-xxx), service-account (sa-xxx) or identity-pool (pool-xxx).
         * @example u-a83k9b
         */
        assigned_resource_owner?: components["schemas"]["SearchFilter"];
      };
      header?: never;
      path: {
        /** @description The Provider */
        provider_id: string;
      };
      cookie?: never;
    };
    requestBody?: {
      content: {
        "application/json": components["schemas"]["iam.v2.IdentityPool"] &
          Record<string, unknown>;
      };
    };
    responses: {
      /** @description An Identity Pool was created. */
      201: {
        headers: {
          /** @description The unique identifier for the API request. */
          "X-Request-Id"?: string;
          /** @description The maximum number of requests you're permitted to make per time period. */
          "X-RateLimit-Limit"?: number;
          /** @description The number of requests remaining in the current rate limit window. */
          "X-RateLimit-Remaining"?: number;
          /** @description The relative time in seconds until the current rate-limit window resets.
           *
           *     **Important:** This differs from Github and Twitter's same-named header which uses UTC epoch seconds. We use relative time to avoid client/server time synchronization issues. */
          "X-RateLimit-Reset"?: number;
          /** @description IdentityPool resource uri */
          Location?: string;
          [name: string]: unknown;
        };
        content: {
          "application/json": components["schemas"]["iam.v2.IdentityPool"] &
            Record<string, unknown>;
        };
      };
      400: components["responses"]["BadRequestError"];
      401: components["responses"]["UnauthenticatedError"];
      402: components["responses"]["OverQuotaError"];
      403: components["responses"]["UnauthorizedError"];
      409: components["responses"]["ConflictError"];
      422: components["responses"]["ValidationError"];
      429: components["responses"]["RateLimitError"];
      500: components["responses"]["DefaultSystemError"];
    };
  };
  getIamV2IdentityPool: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description The Provider */
        provider_id: string;
        /** @description The unique identifier for the identity pool. */
        id: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description Identity Pool. */
      200: {
        headers: {
          /** @description The unique identifier for the API request. */
          "X-Request-Id"?: string;
          /** @description The maximum number of requests you're permitted to make per time period. */
          "X-RateLimit-Limit"?: number;
          /** @description The number of requests remaining in the current rate limit window. */
          "X-RateLimit-Remaining"?: number;
          /** @description The relative time in seconds until the current rate-limit window resets.
           *
           *     **Important:** This differs from Github and Twitter's same-named header which uses UTC epoch seconds. We use relative time to avoid client/server time synchronization issues. */
          "X-RateLimit-Reset"?: number;
          [name: string]: unknown;
        };
        content: {
          "application/json": components["schemas"]["iam.v2.IdentityPool"] &
            Record<string, unknown>;
        };
      };
      400: components["responses"]["BadRequestError"];
      401: components["responses"]["UnauthenticatedError"];
      403: components["responses"]["UnauthorizedError"];
      404: components["responses"]["NotFoundError"];
      429: components["responses"]["RateLimitError"];
      500: components["responses"]["DefaultSystemError"];
    };
  };
  deleteIamV2IdentityPool: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description The Provider */
        provider_id: string;
        /** @description The unique identifier for the identity pool. */
        id: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description An Identity Pool is being deleted. */
      204: {
        headers: {
          /** @description The unique identifier for the API request. */
          "X-Request-Id"?: string;
          /** @description The maximum number of requests you're permitted to make per time period. */
          "X-RateLimit-Limit"?: number;
          /** @description The number of requests remaining in the current rate limit window. */
          "X-RateLimit-Remaining"?: number;
          /** @description The relative time in seconds until the current rate-limit window resets.
           *
           *     **Important:** This differs from Github and Twitter's same-named header which uses UTC epoch seconds. We use relative time to avoid client/server time synchronization issues. */
          "X-RateLimit-Reset"?: number;
          [name: string]: unknown;
        };
        content?: never;
      };
      400: components["responses"]["BadRequestError"];
      401: components["responses"]["UnauthenticatedError"];
      403: components["responses"]["UnauthorizedError"];
      404: components["responses"]["NotFoundError"];
      429: components["responses"]["RateLimitError"];
      500: components["responses"]["DefaultSystemError"];
    };
  };
  updateIamV2IdentityPool: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description The Provider */
        provider_id: string;
        /** @description The unique identifier for the identity pool. */
        id: string;
      };
      cookie?: never;
    };
    requestBody?: {
      content: {
        "application/json": components["schemas"]["iam.v2.IdentityPool"];
      };
    };
    responses: {
      /** @description Identity Pool. */
      200: {
        headers: {
          /** @description The unique identifier for the API request. */
          "X-Request-Id"?: string;
          /** @description The maximum number of requests you're permitted to make per time period. */
          "X-RateLimit-Limit"?: number;
          /** @description The number of requests remaining in the current rate limit window. */
          "X-RateLimit-Remaining"?: number;
          /** @description The relative time in seconds until the current rate-limit window resets.
           *
           *     **Important:** This differs from Github and Twitter's same-named header which uses UTC epoch seconds. We use relative time to avoid client/server time synchronization issues. */
          "X-RateLimit-Reset"?: number;
          [name: string]: unknown;
        };
        content: {
          "application/json": components["schemas"]["iam.v2.IdentityPool"] &
            Record<string, unknown>;
        };
      };
      400: components["responses"]["BadRequestError"];
      401: components["responses"]["UnauthenticatedError"];
      402: components["responses"]["OverQuotaError"];
      403: components["responses"]["UnauthorizedError"];
      404: components["responses"]["NotFoundError"];
      409: components["responses"]["ConflictError"];
      422: components["responses"]["ValidationError"];
      429: components["responses"]["RateLimitError"];
      500: components["responses"]["DefaultSystemError"];
    };
  };
  exchangeStsV1OauthToken: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody?: {
      content: {
        "application/x-www-form-urlencoded": components["schemas"]["sts.v1.TokenExchangeRequest"] &
          Record<string, unknown>;
      };
    };
    responses: {
      /** @description access token used to access public control plane api
       *      */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "application/json": components["schemas"]["sts.v1.TokenExchangeReply"];
        };
      };
      400: components["responses"]["BadRequestError"];
      429: components["responses"]["RateLimitError"];
      500: components["responses"]["DefaultSystemError"];
    };
  };
  listKafkaQuotasV1ClientQuotas: {
    parameters: {
      query: {
        /**
         * @description Filter the results by exact match for spec.cluster.
         * @example lkc-xxxxx
         */
        "spec.cluster": components["schemas"]["SearchFilter"];
        /**
         * @description Filter the results by exact match for environment.
         * @example env-xxxxx
         */
        environment: components["schemas"]["SearchFilter"];
        /** @description A pagination size for collection requests. */
        page_size?: number;
        /** @description An opaque pagination token for collection requests. */
        page_token?: string;
      };
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description Client Quota. */
      200: {
        headers: {
          /** @description The unique identifier for the API request. */
          "X-Request-Id"?: string;
          /** @description The maximum number of requests you're permitted to make per time period. */
          "X-RateLimit-Limit"?: number;
          /** @description The number of requests remaining in the current rate limit window. */
          "X-RateLimit-Remaining"?: number;
          /** @description The relative time in seconds until the current rate-limit window resets.
           *
           *     **Important:** This differs from Github and Twitter's same-named header which uses UTC epoch seconds. We use relative time to avoid client/server time synchronization issues. */
          "X-RateLimit-Reset"?: number;
          [name: string]: unknown;
        };
        content: {
          "application/json": components["schemas"]["kafka-quotas.v1.ClientQuotaList"] & {
            data?: {
              spec?: {
                /** @example {
                 *       "id": "lkc-xxxxx",
                 *       "related": "https://api.confluent.cloud/cmk/v2/clusters/lkc-xxxxx",
                 *       "resource_name": "https://api.confluent.cloud/organization=9bb441c4-edef-46ac-8a41-c49e44a3fd9a/environment=env-abc123/cloud-cluster=lkc-xxxxx"
                 *     } */
                cluster?: unknown;
                /** @example [
                 *       {
                 *         "id": "env-xxxxx",
                 *         "related": "https://api.confluent.cloud/v2/environments/env-xxxxx",
                 *         "resource_name": "https://api.confluent.cloud/organization=9bb441c4-edef-46ac-8a41-c49e44a3fd9a/environment=env-xxxxx"
                 *       }
                 *     ] */
                environment?: unknown;
              };
            }[];
          };
        };
      };
      400: components["responses"]["BadRequestError"];
      401: components["responses"]["UnauthenticatedError"];
      403: components["responses"]["UnauthorizedError"];
      429: components["responses"]["RateLimitError"];
      500: components["responses"]["DefaultSystemError"];
    };
  };
  createKafkaQuotasV1ClientQuota: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        "application/json": unknown;
      };
    };
    responses: {
      /** @description A Client Quota is being created. */
      202: {
        headers: {
          /** @description The unique identifier for the API request. */
          "X-Request-Id"?: string;
          /** @description The maximum number of requests you're permitted to make per time period. */
          "X-RateLimit-Limit"?: number;
          /** @description The number of requests remaining in the current rate limit window. */
          "X-RateLimit-Remaining"?: number;
          /** @description The relative time in seconds until the current rate-limit window resets.
           *
           *     **Important:** This differs from Github and Twitter's same-named header which uses UTC epoch seconds. We use relative time to avoid client/server time synchronization issues. */
          "X-RateLimit-Reset"?: number;
          /** @description ClientQuota resource uri */
          Location?: string;
          [name: string]: unknown;
        };
        content: {
          "application/json": components["schemas"]["kafka-quotas.v1.ClientQuota"] & {
            spec: Record<string, unknown>;
          } & {
            spec?: {
              /** @example {
               *       "id": "lkc-xxxxx",
               *       "related": "https://api.confluent.cloud/cmk/v2/clusters/lkc-xxxxx",
               *       "resource_name": "https://api.confluent.cloud/organization=9bb441c4-edef-46ac-8a41-c49e44a3fd9a/environment=env-abc123/cloud-cluster=lkc-xxxxx"
               *     } */
              cluster?: unknown;
              /** @example [
               *       {
               *         "id": "env-xxxxx",
               *         "related": "https://api.confluent.cloud/v2/environments/env-xxxxx",
               *         "resource_name": "https://api.confluent.cloud/organization=9bb441c4-edef-46ac-8a41-c49e44a3fd9a/environment=env-xxxxx"
               *       }
               *     ] */
              environment?: unknown;
            };
          };
        };
      };
      400: components["responses"]["BadRequestError"];
      401: components["responses"]["UnauthenticatedError"];
      403: components["responses"]["UnauthorizedError"];
      409: components["responses"]["ConflictError"];
      422: components["responses"]["ValidationError"];
      429: components["responses"]["RateLimitError"];
      500: components["responses"]["DefaultSystemError"];
    };
  };
  getKafkaQuotasV1ClientQuota: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description The unique identifier for the client quota. */
        id: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description Client Quota. */
      200: {
        headers: {
          /** @description The unique identifier for the API request. */
          "X-Request-Id"?: string;
          /** @description The maximum number of requests you're permitted to make per time period. */
          "X-RateLimit-Limit"?: number;
          /** @description The number of requests remaining in the current rate limit window. */
          "X-RateLimit-Remaining"?: number;
          /** @description The relative time in seconds until the current rate-limit window resets.
           *
           *     **Important:** This differs from Github and Twitter's same-named header which uses UTC epoch seconds. We use relative time to avoid client/server time synchronization issues. */
          "X-RateLimit-Reset"?: number;
          [name: string]: unknown;
        };
        content: {
          "application/json": components["schemas"]["kafka-quotas.v1.ClientQuota"] & {
            spec: Record<string, unknown>;
          } & {
            spec?: {
              /** @example {
               *       "id": "lkc-xxxxx",
               *       "related": "https://api.confluent.cloud/cmk/v2/clusters/lkc-xxxxx",
               *       "resource_name": "https://api.confluent.cloud/organization=9bb441c4-edef-46ac-8a41-c49e44a3fd9a/environment=env-abc123/cloud-cluster=lkc-xxxxx"
               *     } */
              cluster?: unknown;
              /** @example [
               *       {
               *         "id": "env-xxxxx",
               *         "related": "https://api.confluent.cloud/v2/environments/env-xxxxx",
               *         "resource_name": "https://api.confluent.cloud/organization=9bb441c4-edef-46ac-8a41-c49e44a3fd9a/environment=env-xxxxx"
               *       }
               *     ] */
              environment?: unknown;
            };
          };
        };
      };
      400: components["responses"]["BadRequestError"];
      401: components["responses"]["UnauthenticatedError"];
      403: components["responses"]["UnauthorizedError"];
      404: components["responses"]["NotFoundError"];
      429: components["responses"]["RateLimitError"];
      500: components["responses"]["DefaultSystemError"];
    };
  };
  deleteKafkaQuotasV1ClientQuota: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description The unique identifier for the client quota. */
        id: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description A Client Quota is being deleted. */
      204: {
        headers: {
          /** @description The unique identifier for the API request. */
          "X-Request-Id"?: string;
          /** @description The maximum number of requests you're permitted to make per time period. */
          "X-RateLimit-Limit"?: number;
          /** @description The number of requests remaining in the current rate limit window. */
          "X-RateLimit-Remaining"?: number;
          /** @description The relative time in seconds until the current rate-limit window resets.
           *
           *     **Important:** This differs from Github and Twitter's same-named header which uses UTC epoch seconds. We use relative time to avoid client/server time synchronization issues. */
          "X-RateLimit-Reset"?: number;
          [name: string]: unknown;
        };
        content?: never;
      };
      400: components["responses"]["BadRequestError"];
      401: components["responses"]["UnauthenticatedError"];
      403: components["responses"]["UnauthorizedError"];
      404: components["responses"]["NotFoundError"];
      429: components["responses"]["RateLimitError"];
      500: components["responses"]["DefaultSystemError"];
    };
  };
  updateKafkaQuotasV1ClientQuota: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description The unique identifier for the client quota. */
        id: string;
      };
      cookie?: never;
    };
    requestBody?: {
      content: {
        "application/json": components["schemas"]["kafka-quotas.v1.ClientQuotaUpdate"] & {
          spec: {
            /** @example {
             *       "id": "env-00000"
             *     } */
            environment: unknown;
          };
        };
      };
    };
    responses: {
      /** @description Client Quota. */
      200: {
        headers: {
          /** @description The unique identifier for the API request. */
          "X-Request-Id"?: string;
          /** @description The maximum number of requests you're permitted to make per time period. */
          "X-RateLimit-Limit"?: number;
          /** @description The number of requests remaining in the current rate limit window. */
          "X-RateLimit-Remaining"?: number;
          /** @description The relative time in seconds until the current rate-limit window resets.
           *
           *     **Important:** This differs from Github and Twitter's same-named header which uses UTC epoch seconds. We use relative time to avoid client/server time synchronization issues. */
          "X-RateLimit-Reset"?: number;
          [name: string]: unknown;
        };
        content: {
          "application/json": components["schemas"]["kafka-quotas.v1.ClientQuota"] & {
            spec: Record<string, unknown>;
          } & {
            spec?: {
              /** @example {
               *       "id": "lkc-xxxxx",
               *       "related": "https://api.confluent.cloud/cmk/v2/clusters/lkc-xxxxx",
               *       "resource_name": "https://api.confluent.cloud/organization=9bb441c4-edef-46ac-8a41-c49e44a3fd9a/environment=env-abc123/cloud-cluster=lkc-xxxxx"
               *     } */
              cluster?: unknown;
              /** @example [
               *       {
               *         "id": "env-xxxxx",
               *         "related": "https://api.confluent.cloud/v2/environments/env-xxxxx",
               *         "resource_name": "https://api.confluent.cloud/organization=9bb441c4-edef-46ac-8a41-c49e44a3fd9a/environment=env-xxxxx"
               *       }
               *     ] */
              environment?: unknown;
            };
          };
        };
      };
      400: components["responses"]["BadRequestError"];
      401: components["responses"]["UnauthenticatedError"];
      403: components["responses"]["UnauthorizedError"];
      404: components["responses"]["NotFoundError"];
      409: components["responses"]["ConflictError"];
      422: components["responses"]["ValidationError"];
      429: components["responses"]["RateLimitError"];
      500: components["responses"]["DefaultSystemError"];
    };
  };
  listByokV1Keys: {
    parameters: {
      query?: {
        /**
         * @description Filter the results by exact match for provider.
         * @example AWS
         */
        provider?: components["schemas"]["SearchFilter"];
        /**
         * @description Filter the results by exact match for state.
         * @example IN_USE
         */
        state?: components["schemas"]["SearchFilter"];
        /** @description A pagination size for collection requests. */
        page_size?: number;
        /** @description An opaque pagination token for collection requests. */
        page_token?: string;
      };
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description Key. */
      200: {
        headers: {
          /** @description The unique identifier for the API request. */
          "X-Request-Id"?: string;
          /** @description The maximum number of requests you're permitted to make per time period. */
          "X-RateLimit-Limit"?: number;
          /** @description The number of requests remaining in the current rate limit window. */
          "X-RateLimit-Remaining"?: number;
          /** @description The relative time in seconds until the current rate-limit window resets.
           *
           *     **Important:** This differs from Github and Twitter's same-named header which uses UTC epoch seconds. We use relative time to avoid client/server time synchronization issues. */
          "X-RateLimit-Reset"?: number;
          [name: string]: unknown;
        };
        content: {
          "application/json": components["schemas"]["byok.v1.KeyList"];
        };
      };
      400: components["responses"]["BadRequestError"];
      401: components["responses"]["UnauthenticatedError"];
      403: components["responses"]["UnauthorizedError"];
      429: components["responses"]["RateLimitError"];
      500: components["responses"]["DefaultSystemError"];
    };
  };
  createByokV1Key: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody?: {
      content: {
        "application/json": components["schemas"]["byok.v1.Key"] &
          Record<string, unknown>;
      };
    };
    responses: {
      /** @description A Key was created. */
      201: {
        headers: {
          /** @description The unique identifier for the API request. */
          "X-Request-Id"?: string;
          /** @description The maximum number of requests you're permitted to make per time period. */
          "X-RateLimit-Limit"?: number;
          /** @description The number of requests remaining in the current rate limit window. */
          "X-RateLimit-Remaining"?: number;
          /** @description The relative time in seconds until the current rate-limit window resets.
           *
           *     **Important:** This differs from Github and Twitter's same-named header which uses UTC epoch seconds. We use relative time to avoid client/server time synchronization issues. */
          "X-RateLimit-Reset"?: number;
          /** @description Key resource uri */
          Location?: string;
          [name: string]: unknown;
        };
        content: {
          "application/json": components["schemas"]["byok.v1.Key"] &
            Record<string, unknown>;
        };
      };
      400: components["responses"]["BadRequestError"];
      401: components["responses"]["UnauthenticatedError"];
      402: components["responses"]["OverQuotaError"];
      403: components["responses"]["UnauthorizedError"];
      409: components["responses"]["ConflictError"];
      422: components["responses"]["ValidationError"];
      429: components["responses"]["RateLimitError"];
      500: components["responses"]["DefaultSystemError"];
    };
  };
  getByokV1Key: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description The unique identifier for the key. */
        id: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description Key. */
      200: {
        headers: {
          /** @description The unique identifier for the API request. */
          "X-Request-Id"?: string;
          /** @description The maximum number of requests you're permitted to make per time period. */
          "X-RateLimit-Limit"?: number;
          /** @description The number of requests remaining in the current rate limit window. */
          "X-RateLimit-Remaining"?: number;
          /** @description The relative time in seconds until the current rate-limit window resets.
           *
           *     **Important:** This differs from Github and Twitter's same-named header which uses UTC epoch seconds. We use relative time to avoid client/server time synchronization issues. */
          "X-RateLimit-Reset"?: number;
          [name: string]: unknown;
        };
        content: {
          "application/json": components["schemas"]["byok.v1.Key"] &
            Record<string, unknown>;
        };
      };
      400: components["responses"]["BadRequestError"];
      401: components["responses"]["UnauthenticatedError"];
      403: components["responses"]["UnauthorizedError"];
      404: components["responses"]["NotFoundError"];
      429: components["responses"]["RateLimitError"];
      500: components["responses"]["DefaultSystemError"];
    };
  };
  deleteByokV1Key: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description The unique identifier for the key. */
        id: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description A Key is being deleted. */
      204: {
        headers: {
          /** @description The unique identifier for the API request. */
          "X-Request-Id"?: string;
          /** @description The maximum number of requests you're permitted to make per time period. */
          "X-RateLimit-Limit"?: number;
          /** @description The number of requests remaining in the current rate limit window. */
          "X-RateLimit-Remaining"?: number;
          /** @description The relative time in seconds until the current rate-limit window resets.
           *
           *     **Important:** This differs from Github and Twitter's same-named header which uses UTC epoch seconds. We use relative time to avoid client/server time synchronization issues. */
          "X-RateLimit-Reset"?: number;
          [name: string]: unknown;
        };
        content?: never;
      };
      400: components["responses"]["BadRequestError"];
      401: components["responses"]["UnauthenticatedError"];
      403: components["responses"]["UnauthorizedError"];
      404: components["responses"]["NotFoundError"];
      429: components["responses"]["RateLimitError"];
      500: components["responses"]["DefaultSystemError"];
    };
  };
  listBillingV1Costs: {
    parameters: {
      query: {
        /**
         * @description Filter the results by exact match for start_date.
         * @example 2022-10-12
         */
        start_date: components["schemas"]["SearchFilter"];
        /**
         * @description Filter the results by exact match for end_date.
         * @example 2022-10-15
         */
        end_date: components["schemas"]["SearchFilter"];
        /** @description A pagination size for collection requests. */
        page_size?: number;
        /** @description An opaque pagination token for collection requests. */
        page_token?: string;
      };
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description Cost. */
      200: {
        headers: {
          /** @description The unique identifier for the API request. */
          "X-Request-Id"?: string;
          /** @description The maximum number of requests you're permitted to make per time period. */
          "X-RateLimit-Limit"?: number;
          /** @description The number of requests remaining in the current rate limit window. */
          "X-RateLimit-Remaining"?: number;
          /** @description The relative time in seconds until the current rate-limit window resets.
           *
           *     **Important:** This differs from Github and Twitter's same-named header which uses UTC epoch seconds. We use relative time to avoid client/server time synchronization issues. */
          "X-RateLimit-Reset"?: number;
          [name: string]: unknown;
        };
        content: {
          "application/json": components["schemas"]["billing.v1.CostList"];
        };
      };
      400: components["responses"]["BadRequestError"];
      401: components["responses"]["UnauthenticatedError"];
      403: components["responses"]["UnauthorizedError"];
      429: components["responses"]["RateLimitError"];
      500: components["responses"]["DefaultSystemError"];
    };
  };
  listIamV2SsoGroupMappings: {
    parameters: {
      query?: {
        /** @description A pagination size for collection requests. */
        page_size?: number;
        /** @description An opaque pagination token for collection requests. */
        page_token?: string;
      };
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description Group Mapping. */
      200: {
        headers: {
          /** @description The unique identifier for the API request. */
          "X-Request-Id"?: string;
          /** @description The maximum number of requests you're permitted to make per time period. */
          "X-RateLimit-Limit"?: number;
          /** @description The number of requests remaining in the current rate limit window. */
          "X-RateLimit-Remaining"?: number;
          /** @description The relative time in seconds until the current rate-limit window resets.
           *
           *     **Important:** This differs from Github and Twitter's same-named header which uses UTC epoch seconds. We use relative time to avoid client/server time synchronization issues. */
          "X-RateLimit-Reset"?: number;
          [name: string]: unknown;
        };
        content: {
          "application/json": components["schemas"]["iam.v2.sso.GroupMappingList"];
        };
      };
      400: components["responses"]["BadRequestError"];
      401: components["responses"]["UnauthenticatedError"];
      403: components["responses"]["UnauthorizedError"];
      429: components["responses"]["RateLimitError"];
      500: components["responses"]["DefaultSystemError"];
    };
  };
  createIamV2SsoGroupMapping: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody?: {
      content: {
        "application/json": components["schemas"]["iam.v2.sso.GroupMapping"] &
          Record<string, unknown>;
      };
    };
    responses: {
      /** @description A Group Mapping was created. */
      201: {
        headers: {
          /** @description The unique identifier for the API request. */
          "X-Request-Id"?: string;
          /** @description The maximum number of requests you're permitted to make per time period. */
          "X-RateLimit-Limit"?: number;
          /** @description The number of requests remaining in the current rate limit window. */
          "X-RateLimit-Remaining"?: number;
          /** @description The relative time in seconds until the current rate-limit window resets.
           *
           *     **Important:** This differs from Github and Twitter's same-named header which uses UTC epoch seconds. We use relative time to avoid client/server time synchronization issues. */
          "X-RateLimit-Reset"?: number;
          /** @description GroupMapping resource uri */
          Location?: string;
          [name: string]: unknown;
        };
        content: {
          "application/json": components["schemas"]["iam.v2.sso.GroupMapping"] &
            Record<string, unknown>;
        };
      };
      400: components["responses"]["BadRequestError"];
      401: components["responses"]["UnauthenticatedError"];
      402: components["responses"]["OverQuotaError"];
      403: components["responses"]["UnauthorizedError"];
      409: components["responses"]["ConflictError"];
      422: components["responses"]["ValidationError"];
      429: components["responses"]["RateLimitError"];
      500: components["responses"]["DefaultSystemError"];
    };
  };
  getIamV2SsoGroupMapping: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description The unique identifier for the group mapping. */
        id: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description Group Mapping. */
      200: {
        headers: {
          /** @description The unique identifier for the API request. */
          "X-Request-Id"?: string;
          /** @description The maximum number of requests you're permitted to make per time period. */
          "X-RateLimit-Limit"?: number;
          /** @description The number of requests remaining in the current rate limit window. */
          "X-RateLimit-Remaining"?: number;
          /** @description The relative time in seconds until the current rate-limit window resets.
           *
           *     **Important:** This differs from Github and Twitter's same-named header which uses UTC epoch seconds. We use relative time to avoid client/server time synchronization issues. */
          "X-RateLimit-Reset"?: number;
          [name: string]: unknown;
        };
        content: {
          "application/json": components["schemas"]["iam.v2.sso.GroupMapping"] &
            Record<string, unknown>;
        };
      };
      400: components["responses"]["BadRequestError"];
      401: components["responses"]["UnauthenticatedError"];
      403: components["responses"]["UnauthorizedError"];
      404: components["responses"]["NotFoundError"];
      429: components["responses"]["RateLimitError"];
      500: components["responses"]["DefaultSystemError"];
    };
  };
  deleteIamV2SsoGroupMapping: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description The unique identifier for the group mapping. */
        id: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description A Group Mapping is being deleted. */
      204: {
        headers: {
          /** @description The unique identifier for the API request. */
          "X-Request-Id"?: string;
          /** @description The maximum number of requests you're permitted to make per time period. */
          "X-RateLimit-Limit"?: number;
          /** @description The number of requests remaining in the current rate limit window. */
          "X-RateLimit-Remaining"?: number;
          /** @description The relative time in seconds until the current rate-limit window resets.
           *
           *     **Important:** This differs from Github and Twitter's same-named header which uses UTC epoch seconds. We use relative time to avoid client/server time synchronization issues. */
          "X-RateLimit-Reset"?: number;
          [name: string]: unknown;
        };
        content?: never;
      };
      400: components["responses"]["BadRequestError"];
      401: components["responses"]["UnauthenticatedError"];
      403: components["responses"]["UnauthorizedError"];
      404: components["responses"]["NotFoundError"];
      429: components["responses"]["RateLimitError"];
      500: components["responses"]["DefaultSystemError"];
    };
  };
  updateIamV2SsoGroupMapping: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description The unique identifier for the group mapping. */
        id: string;
      };
      cookie?: never;
    };
    requestBody?: {
      content: {
        "application/json": components["schemas"]["iam.v2.sso.GroupMapping"];
      };
    };
    responses: {
      /** @description Group Mapping. */
      200: {
        headers: {
          /** @description The unique identifier for the API request. */
          "X-Request-Id"?: string;
          /** @description The maximum number of requests you're permitted to make per time period. */
          "X-RateLimit-Limit"?: number;
          /** @description The number of requests remaining in the current rate limit window. */
          "X-RateLimit-Remaining"?: number;
          /** @description The relative time in seconds until the current rate-limit window resets.
           *
           *     **Important:** This differs from Github and Twitter's same-named header which uses UTC epoch seconds. We use relative time to avoid client/server time synchronization issues. */
          "X-RateLimit-Reset"?: number;
          [name: string]: unknown;
        };
        content: {
          "application/json": components["schemas"]["iam.v2.sso.GroupMapping"] &
            Record<string, unknown>;
        };
      };
      400: components["responses"]["BadRequestError"];
      401: components["responses"]["UnauthenticatedError"];
      402: components["responses"]["OverQuotaError"];
      403: components["responses"]["UnauthorizedError"];
      404: components["responses"]["NotFoundError"];
      409: components["responses"]["ConflictError"];
      422: components["responses"]["ValidationError"];
      429: components["responses"]["RateLimitError"];
      500: components["responses"]["DefaultSystemError"];
    };
  };
  listFcpmV2ComputePools: {
    parameters: {
      query: {
        /**
         * @description Filter the results by exact match for spec.region.
         * @example us-west-1
         */
        "spec.region"?: components["schemas"]["SearchFilter"];
        /**
         * @description Filter the results by exact match for environment.
         * @example env-00000
         */
        environment: components["schemas"]["SearchFilter"];
        /**
         * @description Filter the results by exact match for spec.network.
         * @example n-00000
         */
        "spec.network"?: components["schemas"]["SearchFilter"];
        /** @description A pagination size for collection requests. */
        page_size?: number;
        /** @description An opaque pagination token for collection requests. */
        page_token?: string;
      };
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description Compute Pool. */
      200: {
        headers: {
          /** @description The unique identifier for the API request. */
          "X-Request-Id"?: string;
          /** @description The maximum number of requests you're permitted to make per time period. */
          "X-RateLimit-Limit"?: number;
          /** @description The number of requests remaining in the current rate limit window. */
          "X-RateLimit-Remaining"?: number;
          /** @description The relative time in seconds until the current rate-limit window resets.
           *
           *     **Important:** This differs from Github and Twitter's same-named header which uses UTC epoch seconds. We use relative time to avoid client/server time synchronization issues. */
          "X-RateLimit-Reset"?: number;
          [name: string]: unknown;
        };
        content: {
          "application/json": components["schemas"]["fcpm.v2.ComputePoolList"] & {
            data?: {
              spec?: {
                /** @example {
                 *       "id": "env-00000",
                 *       "related": "https://api.confluent.cloud/org/v2/environments/env-00000",
                 *       "resource_name": "https://api.confluent.cloud/organization=9bb441c4-edef-46ac-8a41-c49e44a3fd9a/environment=env-00000"
                 *     } */
                environment?: unknown;
                /** @example {
                 *       "id": "n-00000",
                 *       "related": "https://api.confluent.cloud/networking/v1/networks/n-00000",
                 *       "resource_name": "https://api.confluent.cloud/organization=9bb441c4-edef-46ac-8a41-c49e44a3fd9a/environment=env-abc123/network=n-00000"
                 *     } */
                network?: unknown;
              };
            }[];
          };
        };
      };
      400: components["responses"]["BadRequestError"];
      401: components["responses"]["UnauthenticatedError"];
      403: components["responses"]["UnauthorizedError"];
      429: components["responses"]["RateLimitError"];
      500: components["responses"]["DefaultSystemError"];
    };
  };
  createFcpmV2ComputePool: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody?: {
      content: {
        "application/json": components["schemas"]["fcpm.v2.ComputePool"] & {
          spec: Record<string, unknown>;
        } & {
          spec?: {
            /** @example {
             *       "id": "env-00000"
             *     } */
            environment?: unknown;
            /** @example {
             *       "id": "n-00000"
             *     } */
            network?: unknown;
          };
        };
      };
    };
    responses: {
      /** @description A Compute Pool is being created. */
      202: {
        headers: {
          /** @description The unique identifier for the API request. */
          "X-Request-Id"?: string;
          /** @description The maximum number of requests you're permitted to make per time period. */
          "X-RateLimit-Limit"?: number;
          /** @description The number of requests remaining in the current rate limit window. */
          "X-RateLimit-Remaining"?: number;
          /** @description The relative time in seconds until the current rate-limit window resets.
           *
           *     **Important:** This differs from Github and Twitter's same-named header which uses UTC epoch seconds. We use relative time to avoid client/server time synchronization issues. */
          "X-RateLimit-Reset"?: number;
          /** @description ComputePool resource uri */
          Location?: string;
          [name: string]: unknown;
        };
        content: {
          "application/json": components["schemas"]["fcpm.v2.ComputePool"] & {
            spec: Record<string, unknown>;
          } & {
            spec?: {
              /** @example {
               *       "id": "env-00000",
               *       "related": "https://api.confluent.cloud/org/v2/environments/env-00000",
               *       "resource_name": "https://api.confluent.cloud/organization=9bb441c4-edef-46ac-8a41-c49e44a3fd9a/environment=env-00000"
               *     } */
              environment?: unknown;
              /** @example {
               *       "id": "n-00000",
               *       "related": "https://api.confluent.cloud/networking/v1/networks/n-00000",
               *       "resource_name": "https://api.confluent.cloud/organization=9bb441c4-edef-46ac-8a41-c49e44a3fd9a/environment=env-abc123/network=n-00000"
               *     } */
              network?: unknown;
            };
          };
        };
      };
      400: components["responses"]["BadRequestError"];
      401: components["responses"]["UnauthenticatedError"];
      403: components["responses"]["UnauthorizedError"];
      409: components["responses"]["ConflictError"];
      422: components["responses"]["ValidationError"];
      429: components["responses"]["RateLimitError"];
      500: components["responses"]["DefaultSystemError"];
    };
  };
  getFcpmV2ComputePool: {
    parameters: {
      query: {
        /**
         * @description Scope the operation to the given environment.
         * @example env-00000
         */
        environment: components["schemas"]["SearchFilter"];
      };
      header?: never;
      path: {
        /** @description The unique identifier for the compute pool. */
        id: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description Compute Pool. */
      200: {
        headers: {
          /** @description The unique identifier for the API request. */
          "X-Request-Id"?: string;
          /** @description The maximum number of requests you're permitted to make per time period. */
          "X-RateLimit-Limit"?: number;
          /** @description The number of requests remaining in the current rate limit window. */
          "X-RateLimit-Remaining"?: number;
          /** @description The relative time in seconds until the current rate-limit window resets.
           *
           *     **Important:** This differs from Github and Twitter's same-named header which uses UTC epoch seconds. We use relative time to avoid client/server time synchronization issues. */
          "X-RateLimit-Reset"?: number;
          [name: string]: unknown;
        };
        content: {
          "application/json": components["schemas"]["fcpm.v2.ComputePool"] & {
            spec: Record<string, unknown>;
          } & {
            spec?: {
              /** @example {
               *       "id": "env-00000",
               *       "related": "https://api.confluent.cloud/org/v2/environments/env-00000",
               *       "resource_name": "https://api.confluent.cloud/organization=9bb441c4-edef-46ac-8a41-c49e44a3fd9a/environment=env-00000"
               *     } */
              environment?: unknown;
              /** @example {
               *       "id": "n-00000",
               *       "related": "https://api.confluent.cloud/networking/v1/networks/n-00000",
               *       "resource_name": "https://api.confluent.cloud/organization=9bb441c4-edef-46ac-8a41-c49e44a3fd9a/environment=env-abc123/network=n-00000"
               *     } */
              network?: unknown;
            };
          };
        };
      };
      400: components["responses"]["BadRequestError"];
      401: components["responses"]["UnauthenticatedError"];
      403: components["responses"]["UnauthorizedError"];
      404: components["responses"]["NotFoundError"];
      429: components["responses"]["RateLimitError"];
      500: components["responses"]["DefaultSystemError"];
    };
  };
  deleteFcpmV2ComputePool: {
    parameters: {
      query: {
        /**
         * @description Scope the operation to the given environment.
         * @example env-00000
         */
        environment: components["schemas"]["SearchFilter"];
      };
      header?: never;
      path: {
        /** @description The unique identifier for the compute pool. */
        id: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description A Compute Pool is being deleted. */
      204: {
        headers: {
          /** @description The unique identifier for the API request. */
          "X-Request-Id"?: string;
          /** @description The maximum number of requests you're permitted to make per time period. */
          "X-RateLimit-Limit"?: number;
          /** @description The number of requests remaining in the current rate limit window. */
          "X-RateLimit-Remaining"?: number;
          /** @description The relative time in seconds until the current rate-limit window resets.
           *
           *     **Important:** This differs from Github and Twitter's same-named header which uses UTC epoch seconds. We use relative time to avoid client/server time synchronization issues. */
          "X-RateLimit-Reset"?: number;
          [name: string]: unknown;
        };
        content?: never;
      };
      400: components["responses"]["BadRequestError"];
      401: components["responses"]["UnauthenticatedError"];
      403: components["responses"]["UnauthorizedError"];
      404: components["responses"]["NotFoundError"];
      429: components["responses"]["RateLimitError"];
      500: components["responses"]["DefaultSystemError"];
    };
  };
  updateFcpmV2ComputePool: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description The unique identifier for the compute pool. */
        id: string;
      };
      cookie?: never;
    };
    requestBody?: {
      content: {
        "application/json": components["schemas"]["fcpm.v2.ComputePoolUpdate"] & {
          spec: {
            /** @example {
             *       "id": "env-00000"
             *     } */
            environment: unknown;
          };
        };
      };
    };
    responses: {
      /** @description Compute Pool. */
      200: {
        headers: {
          /** @description The unique identifier for the API request. */
          "X-Request-Id"?: string;
          /** @description The maximum number of requests you're permitted to make per time period. */
          "X-RateLimit-Limit"?: number;
          /** @description The number of requests remaining in the current rate limit window. */
          "X-RateLimit-Remaining"?: number;
          /** @description The relative time in seconds until the current rate-limit window resets.
           *
           *     **Important:** This differs from Github and Twitter's same-named header which uses UTC epoch seconds. We use relative time to avoid client/server time synchronization issues. */
          "X-RateLimit-Reset"?: number;
          [name: string]: unknown;
        };
        content: {
          "application/json": components["schemas"]["fcpm.v2.ComputePool"] & {
            spec: Record<string, unknown>;
          } & {
            spec?: {
              /** @example {
               *       "id": "env-00000",
               *       "related": "https://api.confluent.cloud/org/v2/environments/env-00000",
               *       "resource_name": "https://api.confluent.cloud/organization=9bb441c4-edef-46ac-8a41-c49e44a3fd9a/environment=env-00000"
               *     } */
              environment?: unknown;
              /** @example {
               *       "id": "n-00000",
               *       "related": "https://api.confluent.cloud/networking/v1/networks/n-00000",
               *       "resource_name": "https://api.confluent.cloud/organization=9bb441c4-edef-46ac-8a41-c49e44a3fd9a/environment=env-abc123/network=n-00000"
               *     } */
              network?: unknown;
            };
          };
        };
      };
      400: components["responses"]["BadRequestError"];
      401: components["responses"]["UnauthenticatedError"];
      403: components["responses"]["UnauthorizedError"];
      404: components["responses"]["NotFoundError"];
      409: components["responses"]["ConflictError"];
      422: components["responses"]["ValidationError"];
      429: components["responses"]["RateLimitError"];
      500: components["responses"]["DefaultSystemError"];
    };
  };
  listFcpmV2Regions: {
    parameters: {
      query?: {
        /**
         * @description Filter the results by exact match for cloud.
         * @example AWS
         */
        cloud?: components["schemas"]["SearchFilter"];
        /**
         * @description Filter the results by exact match for region_name.
         * @example us-east-2
         */
        region_name?: components["schemas"]["SearchFilter"];
        /** @description A pagination size for collection requests. */
        page_size?: number;
        /** @description An opaque pagination token for collection requests. */
        page_token?: string;
      };
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description Region. */
      200: {
        headers: {
          /** @description The unique identifier for the API request. */
          "X-Request-Id"?: string;
          /** @description The maximum number of requests you're permitted to make per time period. */
          "X-RateLimit-Limit"?: number;
          /** @description The number of requests remaining in the current rate limit window. */
          "X-RateLimit-Remaining"?: number;
          /** @description The relative time in seconds until the current rate-limit window resets.
           *
           *     **Important:** This differs from Github and Twitter's same-named header which uses UTC epoch seconds. We use relative time to avoid client/server time synchronization issues. */
          "X-RateLimit-Reset"?: number;
          [name: string]: unknown;
        };
        content: {
          "application/json": components["schemas"]["fcpm.v2.RegionList"];
        };
      };
      400: components["responses"]["BadRequestError"];
      401: components["responses"]["UnauthenticatedError"];
      403: components["responses"]["UnauthorizedError"];
      429: components["responses"]["RateLimitError"];
      500: components["responses"]["DefaultSystemError"];
    };
  };
  listSqlv1Connections: {
    parameters: {
      query?: {
        /** @description Filter the results by exact match for spec.connection_type */
        "spec.connection_type"?: string;
        /** @description A pagination size for collection requests. */
        page_size?: number;
        /** @description An opaque pagination token for collection requests. */
        page_token?: string;
      };
      header?: never;
      path: {
        /** @description The unique identifier for the organization. */
        organization_id: string;
        /** @description The unique identifier for the environment. */
        environment_id: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description Connections. */
      200: {
        headers: {
          /** @description The unique identifier for the API request. */
          "X-Request-Id"?: string;
          [name: string]: unknown;
        };
        content: {
          "application/json": components["schemas"]["sql.v1.ConnectionList"];
        };
      };
      400: components["responses"]["BadRequestError"];
      401: components["responses"]["UnauthenticatedError"];
      403: components["responses"]["UnauthorizedError"];
      404: components["responses"]["NotFoundError"];
      429: components["responses"]["RateLimitError"];
      500: components["responses"]["DefaultSystemError"];
    };
  };
  createSqlv1Connection: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description The unique identifier for the organization. */
        organization_id: string;
        /** @description The unique identifier for the environment. */
        environment_id: string;
      };
      cookie?: never;
    };
    requestBody?: {
      content: {
        "application/json": components["schemas"]["sql.v1.Connection"] & {
          spec: Record<string, unknown>;
        };
      };
    };
    responses: {
      /** @description A Connection has been successfully created. */
      201: {
        headers: {
          /** @description The unique identifier for the API request. */
          "X-Request-Id"?: string;
          /** @description Connection resource uri */
          Location?: string;
          [name: string]: unknown;
        };
        content: {
          "application/json": components["schemas"]["sql.v1.Connection"] & {
            spec: Record<string, unknown>;
          };
        };
      };
      400: components["responses"]["BadRequestError"];
      401: components["responses"]["UnauthenticatedError"];
      403: components["responses"]["UnauthorizedError"];
      409: components["responses"]["ConflictError"];
      422: components["responses"]["ValidationError"];
      429: components["responses"]["RateLimitError"];
      500: components["responses"]["DefaultSystemError"];
    };
  };
  getSqlv1Connection: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description The unique identifier for the organization. */
        organization_id: string;
        /** @description The unique identifier for the environment. */
        environment_id: string;
        /** @description The user provided name of the Connection. Unique within a region within an org and env. */
        connection_name: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description Connection. */
      200: {
        headers: {
          /** @description The unique identifier for the API request. */
          "X-Request-Id"?: string;
          [name: string]: unknown;
        };
        content: {
          "application/json": components["schemas"]["sql.v1.Connection"] & {
            spec: Record<string, unknown>;
          };
        };
      };
      400: components["responses"]["BadRequestError"];
      401: components["responses"]["UnauthenticatedError"];
      403: components["responses"]["UnauthorizedError"];
      404: components["responses"]["NotFoundError"];
      429: components["responses"]["RateLimitError"];
      500: components["responses"]["DefaultSystemError"];
    };
  };
  updateSqlv1Connection: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description The unique identifier for the organization. */
        organization_id: string;
        /** @description The unique identifier for the environment. */
        environment_id: string;
        /** @description The unique identifier for the connection. */
        connection_name: string;
      };
      cookie?: never;
    };
    requestBody?: {
      content: {
        "application/json": components["schemas"]["sql.v1.Connection"] & {
          spec: Record<string, unknown>;
          metadata: Record<string, unknown>;
        };
      };
    };
    responses: {
      /** @description A Connection has been updated. */
      200: {
        headers: {
          /** @description The unique identifier for the API request. */
          "X-Request-Id"?: string;
          [name: string]: unknown;
        };
        content?: never;
      };
      400: components["responses"]["BadRequestError"];
      401: components["responses"]["UnauthenticatedError"];
      403: components["responses"]["UnauthorizedError"];
      404: components["responses"]["NotFoundError"];
      429: components["responses"]["RateLimitError"];
      500: components["responses"]["DefaultSystemError"];
    };
  };
  deleteSqlv1Connection: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description The unique identifier for the organization. */
        organization_id: string;
        /** @description The unique identifier for the environment. */
        environment_id: string;
        /** @description The unique identifier for the connection. */
        connection_name: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description A Connection has been deleted. */
      200: {
        headers: {
          /** @description The unique identifier for the API request. */
          "X-Request-Id"?: string;
          [name: string]: unknown;
        };
        content?: never;
      };
      400: components["responses"]["BadRequestError"];
      401: components["responses"]["UnauthenticatedError"];
      403: components["responses"]["UnauthorizedError"];
      404: components["responses"]["NotFoundError"];
      429: components["responses"]["RateLimitError"];
      500: components["responses"]["DefaultSystemError"];
    };
  };
  getSqlv1StatementResult: {
    parameters: {
      query?: {
        /** @description It contains the field offset in the CollectSinkFunction protocol. On the first request, it should be unset. The offset is assumed to start at 0. */
        page_token?: string;
      };
      header?: never;
      path: {
        /** @description The unique identifier for the organization. */
        organization_id: string;
        /** @description The unique identifier for the environment. */
        environment_id: string;
        /** @description The unique identifier for the statement. */
        name: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description Statement Result. */
      200: {
        headers: {
          /** @description The unique identifier for the API request. */
          "X-Request-Id"?: string;
          [name: string]: unknown;
        };
        content: {
          "application/json": components["schemas"]["sql.v1.StatementResult"] & {
            results: Record<string, unknown>;
          };
        };
      };
      400: components["responses"]["BadRequestError"];
      401: components["responses"]["UnauthenticatedError"];
      403: components["responses"]["UnauthorizedError"];
      404: components["responses"]["NotFoundError"];
      429: components["responses"]["RateLimitError"];
      500: components["responses"]["DefaultSystemError"];
    };
  };
  listSqlv1Statements: {
    parameters: {
      query?: {
        /**
         * @description Filter the results by exact match for spec.compute_pool.
         * @example lfcp-00000
         */
        "spec.compute_pool_id"?: string;
        /** @description A pagination size for collection requests. */
        page_size?: number;
        /** @description An opaque pagination token for collection requests. */
        page_token?: string;
        /** @description A comma-separated label selector to filter the statements. */
        label_selector?: string;
      };
      header?: never;
      path: {
        /** @description The unique identifier for the organization. */
        organization_id: string;
        /** @description The unique identifier for the environment. */
        environment_id: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description Statements. */
      200: {
        headers: {
          /** @description The unique identifier for the API request. */
          "X-Request-Id"?: string;
          [name: string]: unknown;
        };
        content: {
          "application/json": components["schemas"]["sql.v1.StatementList"];
        };
      };
      400: components["responses"]["BadRequestError"];
      401: components["responses"]["UnauthenticatedError"];
      403: components["responses"]["UnauthorizedError"];
      404: components["responses"]["NotFoundError"];
      429: components["responses"]["RateLimitError"];
      500: components["responses"]["DefaultSystemError"];
    };
  };
  createSqlv1Statement: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description The unique identifier for the organization. */
        organization_id: string;
        /** @description The unique identifier for the environment. */
        environment_id: string;
      };
      cookie?: never;
    };
    requestBody?: {
      content: {
        "application/json": components["schemas"]["sql.v1.Statement"] & {
          spec: Record<string, unknown>;
        };
      };
    };
    responses: {
      /** @description A Statement is being created. */
      201: {
        headers: {
          /** @description The unique identifier for the API request. */
          "X-Request-Id"?: string;
          /** @description Statement resource uri */
          Location?: string;
          [name: string]: unknown;
        };
        content: {
          "application/json": components["schemas"]["sql.v1.Statement"] & {
            spec: Record<string, unknown>;
          };
        };
      };
      400: components["responses"]["BadRequestError"];
      401: components["responses"]["UnauthenticatedError"];
      403: components["responses"]["UnauthorizedError"];
      409: components["responses"]["ConflictError"];
      422: components["responses"]["ValidationError"];
      429: components["responses"]["RateLimitError"];
      500: components["responses"]["DefaultSystemError"];
    };
  };
  getSqlv1Statement: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description The unique identifier for the organization. */
        organization_id: string;
        /** @description The unique identifier for the environment. */
        environment_id: string;
        /** @description The unique identifier for the statement. */
        statement_name: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description Statement. */
      200: {
        headers: {
          /** @description The unique identifier for the API request. */
          "X-Request-Id"?: string;
          [name: string]: unknown;
        };
        content: {
          "application/json": components["schemas"]["sql.v1.Statement"] & {
            spec: Record<string, unknown>;
          };
        };
      };
      400: components["responses"]["BadRequestError"];
      401: components["responses"]["UnauthenticatedError"];
      403: components["responses"]["UnauthorizedError"];
      404: components["responses"]["NotFoundError"];
      429: components["responses"]["RateLimitError"];
      500: components["responses"]["DefaultSystemError"];
    };
  };
  updateSqlv1Statement: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description The unique identifier for the organization. */
        organization_id: string;
        /** @description The unique identifier for the environment. */
        environment_id: string;
        /** @description The unique identifier for the statement. */
        statement_name: string;
      };
      cookie?: never;
    };
    requestBody?: {
      content: {
        "application/json": components["schemas"]["sql.v1.Statement"] & {
          spec: Record<string, unknown>;
          metadata: Record<string, unknown>;
        };
      };
    };
    responses: {
      /** @description A Statement is being updated. */
      202: {
        headers: {
          /** @description The unique identifier for the API request. */
          "X-Request-Id"?: string;
          [name: string]: unknown;
        };
        content?: never;
      };
      400: components["responses"]["BadRequestError"];
      401: components["responses"]["UnauthenticatedError"];
      403: components["responses"]["UnauthorizedError"];
      404: components["responses"]["NotFoundError"];
      429: components["responses"]["RateLimitError"];
      500: components["responses"]["DefaultSystemError"];
    };
  };
  deleteSqlv1Statement: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description The unique identifier for the organization. */
        organization_id: string;
        /** @description The unique identifier for the environment. */
        environment_id: string;
        /** @description The unique identifier for the statement. */
        statement_name: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description A Statement is being deleted. */
      202: {
        headers: {
          /** @description The unique identifier for the API request. */
          "X-Request-Id"?: string;
          [name: string]: unknown;
        };
        content?: never;
      };
      400: components["responses"]["BadRequestError"];
      401: components["responses"]["UnauthenticatedError"];
      403: components["responses"]["UnauthorizedError"];
      404: components["responses"]["NotFoundError"];
      429: components["responses"]["RateLimitError"];
      500: components["responses"]["DefaultSystemError"];
    };
  };
  patchSqlv1Statement: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description The unique identifier for the organization. */
        organization_id: string;
        /** @description The unique identifier for the environment. */
        environment_id: string;
        /** @description The unique identifier for the statement. */
        statement_name: string;
      };
      cookie?: never;
    };
    requestBody?: {
      content: {
        "application/json-patch+json": components["schemas"]["PatchRequest"];
      };
    };
    responses: {
      /** @description Patched Statement. */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "application/json": components["schemas"]["sql.v1.Statement"] & {
            spec: Record<string, unknown>;
          };
        };
      };
      400: components["responses"]["BadRequestError"];
      401: components["responses"]["UnauthenticatedError"];
      403: components["responses"]["UnauthorizedError"];
      404: components["responses"]["NotFoundError"];
      409: components["responses"]["ConflictError"];
      422: components["responses"]["ValidationError"];
      429: components["responses"]["RateLimitError"];
      500: components["responses"]["DefaultSystemError"];
    };
  };
  getSqlv1StatementExceptions: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description The unique identifier for the organization. */
        organization_id: string;
        /** @description The unique identifier for the environment. */
        environment_id: string;
        /** @description The unique identifier for the statement. */
        statement_name: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description Statement Exceptions. */
      200: {
        headers: {
          /** @description The unique identifier for the API request. */
          "X-Request-Id"?: string;
          [name: string]: unknown;
        };
        content: {
          "application/json": components["schemas"]["sql.v1.StatementExceptionList"];
        };
      };
      400: components["responses"]["BadRequestError"];
      401: components["responses"]["UnauthenticatedError"];
      403: components["responses"]["UnauthorizedError"];
      404: components["responses"]["NotFoundError"];
      429: components["responses"]["RateLimitError"];
      500: components["responses"]["DefaultSystemError"];
    };
  };
  listNetworkingV1DnsForwarders: {
    parameters: {
      query: {
        /**
         * @description Filter the results by exact match for environment.
         * @example env-00000
         */
        environment: components["schemas"]["SearchFilter"];
        /** @description A pagination size for collection requests. */
        page_size?: number;
        /** @description An opaque pagination token for collection requests. */
        page_token?: string;
      };
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description DNS Forwarder. */
      200: {
        headers: {
          /** @description The unique identifier for the API request. */
          "X-Request-Id"?: string;
          /** @description The maximum number of requests you're permitted to make per time period. */
          "X-RateLimit-Limit"?: number;
          /** @description The number of requests remaining in the current rate limit window. */
          "X-RateLimit-Remaining"?: number;
          /** @description The relative time in seconds until the current rate-limit window resets.
           *
           *     **Important:** This differs from Github and Twitter's same-named header which uses UTC epoch seconds. We use relative time to avoid client/server time synchronization issues. */
          "X-RateLimit-Reset"?: number;
          [name: string]: unknown;
        };
        content: {
          "application/json": components["schemas"]["networking.v1.DnsForwarderList"] & {
            data?: {
              spec?: {
                /** @example {
                 *       "id": "env-00000",
                 *       "related": "https://api.confluent.cloud/v2/environments/env-00000",
                 *       "resource_name": "https://api.confluent.cloud/organization=9bb441c4-edef-46ac-8a41-c49e44a3fd9a/environment=env-00000"
                 *     } */
                environment?: unknown;
                /** @example {
                 *       "id": "gw-00000",
                 *       "related": "https://api.confluent.cloud/networking/v1/gateways/gw-00000",
                 *       "resource_name": "https://api.confluent.cloud/organization=9bb441c4-edef-46ac-8a41-c49e44a3fd9a/environment=env-abc123/gateway=gw-00000"
                 *     } */
                gateway?: unknown;
              };
            }[];
          };
        };
      };
      400: components["responses"]["BadRequestError"];
      401: components["responses"]["UnauthenticatedError"];
      403: components["responses"]["UnauthorizedError"];
      429: components["responses"]["RateLimitError"];
      500: components["responses"]["DefaultSystemError"];
    };
  };
  createNetworkingV1DnsForwarder: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody?: {
      content: {
        "application/json": components["schemas"]["networking.v1.DnsForwarder"] & {
          spec: Record<string, unknown>;
        } & {
          spec?: {
            /** @example {
             *       "id": "env-00000"
             *     } */
            environment?: unknown;
            /** @example {
             *       "id": "gw-00000"
             *     } */
            gateway?: unknown;
          };
        };
      };
    };
    responses: {
      /** @description A DNS Forwarder is being created. */
      202: {
        headers: {
          /** @description The unique identifier for the API request. */
          "X-Request-Id"?: string;
          /** @description The maximum number of requests you're permitted to make per time period. */
          "X-RateLimit-Limit"?: number;
          /** @description The number of requests remaining in the current rate limit window. */
          "X-RateLimit-Remaining"?: number;
          /** @description The relative time in seconds until the current rate-limit window resets.
           *
           *     **Important:** This differs from Github and Twitter's same-named header which uses UTC epoch seconds. We use relative time to avoid client/server time synchronization issues. */
          "X-RateLimit-Reset"?: number;
          /** @description DnsForwarder resource uri */
          Location?: string;
          [name: string]: unknown;
        };
        content: {
          "application/json": components["schemas"]["networking.v1.DnsForwarder"] & {
            spec: Record<string, unknown>;
          } & {
            spec?: {
              /** @example {
               *       "id": "env-00000",
               *       "related": "https://api.confluent.cloud/v2/environments/env-00000",
               *       "resource_name": "https://api.confluent.cloud/organization=9bb441c4-edef-46ac-8a41-c49e44a3fd9a/environment=env-00000"
               *     } */
              environment?: unknown;
              /** @example {
               *       "id": "gw-00000",
               *       "related": "https://api.confluent.cloud/networking/v1/gateways/gw-00000",
               *       "resource_name": "https://api.confluent.cloud/organization=9bb441c4-edef-46ac-8a41-c49e44a3fd9a/environment=env-abc123/gateway=gw-00000"
               *     } */
              gateway?: unknown;
            };
          };
        };
      };
      400: components["responses"]["BadRequestError"];
      401: components["responses"]["UnauthenticatedError"];
      403: components["responses"]["UnauthorizedError"];
      409: components["responses"]["ConflictError"];
      422: components["responses"]["ValidationError"];
      429: components["responses"]["RateLimitError"];
      500: components["responses"]["DefaultSystemError"];
    };
  };
  getNetworkingV1DnsForwarder: {
    parameters: {
      query: {
        /**
         * @description Scope the operation to the given environment.
         * @example env-00000
         */
        environment: components["schemas"]["SearchFilter"];
      };
      header?: never;
      path: {
        /** @description The unique identifier for the DNS forwarder. */
        id: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description DNS Forwarder. */
      200: {
        headers: {
          /** @description The unique identifier for the API request. */
          "X-Request-Id"?: string;
          /** @description The maximum number of requests you're permitted to make per time period. */
          "X-RateLimit-Limit"?: number;
          /** @description The number of requests remaining in the current rate limit window. */
          "X-RateLimit-Remaining"?: number;
          /** @description The relative time in seconds until the current rate-limit window resets.
           *
           *     **Important:** This differs from Github and Twitter's same-named header which uses UTC epoch seconds. We use relative time to avoid client/server time synchronization issues. */
          "X-RateLimit-Reset"?: number;
          [name: string]: unknown;
        };
        content: {
          "application/json": components["schemas"]["networking.v1.DnsForwarder"] & {
            spec: Record<string, unknown>;
          } & {
            spec?: {
              /** @example {
               *       "id": "env-00000",
               *       "related": "https://api.confluent.cloud/v2/environments/env-00000",
               *       "resource_name": "https://api.confluent.cloud/organization=9bb441c4-edef-46ac-8a41-c49e44a3fd9a/environment=env-00000"
               *     } */
              environment?: unknown;
              /** @example {
               *       "id": "gw-00000",
               *       "related": "https://api.confluent.cloud/networking/v1/gateways/gw-00000",
               *       "resource_name": "https://api.confluent.cloud/organization=9bb441c4-edef-46ac-8a41-c49e44a3fd9a/environment=env-abc123/gateway=gw-00000"
               *     } */
              gateway?: unknown;
            };
          };
        };
      };
      400: components["responses"]["BadRequestError"];
      401: components["responses"]["UnauthenticatedError"];
      403: components["responses"]["UnauthorizedError"];
      404: components["responses"]["NotFoundError"];
      429: components["responses"]["RateLimitError"];
      500: components["responses"]["DefaultSystemError"];
    };
  };
  deleteNetworkingV1DnsForwarder: {
    parameters: {
      query: {
        /**
         * @description Scope the operation to the given environment.
         * @example env-00000
         */
        environment: components["schemas"]["SearchFilter"];
      };
      header?: never;
      path: {
        /** @description The unique identifier for the DNS forwarder. */
        id: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description A DNS Forwarder is being deleted. */
      204: {
        headers: {
          /** @description The unique identifier for the API request. */
          "X-Request-Id"?: string;
          /** @description The maximum number of requests you're permitted to make per time period. */
          "X-RateLimit-Limit"?: number;
          /** @description The number of requests remaining in the current rate limit window. */
          "X-RateLimit-Remaining"?: number;
          /** @description The relative time in seconds until the current rate-limit window resets.
           *
           *     **Important:** This differs from Github and Twitter's same-named header which uses UTC epoch seconds. We use relative time to avoid client/server time synchronization issues. */
          "X-RateLimit-Reset"?: number;
          [name: string]: unknown;
        };
        content?: never;
      };
      400: components["responses"]["BadRequestError"];
      401: components["responses"]["UnauthenticatedError"];
      403: components["responses"]["UnauthorizedError"];
      404: components["responses"]["NotFoundError"];
      429: components["responses"]["RateLimitError"];
      500: components["responses"]["DefaultSystemError"];
    };
  };
  updateNetworkingV1DnsForwarder: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description The unique identifier for the DNS forwarder. */
        id: string;
      };
      cookie?: never;
    };
    requestBody?: {
      content: {
        "application/json": components["schemas"]["networking.v1.DnsForwarderUpdate"] & {
          spec: {
            /** @example {
             *       "id": "env-00000"
             *     } */
            environment: unknown;
          };
        };
      };
    };
    responses: {
      /** @description DNS Forwarder. */
      200: {
        headers: {
          /** @description The unique identifier for the API request. */
          "X-Request-Id"?: string;
          /** @description The maximum number of requests you're permitted to make per time period. */
          "X-RateLimit-Limit"?: number;
          /** @description The number of requests remaining in the current rate limit window. */
          "X-RateLimit-Remaining"?: number;
          /** @description The relative time in seconds until the current rate-limit window resets.
           *
           *     **Important:** This differs from Github and Twitter's same-named header which uses UTC epoch seconds. We use relative time to avoid client/server time synchronization issues. */
          "X-RateLimit-Reset"?: number;
          [name: string]: unknown;
        };
        content: {
          "application/json": components["schemas"]["networking.v1.DnsForwarder"] & {
            spec: Record<string, unknown>;
          } & {
            spec?: {
              /** @example {
               *       "id": "env-00000",
               *       "related": "https://api.confluent.cloud/v2/environments/env-00000",
               *       "resource_name": "https://api.confluent.cloud/organization=9bb441c4-edef-46ac-8a41-c49e44a3fd9a/environment=env-00000"
               *     } */
              environment?: unknown;
              /** @example {
               *       "id": "gw-00000",
               *       "related": "https://api.confluent.cloud/networking/v1/gateways/gw-00000",
               *       "resource_name": "https://api.confluent.cloud/organization=9bb441c4-edef-46ac-8a41-c49e44a3fd9a/environment=env-abc123/gateway=gw-00000"
               *     } */
              gateway?: unknown;
            };
          };
        };
      };
      400: components["responses"]["BadRequestError"];
      401: components["responses"]["UnauthenticatedError"];
      403: components["responses"]["UnauthorizedError"];
      404: components["responses"]["NotFoundError"];
      409: components["responses"]["ConflictError"];
      422: components["responses"]["ValidationError"];
      429: components["responses"]["RateLimitError"];
      500: components["responses"]["DefaultSystemError"];
    };
  };
  listNetworkingV1AccessPoints: {
    parameters: {
      query: {
        /**
         * @description Filter the results by exact match for spec.display_name. Pass multiple times to see results matching any of the values.
         * @example [
         *       "prod-ap-egress-use1",
         *       "prod-ap-egress-usw2"
         *     ]
         */
        "spec.display_name"?: components["schemas"]["MultipleSearchFilter"];
        /**
         * @description Filter the results by exact match for environment.
         * @example env-00000
         */
        environment: components["schemas"]["SearchFilter"];
        /**
         * @description Filter the results by exact match for spec.gateway. Pass multiple times to see results matching any of the values.
         * @example [
         *       "gw-00000",
         *       "gw-00001"
         *     ]
         */
        "spec.gateway"?: components["schemas"]["MultipleSearchFilter"];
        /**
         * @description Filter the results by exact match for id. Pass multiple times to see results matching any of the values.
         * @example [
         *       "ap-1",
         *       "ap-2"
         *     ]
         */
        id?: components["schemas"]["MultipleSearchFilter"];
        /** @description A pagination size for collection requests. */
        page_size?: number;
        /** @description An opaque pagination token for collection requests. */
        page_token?: string;
      };
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description Access Point. */
      200: {
        headers: {
          /** @description The unique identifier for the API request. */
          "X-Request-Id"?: string;
          /** @description The maximum number of requests you're permitted to make per time period. */
          "X-RateLimit-Limit"?: number;
          /** @description The number of requests remaining in the current rate limit window. */
          "X-RateLimit-Remaining"?: number;
          /** @description The relative time in seconds until the current rate-limit window resets.
           *
           *     **Important:** This differs from Github and Twitter's same-named header which uses UTC epoch seconds. We use relative time to avoid client/server time synchronization issues. */
          "X-RateLimit-Reset"?: number;
          [name: string]: unknown;
        };
        content: {
          "application/json": components["schemas"]["networking.v1.AccessPointList"] & {
            data?: {
              spec?: {
                /** @example {
                 *       "id": "env-00000",
                 *       "related": "https://api.confluent.cloud/v2/environments/env-00000",
                 *       "resource_name": "https://api.confluent.cloud/organization=9bb441c4-edef-46ac-8a41-c49e44a3fd9a/environment=env-00000"
                 *     } */
                environment?: unknown;
                /** @example {
                 *       "id": "gw-00000",
                 *       "related": "https://api.confluent.cloud/networking/v1/gateways/gw-00000",
                 *       "resource_name": "https://api.confluent.cloud/organization=9bb441c4-edef-46ac-8a41-c49e44a3fd9a/environment=env-abc123/gateway=gw-00000"
                 *     } */
                gateway?: unknown;
              };
            }[];
          };
        };
      };
      400: components["responses"]["BadRequestError"];
      401: components["responses"]["UnauthenticatedError"];
      403: components["responses"]["UnauthorizedError"];
      429: components["responses"]["RateLimitError"];
      500: components["responses"]["DefaultSystemError"];
    };
  };
  createNetworkingV1AccessPoint: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody?: {
      content: {
        "application/json": components["schemas"]["networking.v1.AccessPoint"] & {
          spec: Record<string, unknown>;
        } & {
          spec?: {
            /** @example {
             *       "id": "env-00000"
             *     } */
            environment?: unknown;
            /** @example {
             *       "id": "gw-00000"
             *     } */
            gateway?: unknown;
          };
        };
      };
    };
    responses: {
      /** @description An Access Point is being created. */
      202: {
        headers: {
          /** @description The unique identifier for the API request. */
          "X-Request-Id"?: string;
          /** @description The maximum number of requests you're permitted to make per time period. */
          "X-RateLimit-Limit"?: number;
          /** @description The number of requests remaining in the current rate limit window. */
          "X-RateLimit-Remaining"?: number;
          /** @description The relative time in seconds until the current rate-limit window resets.
           *
           *     **Important:** This differs from Github and Twitter's same-named header which uses UTC epoch seconds. We use relative time to avoid client/server time synchronization issues. */
          "X-RateLimit-Reset"?: number;
          /** @description AccessPoint resource uri */
          Location?: string;
          [name: string]: unknown;
        };
        content: {
          "application/json": components["schemas"]["networking.v1.AccessPoint"] & {
            spec: Record<string, unknown>;
          } & {
            spec?: {
              /** @example {
               *       "id": "env-00000",
               *       "related": "https://api.confluent.cloud/v2/environments/env-00000",
               *       "resource_name": "https://api.confluent.cloud/organization=9bb441c4-edef-46ac-8a41-c49e44a3fd9a/environment=env-00000"
               *     } */
              environment?: unknown;
              /** @example {
               *       "id": "gw-00000",
               *       "related": "https://api.confluent.cloud/networking/v1/gateways/gw-00000",
               *       "resource_name": "https://api.confluent.cloud/organization=9bb441c4-edef-46ac-8a41-c49e44a3fd9a/environment=env-abc123/gateway=gw-00000"
               *     } */
              gateway?: unknown;
            };
          };
        };
      };
      400: components["responses"]["BadRequestError"];
      401: components["responses"]["UnauthenticatedError"];
      403: components["responses"]["UnauthorizedError"];
      409: components["responses"]["ConflictError"];
      422: components["responses"]["ValidationError"];
      429: components["responses"]["RateLimitError"];
      500: components["responses"]["DefaultSystemError"];
    };
  };
  getNetworkingV1AccessPoint: {
    parameters: {
      query: {
        /**
         * @description Scope the operation to the given environment.
         * @example env-00000
         */
        environment: components["schemas"]["SearchFilter"];
      };
      header?: never;
      path: {
        /** @description The unique identifier for the access point. */
        id: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description Access Point. */
      200: {
        headers: {
          /** @description The unique identifier for the API request. */
          "X-Request-Id"?: string;
          /** @description The maximum number of requests you're permitted to make per time period. */
          "X-RateLimit-Limit"?: number;
          /** @description The number of requests remaining in the current rate limit window. */
          "X-RateLimit-Remaining"?: number;
          /** @description The relative time in seconds until the current rate-limit window resets.
           *
           *     **Important:** This differs from Github and Twitter's same-named header which uses UTC epoch seconds. We use relative time to avoid client/server time synchronization issues. */
          "X-RateLimit-Reset"?: number;
          [name: string]: unknown;
        };
        content: {
          "application/json": components["schemas"]["networking.v1.AccessPoint"] & {
            spec: Record<string, unknown>;
          } & {
            spec?: {
              /** @example {
               *       "id": "env-00000",
               *       "related": "https://api.confluent.cloud/v2/environments/env-00000",
               *       "resource_name": "https://api.confluent.cloud/organization=9bb441c4-edef-46ac-8a41-c49e44a3fd9a/environment=env-00000"
               *     } */
              environment?: unknown;
              /** @example {
               *       "id": "gw-00000",
               *       "related": "https://api.confluent.cloud/networking/v1/gateways/gw-00000",
               *       "resource_name": "https://api.confluent.cloud/organization=9bb441c4-edef-46ac-8a41-c49e44a3fd9a/environment=env-abc123/gateway=gw-00000"
               *     } */
              gateway?: unknown;
            };
          };
        };
      };
      400: components["responses"]["BadRequestError"];
      401: components["responses"]["UnauthenticatedError"];
      403: components["responses"]["UnauthorizedError"];
      404: components["responses"]["NotFoundError"];
      429: components["responses"]["RateLimitError"];
      500: components["responses"]["DefaultSystemError"];
    };
  };
  deleteNetworkingV1AccessPoint: {
    parameters: {
      query: {
        /**
         * @description Scope the operation to the given environment.
         * @example env-00000
         */
        environment: components["schemas"]["SearchFilter"];
      };
      header?: never;
      path: {
        /** @description The unique identifier for the access point. */
        id: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description An Access Point is being deleted. */
      204: {
        headers: {
          /** @description The unique identifier for the API request. */
          "X-Request-Id"?: string;
          /** @description The maximum number of requests you're permitted to make per time period. */
          "X-RateLimit-Limit"?: number;
          /** @description The number of requests remaining in the current rate limit window. */
          "X-RateLimit-Remaining"?: number;
          /** @description The relative time in seconds until the current rate-limit window resets.
           *
           *     **Important:** This differs from Github and Twitter's same-named header which uses UTC epoch seconds. We use relative time to avoid client/server time synchronization issues. */
          "X-RateLimit-Reset"?: number;
          [name: string]: unknown;
        };
        content?: never;
      };
      400: components["responses"]["BadRequestError"];
      401: components["responses"]["UnauthenticatedError"];
      403: components["responses"]["UnauthorizedError"];
      404: components["responses"]["NotFoundError"];
      429: components["responses"]["RateLimitError"];
      500: components["responses"]["DefaultSystemError"];
    };
  };
  updateNetworkingV1AccessPoint: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description The unique identifier for the access point. */
        id: string;
      };
      cookie?: never;
    };
    requestBody?: {
      content: {
        "application/json": components["schemas"]["networking.v1.AccessPointUpdate"] & {
          spec: {
            /** @example {
             *       "id": "env-00000"
             *     } */
            environment: unknown;
          };
        };
      };
    };
    responses: {
      /** @description Access Point. */
      200: {
        headers: {
          /** @description The unique identifier for the API request. */
          "X-Request-Id"?: string;
          /** @description The maximum number of requests you're permitted to make per time period. */
          "X-RateLimit-Limit"?: number;
          /** @description The number of requests remaining in the current rate limit window. */
          "X-RateLimit-Remaining"?: number;
          /** @description The relative time in seconds until the current rate-limit window resets.
           *
           *     **Important:** This differs from Github and Twitter's same-named header which uses UTC epoch seconds. We use relative time to avoid client/server time synchronization issues. */
          "X-RateLimit-Reset"?: number;
          [name: string]: unknown;
        };
        content: {
          "application/json": components["schemas"]["networking.v1.AccessPoint"] & {
            spec: Record<string, unknown>;
          } & {
            spec?: {
              /** @example {
               *       "id": "env-00000",
               *       "related": "https://api.confluent.cloud/v2/environments/env-00000",
               *       "resource_name": "https://api.confluent.cloud/organization=9bb441c4-edef-46ac-8a41-c49e44a3fd9a/environment=env-00000"
               *     } */
              environment?: unknown;
              /** @example {
               *       "id": "gw-00000",
               *       "related": "https://api.confluent.cloud/networking/v1/gateways/gw-00000",
               *       "resource_name": "https://api.confluent.cloud/organization=9bb441c4-edef-46ac-8a41-c49e44a3fd9a/environment=env-abc123/gateway=gw-00000"
               *     } */
              gateway?: unknown;
            };
          };
        };
      };
      400: components["responses"]["BadRequestError"];
      401: components["responses"]["UnauthenticatedError"];
      403: components["responses"]["UnauthorizedError"];
      404: components["responses"]["NotFoundError"];
      409: components["responses"]["ConflictError"];
      422: components["responses"]["ValidationError"];
      429: components["responses"]["RateLimitError"];
      500: components["responses"]["DefaultSystemError"];
    };
  };
  listNetworkingV1DnsRecords: {
    parameters: {
      query: {
        /**
         * @description Filter the results by exact match for spec.display_name. Pass multiple times to see results matching any of the values.
         * @example [
         *       "prod-dnsrec-1",
         *       "prod-dnsrec-2"
         *     ]
         */
        "spec.display_name"?: components["schemas"]["MultipleSearchFilter"];
        /**
         * @description Filter the results by exact match for spec.domain. Pass multiple times to see results matching any of the values.
         * @example [
         *       "example.com",
         *       "example2.com"
         *     ]
         */
        "spec.domain"?: components["schemas"]["MultipleSearchFilter"];
        /**
         * @description Filter the results by exact match for environment.
         * @example env-00000
         */
        environment: components["schemas"]["SearchFilter"];
        /**
         * @description Filter the results by exact match for spec.gateway. Pass multiple times to see results matching any of the values.
         * @example [
         *       "gw-00000",
         *       "gw-00001"
         *     ]
         */
        "spec.gateway"?: components["schemas"]["MultipleSearchFilter"];
        /**
         * @description Filter the results by exact match for resource. Pass multiple times to see results matching any of the values.
         * @example [
         *       "ap-11111",
         *       "ap-22222"
         *     ]
         */
        resource?: components["schemas"]["MultipleSearchFilter"];
        /** @description A pagination size for collection requests. */
        page_size?: number;
        /** @description An opaque pagination token for collection requests. */
        page_token?: string;
      };
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description DNS Record. */
      200: {
        headers: {
          /** @description The unique identifier for the API request. */
          "X-Request-Id"?: string;
          /** @description The maximum number of requests you're permitted to make per time period. */
          "X-RateLimit-Limit"?: number;
          /** @description The number of requests remaining in the current rate limit window. */
          "X-RateLimit-Remaining"?: number;
          /** @description The relative time in seconds until the current rate-limit window resets.
           *
           *     **Important:** This differs from Github and Twitter's same-named header which uses UTC epoch seconds. We use relative time to avoid client/server time synchronization issues. */
          "X-RateLimit-Reset"?: number;
          [name: string]: unknown;
        };
        content: {
          "application/json": components["schemas"]["networking.v1.DnsRecordList"] & {
            data?: {
              spec?: {
                /** @example {
                 *       "id": "env-00000",
                 *       "related": "https://api.confluent.cloud/v2/environments/env-00000",
                 *       "resource_name": "https://api.confluent.cloud/organization=9bb441c4-edef-46ac-8a41-c49e44a3fd9a/environment=env-00000"
                 *     } */
                environment?: unknown;
                /** @example {
                 *       "id": "gw-00000",
                 *       "related": "https://api.confluent.cloud/networking/v1/gateways/gw-00000",
                 *       "resource_name": "https://api.confluent.cloud/organization=9bb441c4-edef-46ac-8a41-c49e44a3fd9a/environment=env-abc123/gateway=gw-00000"
                 *     } */
                gateway?: unknown;
              };
            }[];
          };
        };
      };
      400: components["responses"]["BadRequestError"];
      401: components["responses"]["UnauthenticatedError"];
      403: components["responses"]["UnauthorizedError"];
      429: components["responses"]["RateLimitError"];
      500: components["responses"]["DefaultSystemError"];
    };
  };
  createNetworkingV1DnsRecord: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody?: {
      content: {
        "application/json": components["schemas"]["networking.v1.DnsRecord"] & {
          spec: Record<string, unknown>;
        } & {
          spec?: {
            /** @example {
             *       "id": "env-00000"
             *     } */
            environment?: unknown;
            /** @example {
             *       "id": "gw-00000"
             *     } */
            gateway?: unknown;
          };
        };
      };
    };
    responses: {
      /** @description A DNS Record is being created. */
      202: {
        headers: {
          /** @description The unique identifier for the API request. */
          "X-Request-Id"?: string;
          /** @description The maximum number of requests you're permitted to make per time period. */
          "X-RateLimit-Limit"?: number;
          /** @description The number of requests remaining in the current rate limit window. */
          "X-RateLimit-Remaining"?: number;
          /** @description The relative time in seconds until the current rate-limit window resets.
           *
           *     **Important:** This differs from Github and Twitter's same-named header which uses UTC epoch seconds. We use relative time to avoid client/server time synchronization issues. */
          "X-RateLimit-Reset"?: number;
          /** @description DnsRecord resource uri */
          Location?: string;
          [name: string]: unknown;
        };
        content: {
          "application/json": components["schemas"]["networking.v1.DnsRecord"] & {
            spec: Record<string, unknown>;
          } & {
            spec?: {
              /** @example {
               *       "id": "env-00000",
               *       "related": "https://api.confluent.cloud/v2/environments/env-00000",
               *       "resource_name": "https://api.confluent.cloud/organization=9bb441c4-edef-46ac-8a41-c49e44a3fd9a/environment=env-00000"
               *     } */
              environment?: unknown;
              /** @example {
               *       "id": "gw-00000",
               *       "related": "https://api.confluent.cloud/networking/v1/gateways/gw-00000",
               *       "resource_name": "https://api.confluent.cloud/organization=9bb441c4-edef-46ac-8a41-c49e44a3fd9a/environment=env-abc123/gateway=gw-00000"
               *     } */
              gateway?: unknown;
            };
          };
        };
      };
      400: components["responses"]["BadRequestError"];
      401: components["responses"]["UnauthenticatedError"];
      403: components["responses"]["UnauthorizedError"];
      409: components["responses"]["ConflictError"];
      422: components["responses"]["ValidationError"];
      429: components["responses"]["RateLimitError"];
      500: components["responses"]["DefaultSystemError"];
    };
  };
  getNetworkingV1DnsRecord: {
    parameters: {
      query: {
        /**
         * @description Scope the operation to the given environment.
         * @example env-00000
         */
        environment: components["schemas"]["SearchFilter"];
      };
      header?: never;
      path: {
        /** @description The unique identifier for the DNS record. */
        id: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description DNS Record. */
      200: {
        headers: {
          /** @description The unique identifier for the API request. */
          "X-Request-Id"?: string;
          /** @description The maximum number of requests you're permitted to make per time period. */
          "X-RateLimit-Limit"?: number;
          /** @description The number of requests remaining in the current rate limit window. */
          "X-RateLimit-Remaining"?: number;
          /** @description The relative time in seconds until the current rate-limit window resets.
           *
           *     **Important:** This differs from Github and Twitter's same-named header which uses UTC epoch seconds. We use relative time to avoid client/server time synchronization issues. */
          "X-RateLimit-Reset"?: number;
          [name: string]: unknown;
        };
        content: {
          "application/json": components["schemas"]["networking.v1.DnsRecord"] & {
            spec: Record<string, unknown>;
          } & {
            spec?: {
              /** @example {
               *       "id": "env-00000",
               *       "related": "https://api.confluent.cloud/v2/environments/env-00000",
               *       "resource_name": "https://api.confluent.cloud/organization=9bb441c4-edef-46ac-8a41-c49e44a3fd9a/environment=env-00000"
               *     } */
              environment?: unknown;
              /** @example {
               *       "id": "gw-00000",
               *       "related": "https://api.confluent.cloud/networking/v1/gateways/gw-00000",
               *       "resource_name": "https://api.confluent.cloud/organization=9bb441c4-edef-46ac-8a41-c49e44a3fd9a/environment=env-abc123/gateway=gw-00000"
               *     } */
              gateway?: unknown;
            };
          };
        };
      };
      400: components["responses"]["BadRequestError"];
      401: components["responses"]["UnauthenticatedError"];
      403: components["responses"]["UnauthorizedError"];
      404: components["responses"]["NotFoundError"];
      429: components["responses"]["RateLimitError"];
      500: components["responses"]["DefaultSystemError"];
    };
  };
  deleteNetworkingV1DnsRecord: {
    parameters: {
      query: {
        /**
         * @description Scope the operation to the given environment.
         * @example env-00000
         */
        environment: components["schemas"]["SearchFilter"];
      };
      header?: never;
      path: {
        /** @description The unique identifier for the DNS record. */
        id: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description A DNS Record is being deleted. */
      204: {
        headers: {
          /** @description The unique identifier for the API request. */
          "X-Request-Id"?: string;
          /** @description The maximum number of requests you're permitted to make per time period. */
          "X-RateLimit-Limit"?: number;
          /** @description The number of requests remaining in the current rate limit window. */
          "X-RateLimit-Remaining"?: number;
          /** @description The relative time in seconds until the current rate-limit window resets.
           *
           *     **Important:** This differs from Github and Twitter's same-named header which uses UTC epoch seconds. We use relative time to avoid client/server time synchronization issues. */
          "X-RateLimit-Reset"?: number;
          [name: string]: unknown;
        };
        content?: never;
      };
      400: components["responses"]["BadRequestError"];
      401: components["responses"]["UnauthenticatedError"];
      403: components["responses"]["UnauthorizedError"];
      404: components["responses"]["NotFoundError"];
      429: components["responses"]["RateLimitError"];
      500: components["responses"]["DefaultSystemError"];
    };
  };
  updateNetworkingV1DnsRecord: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description The unique identifier for the DNS record. */
        id: string;
      };
      cookie?: never;
    };
    requestBody?: {
      content: {
        "application/json": components["schemas"]["networking.v1.DnsRecordUpdate"] & {
          spec: {
            /** @example {
             *       "id": "env-00000"
             *     } */
            environment: unknown;
          };
        };
      };
    };
    responses: {
      /** @description DNS Record. */
      200: {
        headers: {
          /** @description The unique identifier for the API request. */
          "X-Request-Id"?: string;
          /** @description The maximum number of requests you're permitted to make per time period. */
          "X-RateLimit-Limit"?: number;
          /** @description The number of requests remaining in the current rate limit window. */
          "X-RateLimit-Remaining"?: number;
          /** @description The relative time in seconds until the current rate-limit window resets.
           *
           *     **Important:** This differs from Github and Twitter's same-named header which uses UTC epoch seconds. We use relative time to avoid client/server time synchronization issues. */
          "X-RateLimit-Reset"?: number;
          [name: string]: unknown;
        };
        content: {
          "application/json": components["schemas"]["networking.v1.DnsRecord"] & {
            spec: Record<string, unknown>;
          } & {
            spec?: {
              /** @example {
               *       "id": "env-00000",
               *       "related": "https://api.confluent.cloud/v2/environments/env-00000",
               *       "resource_name": "https://api.confluent.cloud/organization=9bb441c4-edef-46ac-8a41-c49e44a3fd9a/environment=env-00000"
               *     } */
              environment?: unknown;
              /** @example {
               *       "id": "gw-00000",
               *       "related": "https://api.confluent.cloud/networking/v1/gateways/gw-00000",
               *       "resource_name": "https://api.confluent.cloud/organization=9bb441c4-edef-46ac-8a41-c49e44a3fd9a/environment=env-abc123/gateway=gw-00000"
               *     } */
              gateway?: unknown;
            };
          };
        };
      };
      400: components["responses"]["BadRequestError"];
      401: components["responses"]["UnauthenticatedError"];
      403: components["responses"]["UnauthorizedError"];
      404: components["responses"]["NotFoundError"];
      409: components["responses"]["ConflictError"];
      422: components["responses"]["ValidationError"];
      429: components["responses"]["RateLimitError"];
      500: components["responses"]["DefaultSystemError"];
    };
  };
  listIamV2CertificateAuthorities: {
    parameters: {
      query?: {
        /** @description A pagination size for collection requests. */
        page_size?: number;
        /** @description An opaque pagination token for collection requests. */
        page_token?: string;
      };
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description Certificate Authority. */
      200: {
        headers: {
          /** @description The unique identifier for the API request. */
          "X-Request-Id"?: string;
          /** @description The maximum number of requests you're permitted to make per time period. */
          "X-RateLimit-Limit"?: number;
          /** @description The number of requests remaining in the current rate limit window. */
          "X-RateLimit-Remaining"?: number;
          /** @description The relative time in seconds until the current rate-limit window resets.
           *
           *     **Important:** This differs from Github and Twitter's same-named header which uses UTC epoch seconds. We use relative time to avoid client/server time synchronization issues. */
          "X-RateLimit-Reset"?: number;
          [name: string]: unknown;
        };
        content: {
          "application/json": components["schemas"]["iam.v2.CertificateAuthorityList"];
        };
      };
      400: components["responses"]["BadRequestError"];
      401: components["responses"]["UnauthenticatedError"];
      403: components["responses"]["UnauthorizedError"];
      429: components["responses"]["RateLimitError"];
      500: components["responses"]["DefaultSystemError"];
    };
  };
  createIamV2CertificateAuthority: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody?: {
      content: {
        "application/json": components["schemas"]["iam.v2.CreateCertRequest"];
      };
    };
    responses: {
      /** @description A Certificate Authority was created. */
      201: {
        headers: {
          /** @description The unique identifier for the API request. */
          "X-Request-Id"?: string;
          /** @description The maximum number of requests you're permitted to make per time period. */
          "X-RateLimit-Limit"?: number;
          /** @description The number of requests remaining in the current rate limit window. */
          "X-RateLimit-Remaining"?: number;
          /** @description The relative time in seconds until the current rate-limit window resets.
           *
           *     **Important:** This differs from Github and Twitter's same-named header which uses UTC epoch seconds. We use relative time to avoid client/server time synchronization issues. */
          "X-RateLimit-Reset"?: number;
          /** @description CertificateAuthority resource uri */
          Location?: string;
          [name: string]: unknown;
        };
        content: {
          "application/json": components["schemas"]["iam.v2.CertificateAuthority"] &
            Record<string, unknown>;
        };
      };
      400: components["responses"]["BadRequestError"];
      401: components["responses"]["UnauthenticatedError"];
      402: components["responses"]["OverQuotaError"];
      403: components["responses"]["UnauthorizedError"];
      409: components["responses"]["ConflictError"];
      422: components["responses"]["ValidationError"];
      429: components["responses"]["RateLimitError"];
      500: components["responses"]["DefaultSystemError"];
    };
  };
  getIamV2CertificateAuthority: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description The unique identifier for the certificate authority. */
        id: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description Certificate Authority. */
      200: {
        headers: {
          /** @description The unique identifier for the API request. */
          "X-Request-Id"?: string;
          /** @description The maximum number of requests you're permitted to make per time period. */
          "X-RateLimit-Limit"?: number;
          /** @description The number of requests remaining in the current rate limit window. */
          "X-RateLimit-Remaining"?: number;
          /** @description The relative time in seconds until the current rate-limit window resets.
           *
           *     **Important:** This differs from Github and Twitter's same-named header which uses UTC epoch seconds. We use relative time to avoid client/server time synchronization issues. */
          "X-RateLimit-Reset"?: number;
          [name: string]: unknown;
        };
        content: {
          "application/json": components["schemas"]["iam.v2.CertificateAuthority"] &
            Record<string, unknown>;
        };
      };
      400: components["responses"]["BadRequestError"];
      401: components["responses"]["UnauthenticatedError"];
      403: components["responses"]["UnauthorizedError"];
      404: components["responses"]["NotFoundError"];
      429: components["responses"]["RateLimitError"];
      500: components["responses"]["DefaultSystemError"];
    };
  };
  updateIamV2CertificateAuthority: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description The unique identifier for the certificate authority. */
        id: string;
      };
      cookie?: never;
    };
    requestBody?: {
      content: {
        "application/json": components["schemas"]["iam.v2.UpdateCertRequest"];
      };
    };
    responses: {
      /** @description Certificate Authority. */
      200: {
        headers: {
          /** @description The unique identifier for the API request. */
          "X-Request-Id"?: string;
          /** @description The maximum number of requests you're permitted to make per time period. */
          "X-RateLimit-Limit"?: number;
          /** @description The number of requests remaining in the current rate limit window. */
          "X-RateLimit-Remaining"?: number;
          /** @description The relative time in seconds until the current rate-limit window resets.
           *
           *     **Important:** This differs from Github and Twitter's same-named header which uses UTC epoch seconds. We use relative time to avoid client/server time synchronization issues. */
          "X-RateLimit-Reset"?: number;
          [name: string]: unknown;
        };
        content: {
          "application/json": components["schemas"]["iam.v2.CertificateAuthority"] &
            Record<string, unknown>;
        };
      };
      400: components["responses"]["BadRequestError"];
      401: components["responses"]["UnauthenticatedError"];
      402: components["responses"]["OverQuotaError"];
      403: components["responses"]["UnauthorizedError"];
      404: components["responses"]["NotFoundError"];
      409: components["responses"]["ConflictError"];
      422: components["responses"]["ValidationError"];
      429: components["responses"]["RateLimitError"];
      500: components["responses"]["DefaultSystemError"];
    };
  };
  deleteIamV2CertificateAuthority: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description The unique identifier for the certificate authority. */
        id: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description A Certificate Authority is being deleted. */
      200: {
        headers: {
          /** @description The unique identifier for the API request. */
          "X-Request-Id"?: string;
          /** @description The maximum number of requests you're permitted to make per time period. */
          "X-RateLimit-Limit"?: number;
          /** @description The number of requests remaining in the current rate limit window. */
          "X-RateLimit-Remaining"?: number;
          /** @description The relative time in seconds until the current rate-limit window resets.
           *
           *     **Important:** This differs from Github and Twitter's same-named header which uses UTC epoch seconds. We use relative time to avoid client/server time synchronization issues. */
          "X-RateLimit-Reset"?: number;
          [name: string]: unknown;
        };
        content: {
          "application/json": components["schemas"]["iam.v2.CertificateAuthority"] &
            Record<string, unknown>;
        };
      };
      400: components["responses"]["BadRequestError"];
      401: components["responses"]["UnauthenticatedError"];
      403: components["responses"]["UnauthorizedError"];
      404: components["responses"]["NotFoundError"];
      429: components["responses"]["RateLimitError"];
      500: components["responses"]["DefaultSystemError"];
    };
  };
  listIamV2CertificateIdentityPools: {
    parameters: {
      query?: {
        /** @description A pagination size for collection requests. */
        page_size?: number;
        /** @description An opaque pagination token for collection requests. */
        page_token?: string;
      };
      header?: never;
      path: {
        /** @description The Certificate Authority */
        certificate_authority_id: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description Certificate Identity Pool. */
      200: {
        headers: {
          /** @description The unique identifier for the API request. */
          "X-Request-Id"?: string;
          /** @description The maximum number of requests you're permitted to make per time period. */
          "X-RateLimit-Limit"?: number;
          /** @description The number of requests remaining in the current rate limit window. */
          "X-RateLimit-Remaining"?: number;
          /** @description The relative time in seconds until the current rate-limit window resets.
           *
           *     **Important:** This differs from Github and Twitter's same-named header which uses UTC epoch seconds. We use relative time to avoid client/server time synchronization issues. */
          "X-RateLimit-Reset"?: number;
          [name: string]: unknown;
        };
        content: {
          "application/json": components["schemas"]["iam.v2.CertificateIdentityPoolList"];
        };
      };
      400: components["responses"]["BadRequestError"];
      401: components["responses"]["UnauthenticatedError"];
      403: components["responses"]["UnauthorizedError"];
      429: components["responses"]["RateLimitError"];
      500: components["responses"]["DefaultSystemError"];
    };
  };
  createIamV2CertificateIdentityPool: {
    parameters: {
      query?: {
        /**
         * @description The resource_id of the principal who will be assigned resource owner on the created certificate identity pool. Principal can be group-mapping (group-xxx), user (u-xxx), service-account (sa-xxx) or identity-pool (pool-xxx).
         * @example u-a83k9b
         */
        assigned_resource_owner?: components["schemas"]["SearchFilter"];
      };
      header?: never;
      path: {
        /** @description The Certificate Authority */
        certificate_authority_id: string;
      };
      cookie?: never;
    };
    requestBody?: {
      content: {
        "application/json": components["schemas"]["iam.v2.CertificateIdentityPool"] &
          Record<string, unknown>;
      };
    };
    responses: {
      /** @description A Certificate Identity Pool was created. */
      201: {
        headers: {
          /** @description The unique identifier for the API request. */
          "X-Request-Id"?: string;
          /** @description The maximum number of requests you're permitted to make per time period. */
          "X-RateLimit-Limit"?: number;
          /** @description The number of requests remaining in the current rate limit window. */
          "X-RateLimit-Remaining"?: number;
          /** @description The relative time in seconds until the current rate-limit window resets.
           *
           *     **Important:** This differs from Github and Twitter's same-named header which uses UTC epoch seconds. We use relative time to avoid client/server time synchronization issues. */
          "X-RateLimit-Reset"?: number;
          /** @description CertificateIdentityPool resource uri */
          Location?: string;
          [name: string]: unknown;
        };
        content: {
          "application/json": components["schemas"]["iam.v2.CertificateIdentityPool"] &
            Record<string, unknown>;
        };
      };
      400: components["responses"]["BadRequestError"];
      401: components["responses"]["UnauthenticatedError"];
      402: components["responses"]["OverQuotaError"];
      403: components["responses"]["UnauthorizedError"];
      409: components["responses"]["ConflictError"];
      422: components["responses"]["ValidationError"];
      429: components["responses"]["RateLimitError"];
      500: components["responses"]["DefaultSystemError"];
    };
  };
  getIamV2CertificateIdentityPool: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description The Certificate Authority */
        certificate_authority_id: string;
        /** @description The unique identifier for the certificate identity pool. */
        id: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description Certificate Identity Pool. */
      200: {
        headers: {
          /** @description The unique identifier for the API request. */
          "X-Request-Id"?: string;
          /** @description The maximum number of requests you're permitted to make per time period. */
          "X-RateLimit-Limit"?: number;
          /** @description The number of requests remaining in the current rate limit window. */
          "X-RateLimit-Remaining"?: number;
          /** @description The relative time in seconds until the current rate-limit window resets.
           *
           *     **Important:** This differs from Github and Twitter's same-named header which uses UTC epoch seconds. We use relative time to avoid client/server time synchronization issues. */
          "X-RateLimit-Reset"?: number;
          [name: string]: unknown;
        };
        content: {
          "application/json": components["schemas"]["iam.v2.CertificateIdentityPool"] &
            Record<string, unknown>;
        };
      };
      400: components["responses"]["BadRequestError"];
      401: components["responses"]["UnauthenticatedError"];
      403: components["responses"]["UnauthorizedError"];
      404: components["responses"]["NotFoundError"];
      429: components["responses"]["RateLimitError"];
      500: components["responses"]["DefaultSystemError"];
    };
  };
  updateIamV2CertificateIdentityPool: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description The Certificate Authority */
        certificate_authority_id: string;
        /** @description The unique identifier for the certificate identity pool. */
        id: string;
      };
      cookie?: never;
    };
    requestBody?: {
      content: {
        "application/json": components["schemas"]["iam.v2.CertificateIdentityPool"];
      };
    };
    responses: {
      /** @description Certificate Identity Pool. */
      200: {
        headers: {
          /** @description The unique identifier for the API request. */
          "X-Request-Id"?: string;
          /** @description The maximum number of requests you're permitted to make per time period. */
          "X-RateLimit-Limit"?: number;
          /** @description The number of requests remaining in the current rate limit window. */
          "X-RateLimit-Remaining"?: number;
          /** @description The relative time in seconds until the current rate-limit window resets.
           *
           *     **Important:** This differs from Github and Twitter's same-named header which uses UTC epoch seconds. We use relative time to avoid client/server time synchronization issues. */
          "X-RateLimit-Reset"?: number;
          [name: string]: unknown;
        };
        content: {
          "application/json": components["schemas"]["iam.v2.CertificateIdentityPool"] &
            Record<string, unknown>;
        };
      };
      400: components["responses"]["BadRequestError"];
      401: components["responses"]["UnauthenticatedError"];
      402: components["responses"]["OverQuotaError"];
      403: components["responses"]["UnauthorizedError"];
      404: components["responses"]["NotFoundError"];
      409: components["responses"]["ConflictError"];
      422: components["responses"]["ValidationError"];
      429: components["responses"]["RateLimitError"];
      500: components["responses"]["DefaultSystemError"];
    };
  };
  deleteIamV2CertificateIdentityPool: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description The Certificate Authority */
        certificate_authority_id: string;
        /** @description The unique identifier for the certificate identity pool. */
        id: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description A Certificate Identity Pool is being deleted. */
      200: {
        headers: {
          /** @description The unique identifier for the API request. */
          "X-Request-Id"?: string;
          /** @description The maximum number of requests you're permitted to make per time period. */
          "X-RateLimit-Limit"?: number;
          /** @description The number of requests remaining in the current rate limit window. */
          "X-RateLimit-Remaining"?: number;
          /** @description The relative time in seconds until the current rate-limit window resets.
           *
           *     **Important:** This differs from Github and Twitter's same-named header which uses UTC epoch seconds. We use relative time to avoid client/server time synchronization issues. */
          "X-RateLimit-Reset"?: number;
          [name: string]: unknown;
        };
        content: {
          "application/json": components["schemas"]["iam.v2.CertificateIdentityPool"] &
            Record<string, unknown>;
        };
      };
      400: components["responses"]["BadRequestError"];
      401: components["responses"]["UnauthenticatedError"];
      403: components["responses"]["UnauthorizedError"];
      404: components["responses"]["NotFoundError"];
      429: components["responses"]["RateLimitError"];
      500: components["responses"]["DefaultSystemError"];
    };
  };
  listPimV1Integrations: {
    parameters: {
      query: {
        /**
         * @description Filter the results by exact match for provider.
         * @example AWS
         */
        provider?: components["schemas"]["SearchFilter"];
        /**
         * @description Filter the results by exact match for environment.
         * @example env-00000
         */
        environment: components["schemas"]["SearchFilter"];
        /** @description A pagination size for collection requests. */
        page_size?: number;
        /** @description An opaque pagination token for collection requests. */
        page_token?: string;
      };
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description Integration. */
      200: {
        headers: {
          /** @description The unique identifier for the API request. */
          "X-Request-Id"?: string;
          /** @description The maximum number of requests you're permitted to make per time period. */
          "X-RateLimit-Limit"?: number;
          /** @description The number of requests remaining in the current rate limit window. */
          "X-RateLimit-Remaining"?: number;
          /** @description The relative time in seconds until the current rate-limit window resets.
           *
           *     **Important:** This differs from Github and Twitter's same-named header which uses UTC epoch seconds. We use relative time to avoid client/server time synchronization issues. */
          "X-RateLimit-Reset"?: number;
          [name: string]: unknown;
        };
        content: {
          "application/json": components["schemas"]["pim.v1.IntegrationList"] & {
            data?: {
              /** @example {
               *       "id": "env-00000",
               *       "related": "https://api.confluent.cloud/v2/environments/env-00000",
               *       "resource_name": "https://api.confluent.cloud/organization=9bb441c4-edef-46ac-8a41-c49e44a3fd9a/environment=env-00000"
               *     } */
              environment?: unknown;
            }[];
          };
        };
      };
      400: components["responses"]["BadRequestError"];
      401: components["responses"]["UnauthenticatedError"];
      403: components["responses"]["UnauthorizedError"];
      429: components["responses"]["RateLimitError"];
      500: components["responses"]["DefaultSystemError"];
    };
  };
  createPimV1Integration: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody?: {
      content: {
        "application/json": components["schemas"]["pim.v1.Integration"] &
          Record<string, unknown> & {
            /** @example {
             *       "id": "env-00000"
             *     } */
            environment?: unknown;
          };
      };
    };
    responses: {
      /** @description An Integration was created. */
      201: {
        headers: {
          /** @description The unique identifier for the API request. */
          "X-Request-Id"?: string;
          /** @description The maximum number of requests you're permitted to make per time period. */
          "X-RateLimit-Limit"?: number;
          /** @description The number of requests remaining in the current rate limit window. */
          "X-RateLimit-Remaining"?: number;
          /** @description The relative time in seconds until the current rate-limit window resets.
           *
           *     **Important:** This differs from Github and Twitter's same-named header which uses UTC epoch seconds. We use relative time to avoid client/server time synchronization issues. */
          "X-RateLimit-Reset"?: number;
          /** @description Integration resource uri */
          Location?: string;
          [name: string]: unknown;
        };
        content: {
          "application/json": components["schemas"]["pim.v1.Integration"] &
            Record<string, unknown> & {
              /** @example {
               *       "id": "env-00000",
               *       "related": "https://api.confluent.cloud/v2/environments/env-00000",
               *       "resource_name": "https://api.confluent.cloud/organization=9bb441c4-edef-46ac-8a41-c49e44a3fd9a/environment=env-00000"
               *     } */
              environment?: unknown;
            };
        };
      };
      400: components["responses"]["BadRequestError"];
      401: components["responses"]["UnauthenticatedError"];
      403: components["responses"]["UnauthorizedError"];
      409: components["responses"]["ConflictError"];
      422: components["responses"]["ValidationError"];
      429: components["responses"]["RateLimitError"];
      500: components["responses"]["DefaultSystemError"];
    };
  };
  getPimV1Integration: {
    parameters: {
      query: {
        /**
         * @description Scope the operation to the given environment.
         * @example env-00000
         */
        environment: components["schemas"]["SearchFilter"];
      };
      header?: never;
      path: {
        /** @description The unique identifier for the integration. */
        id: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description Integration. */
      200: {
        headers: {
          /** @description The unique identifier for the API request. */
          "X-Request-Id"?: string;
          /** @description The maximum number of requests you're permitted to make per time period. */
          "X-RateLimit-Limit"?: number;
          /** @description The number of requests remaining in the current rate limit window. */
          "X-RateLimit-Remaining"?: number;
          /** @description The relative time in seconds until the current rate-limit window resets.
           *
           *     **Important:** This differs from Github and Twitter's same-named header which uses UTC epoch seconds. We use relative time to avoid client/server time synchronization issues. */
          "X-RateLimit-Reset"?: number;
          [name: string]: unknown;
        };
        content: {
          "application/json": components["schemas"]["pim.v1.Integration"] &
            Record<string, unknown> & {
              /** @example {
               *       "id": "env-00000",
               *       "related": "https://api.confluent.cloud/v2/environments/env-00000",
               *       "resource_name": "https://api.confluent.cloud/organization=9bb441c4-edef-46ac-8a41-c49e44a3fd9a/environment=env-00000"
               *     } */
              environment?: unknown;
            };
        };
      };
      400: components["responses"]["BadRequestError"];
      401: components["responses"]["UnauthenticatedError"];
      403: components["responses"]["UnauthorizedError"];
      404: components["responses"]["NotFoundError"];
      429: components["responses"]["RateLimitError"];
      500: components["responses"]["DefaultSystemError"];
    };
  };
  deletePimV1Integration: {
    parameters: {
      query: {
        /**
         * @description Scope the operation to the given environment.
         * @example env-00000
         */
        environment: components["schemas"]["SearchFilter"];
      };
      header?: never;
      path: {
        /** @description The unique identifier for the integration. */
        id: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description An Integration is being deleted. */
      204: {
        headers: {
          /** @description The unique identifier for the API request. */
          "X-Request-Id"?: string;
          /** @description The maximum number of requests you're permitted to make per time period. */
          "X-RateLimit-Limit"?: number;
          /** @description The number of requests remaining in the current rate limit window. */
          "X-RateLimit-Remaining"?: number;
          /** @description The relative time in seconds until the current rate-limit window resets.
           *
           *     **Important:** This differs from Github and Twitter's same-named header which uses UTC epoch seconds. We use relative time to avoid client/server time synchronization issues. */
          "X-RateLimit-Reset"?: number;
          [name: string]: unknown;
        };
        content?: never;
      };
      400: components["responses"]["BadRequestError"];
      401: components["responses"]["UnauthenticatedError"];
      403: components["responses"]["UnauthorizedError"];
      404: components["responses"]["NotFoundError"];
      429: components["responses"]["RateLimitError"];
      500: components["responses"]["DefaultSystemError"];
    };
  };
  listArtifactV1FlinkArtifacts: {
    parameters: {
      query: {
        /**
         * @description Filter the results by exact match for cloud.
         * @example AWS
         */
        cloud: components["schemas"]["SearchFilter"];
        /**
         * @description Filter the results by exact match for region.
         * @example us-east-1
         */
        region: components["schemas"]["SearchFilter"];
        /**
         * @description Filter the results by exact match for environment.
         * @example env-00000
         */
        environment: components["schemas"]["SearchFilter"];
        /** @description A pagination size for collection requests. */
        page_size?: number;
        /** @description An opaque pagination token for collection requests. */
        page_token?: string;
      };
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description Flink Artifact. */
      200: {
        headers: {
          /** @description The unique identifier for the API request. */
          "X-Request-Id"?: string;
          /** @description The maximum number of requests you're permitted to make per time period. */
          "X-RateLimit-Limit"?: number;
          /** @description The number of requests remaining in the current rate limit window. */
          "X-RateLimit-Remaining"?: number;
          /** @description The relative time in seconds until the current rate-limit window resets.
           *
           *     **Important:** This differs from Github and Twitter's same-named header which uses UTC epoch seconds. We use relative time to avoid client/server time synchronization issues. */
          "X-RateLimit-Reset"?: number;
          [name: string]: unknown;
        };
        content: {
          "application/json": components["schemas"]["artifact.v1.FlinkArtifactList"];
        };
      };
      400: components["responses"]["BadRequestError"];
      401: components["responses"]["UnauthenticatedError"];
      403: components["responses"]["UnauthorizedError"];
      429: components["responses"]["RateLimitError"];
      500: components["responses"]["DefaultSystemError"];
    };
  };
  createArtifactV1FlinkArtifact: {
    parameters: {
      query: {
        /**
         * @description Scope the operation to the given cloud.
         * @example AWS
         */
        cloud: components["schemas"]["SearchFilter"];
        /**
         * @description Scope the operation to the given region.
         * @example us-east-1
         */
        region: components["schemas"]["SearchFilter"];
      };
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody?: {
      content: {
        "application/json": {
          /**
           * @description Cloud provider where the Flink Artifact archive is uploaded.
           * @example AWS
           */
          cloud: string;
          /**
           * @description The Cloud provider region the Flink Artifact archive is uploaded.
           * @example us-east-1
           */
          region: string;
          /**
           * @description Environment the Flink Artifact belongs to.
           * @example env-00000
           */
          environment: string;
          /** @description Unique name of the Flink Artifact per cloud, region, environment scope. */
          display_name: string;
          /**
           * @deprecated
           * @description Java class or alias for the artifact as provided by developer. Deprecated
           * @example io.confluent.example.SumScalarFunction
           */
          class?: string;
          /**
           * @description Archive format of the Flink Artifact.
           * @example JAR
           */
          content_format?: string;
          /** @description Description of the Flink Artifact. */
          description?: string;
          /** @description Documentation link of the Flink Artifact. */
          documentation_link?: string;
          /**
           * @description Runtime language of the Flink Artifact.
           * @default JAVA
           * @example JAVA
           */
          runtime_language?: string;
          /** @description Upload source of the Flink Artifact source. */
          upload_source: components["schemas"]["artifact.v1.UploadSource.PresignedUrl"];
        };
      };
    };
    responses: {
      /** @description A Flink Artifact was created. */
      201: {
        headers: {
          /** @description The unique identifier for the API request. */
          "X-Request-Id"?: string;
          /** @description The maximum number of requests you're permitted to make per time period. */
          "X-RateLimit-Limit"?: number;
          /** @description The number of requests remaining in the current rate limit window. */
          "X-RateLimit-Remaining"?: number;
          /** @description The relative time in seconds until the current rate-limit window resets.
           *
           *     **Important:** This differs from Github and Twitter's same-named header which uses UTC epoch seconds. We use relative time to avoid client/server time synchronization issues. */
          "X-RateLimit-Reset"?: number;
          /** @description FlinkArtifact resource uri */
          Location?: string;
          [name: string]: unknown;
        };
        content: {
          "application/json": components["schemas"]["artifact.v1.FlinkArtifact"] &
            Record<string, unknown>;
        };
      };
      400: components["responses"]["BadRequestError"];
      401: components["responses"]["UnauthenticatedError"];
      403: components["responses"]["UnauthorizedError"];
      409: components["responses"]["ConflictError"];
      422: components["responses"]["ValidationError"];
      429: components["responses"]["RateLimitError"];
      500: components["responses"]["DefaultSystemError"];
    };
  };
  getArtifactV1FlinkArtifact: {
    parameters: {
      query: {
        /**
         * @description Scope the operation to the given cloud.
         * @example AWS
         */
        cloud: components["schemas"]["SearchFilter"];
        /**
         * @description Scope the operation to the given region.
         * @example us-east-1
         */
        region: components["schemas"]["SearchFilter"];
        /**
         * @description Scope the operation to the given environment.
         * @example env-00000
         */
        environment: components["schemas"]["SearchFilter"];
      };
      header?: never;
      path: {
        /** @description The unique identifier for the flink artifact. */
        id: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description Flink Artifact. */
      200: {
        headers: {
          /** @description The unique identifier for the API request. */
          "X-Request-Id"?: string;
          /** @description The maximum number of requests you're permitted to make per time period. */
          "X-RateLimit-Limit"?: number;
          /** @description The number of requests remaining in the current rate limit window. */
          "X-RateLimit-Remaining"?: number;
          /** @description The relative time in seconds until the current rate-limit window resets.
           *
           *     **Important:** This differs from Github and Twitter's same-named header which uses UTC epoch seconds. We use relative time to avoid client/server time synchronization issues. */
          "X-RateLimit-Reset"?: number;
          [name: string]: unknown;
        };
        content: {
          "application/json": components["schemas"]["artifact.v1.FlinkArtifact"] &
            Record<string, unknown>;
        };
      };
      400: components["responses"]["BadRequestError"];
      401: components["responses"]["UnauthenticatedError"];
      403: components["responses"]["UnauthorizedError"];
      404: components["responses"]["NotFoundError"];
      429: components["responses"]["RateLimitError"];
      500: components["responses"]["DefaultSystemError"];
    };
  };
  deleteArtifactV1FlinkArtifact: {
    parameters: {
      query: {
        /**
         * @description Scope the operation to the given cloud.
         * @example AWS
         */
        cloud: components["schemas"]["SearchFilter"];
        /**
         * @description Scope the operation to the given region.
         * @example us-east-1
         */
        region: components["schemas"]["SearchFilter"];
        /**
         * @description Scope the operation to the given environment.
         * @example env-00000
         */
        environment: components["schemas"]["SearchFilter"];
      };
      header?: never;
      path: {
        /** @description The unique identifier for the flink artifact. */
        id: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description A Flink Artifact is being deleted. */
      204: {
        headers: {
          /** @description The unique identifier for the API request. */
          "X-Request-Id"?: string;
          /** @description The maximum number of requests you're permitted to make per time period. */
          "X-RateLimit-Limit"?: number;
          /** @description The number of requests remaining in the current rate limit window. */
          "X-RateLimit-Remaining"?: number;
          /** @description The relative time in seconds until the current rate-limit window resets.
           *
           *     **Important:** This differs from Github and Twitter's same-named header which uses UTC epoch seconds. We use relative time to avoid client/server time synchronization issues. */
          "X-RateLimit-Reset"?: number;
          [name: string]: unknown;
        };
        content?: never;
      };
      400: components["responses"]["BadRequestError"];
      401: components["responses"]["UnauthenticatedError"];
      403: components["responses"]["UnauthorizedError"];
      404: components["responses"]["NotFoundError"];
      429: components["responses"]["RateLimitError"];
      500: components["responses"]["DefaultSystemError"];
    };
  };
  updateArtifactV1FlinkArtifact: {
    parameters: {
      query: {
        /**
         * @description Scope the operation to the given cloud.
         * @example AWS
         */
        cloud: components["schemas"]["SearchFilter"];
        /**
         * @description Scope the operation to the given region.
         * @example us-east-1
         */
        region: components["schemas"]["SearchFilter"];
        /**
         * @description Scope the operation to the given environment.
         * @example env-00000
         */
        environment: components["schemas"]["SearchFilter"];
      };
      header?: never;
      path: {
        /** @description The unique identifier for the flink artifact. */
        id: string;
      };
      cookie?: never;
    };
    requestBody?: {
      content: {
        "application/json": components["schemas"]["artifact.v1.FlinkArtifactUpdate"];
      };
    };
    responses: {
      /** @description Flink Artifact. */
      200: {
        headers: {
          /** @description The unique identifier for the API request. */
          "X-Request-Id"?: string;
          /** @description The maximum number of requests you're permitted to make per time period. */
          "X-RateLimit-Limit"?: number;
          /** @description The number of requests remaining in the current rate limit window. */
          "X-RateLimit-Remaining"?: number;
          /** @description The relative time in seconds until the current rate-limit window resets.
           *
           *     **Important:** This differs from Github and Twitter's same-named header which uses UTC epoch seconds. We use relative time to avoid client/server time synchronization issues. */
          "X-RateLimit-Reset"?: number;
          [name: string]: unknown;
        };
        content: {
          "application/json": components["schemas"]["artifact.v1.FlinkArtifact"] &
            Record<string, unknown>;
        };
      };
      400: components["responses"]["BadRequestError"];
      401: components["responses"]["UnauthenticatedError"];
      403: components["responses"]["UnauthorizedError"];
      404: components["responses"]["NotFoundError"];
      409: components["responses"]["ConflictError"];
      422: components["responses"]["ValidationError"];
      429: components["responses"]["RateLimitError"];
      500: components["responses"]["DefaultSystemError"];
    };
  };
  "presigned-upload-urlArtifactV1PresignedUrl": {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody?: {
      content: {
        "application/json": components["schemas"]["artifact.v1.PresignedUrlRequest"] &
          Record<string, unknown>;
      };
    };
    responses: {
      /** @description Presigned Url. */
      200: {
        headers: {
          /** @description The unique identifier for the API request. */
          "X-Request-Id"?: string;
          /** @description The maximum number of requests you're permitted to make per time period. */
          "X-RateLimit-Limit"?: number;
          /** @description The number of requests remaining in the current rate limit window. */
          "X-RateLimit-Remaining"?: number;
          /** @description The relative time in seconds until the current rate-limit window resets.
           *
           *     **Important:** This differs from Github and Twitter's same-named header which uses UTC epoch seconds. We use relative time to avoid client/server time synchronization issues. */
          "X-RateLimit-Reset"?: number;
          [name: string]: unknown;
        };
        content: {
          "application/json": components["schemas"]["artifact.v1.PresignedUrl"] &
            Record<string, unknown>;
        };
      };
      400: components["responses"]["BadRequestError"];
      401: components["responses"]["UnauthenticatedError"];
      403: components["responses"]["UnauthorizedError"];
      404: components["responses"]["NotFoundError"];
      429: components["responses"]["RateLimitError"];
      500: components["responses"]["DefaultSystemError"];
    };
  };
  listNetworkingV1Gateways: {
    parameters: {
      query: {
        /**
         * @description Filter the results by exact match for environment.
         * @example env-00000
         */
        environment: components["schemas"]["SearchFilter"];
        /**
         * @description Filter the results by exact match for gateway_type. Pass multiple times to see results matching any of the values.
         * @example [
         *       "AwsEgressPrivateLink",
         *       "AzureEgressPrivateLink"
         *     ]
         */
        gateway_type?: components["schemas"]["MultipleSearchFilter"];
        /**
         * @description Filter the results by exact match for id. Pass multiple times to see results matching any of the values.
         * @example [
         *       "gw-1",
         *       "gw-2"
         *     ]
         */
        id?: components["schemas"]["MultipleSearchFilter"];
        /** @description A pagination size for collection requests. */
        page_size?: number;
        /** @description An opaque pagination token for collection requests. */
        page_token?: string;
      };
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description Gateway. */
      200: {
        headers: {
          /** @description The unique identifier for the API request. */
          "X-Request-Id"?: string;
          /** @description The maximum number of requests you're permitted to make per time period. */
          "X-RateLimit-Limit"?: number;
          /** @description The number of requests remaining in the current rate limit window. */
          "X-RateLimit-Remaining"?: number;
          /** @description The relative time in seconds until the current rate-limit window resets.
           *
           *     **Important:** This differs from Github and Twitter's same-named header which uses UTC epoch seconds. We use relative time to avoid client/server time synchronization issues. */
          "X-RateLimit-Reset"?: number;
          [name: string]: unknown;
        };
        content: {
          "application/json": components["schemas"]["networking.v1.GatewayList"] & {
            data?: {
              spec?: {
                /** @example {
                 *       "id": "env-00000",
                 *       "related": "https://api.confluent.cloud/v2/environments/env-00000",
                 *       "resource_name": "https://api.confluent.cloud/organization=9bb441c4-edef-46ac-8a41-c49e44a3fd9a/environment=env-00000"
                 *     } */
                environment?: unknown;
              };
            }[];
          };
        };
      };
      400: components["responses"]["BadRequestError"];
      401: components["responses"]["UnauthenticatedError"];
      403: components["responses"]["UnauthorizedError"];
      429: components["responses"]["RateLimitError"];
      500: components["responses"]["DefaultSystemError"];
    };
  };
  createNetworkingV1Gateway: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody?: {
      content: {
        "application/json": components["schemas"]["networking.v1.Gateway"] & {
          spec: Record<string, unknown>;
        } & {
          spec?: {
            /** @example {
             *       "id": "env-00000"
             *     } */
            environment?: unknown;
          };
        };
      };
    };
    responses: {
      /** @description A Gateway is being created. */
      202: {
        headers: {
          /** @description The unique identifier for the API request. */
          "X-Request-Id"?: string;
          /** @description The maximum number of requests you're permitted to make per time period. */
          "X-RateLimit-Limit"?: number;
          /** @description The number of requests remaining in the current rate limit window. */
          "X-RateLimit-Remaining"?: number;
          /** @description The relative time in seconds until the current rate-limit window resets.
           *
           *     **Important:** This differs from Github and Twitter's same-named header which uses UTC epoch seconds. We use relative time to avoid client/server time synchronization issues. */
          "X-RateLimit-Reset"?: number;
          /** @description Gateway resource uri */
          Location?: string;
          [name: string]: unknown;
        };
        content: {
          "application/json": components["schemas"]["networking.v1.Gateway"] & {
            spec: Record<string, unknown>;
          } & {
            spec?: {
              /** @example {
               *       "id": "env-00000",
               *       "related": "https://api.confluent.cloud/v2/environments/env-00000",
               *       "resource_name": "https://api.confluent.cloud/organization=9bb441c4-edef-46ac-8a41-c49e44a3fd9a/environment=env-00000"
               *     } */
              environment?: unknown;
            };
          };
        };
      };
      400: components["responses"]["BadRequestError"];
      401: components["responses"]["UnauthenticatedError"];
      402: components["responses"]["OverQuotaError"];
      403: components["responses"]["UnauthorizedError"];
      409: components["responses"]["ConflictError"];
      422: components["responses"]["ValidationError"];
      429: components["responses"]["RateLimitError"];
      500: components["responses"]["DefaultSystemError"];
    };
  };
  getNetworkingV1Gateway: {
    parameters: {
      query: {
        /**
         * @description Scope the operation to the given environment.
         * @example env-00000
         */
        environment: components["schemas"]["SearchFilter"];
      };
      header?: never;
      path: {
        /** @description The unique identifier for the gateway. */
        id: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description Gateway. */
      200: {
        headers: {
          /** @description The unique identifier for the API request. */
          "X-Request-Id"?: string;
          /** @description The maximum number of requests you're permitted to make per time period. */
          "X-RateLimit-Limit"?: number;
          /** @description The number of requests remaining in the current rate limit window. */
          "X-RateLimit-Remaining"?: number;
          /** @description The relative time in seconds until the current rate-limit window resets.
           *
           *     **Important:** This differs from Github and Twitter's same-named header which uses UTC epoch seconds. We use relative time to avoid client/server time synchronization issues. */
          "X-RateLimit-Reset"?: number;
          [name: string]: unknown;
        };
        content: {
          "application/json": components["schemas"]["networking.v1.Gateway"] & {
            spec: Record<string, unknown>;
          } & {
            spec?: {
              /** @example {
               *       "id": "env-00000",
               *       "related": "https://api.confluent.cloud/v2/environments/env-00000",
               *       "resource_name": "https://api.confluent.cloud/organization=9bb441c4-edef-46ac-8a41-c49e44a3fd9a/environment=env-00000"
               *     } */
              environment?: unknown;
            };
          };
        };
      };
      400: components["responses"]["BadRequestError"];
      401: components["responses"]["UnauthenticatedError"];
      403: components["responses"]["UnauthorizedError"];
      404: components["responses"]["NotFoundError"];
      429: components["responses"]["RateLimitError"];
      500: components["responses"]["DefaultSystemError"];
    };
  };
  deleteNetworkingV1Gateway: {
    parameters: {
      query: {
        /**
         * @description Scope the operation to the given environment.
         * @example env-00000
         */
        environment: components["schemas"]["SearchFilter"];
      };
      header?: never;
      path: {
        /** @description The unique identifier for the gateway. */
        id: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description A Gateway is being deleted. */
      204: {
        headers: {
          /** @description The unique identifier for the API request. */
          "X-Request-Id"?: string;
          /** @description The maximum number of requests you're permitted to make per time period. */
          "X-RateLimit-Limit"?: number;
          /** @description The number of requests remaining in the current rate limit window. */
          "X-RateLimit-Remaining"?: number;
          /** @description The relative time in seconds until the current rate-limit window resets.
           *
           *     **Important:** This differs from Github and Twitter's same-named header which uses UTC epoch seconds. We use relative time to avoid client/server time synchronization issues. */
          "X-RateLimit-Reset"?: number;
          [name: string]: unknown;
        };
        content?: never;
      };
      400: components["responses"]["BadRequestError"];
      401: components["responses"]["UnauthenticatedError"];
      403: components["responses"]["UnauthorizedError"];
      404: components["responses"]["NotFoundError"];
      429: components["responses"]["RateLimitError"];
      500: components["responses"]["DefaultSystemError"];
    };
  };
  updateNetworkingV1Gateway: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description The unique identifier for the gateway. */
        id: string;
      };
      cookie?: never;
    };
    requestBody?: {
      content: {
        "application/json": components["schemas"]["networking.v1.GatewayUpdate"] & {
          spec: {
            /** @example {
             *       "id": "env-00000"
             *     } */
            environment: unknown;
          };
        };
      };
    };
    responses: {
      /** @description Gateway. */
      200: {
        headers: {
          /** @description The unique identifier for the API request. */
          "X-Request-Id"?: string;
          /** @description The maximum number of requests you're permitted to make per time period. */
          "X-RateLimit-Limit"?: number;
          /** @description The number of requests remaining in the current rate limit window. */
          "X-RateLimit-Remaining"?: number;
          /** @description The relative time in seconds until the current rate-limit window resets.
           *
           *     **Important:** This differs from Github and Twitter's same-named header which uses UTC epoch seconds. We use relative time to avoid client/server time synchronization issues. */
          "X-RateLimit-Reset"?: number;
          [name: string]: unknown;
        };
        content: {
          "application/json": components["schemas"]["networking.v1.Gateway"] & {
            spec: Record<string, unknown>;
          } & {
            spec?: {
              /** @example {
               *       "id": "env-00000",
               *       "related": "https://api.confluent.cloud/v2/environments/env-00000",
               *       "resource_name": "https://api.confluent.cloud/organization=9bb441c4-edef-46ac-8a41-c49e44a3fd9a/environment=env-00000"
               *     } */
              environment?: unknown;
            };
          };
        };
      };
      400: components["responses"]["BadRequestError"];
      401: components["responses"]["UnauthenticatedError"];
      402: components["responses"]["OverQuotaError"];
      403: components["responses"]["UnauthorizedError"];
      404: components["responses"]["NotFoundError"];
      409: components["responses"]["ConflictError"];
      422: components["responses"]["ValidationError"];
      429: components["responses"]["RateLimitError"];
      500: components["responses"]["DefaultSystemError"];
    };
  };
  listCclV1CustomCodeLoggings: {
    parameters: {
      query: {
        /**
         * @description Filter the results by exact match for environment.
         * @example env-00000
         */
        environment: components["schemas"]["SearchFilter"];
        /** @description A pagination size for collection requests. */
        page_size?: number;
        /** @description An opaque pagination token for collection requests. */
        page_token?: string;
      };
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description Custom Code Logging. */
      200: {
        headers: {
          /** @description The unique identifier for the API request. */
          "X-Request-Id"?: string;
          /** @description The maximum number of requests you're permitted to make per time period. */
          "X-RateLimit-Limit"?: number;
          /** @description The number of requests remaining in the current rate limit window. */
          "X-RateLimit-Remaining"?: number;
          /** @description The relative time in seconds until the current rate-limit window resets.
           *
           *     **Important:** This differs from Github and Twitter's same-named header which uses UTC epoch seconds. We use relative time to avoid client/server time synchronization issues. */
          "X-RateLimit-Reset"?: number;
          [name: string]: unknown;
        };
        content: {
          "application/json": components["schemas"]["ccl.v1.CustomCodeLoggingList"] & {
            data?: {
              /** @example {
               *       "id": "env-00000",
               *       "related": "https://api.confluent.cloud/v2/environments/env-00000",
               *       "resource_name": "https://api.confluent.cloud/organization=9bb441c4-edef-46ac-8a41-c49e44a3fd9a/environment=env-00000"
               *     } */
              environment?: unknown;
            }[];
          };
        };
      };
      400: components["responses"]["BadRequestError"];
      401: components["responses"]["UnauthenticatedError"];
      403: components["responses"]["UnauthorizedError"];
      429: components["responses"]["RateLimitError"];
      500: components["responses"]["DefaultSystemError"];
    };
  };
  createCclV1CustomCodeLogging: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody?: {
      content: {
        "application/json": components["schemas"]["ccl.v1.CustomCodeLogging"] &
          Record<string, unknown> & {
            /** @example {
             *       "id": "env-00000"
             *     } */
            environment?: unknown;
          };
      };
    };
    responses: {
      /** @description A Custom Code Logging was created. */
      201: {
        headers: {
          /** @description The unique identifier for the API request. */
          "X-Request-Id"?: string;
          /** @description The maximum number of requests you're permitted to make per time period. */
          "X-RateLimit-Limit"?: number;
          /** @description The number of requests remaining in the current rate limit window. */
          "X-RateLimit-Remaining"?: number;
          /** @description The relative time in seconds until the current rate-limit window resets.
           *
           *     **Important:** This differs from Github and Twitter's same-named header which uses UTC epoch seconds. We use relative time to avoid client/server time synchronization issues. */
          "X-RateLimit-Reset"?: number;
          /** @description CustomCodeLogging resource uri */
          Location?: string;
          [name: string]: unknown;
        };
        content: {
          "application/json": components["schemas"]["ccl.v1.CustomCodeLogging"] &
            Record<string, unknown> & {
              /** @example {
               *       "id": "env-00000",
               *       "related": "https://api.confluent.cloud/v2/environments/env-00000",
               *       "resource_name": "https://api.confluent.cloud/organization=9bb441c4-edef-46ac-8a41-c49e44a3fd9a/environment=env-00000"
               *     } */
              environment?: unknown;
            };
        };
      };
      400: components["responses"]["BadRequestError"];
      401: components["responses"]["UnauthenticatedError"];
      403: components["responses"]["UnauthorizedError"];
      409: components["responses"]["ConflictError"];
      422: components["responses"]["ValidationError"];
      429: components["responses"]["RateLimitError"];
      500: components["responses"]["DefaultSystemError"];
    };
  };
  getCclV1CustomCodeLogging: {
    parameters: {
      query: {
        /**
         * @description Scope the operation to the given environment.
         * @example env-00000
         */
        environment: components["schemas"]["SearchFilter"];
      };
      header?: never;
      path: {
        /** @description The unique identifier for the custom code logging. */
        id: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description Custom Code Logging. */
      200: {
        headers: {
          /** @description The unique identifier for the API request. */
          "X-Request-Id"?: string;
          /** @description The maximum number of requests you're permitted to make per time period. */
          "X-RateLimit-Limit"?: number;
          /** @description The number of requests remaining in the current rate limit window. */
          "X-RateLimit-Remaining"?: number;
          /** @description The relative time in seconds until the current rate-limit window resets.
           *
           *     **Important:** This differs from Github and Twitter's same-named header which uses UTC epoch seconds. We use relative time to avoid client/server time synchronization issues. */
          "X-RateLimit-Reset"?: number;
          [name: string]: unknown;
        };
        content: {
          "application/json": components["schemas"]["ccl.v1.CustomCodeLogging"] &
            Record<string, unknown> & {
              /** @example {
               *       "id": "env-00000",
               *       "related": "https://api.confluent.cloud/v2/environments/env-00000",
               *       "resource_name": "https://api.confluent.cloud/organization=9bb441c4-edef-46ac-8a41-c49e44a3fd9a/environment=env-00000"
               *     } */
              environment?: unknown;
            };
        };
      };
      400: components["responses"]["BadRequestError"];
      401: components["responses"]["UnauthenticatedError"];
      403: components["responses"]["UnauthorizedError"];
      404: components["responses"]["NotFoundError"];
      429: components["responses"]["RateLimitError"];
      500: components["responses"]["DefaultSystemError"];
    };
  };
  deleteCclV1CustomCodeLogging: {
    parameters: {
      query: {
        /**
         * @description Scope the operation to the given environment.
         * @example env-00000
         */
        environment: components["schemas"]["SearchFilter"];
      };
      header?: never;
      path: {
        /** @description The unique identifier for the custom code logging. */
        id: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description A Custom Code Logging is being deleted. */
      204: {
        headers: {
          /** @description The unique identifier for the API request. */
          "X-Request-Id"?: string;
          /** @description The maximum number of requests you're permitted to make per time period. */
          "X-RateLimit-Limit"?: number;
          /** @description The number of requests remaining in the current rate limit window. */
          "X-RateLimit-Remaining"?: number;
          /** @description The relative time in seconds until the current rate-limit window resets.
           *
           *     **Important:** This differs from Github and Twitter's same-named header which uses UTC epoch seconds. We use relative time to avoid client/server time synchronization issues. */
          "X-RateLimit-Reset"?: number;
          [name: string]: unknown;
        };
        content?: never;
      };
      400: components["responses"]["BadRequestError"];
      401: components["responses"]["UnauthenticatedError"];
      403: components["responses"]["UnauthorizedError"];
      404: components["responses"]["NotFoundError"];
      429: components["responses"]["RateLimitError"];
      500: components["responses"]["DefaultSystemError"];
    };
  };
  updateCclV1CustomCodeLogging: {
    parameters: {
      query: {
        /**
         * @description Scope the operation to the given environment.
         * @example env-00000
         */
        environment: components["schemas"]["SearchFilter"];
      };
      header?: never;
      path: {
        /** @description The unique identifier for the custom code logging. */
        id: string;
      };
      cookie?: never;
    };
    requestBody?: {
      content: {
        "application/json": components["schemas"]["ccl.v1.CustomCodeLoggingUpdate"] & {
          /** @example {
           *       "id": "env-00000"
           *     } */
          environment: unknown;
        };
      };
    };
    responses: {
      /** @description Custom Code Logging. */
      200: {
        headers: {
          /** @description The unique identifier for the API request. */
          "X-Request-Id"?: string;
          /** @description The maximum number of requests you're permitted to make per time period. */
          "X-RateLimit-Limit"?: number;
          /** @description The number of requests remaining in the current rate limit window. */
          "X-RateLimit-Remaining"?: number;
          /** @description The relative time in seconds until the current rate-limit window resets.
           *
           *     **Important:** This differs from Github and Twitter's same-named header which uses UTC epoch seconds. We use relative time to avoid client/server time synchronization issues. */
          "X-RateLimit-Reset"?: number;
          [name: string]: unknown;
        };
        content: {
          "application/json": components["schemas"]["ccl.v1.CustomCodeLogging"] &
            Record<string, unknown> & {
              /** @example {
               *       "id": "env-00000",
               *       "related": "https://api.confluent.cloud/v2/environments/env-00000",
               *       "resource_name": "https://api.confluent.cloud/organization=9bb441c4-edef-46ac-8a41-c49e44a3fd9a/environment=env-00000"
               *     } */
              environment?: unknown;
            };
        };
      };
      400: components["responses"]["BadRequestError"];
      401: components["responses"]["UnauthenticatedError"];
      403: components["responses"]["UnauthorizedError"];
      404: components["responses"]["NotFoundError"];
      409: components["responses"]["ConflictError"];
      422: components["responses"]["ValidationError"];
      429: components["responses"]["RateLimitError"];
      500: components["responses"]["DefaultSystemError"];
    };
  };
  listTableflowV1Regions: {
    parameters: {
      query?: {
        /**
         * @description Filter the results by exact match for cloud.
         * @example AWS
         */
        cloud?: components["schemas"]["SearchFilter"];
        /** @description A pagination size for collection requests. */
        page_size?: number;
        /** @description An opaque pagination token for collection requests. */
        page_token?: string;
      };
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description Region. */
      200: {
        headers: {
          /** @description The unique identifier for the API request. */
          "X-Request-Id"?: string;
          /** @description The maximum number of requests you're permitted to make per time period. */
          "X-RateLimit-Limit"?: number;
          /** @description The number of requests remaining in the current rate limit window. */
          "X-RateLimit-Remaining"?: number;
          /** @description The relative time in seconds until the current rate-limit window resets.
           *
           *     **Important:** This differs from Github and Twitter's same-named header which uses UTC epoch seconds. We use relative time to avoid client/server time synchronization issues. */
          "X-RateLimit-Reset"?: number;
          [name: string]: unknown;
        };
        content: {
          "application/json": components["schemas"]["tableflow.v1.RegionList"];
        };
      };
      400: components["responses"]["BadRequestError"];
      401: components["responses"]["UnauthenticatedError"];
      403: components["responses"]["UnauthorizedError"];
      429: components["responses"]["RateLimitError"];
      500: components["responses"]["DefaultSystemError"];
    };
  };
  listTableflowV1TableflowTopics: {
    parameters: {
      query: {
        /**
         * @description Filter the results by exact match for environment.
         * @example env-00000
         */
        environment: components["schemas"]["SearchFilter"];
        /**
         * @description Filter the results by exact match for spec.kafka_cluster.
         * @example lkc-00000
         */
        "spec.kafka_cluster": components["schemas"]["SearchFilter"];
        /** @description A pagination size for collection requests. */
        page_size?: number;
        /** @description An opaque pagination token for collection requests. */
        page_token?: string;
      };
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description Tableflow Topic. */
      200: {
        headers: {
          /** @description The unique identifier for the API request. */
          "X-Request-Id"?: string;
          /** @description The maximum number of requests you're permitted to make per time period. */
          "X-RateLimit-Limit"?: number;
          /** @description The number of requests remaining in the current rate limit window. */
          "X-RateLimit-Remaining"?: number;
          /** @description The relative time in seconds until the current rate-limit window resets.
           *
           *     **Important:** This differs from Github and Twitter's same-named header which uses UTC epoch seconds. We use relative time to avoid client/server time synchronization issues. */
          "X-RateLimit-Reset"?: number;
          [name: string]: unknown;
        };
        content: {
          "application/json": components["schemas"]["tableflow.v1.TableflowTopicList"] & {
            data?: {
              spec?: {
                /** @example {
                 *       "id": "env-00000",
                 *       "related": "https://api.confluent.cloud/org/v2/environments/env-00000",
                 *       "resource_name": "https://api.confluent.cloud/organization=9bb441c4-edef-46ac-8a41-c49e44a3fd9a/environment=env-00000"
                 *     } */
                environment?: unknown;
                /** @example {
                 *       "id": "lkc-00000",
                 *       "related": "https://api.confluent.cloud/cmk/v2/clusters/lkc-00000",
                 *       "resource_name": "https://api.confluent.cloud/organization=9bb441c4-edef-46ac-8a41-c49e44a3fd9a/environment=env-abc123/cloud-cluster=lkc-00000"
                 *     } */
                kafka_cluster?: unknown;
              };
            }[];
          };
        };
      };
      400: components["responses"]["BadRequestError"];
      401: components["responses"]["UnauthenticatedError"];
      403: components["responses"]["UnauthorizedError"];
      429: components["responses"]["RateLimitError"];
      500: components["responses"]["DefaultSystemError"];
    };
  };
  createTableflowV1TableflowTopic: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody?: {
      content: {
        "application/json": components["schemas"]["tableflow.v1.TableflowTopic"] & {
          spec: Record<string, unknown>;
        } & {
          spec?: {
            /** @example {
             *       "id": "env-00000"
             *     } */
            environment?: unknown;
            /** @example {
             *       "id": "lkc-00000"
             *     } */
            kafka_cluster?: unknown;
          };
        };
      };
    };
    responses: {
      /** @description A Tableflow Topic is being created. */
      202: {
        headers: {
          /** @description The unique identifier for the API request. */
          "X-Request-Id"?: string;
          /** @description The maximum number of requests you're permitted to make per time period. */
          "X-RateLimit-Limit"?: number;
          /** @description The number of requests remaining in the current rate limit window. */
          "X-RateLimit-Remaining"?: number;
          /** @description The relative time in seconds until the current rate-limit window resets.
           *
           *     **Important:** This differs from Github and Twitter's same-named header which uses UTC epoch seconds. We use relative time to avoid client/server time synchronization issues. */
          "X-RateLimit-Reset"?: number;
          /** @description TableflowTopic resource uri */
          Location?: string;
          [name: string]: unknown;
        };
        content: {
          "application/json": components["schemas"]["tableflow.v1.TableflowTopic"] & {
            spec: Record<string, unknown>;
          } & {
            spec?: {
              /** @example {
               *       "id": "env-00000",
               *       "related": "https://api.confluent.cloud/org/v2/environments/env-00000",
               *       "resource_name": "https://api.confluent.cloud/organization=9bb441c4-edef-46ac-8a41-c49e44a3fd9a/environment=env-00000"
               *     } */
              environment?: unknown;
              /** @example {
               *       "id": "lkc-00000",
               *       "related": "https://api.confluent.cloud/cmk/v2/clusters/lkc-00000",
               *       "resource_name": "https://api.confluent.cloud/organization=9bb441c4-edef-46ac-8a41-c49e44a3fd9a/environment=env-abc123/cloud-cluster=lkc-00000"
               *     } */
              kafka_cluster?: unknown;
            };
          };
        };
      };
      400: components["responses"]["BadRequestError"];
      401: components["responses"]["UnauthenticatedError"];
      403: components["responses"]["UnauthorizedError"];
      409: components["responses"]["ConflictError"];
      422: components["responses"]["ValidationError"];
      429: components["responses"]["RateLimitError"];
      500: components["responses"]["DefaultSystemError"];
    };
  };
  getTableflowV1TableflowTopic: {
    parameters: {
      query: {
        /**
         * @description Scope the operation to the given environment.
         * @example env-00000
         */
        environment: components["schemas"]["SearchFilter"];
        /**
         * @description Scope the operation to the given spec.kafka_cluster.
         * @example lkc-00000
         */
        "spec.kafka_cluster": components["schemas"]["SearchFilter"];
      };
      header?: never;
      path: {
        /** @description The name of the Kafka topic for which Tableflow is enabled. */
        display_name: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description Tableflow Topic. */
      200: {
        headers: {
          /** @description The unique identifier for the API request. */
          "X-Request-Id"?: string;
          /** @description The maximum number of requests you're permitted to make per time period. */
          "X-RateLimit-Limit"?: number;
          /** @description The number of requests remaining in the current rate limit window. */
          "X-RateLimit-Remaining"?: number;
          /** @description The relative time in seconds until the current rate-limit window resets.
           *
           *     **Important:** This differs from Github and Twitter's same-named header which uses UTC epoch seconds. We use relative time to avoid client/server time synchronization issues. */
          "X-RateLimit-Reset"?: number;
          [name: string]: unknown;
        };
        content: {
          "application/json": components["schemas"]["tableflow.v1.TableflowTopic"] & {
            spec: Record<string, unknown>;
          } & {
            spec?: {
              /** @example {
               *       "id": "env-00000",
               *       "related": "https://api.confluent.cloud/org/v2/environments/env-00000",
               *       "resource_name": "https://api.confluent.cloud/organization=9bb441c4-edef-46ac-8a41-c49e44a3fd9a/environment=env-00000"
               *     } */
              environment?: unknown;
              /** @example {
               *       "id": "lkc-00000",
               *       "related": "https://api.confluent.cloud/cmk/v2/clusters/lkc-00000",
               *       "resource_name": "https://api.confluent.cloud/organization=9bb441c4-edef-46ac-8a41-c49e44a3fd9a/environment=env-abc123/cloud-cluster=lkc-00000"
               *     } */
              kafka_cluster?: unknown;
            };
          };
        };
      };
      400: components["responses"]["BadRequestError"];
      401: components["responses"]["UnauthenticatedError"];
      403: components["responses"]["UnauthorizedError"];
      404: components["responses"]["NotFoundError"];
      429: components["responses"]["RateLimitError"];
      500: components["responses"]["DefaultSystemError"];
    };
  };
  deleteTableflowV1TableflowTopic: {
    parameters: {
      query: {
        /**
         * @description Scope the operation to the given environment.
         * @example env-00000
         */
        environment: components["schemas"]["SearchFilter"];
        /**
         * @description Scope the operation to the given spec.kafka_cluster.
         * @example lkc-00000
         */
        "spec.kafka_cluster": components["schemas"]["SearchFilter"];
      };
      header?: never;
      path: {
        /** @description The name of the Kafka topic for which Tableflow is enabled. */
        display_name: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description A Tableflow Topic is being deleted. */
      204: {
        headers: {
          /** @description The unique identifier for the API request. */
          "X-Request-Id"?: string;
          /** @description The maximum number of requests you're permitted to make per time period. */
          "X-RateLimit-Limit"?: number;
          /** @description The number of requests remaining in the current rate limit window. */
          "X-RateLimit-Remaining"?: number;
          /** @description The relative time in seconds until the current rate-limit window resets.
           *
           *     **Important:** This differs from Github and Twitter's same-named header which uses UTC epoch seconds. We use relative time to avoid client/server time synchronization issues. */
          "X-RateLimit-Reset"?: number;
          [name: string]: unknown;
        };
        content?: never;
      };
      400: components["responses"]["BadRequestError"];
      401: components["responses"]["UnauthenticatedError"];
      403: components["responses"]["UnauthorizedError"];
      404: components["responses"]["NotFoundError"];
      429: components["responses"]["RateLimitError"];
      500: components["responses"]["DefaultSystemError"];
    };
  };
  updateTableflowV1TableflowTopic: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description The name of the Kafka topic for which Tableflow is enabled. */
        display_name: string;
      };
      cookie?: never;
    };
    requestBody?: {
      content: {
        "application/json": components["schemas"]["tableflow.v1.TableflowTopicUpdate"] & {
          spec: {
            /** @example {
             *       "id": "env-00000"
             *     } */
            environment: unknown;
          };
        };
      };
    };
    responses: {
      /** @description Tableflow Topic. */
      200: {
        headers: {
          /** @description The unique identifier for the API request. */
          "X-Request-Id"?: string;
          /** @description The maximum number of requests you're permitted to make per time period. */
          "X-RateLimit-Limit"?: number;
          /** @description The number of requests remaining in the current rate limit window. */
          "X-RateLimit-Remaining"?: number;
          /** @description The relative time in seconds until the current rate-limit window resets.
           *
           *     **Important:** This differs from Github and Twitter's same-named header which uses UTC epoch seconds. We use relative time to avoid client/server time synchronization issues. */
          "X-RateLimit-Reset"?: number;
          [name: string]: unknown;
        };
        content: {
          "application/json": components["schemas"]["tableflow.v1.TableflowTopic"] & {
            spec: Record<string, unknown>;
          } & {
            spec?: {
              /** @example {
               *       "id": "env-00000",
               *       "related": "https://api.confluent.cloud/org/v2/environments/env-00000",
               *       "resource_name": "https://api.confluent.cloud/organization=9bb441c4-edef-46ac-8a41-c49e44a3fd9a/environment=env-00000"
               *     } */
              environment?: unknown;
              /** @example {
               *       "id": "lkc-00000",
               *       "related": "https://api.confluent.cloud/cmk/v2/clusters/lkc-00000",
               *       "resource_name": "https://api.confluent.cloud/organization=9bb441c4-edef-46ac-8a41-c49e44a3fd9a/environment=env-abc123/cloud-cluster=lkc-00000"
               *     } */
              kafka_cluster?: unknown;
            };
          };
        };
      };
      400: components["responses"]["BadRequestError"];
      401: components["responses"]["UnauthenticatedError"];
      403: components["responses"]["UnauthorizedError"];
      404: components["responses"]["NotFoundError"];
      409: components["responses"]["ConflictError"];
      422: components["responses"]["ValidationError"];
      429: components["responses"]["RateLimitError"];
      500: components["responses"]["DefaultSystemError"];
    };
  };
  listTableflowV1CatalogIntegrations: {
    parameters: {
      query: {
        /**
         * @description Filter the results by exact match for environment.
         * @example env-00000
         */
        environment: components["schemas"]["SearchFilter"];
        /**
         * @description Filter the results by exact match for spec.kafka_cluster.
         * @example lkc-00000
         */
        "spec.kafka_cluster": components["schemas"]["SearchFilter"];
        /** @description A pagination size for collection requests. */
        page_size?: number;
        /** @description An opaque pagination token for collection requests. */
        page_token?: string;
      };
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description Catalog Integration. */
      200: {
        headers: {
          /** @description The unique identifier for the API request. */
          "X-Request-Id"?: string;
          /** @description The maximum number of requests you're permitted to make per time period. */
          "X-RateLimit-Limit"?: number;
          /** @description The number of requests remaining in the current rate limit window. */
          "X-RateLimit-Remaining"?: number;
          /** @description The relative time in seconds until the current rate-limit window resets.
           *
           *     **Important:** This differs from Github and Twitter's same-named header which uses UTC epoch seconds. We use relative time to avoid client/server time synchronization issues. */
          "X-RateLimit-Reset"?: number;
          [name: string]: unknown;
        };
        content: {
          "application/json": components["schemas"]["tableflow.v1.CatalogIntegrationList"] & {
            data?: {
              spec?: {
                /** @example {
                 *       "id": "env-00000",
                 *       "related": "https://api.confluent.cloud/org/v2/environments/env-00000",
                 *       "resource_name": "https://api.confluent.cloud/organization=9bb441c4-edef-46ac-8a41-c49e44a3fd9a/environment=env-00000"
                 *     } */
                environment?: unknown;
                /** @example {
                 *       "id": "lkc-00000",
                 *       "related": "https://api.confluent.cloud/cmk/v2/clusters/lkc-00000",
                 *       "resource_name": "https://api.confluent.cloud/organization=9bb441c4-edef-46ac-8a41-c49e44a3fd9a/environment=env-abc123/cloud-cluster=lkc-00000"
                 *     } */
                kafka_cluster?: unknown;
              };
            }[];
          };
        };
      };
      400: components["responses"]["BadRequestError"];
      401: components["responses"]["UnauthenticatedError"];
      403: components["responses"]["UnauthorizedError"];
      429: components["responses"]["RateLimitError"];
      500: components["responses"]["DefaultSystemError"];
    };
  };
  createTableflowV1CatalogIntegration: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody?: {
      content: {
        "application/json": components["schemas"]["tableflow.v1.CatalogIntegration"] & {
          spec: Record<string, unknown>;
        } & {
          spec?: {
            /** @example {
             *       "id": "env-00000"
             *     } */
            environment?: unknown;
            /** @example {
             *       "id": "lkc-00000"
             *     } */
            kafka_cluster?: unknown;
          };
        };
      };
    };
    responses: {
      /** @description A Catalog Integration is being created. */
      202: {
        headers: {
          /** @description The unique identifier for the API request. */
          "X-Request-Id"?: string;
          /** @description The maximum number of requests you're permitted to make per time period. */
          "X-RateLimit-Limit"?: number;
          /** @description The number of requests remaining in the current rate limit window. */
          "X-RateLimit-Remaining"?: number;
          /** @description The relative time in seconds until the current rate-limit window resets.
           *
           *     **Important:** This differs from Github and Twitter's same-named header which uses UTC epoch seconds. We use relative time to avoid client/server time synchronization issues. */
          "X-RateLimit-Reset"?: number;
          /** @description CatalogIntegration resource uri */
          Location?: string;
          [name: string]: unknown;
        };
        content: {
          "application/json": components["schemas"]["tableflow.v1.CatalogIntegration"] & {
            spec: Record<string, unknown>;
          } & {
            spec?: {
              /** @example {
               *       "id": "env-00000",
               *       "related": "https://api.confluent.cloud/org/v2/environments/env-00000",
               *       "resource_name": "https://api.confluent.cloud/organization=9bb441c4-edef-46ac-8a41-c49e44a3fd9a/environment=env-00000"
               *     } */
              environment?: unknown;
              /** @example {
               *       "id": "lkc-00000",
               *       "related": "https://api.confluent.cloud/cmk/v2/clusters/lkc-00000",
               *       "resource_name": "https://api.confluent.cloud/organization=9bb441c4-edef-46ac-8a41-c49e44a3fd9a/environment=env-abc123/cloud-cluster=lkc-00000"
               *     } */
              kafka_cluster?: unknown;
            };
          };
        };
      };
      400: components["responses"]["BadRequestError"];
      401: components["responses"]["UnauthenticatedError"];
      403: components["responses"]["UnauthorizedError"];
      409: components["responses"]["ConflictError"];
      422: components["responses"]["ValidationError"];
      429: components["responses"]["RateLimitError"];
      500: components["responses"]["DefaultSystemError"];
    };
  };
  getTableflowV1CatalogIntegration: {
    parameters: {
      query: {
        /**
         * @description Scope the operation to the given environment.
         * @example env-00000
         */
        environment: components["schemas"]["SearchFilter"];
        /**
         * @description Scope the operation to the given spec.kafka_cluster.
         * @example lkc-00000
         */
        "spec.kafka_cluster": components["schemas"]["SearchFilter"];
      };
      header?: never;
      path: {
        /** @description The unique identifier for the catalog integration. */
        id: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description Catalog Integration. */
      200: {
        headers: {
          /** @description The unique identifier for the API request. */
          "X-Request-Id"?: string;
          /** @description The maximum number of requests you're permitted to make per time period. */
          "X-RateLimit-Limit"?: number;
          /** @description The number of requests remaining in the current rate limit window. */
          "X-RateLimit-Remaining"?: number;
          /** @description The relative time in seconds until the current rate-limit window resets.
           *
           *     **Important:** This differs from Github and Twitter's same-named header which uses UTC epoch seconds. We use relative time to avoid client/server time synchronization issues. */
          "X-RateLimit-Reset"?: number;
          [name: string]: unknown;
        };
        content: {
          "application/json": components["schemas"]["tableflow.v1.CatalogIntegration"] & {
            spec: Record<string, unknown>;
          } & {
            spec?: {
              /** @example {
               *       "id": "env-00000",
               *       "related": "https://api.confluent.cloud/org/v2/environments/env-00000",
               *       "resource_name": "https://api.confluent.cloud/organization=9bb441c4-edef-46ac-8a41-c49e44a3fd9a/environment=env-00000"
               *     } */
              environment?: unknown;
              /** @example {
               *       "id": "lkc-00000",
               *       "related": "https://api.confluent.cloud/cmk/v2/clusters/lkc-00000",
               *       "resource_name": "https://api.confluent.cloud/organization=9bb441c4-edef-46ac-8a41-c49e44a3fd9a/environment=env-abc123/cloud-cluster=lkc-00000"
               *     } */
              kafka_cluster?: unknown;
            };
          };
        };
      };
      400: components["responses"]["BadRequestError"];
      401: components["responses"]["UnauthenticatedError"];
      403: components["responses"]["UnauthorizedError"];
      404: components["responses"]["NotFoundError"];
      429: components["responses"]["RateLimitError"];
      500: components["responses"]["DefaultSystemError"];
    };
  };
  deleteTableflowV1CatalogIntegration: {
    parameters: {
      query: {
        /**
         * @description Scope the operation to the given environment.
         * @example env-00000
         */
        environment: components["schemas"]["SearchFilter"];
        /**
         * @description Scope the operation to the given spec.kafka_cluster.
         * @example lkc-00000
         */
        "spec.kafka_cluster": components["schemas"]["SearchFilter"];
      };
      header?: never;
      path: {
        /** @description The unique identifier for the catalog integration. */
        id: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description A Catalog Integration is being deleted. */
      204: {
        headers: {
          /** @description The unique identifier for the API request. */
          "X-Request-Id"?: string;
          /** @description The maximum number of requests you're permitted to make per time period. */
          "X-RateLimit-Limit"?: number;
          /** @description The number of requests remaining in the current rate limit window. */
          "X-RateLimit-Remaining"?: number;
          /** @description The relative time in seconds until the current rate-limit window resets.
           *
           *     **Important:** This differs from Github and Twitter's same-named header which uses UTC epoch seconds. We use relative time to avoid client/server time synchronization issues. */
          "X-RateLimit-Reset"?: number;
          [name: string]: unknown;
        };
        content?: never;
      };
      400: components["responses"]["BadRequestError"];
      401: components["responses"]["UnauthenticatedError"];
      403: components["responses"]["UnauthorizedError"];
      404: components["responses"]["NotFoundError"];
      429: components["responses"]["RateLimitError"];
      500: components["responses"]["DefaultSystemError"];
    };
  };
  updateTableflowV1CatalogIntegration: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description The unique identifier for the catalog integration. */
        id: string;
      };
      cookie?: never;
    };
    requestBody?: {
      content: {
        "application/json": components["schemas"]["tableflow.v1.CatalogIntegrationUpdateRequest"];
      };
    };
    responses: {
      /** @description Catalog Integration. */
      200: {
        headers: {
          /** @description The unique identifier for the API request. */
          "X-Request-Id"?: string;
          /** @description The maximum number of requests you're permitted to make per time period. */
          "X-RateLimit-Limit"?: number;
          /** @description The number of requests remaining in the current rate limit window. */
          "X-RateLimit-Remaining"?: number;
          /** @description The relative time in seconds until the current rate-limit window resets.
           *
           *     **Important:** This differs from Github and Twitter's same-named header which uses UTC epoch seconds. We use relative time to avoid client/server time synchronization issues. */
          "X-RateLimit-Reset"?: number;
          [name: string]: unknown;
        };
        content: {
          "application/json": components["schemas"]["tableflow.v1.CatalogIntegration"] & {
            spec: Record<string, unknown>;
          } & {
            spec?: {
              /** @example {
               *       "id": "env-00000",
               *       "related": "https://api.confluent.cloud/org/v2/environments/env-00000",
               *       "resource_name": "https://api.confluent.cloud/organization=9bb441c4-edef-46ac-8a41-c49e44a3fd9a/environment=env-00000"
               *     } */
              environment?: unknown;
              /** @example {
               *       "id": "lkc-00000",
               *       "related": "https://api.confluent.cloud/cmk/v2/clusters/lkc-00000",
               *       "resource_name": "https://api.confluent.cloud/organization=9bb441c4-edef-46ac-8a41-c49e44a3fd9a/environment=env-abc123/cloud-cluster=lkc-00000"
               *     } */
              kafka_cluster?: unknown;
            };
          };
        };
      };
      400: components["responses"]["BadRequestError"];
      401: components["responses"]["UnauthenticatedError"];
      403: components["responses"]["UnauthorizedError"];
      404: components["responses"]["NotFoundError"];
      409: components["responses"]["ConflictError"];
      422: components["responses"]["ValidationError"];
      429: components["responses"]["RateLimitError"];
      500: components["responses"]["DefaultSystemError"];
    };
  };
}
